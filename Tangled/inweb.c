#ifndef PLATFORM_WINDOWS
#define PLATFORM_POSIX
#endif
/* Tangled output generated by inweb: do not edit */
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#ifdef PLATFORM_POSIX
#include <errno.h>
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#include <limits.h>
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_WINDOWS
#include <errno.h>
#endif /* PLATFORM_WINDOWS */
#line 42 "inweb/foundation-module/Chapter 1/Foundation Module.w"
#include <stdint.h>
#line 48 "inweb/foundation-module/Chapter 1/Foundation Module.w"

typedef uint32_t inchar32_t;

#ifdef PLATFORM_POSIX
#line 25 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <sys/stat.h>
#include <sys/types.h>
#line 28 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <dirent.h>
#include <pthread.h>
#line 31 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <unistd.h>

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_UNIX
#ifdef PLATFORM_POSIX
#line 49 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <strings.h>

#endif /* PLATFORM_UNIX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#line 61 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <strings.h>

#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#line 71 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <strings.h>

#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 142 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int _NSGetExecutablePath(char* buf, uint32_t* bufsize);

void Platform__where_am_i(inchar32_t *p, size_t length) {
    char relative_path[4 * PATH_MAX + 1];
    char absolute_path[PATH_MAX + 1];
    size_t convert_len;
    uint32_t pathsize = sizeof(relative_path);
    uint32_t tempsize = pathsize;

    /* Get "a path" to the executable */
    if (_NSGetExecutablePath(relative_path, &tempsize) != 0) 
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 152 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;

    /* Convert to canonical absolute path */
    if (realpath(relative_path, absolute_path) == NULL) 
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 155 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;

    /* Next, convert the obtained buffer (which is a string in the local
     * filename encoding, possibly multibyte) to a wide-char string. */
    convert_len = mbstowcs(p, absolute_path, length);
    if (convert_len == (size_t)-1) 
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 160 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;
}

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 404 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
typedef pthread_t foundation_thread;
typedef pthread_attr_t foundation_thread_attributes;

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#line 439 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <sys/sysinfo.h>

#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 453 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <sys/sysctl.h>

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_WINDOWS
#line 18 "inweb/foundation-module/Chapter 1/Windows Platform.w"
#include <dirent.h>
#line 20 "inweb/foundation-module/Chapter 1/Windows Platform.w"
#include <io.h>
#include <sys/stat.h>

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#undef IN
#undef OUT

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 45 "inweb/foundation-module/Chapter 1/Windows Platform.w"
char *Platform__getenv(const char *name) {
	char *env = getenv(name);
	if (env == 0) {
		char value[MAX_PATH];
		if (strcmp(name, "PWD") == 0) {
			if (GetCurrentDirectoryA(MAX_PATH, value) != 0)
				_putenv_s(name, value);
		} else if (strcmp(name, "HOME") == 0) {
			if (SHGetFolderPathA(0, CSIDL_PERSONAL, 0, SHGFP_TYPE_CURRENT, value) == 0)
				_putenv_s(name, value);
		}
		env = getenv(name);
	}
	return env;
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 89 "inweb/foundation-module/Chapter 1/Windows Platform.w"
/* Check the first element of the command: if it has path separators in
   it, we assume we are running one of our commands, otherwise it is a
   Unix style command. */
int Platform__Win32_is_unix_cmd(const char* cmd) {
	char stop = ' ';
	int i = 0;

	if (cmd[0] == '\"') {
		stop = '\"';
		i = 1;
	}
	while ((cmd[i] != 0) && (cmd[i] != stop)) {
		if ((cmd[i] == '/') || (cmd[i] == '\\'))
			return 0;
		i++;
	}
	return 1;
}

int Platform__system(const char *cmd) {
	char cmd_line[10*MAX_PATH];

	/* Check if the command should be executed with the Windows cmd interpreter
	   or a Unix-like shell. */
	int unix = Platform__Win32_is_unix_cmd(cmd);
	if (unix) {
		/* Some Cygwin commands cannot handle backslashes in paths. */
		int forward_slash = 0;
		if (strncmp(cmd,"pdftex ",7) == 0)
			forward_slash = 1;

		/* For a Unix shell command, escape any double quotes and backslashes. */
		char *pcl;
		const char *pc;
		strcpy(cmd_line, "sh -c \"");
		for (pc = cmd, pcl = cmd_line+strlen(cmd_line); *pc != 0; ++pc, ++pcl) {
			if (*pc == '\"') {
				*(pcl++) = '\\';
				*pcl = *pc;
			}
			else if (*pc == '\\') {
				if (forward_slash)
					*pcl = '/';
				else {
					*(pcl++) = '\\';
					*pcl = *pc;
				}
			}
			else
				*pcl = *pc;
		}
		*(pcl++) = '\"';
		*(pcl++) = 0;
	} else {
		/* Otherwise, run with the Windows command interpreter. */
		strcpy(cmd_line, "cmd /s /c \"");
		strcat(cmd_line, cmd);
		strcat(cmd_line, "\"");
	}

	STARTUPINFOA start;
	memset(&start, 0, sizeof start);
	start.cb = sizeof start;
	start.dwFlags = STARTF_USESHOWWINDOW;
	start.wShowWindow = SW_HIDE;

	PROCESS_INFORMATION process;
	if (CreateProcessA(0, cmd_line, 0, 0, FALSE, CREATE_NO_WINDOW, 0, 0, &start, &process) == 0) {
		if (unix)
			fprintf(stderr, "A Unix-like shell \"sh\" (such as that from MSYS2 or Cygwin) must be in the path.\n");
		return -1;
	}

	CloseHandle(process.hThread);
	if (WaitForSingleObject(process.hProcess, INFINITE) != WAIT_OBJECT_0) {
		CloseHandle(process.hProcess);
		return -1;
	}

	DWORD code = 10;
	GetExitCodeProcess(process.hProcess, &code);
	CloseHandle(process.hProcess);

	return (int)code;
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 389 "inweb/foundation-module/Chapter 1/Windows Platform.w"
typedef HANDLE foundation_thread;
typedef int foundation_thread_attributes;

struct Win32_Thread_Start { void *(*fn)(void *); void* arg; };

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 490 "inweb/foundation-module/Chapter 1/Windows Platform.w"
struct Win32_Mutex { INIT_ONCE init; CRITICAL_SECTION crit; };

#endif /* PLATFORM_WINDOWS */
#define TRUE 1
#define FALSE 0
#define NOT_APPLICABLE 2
#define UTF8_ENC 1 /* Write as UTF-8 without BOM */
#define ISO_ENC 2 /* Write as ISO Latin-1 (i.e., no conversion needed) */
#define MAX_FILENAME_LENGTH 1025
#define LOG_CLSW 0
#define VERSION_CLSW 1
#define CRASH_CLSW 2
#define HELP_CLSW 3
#define FIXTIME_CLSW 4
#define AT_CLSW 5
#define LOCALE_CLSW 6
#ifdef PLATFORM_POSIX
#define FOLDER_SEPARATOR '/'
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#define SHELL_QUOTE_CHARACTER '\''
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#define PLATFORM_STRING "macos"
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#define SHELL_QUOTE_CHARACTER '\''
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#define INFORM_FOLDER_RELATIVE_TO_HOME "Library"
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_UNIX
#ifdef PLATFORM_POSIX
#define PLATFORM_STRING "unix"
#endif /* PLATFORM_UNIX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_UNIX
#ifdef PLATFORM_POSIX
#define INFORM_FOLDER_RELATIVE_TO_HOME ""
#endif /* PLATFORM_UNIX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#define PLATFORM_STRING "linux"
#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#define INFORM_FOLDER_RELATIVE_TO_HOME ""
#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#define PLATFORM_STRING "android"
#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#define SUPPRESS_MAIN 
#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#define INFORM_FOLDER_RELATIVE_TO_HOME ""
#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#define CREATE_MUTEX(name) \
    	static pthread_mutex_t name = PTHREAD_MUTEX_INITIALIZER;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#define LOCK_MUTEX(name) pthread_mutex_lock(&name);
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#define UNLOCK_MUTEX(name) pthread_mutex_unlock(&name);
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_WINDOWS
#define PLATFORM_STRING "windows"
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define LOCALE_IS_ISO 
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define FOLDER_SEPARATOR '\\'
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define SHELL_QUOTE_CHARACTER '\"'
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define INFORM_FOLDER_RELATIVE_TO_HOME ""
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define CREATE_MUTEX(name) \
    	static struct Win32_Mutex name = { INIT_ONCE_STATIC_INIT, { 0 }};
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define LOCK_MUTEX(name) {\
    	BOOL pending;\
    	InitOnceBeginInitialize(&(name.init), 0, &pending, 0);\
    	if (pending) {\
    		InitializeCriticalSection(&(name.crit));\
    		InitOnceComplete(&(name.init), 0, 0);\
    	}\
    	EnterCriticalSection(&(name.crit));\
    }
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#define UNLOCK_MUTEX(name) {\
    	LeaveCriticalSection(&(name.crit));\
    }
#endif /* PLATFORM_WINDOWS */
#define LOG_INDENT STREAM_INDENT(DL)
#define LOG_OUTDENT STREAM_OUTDENT(DL)
#define DEBUGGING_LOG_INCLUSIONS_DA 0
#define SHELL_USAGE_DA 1
#define MEMORY_USAGE_DA 2
#define TEXT_FILES_DA 3
#define CLASS_DEFINITION \
    	int allocation_id; /* Numbered from 0 upwards in creation order */\
    	void *next_structure; /* Next object in double-linked list */\
    	void *prev_structure; /* Previous object in double-linked list */
#define unused_class_value_CLASS 0
#define SAFETY_MARGIN 128
#define BLANK_END_SIZE 256
#define MEMORY_GRANULARITY 100*1024*8 /* which must be divisible by 1024 */
#define INTEGRITY_NUMBER 0x12345678 /* a value unlikely to be in memory just by chance */
#define CREATE(type_name) (allocate_##type_name())
#define COPY(to, from, type_name) (copy_##type_name(to, from))
#define CREATE_BEFORE(existing, type_name) (allocate_##type_name##_before(existing))
#define DESTROY(this, type_name) (deallocate_##type_name(this))
#define FIRST_OBJECT(type_name) ((type_name *) alloc_status[type_name##_CLASS].first_in_memory)
#define LAST_OBJECT(type_name) ((type_name *) alloc_status[type_name##_CLASS].last_in_memory)
#define NEXT_OBJECT(this, type_name) ((type_name *) (this->next_structure))
#define PREV_OBJECT(this, type_name) ((type_name *) (this->prev_structure))
#define NUMBER_CREATED(type_name) (alloc_status[type_name##_CLASS].objects_count)
#define LOOP_OVER(var, type_name)\
    	for (var=FIRST_OBJECT(type_name); var != NULL; var = NEXT_OBJECT(var, type_name))
#define LOOP_BACKWARDS_OVER(var, type_name)\
    	for (var=LAST_OBJECT(type_name); var != NULL; var = PREV_OBJECT(var, type_name))
#define NEW_OBJECT(type_name) ((type_name *) Memory__allocate(type_name##_CLASS, sizeof(type_name)))
#define DECLARE_CLASS(type_name) DECLARE_CLASS_WITH_ID(type_name, type_name##_CLASS)
#define DECLARE_CLASS_WITH_ID(type_name, id_name)\
    MAKE_REFERENCE_ROUTINES(type_name, id_name)\
    type_name *allocate_##type_name(void) {\
    	LOCK_MUTEX(memory_single_allocation_mutex);\
    	alloc_status[id_name].name_of_type = #type_name;\
    	type_name *prev_obj = LAST_OBJECT(type_name);\
    	type_name *new_obj = Memory__allocate(type_name##_CLASS, sizeof(type_name));\
    	new_obj->allocation_id = alloc_status[id_name].objects_allocated-1;\
    	new_obj->next_structure = NULL;\
    	if (prev_obj != NULL)\
    		prev_obj->next_structure = (void *) new_obj;\
    	new_obj->prev_structure = prev_obj;\
    	alloc_status[id_name].objects_count++;\
    	UNLOCK_MUTEX(memory_single_allocation_mutex);\
    	return new_obj;\
    }\
    void deallocate_##type_name(type_name *kill_me) {\
    	LOCK_MUTEX(memory_single_allocation_mutex);\
    	type_name *prev_obj = PREV_OBJECT(kill_me, type_name);\
    	type_name *next_obj = NEXT_OBJECT(kill_me, type_name);\
    	if (prev_obj == NULL) {\
    		alloc_status[id_name].first_in_memory = next_obj;\
    	} else {\
    		prev_obj->next_structure = next_obj;\
    	}\
    	if (next_obj == NULL) {\
    		alloc_status[id_name].last_in_memory = prev_obj;\
    	} else {\
    		next_obj->prev_structure = prev_obj;\
    	}\
    	alloc_status[id_name].objects_count--;\
    	UNLOCK_MUTEX(memory_single_allocation_mutex);\
    }\
    type_name *allocate_##type_name##_before(type_name *existing) {\
    	LOCK_MUTEX(memory_single_allocation_mutex);\
    	type_name *new_obj = allocate_##type_name();\
    	deallocate_##type_name(new_obj);\
    	new_obj->prev_structure = existing->prev_structure;\
    	if (existing->prev_structure != NULL)\
    		((type_name *) existing->prev_structure)->next_structure = new_obj;\
    	else alloc_status[id_name].first_in_memory = (void *) new_obj;\
    	new_obj->next_structure = existing;\
    	existing->prev_structure = new_obj;\
    	alloc_status[id_name].objects_count++;\
    	UNLOCK_MUTEX(memory_single_allocation_mutex);\
    	return new_obj;\
    }\
    void copy_##type_name(type_name *to, type_name *from) {\
    	LOCK_MUTEX(memory_single_allocation_mutex);\
    	type_name *prev_obj = to->prev_structure;\
    	type_name *next_obj = to->next_structure;\
    	int aid = to->allocation_id;\
    	*to = *from;\
    	to->allocation_id = aid;\
    	to->next_structure = next_obj;\
    	to->prev_structure = prev_obj;\
    	UNLOCK_MUTEX(memory_single_allocation_mutex);\
    }
#define DECLARE_CLASS_ALLOCATED_IN_ARRAYS(type_name, NO_TO_ALLOCATE_TOGETHER)\
    MAKE_REFERENCE_ROUTINES(type_name, type_name##_CLASS)\
    typedef struct type_name##_array {\
    	int used;\
    	struct type_name array[NO_TO_ALLOCATE_TOGETHER];\
    	CLASS_DEFINITION\
    } type_name##_array;\
    int type_name##_array_CLASS = type_name##_CLASS; /* C does permit |#define| to make |#define|s */\
    DECLARE_CLASS_WITH_ID(type_name##_array, type_name##_CLASS)\
    type_name##_array *next_##type_name##_array = NULL;\
    struct type_name *allocate_##type_name(void) {\
    	LOCK_MUTEX(memory_array_allocation_mutex);\
    	if ((next_##type_name##_array == NULL) ||\
    		(next_##type_name##_array->used >= NO_TO_ALLOCATE_TOGETHER)) {\
    		alloc_status[type_name##_array_CLASS].no_allocated_together = NO_TO_ALLOCATE_TOGETHER;\
    		next_##type_name##_array = allocate_##type_name##_array();\
    		next_##type_name##_array->used = 0;\
    	}\
    	type_name *rv = &(next_##type_name##_array->array[next_##type_name##_array->used++]);\
    	UNLOCK_MUTEX(memory_array_allocation_mutex);\
    	return rv;\
    }
#define STREAM_MREASON 0
#define FILENAME_STORAGE_MREASON 1
#define STRING_STORAGE_MREASON 2
#define DICTIONARY_MREASON 3
#define ARRAY_SORTING_MREASON 4
#define NULL_GENERAL_POINTER (Memory__store_gp_null())
#define GENERAL_POINTER_IS_NULL(gp) (Memory__test_gp_null(gp))
#define COMPARE_GENERAL_POINTERS(gp1, gp2)\
    	(gp1.pointer_to_data == gp2.pointer_to_data)
#define GENERAL_POINTER_AS_INT(gp) \
    	((pointer_sized_int) gp.pointer_to_data)
#define MAKE_REFERENCE_ROUTINES(type_name, id_code)\
    general_pointer STORE_POINTER_##type_name(type_name *data) {\
    	general_pointer gp;\
    	gp.pointer_to_data = (void *) data;\
    	gp.run_time_type_code = id_code;\
    	return gp;\
    }\
    type_name *RETRIEVE_POINTER_##type_name(general_pointer gp) {\
    	if (gp.run_time_type_code != id_code) {\
    		LOG("Wanted ID code %d, found %d\n", id_code, gp.run_time_type_code);\
    		internal_error("attempt to retrieve wrong pointer type as " #type_name);\
    	}\
    	return (type_name *) gp.pointer_to_data;\
    }\
    general_pointer PASS_POINTER_##type_name(general_pointer gp) {\
    	if (gp.run_time_type_code != id_code) {\
    		LOG("Wanted ID code %d, found %d\n", id_code, gp.run_time_type_code);\
    		internal_error("attempt to pass wrong pointer type as " #type_name);\
    	}\
    	return gp;\
    }\
    int VALID_POINTER_##type_name(general_pointer gp) {\
    	if (gp.run_time_type_code == id_code) return TRUE;\
    	return FALSE;\
    }
#define chapter_md_CLASS 1
#define colouring_language_block_CLASS 2
#define colouring_rule_CLASS 3
#define command_line_switch_CLASS 4
#define debugging_aspect_CLASS 5
#define dict_entry_CLASS 6
#define dictionary_CLASS 7
#define ebook_chapter_CLASS 8
#define ebook_CLASS 9
#define ebook_datum_CLASS 10
#define ebook_image_CLASS 11
#define ebook_mark_CLASS 12
#define ebook_page_CLASS 13
#define ebook_volume_CLASS 14
#define filename_CLASS 15
#define hash_table_entry_CLASS 16
#define heterogeneous_tree_CLASS 17
#define HTML_file_state_CLASS 18
#define HTML_tag_CLASS 19
#define IFM_example_CLASS 20
#define JSON_pair_requirement_CLASS 21
#define JSON_requirement_CLASS 22
#define JSON_single_requirement_CLASS 23
#define JSON_type_CLASS 24
#define JSON_value_CLASS 25
#define linked_list_CLASS 26
#define linked_list_item_CLASS 27
#define markdown_item_CLASS 28
#define markdown_feature_CLASS 29
#define markdown_variation_CLASS 30
#define match_avinue_CLASS 31
#define match_trie_CLASS 32
#define md_link_dictionary_entry_CLASS 33
#define method_CLASS 34
#define method_set_CLASS 35
#define module_CLASS 36
#define module_search_CLASS 37
#define pathname_CLASS 38
#define md_doc_state_CLASS 39
#define md_links_dictionary_CLASS 40
#define md_emphasis_delimiter_CLASS 41
#define preprocessor_macro_CLASS 42
#define preprocessor_macro_parameter_CLASS 43
#define preprocessor_variable_CLASS 44
#define preprocessor_variable_set_CLASS 45
#define programming_language_CLASS 46
#define reserved_word_CLASS 47
#define scan_directory_CLASS 48
#define section_md_CLASS 49
#define semantic_version_number_holder_CLASS 50
#define semver_range_CLASS 51
#define stopwatch_timer_CLASS 52
#define string_storage_area_CLASS 53
#define text_stream_CLASS 54
#define tree_node_CLASS 55
#define tree_node_type_CLASS 56
#define tree_type_CLASS 57
#define web_bibliographic_datum_CLASS 58
#define web_md_CLASS 59
#define SHELL_LOCALE 0
#define CONSOLE_LOCALE 1
#define NEWLINE_IN_STRING ((char) 0x7f) /* Within quoted text, all newlines are converted to this */
#define OUTPUT_STREAM text_stream *OUT /* used only as a function prototype argument */
#define STDOUT Streams__get_stdout()
#define STDERR Streams__get_stderr()
#define PUT(c) Streams__putc(c, OUT)
#define PUT_TO(stream, c) Streams__putc(c, stream)
#define INDENT Streams__indent(OUT);
#define STREAM_INDENT(x) Streams__indent(x);
#define OUTDENT Streams__outdent(OUT);
#define STREAM_OUTDENT(x) Streams__outdent(x);
#define SET_INDENT(N) Streams__set_indentation(OUT, N);
#define TEMPORARY_TEXT(T) \
    	inchar32_t T##_dest[2048];\
    	text_stream T##_stream_structure = Streams__new_buffer(2048, T##_dest);\
    	text_stream *T = &T##_stream_structure;
#define DISCARD_TEXT(T) \
    	STREAM_CLOSE(T);
#define STREAM_OPEN_TO_FILE(new, fn, enc) Streams__open_to_file(new, fn, enc)
#define STREAM_OPEN_TO_FILE_APPEND(new, fn, enc) Streams__open_to_file_append(new, fn, enc)
#define STREAM_OPEN_IN_MEMORY(new) Streams__open_to_memory(new, 20480)
#define STREAM_CLOSE(stream) Streams__close(stream)
#define STREAM_FLUSH(stream) Streams__flush(stream)
#define STREAM_EXTENT(x) Streams__get_position(x)
#define STREAM_MUST_BE_IN_MEMORY(x) \
    	if ((x != NULL) && (x->write_to_memory == NULL))\
    		internal_error("text_stream not in memory");
#define STREAM_BACKSPACE(x) Streams__set_position(x, Streams__get_position(x) - 1)
#define STREAM_ERASE_BACK_TO(start_position) Streams__set_position(OUT, start_position)
#define STREAM_MOST_RECENT_CHAR(x) Streams__latest(x)
#define STREAM_COPY(to, from) Streams__copy(to, from)
#define MALLOCED_STRF 0x00000001 /* was the |write_to_memory| pointer claimed by |malloc|? */
#define USES_XML_ESCAPES_STRF 0x00000002 /* see above */
#define USES_LOG_ESCAPES_STRF 0x00000004 /* |WRITE| to this stream supports |$| escapes */
#define INDENT_PENDING_STRF 0x00000008 /* we have just ended a line, so further text should indent */
#define FILE_ENCODING_ISO_STRF 0x00000010 /* relevant only for file streams */
#define FILE_ENCODING_UTF8_STRF 0x00000020 /* relevant only for file streams */
#define ECHO_BYTES_STRF 0x00000080 /* for debugging only */
#define FOR_RE_STRF 0x00000100 /* for debugging only */
#define FOR_TT_STRF 0x00000200 /* for debugging only */
#define FOR_CO_STRF 0x00000400 /* for debugging only */
#define FOR_FI_STRF 0x00000800 /* for debugging only */
#define FOR_OM_STRF 0x00001000 /* for debugging only */
#define USES_I6_ESCAPES_STRF 0x00002000 /* as if an Inform 6 string */
#define READ_ONLY_STRF 0x00008000
#define INDENTATION_BASE_STRF 0x00010000 /* number of tab stops in from the left margin */
#define INDENTATION_MASK_STRF 0x0FFF0000 /* (held in these bits) */
#define STREAM_USES_UTF8(x) ((x)?((x->stream_flags) & FILE_ENCODING_UTF8_STRF):FALSE)
#define SPACE_AT_END_OF_STREAM 6
#define VACANT_ECAT 0		/* unregistered */
#define POINTER_ECAT 1		/* data to be printed is a pointer to a structure */
#define INTSIZED_ECAT 2		/* data to be printed is or fits into an integer */
#define WORDING_ECAT 3		/* data to be printed is a |wording| structure from inform7 */
#define DIRECT_ECAT 4		/* data must be printed directly by the code below */
#define REGISTER_WRITER(c, f) Writers__register_logger(c, &f##_writer);
#define COMPILE_WRITER(t, f)\
    	void f##_writer(text_stream *format, void *obj) { text_stream *SDL = DL; DL = format; if (DL) f((t) obj); DL = SDL; }
#define REGISTER_WRITER_I(c, f) Writers__register_logger_I(c, &f##_writer);
#define COMPILE_WRITER_I(t, f)\
    	void f##_writer(text_stream *format, int I) { text_stream *SDL = DL; DL = format; if (DL) f((t) I); DL = SDL; }
#define UNUSED_METHOD_ID_MTID 1
#define INT_METHOD_TYPE(id, args...)\
    	typedef int (*id##_type)(args);
#define VOID_METHOD_TYPE(id, args...)\
    	typedef void (*id##_type)(args);
#define METHOD_ADD(upon, id, func)\
    	Methods__add(upon->methods, id, (void *) &func);
#define INT_METHOD_CALL(rval, upon, id, args...) {\
    	rval = FALSE;\
    	for (method *M = upon?(upon->methods->first_method):NULL; M; M = M->next_method)\
    		if (M->method_id == id) {\
    			int method_rval_ = (*((id##_type) (M->method_function)))(upon, args);\
    			if (method_rval_) {\
    				rval = method_rval_;\
    				break;\
    			}\
    		}\
    }
#define INT_METHOD_CALL_WITHOUT_ARGUMENTS(rval, upon, id) {\
    	rval = FALSE;\
    	for (method *M = upon?(upon->methods->first_method):NULL; M; M = M->next_method)\
    		if (M->method_id == id) {\
    			int method_rval_ = (*((id##_type) (M->method_function)))(upon);\
    			if (method_rval_) {\
    				rval = method_rval_;\
    				break;\
    			}\
    		}\
    }
#define VOID_METHOD_CALL(upon, id, args...)\
    	for (method *M = upon?(upon->methods->first_method):NULL; M; M = M->next_method)\
    		if (M->method_id == id)\
    			(*((id##_type) (M->method_function)))(upon, args);
#define VOID_METHOD_CALL_WITHOUT_ARGUMENTS(upon, id)\
    	for (method *M = upon?(upon->methods->first_method):NULL; M; M = M->next_method)\
    		if (M->method_id == id)\
    			(*((id##_type) (M->method_function)))(upon);
#define NO_LL_EARLY_ITEMS 32
#define NEW_LINKED_LIST(T) \
    	(LinkedLists__new())
#define FIRST_ITEM_IN_LINKED_LIST(T, L)\
    	(LinkedLists__first(L))
#define ENTRY_IN_LINKED_LIST(N, T, L)\
    	((T *) (LinkedLists__entry(N, L)))
#define DELETE_FROM_LINKED_LIST(N, T, L)\
    	((T *) (LinkedLists__delete(N, L)))
#define LAST_ITEM_IN_LINKED_LIST(T, L)\
    	(LinkedLists__last(L))
#define NEXT_ITEM_IN_LINKED_LIST(I, T)\
    	(LinkedLists__next(I))
#define CONTENT_IN_ITEM(I, T)\
    	((T *) (LinkedLists__content(I)))
#define ADD_TO_LINKED_LIST(I, T, L)\
    	LinkedLists__add(L, (void *) (I), TRUE)
#define FIRST_IN_LINKED_LIST(T, L)\
    	((T *) (LinkedLists__content(LinkedLists__first(L))))
#define LAST_IN_LINKED_LIST(T, L)\
    	((T *) (LinkedLists__content(LinkedLists__last(L))))
#define LOOP_OVER_LINKED_LIST(P, T, L)\
    	for (linked_list_item *P##_item = (P = FIRST_IN_LINKED_LIST(T, L), FIRST_ITEM_IN_LINKED_LIST(T, L));\
    		P##_item;\
    		P##_item = (P = CONTENT_IN_ITEM(NEXT_ITEM_IN_LINKED_LIST(P##_item, T), T), NEXT_ITEM_IN_LINKED_LIST(P##_item, T)))
#define lifo_stack linked_list
#define NEW_LIFO_STACK(T) \
    	(LinkedLists__new())
#define PUSH_TO_LIFO_STACK(I, T, L)\
    	LinkedLists__add((L), (void *) (I), FALSE)
#define PULL_FROM_LIFO_STACK(T, L)\
    	((T *) LinkedLists__remove_from_front(L))
#define POP_LIFO_STACK(T, L)\
    	(LinkedLists__remove_from_front(L))
#define TOP_OF_LIFO_STACK(T, L)\
    	FIRST_IN_LINKED_LIST(T, L)
#define LIFO_STACK_EMPTY(T, L)\
    	((LinkedLists__len(L) == 0)?TRUE:FALSE)
#define LOOP_DOWN_LIFO_STACK(P, T, L)\
    	LOOP_OVER_LINKED_LIST(P, T, L)
#define internal_error(message) Errors__internal_error_handler(NULL, message, __FILE__, __LINE__)
#define ACTION_CLSF 1
#define BOOLEAN_ON_CLSF 2
#define BOOLEAN_OFF_CLSF 3
#define NUMERICAL_CLSF 4
#define TEXTUAL_CLSF 5
#define NO_CLSG 0
#define FOUNDATION_CLSG 1
#define BOGUS_CLSN -12345678 /* bogus because guaranteed not to be a genuine switch ID */
#define FORMAT_PERHAPS_HTML 1
#define FORMAT_PERHAPS_JPEG 2
#define FORMAT_PERHAPS_PNG 3
#define FORMAT_PERHAPS_OGG 4
#define FORMAT_PERHAPS_AIFF 5
#define FORMAT_PERHAPS_MIDI 6
#define FORMAT_PERHAPS_MOD 7
#define FORMAT_PERHAPS_GLULX 8
#define FORMAT_PERHAPS_ZCODE 9
#define FORMAT_PERHAPS_SVG 10
#define FORMAT_PERHAPS_GIF 11
#define FORMAT_UNRECOGNISED 0
#define SPOOL_LENGTH 4*8*MAX_FILENAME_LENGTH
#define CHRISTMAS_FEAST 1
#define EASTER_FEAST 2
#define NON_FEAST 3
#define MAX_STRING_LENGTH 8*1024
#define LOOP_THROUGH_TEXT(P, ST)\
    	for (string_position P = Str__start(ST); P.index < Str__len(P.S); P.index++)
#define LOOP_BACKWARDS_THROUGH_TEXT(P, ST)\
    	for (string_position P = Str__back(Str__end(ST)); P.index >= 0; P.index--)
#define NONE_UFBHM 1
#define ZSCII_UFBHM 2
#define UNICODE_UFBHM 3
#define PROTECTED_OPEN_BRACE_PPCHAR 0x25A0
#define PROTECTED_CLOSE_BRACE_PPCHAR 0x25A1
#define PROTECTED_BLANK_PPCHAR 0x25A2
#define MAX_PREPROCESSOR_LOOP_DEPTH 8
#define MAX_PP_MACRO_PARAMETERS 8
#define MAX_PP_MACRO_LINES 128
#define TRIE_START -1 /* head: the root of a trie parsing forwards from the start */
#define TRIE_END -2 /* head: the root of a trie parsing backwards from the end */
#define TRIE_ANYTHING 10003 /* choice: match any text here */
#define TRIE_ANY_GROUP 10001 /* choice: match any character from this group */
#define TRIE_NOT_GROUP 10002 /* choice: match any character not in this group */
#define TRIE_STOP -3 /* terminal: here's the outcome */
#define MAX_TRIE_GROUP_SIZE 26 /* size of the allowable groups of characters */
#define MAX_TRIE_REWIND 10 /* that should be far, far more rewinding than necessary */
#define MAX_BRACKETED_SUBEXPRESSIONS 5 /* this many bracketed subexpressions can be extracted */
#define MATCH_TEXT_INITIAL_ALLOCATION 64
#define ANY_CHARCLASS 1
#define DIGIT_CHARCLASS 2
#define WHITESPACE_CHARCLASS 3
#define NONWHITESPACE_CHARCLASS 4
#define IDENTIFIER_CHARCLASS 5
#define PREFORM_CHARCLASS 6
#define PREFORMC_CHARCLASS 7
#define LITERAL_CHARCLASS 8
#define TAB_CHARCLASS 9
#define QUOTE_CHARCLASS 10
#define REP_REPEATING 1
#define REP_ATSTART 2
#define NUMBER_JSONTYPE 1
#define DOUBLE_JSONTYPE 2
#define STRING_JSONTYPE 3
#define BOOLEAN_JSONTYPE 4
#define ARRAY_JSONTYPE 5
#define OBJECT_JSONTYPE 6
#define NULL_JSONTYPE 7
#define ERROR_JSONTYPE 8
#define tag_error(x) {\
    	LOG("Tag error: %s\n", x);\
    	HTML_tag *ht;\
    	int i = 1;\
    	LOG("HTML tag stack:\n");\
    	LOOP_DOWN_LIFO_STACK(ht, HTML_tag, hs->tag_stack) {\
    		LOG("    %d. %s (opened at line %d of '%s')\n", i++,\
    			ht->tag_name, ht->from_line, ht->from_filename);\
    	}\
    	LOG("\n\n");\
    }
#define HTML_TAG(tag) HTML__tag(OUT, tag, NULL);
#define HTML_OPEN(tag) HTML__open(OUT, tag, NULL, __FILE__, __LINE__);
#define HTML_CLOSE(tag) HTML__close(OUT, tag, __FILE__, __LINE__);
#define CORNER_SIZE 8 /* measured in pixels */
#define ROUND_BOX_TOP 1
#define ROUND_BOX_BOTTOM 2
#define SOURCE_REF_CHAR L'\xf0'
#define FORCE_NEW_PARA_CHAR L'\xd0'
#define DOCUMENT_MIT 1
#define FILE_MIT 2
#define BLOCK_QUOTE_MIT 3
#define UNORDERED_LIST_MIT 4
#define ORDERED_LIST_MIT 5
#define UNORDERED_LIST_ITEM_MIT 6
#define ORDERED_LIST_ITEM_MIT 7
#define PARAGRAPH_MIT 8
#define THEMATIC_MIT 9
#define HEADING_MIT 10
#define CODE_BLOCK_MIT 11
#define HTML_MIT 12
#define EMPTY_MIT 13
#define MATERIAL_MIT 14
#define PLAIN_MIT 15
#define LINE_BREAK_MIT 16
#define SOFT_BREAK_MIT 17
#define EMPHASIS_MIT 18
#define STRONG_MIT 19
#define CODE_MIT 20
#define URI_AUTOLINK_MIT 21
#define EMAIL_AUTOLINK_MIT 22
#define INLINE_HTML_MIT 23
#define LINK_MIT 24
#define IMAGE_MIT 25
#define LINK_DEST_MIT 26
#define LINK_TITLE_MIT 27
#define TABLE_MIT 28
#define TABLE_COLUMN_MIT 29
#define TABLE_ROW_MIT 30
#define TICKBOX_MIT 31
#define STRIKETHROUGH_MIT 32
#define XMPP_AUTOLINK_MIT 33
#define MAX_MARKDOWN_CONTAINER_DEPTH 128 /* human users rarely exceed 2 */
#define NO_MDINTERPRETATIONS 12 /* well, okay, so there are actually 11, but... */
#define WHITESPACE_MDINTERPRETATION 1
#define THEMATIC_MDINTERPRETATION 2
#define ATX_HEADING_MDINTERPRETATION 3
#define SETEXT_UNDERLINE_MDINTERPRETATION 4
#define HTML_MDINTERPRETATION 5
#define CODE_FENCE_OPEN_MDINTERPRETATION 6
#define CODE_FENCE_CLOSE_MDINTERPRETATION 7
#define CODE_BLOCK_MDINTERPRETATION 8
#define FENCED_CODE_BLOCK_MDINTERPRETATION 9
#define HTML_CONTINUATION_MDINTERPRETATION 10
#define LAZY_CONTINUATION_MDINTERPRETATION 11
#define PRE_MDHTMLC 1
#define COMMENT_MDHTMLC 2
#define QUERY_MDHTMLC 3
#define PLING_MDHTMLC 4
#define CDATA_MDHTMLC 5
#define MISCSINGLE_MDHTMLC 6
#define MISCPAIR_MDHTMLC 7
#define ABANDON_LINK(reason) \
    	{ if (tracing_Markdown_parser) { PRINT("Link abandoned: %s\n", reason); }\
    	pos = abandon_at; goto AbandonHope; }
#define ASTERISK_EMPHASIS_BIT 1
#define UNDERSCORE_EMPHASIS_BIT 2
#define TILDE_STRIKETHROUGH_BIT 4
#define MAX_MD_EMPHASIS_PAIRS (MAX_MD_EMPHASIS_DELIMITERS*MAX_MD_EMPHASIS_DELIMITERS)
#define MAX_MD_EMPHASIS_DELIMITERS 10
#define TAGS_MDRMODE 0x0001     /* Render HTML tags? */
#define ESCAPES_MDRMODE 0x0002     /* Treat backslash followed by ASCII punctuation as an escape? */
#define URI_MDRMODE 0x0004     /* Encode characters as they need to appear in a URI */
#define RAW_MDRMODE 0x0008     /* Treat all characters literally */
#define LOOSE_MDRMODE 0x0010     /* Wrap list items in paragraph tags */
#define ENTITIES_MDRMODE 0x0020     /* Convert |&entity;| to whatever it ought to represent */
#define FILTERED_MDRMODE 0x0040     /* Make first |<| character safe as |&lt;| */
#define TOLOWER_MDRMODE 0x0080     /* Force letters to lower case */
#define MARKDOWN_URI_HEX(x) {\
    		unsigned int z = (unsigned int) x;\
    		PUT('%');\
    		MDRenderer__hex_digit(OUT, z >> 4);\
    		MDRenderer__hex_digit(OUT, z & 0x0f);\
    	}
#define MAX_MARKDOWNFEATURES 256
#define BLOCK_QUOTES_MARKDOWNFEATURE 0
#define ORDERED_LISTS_MARKDOWNFEATURE 1
#define UNORDERED_LISTS_MARKDOWNFEATURE 2
#define INDENTED_CODE_BLOCKS_MARKDOWNFEATURE 3
#define FENCED_CODE_BLOCKS_MARKDOWNFEATURE 4
#define HTML_BLOCKS_MARKDOWNFEATURE 5
#define THEMATIC_MARKERS_MARKDOWNFEATURE 6
#define ATX_HEADINGS_MARKDOWNFEATURE 7
#define SETEXT_HEADINGS_MARKDOWNFEATURE 8
#define WEB_AUTOLINKS_MARKDOWNFEATURE 9
#define EMAIL_AUTOLINKS_MARKDOWNFEATURE 10
#define INLINE_HTML_MARKDOWNFEATURE 11
#define BACKTICKED_CODE_MARKDOWNFEATURE 12
#define LINKS_MARKDOWNFEATURE 13
#define IMAGES_MARKDOWNFEATURE 14
#define ASTERISK_EMPHASIS_MARKDOWNFEATURE 15
#define UNDERSCORE_EMPHASIS_MARKDOWNFEATURE 16
#define ENTITIES_MARKDOWNFEATURE 17
#define STRIKETHROUGH_MARKDOWNFEATURE 18
#define TABLES_MARKDOWNFEATURE 19
#define TASK_LIST_ITEMS_MARKDOWNFEATURE 20
#define EXTENDED_AUTOLINKS_MARKDOWNFEATURE 21
#define DISALLOWED_RAW_HTML_MARKDOWNFEATURE 22
#define RENDER_MARKDOWN_MTID 2
#define POST_PHASE_I_MARKDOWN_MTID 3
#define POST_PHASE_II_MARKDOWN_MTID 4
#define MULTIFILE_MARKDOWN_MTID 5
#define FORMATTING_ERRORS_MARKDOWNFEATURE 23
#define INFORM_ERROR_MARKER_MIT 34
#define OLD_INDOC_HEADINGS_MARKDOWNFEATURE 24
#define DESCRIPTIVE_INFORM_HEADINGS_MARKDOWNFEATURE 25
#define EMBEDDED_EXAMPLES_MARKDOWNFEATURE 26
#define INFORM_EXAMPLE_HEADING_MIT 35
#define PASTE_BUTTONS_MARKDOWNFEATURE 27
#define PHRASE_DEFN_BOXES_MARKDOWNFEATURE 28
#define INDEXING_MARKS_MARKDOWNFEATURE 29
#define INDEX_MARKER_MIT 36
#define HEADING_MARKERS_MARKDOWNFEATURE 30
#define HEADING_MARKER_MIT 37
#define PARAGRAPH_GATING_MARKDOWNFEATURE 31
#define GATE_MIT 38
#define INDOC_FILE_DIVISIONS_MARKDOWNFEATURE 32
#define INFORM_SYNTAX_COLOURING_MARKDOWNFEATURE 33
#define SEMVER_NUMBER_DEPTH 3 /* major, minor, patch */
#define MMP_SEMVERPART 1
#define PRE_SEMVERPART 2
#define BM_SEMVERPART 3
#define CLOSED_RANGE_END 1
#define OPEN_RANGE_END 2
#define INFINITE_RANGE_END 3
#define EMPTY_RANGE_END 4
#define V1_SYNTAX 1
#define V2_SYNTAX 2
#define LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, Wm)\
    	LOOP_OVER_LINKED_LIST(bd, web_bibliographic_datum, Wm->bibliographic_data)
#define READING_WEB_MOM 0
#define MAKEFILE_TOOL_MOM 1
#define MAKEFILE_WEB_MOM 2
#define MAKEFILE_MODULE_MOM 3
#define INWEB_PARAGRAPH_SYNTAX 1
#define INWEB_CODE_SYNTAX 2
#define INWEB_DASH_SYNTAX 3
#define INWEB_PURPOSE_SYNTAX 4
#define INWEB_FIGURE_SYNTAX 5
#define INWEB_EQUALS_SYNTAX 6
#define INWEB_EXTRACT_SYNTAX 7
#define WHOLE_LINE_CRULE_RUN -1 /* This block applies to the whole snippet being coloured */
#define CHARACTERS_CRULE_RUN -2 /* This block applies to each character in turn */
#define CHARACTERS_IN_CRULE_RUN -3 /* This block applies to each character from a set in turn */
#define INSTANCES_CRULE_RUN -4 /* This block applies to each instance in turn */
#define MATCHES_CRULE_RUN -5 /* This block applies to each match against a regexp in turn */
#define BRACKETS_CRULE_RUN -6 /* This block applies to bracketed subexpressions in a regexp */
#define NOT_A_RULE_PREFIX 1 /* this isn't a prefix rule */
#define UNSPACED_RULE_PREFIX 2 /* for |prefix P| */
#define SPACED_RULE_PREFIX 3 /* for |spaced prefix P| */
#define OPTIONALLY_SPACED_RULE_PREFIX 4 /* for |optionally spaced prefix P| */
#define UNSPACED_RULE_SUFFIX 5 /* for |suffix P| */
#define SPACED_RULE_SUFFIX 6 /* for |spaced suffix P| */
#define OPTIONALLY_SPACED_RULE_SUFFIX 7 /* for |optionally spaced suffix P| */
#define MAX_ILDF_REGEXP_LENGTH 64
#define DEFINITION_COLOUR 'd'
#define FUNCTION_COLOUR 'f'
#define RESERVED_COLOUR 'r'
#define ELEMENT_COLOUR 'e'
#define IDENTIFIER_COLOUR 'i'
#define CHARACTER_COLOUR 'c'
#define CONSTANT_COLOUR 'n'
#define STRING_COLOUR 's'
#define PLAIN_COLOUR 'p'
#define EXTRACT_COLOUR 'x'
#define COMMENT_COLOUR '!'
#define NEWLINE_COLOUR '\n'
#define NOT_A_COLOUR ' '
#define UNQUOTED_COLOUR '_'
#define HASH_TAB_SIZE 1000 /* the possible hash codes are 0 up to this minus 1 */
#define NUMBER_HASH 0 /* literal decimal integers, and no other words, have this hash code */
#define HASH_SAFETY_CODE 0x31415927
#define UNSPACED_RULE_PREFIX 2 /* for |prefix P| */
#define SPACED_RULE_PREFIX 3 /* for |spaced prefix P| */
#define OPTIONALLY_SPACED_RULE_PREFIX 4 /* for |optionally spaced prefix P| */
#define UNSPACED_RULE_SUFFIX 5 /* for |suffix P| */
#define SPACED_RULE_SUFFIX 6 /* for |spaced suffix P| */
#define OPTIONALLY_SPACED_RULE_SUFFIX 7 /* for |optionally spaced suffix P| */
#define PROGRAM_NAME "inweb"
#define THIS_IS_INWEB 
#define asset_rule_CLASS 60
#define breadcrumb_request_CLASS 61
#define chapter_CLASS 62
#define colony_CLASS 63
#define colony_member_CLASS 64
#define colour_scheme_CLASS 65
#define defined_constant_CLASS 66
#define enumeration_set_CLASS 67
#define footnote_CLASS 68
#define hash_table_entry_usage_CLASS 69
#define language_function_CLASS 70
#define language_type_CLASS 71
#define macro_usage_CLASS 72
#define makefile_specifics_CLASS 73
#define nonterminal_variable_CLASS 74
#define para_macro_CLASS 75
#define paragraph_CLASS 76
#define paragraph_tagging_CLASS 77
#define preform_nonterminal_CLASS 78
#define section_CLASS 79
#define source_line_CLASS 80
#define structure_element_CLASS 81
#define tangle_target_CLASS 82
#define tex_results_CLASS 83
#define text_literal_CLASS 84
#define theme_tag_CLASS 85
#define weave_format_CLASS 86
#define weave_pattern_CLASS 87
#define weave_plugin_CLASS 88
#define weave_order_CLASS 89
#define web_CLASS 90
#define writeme_asset_CLASS 91
#define weave_document_node_CLASS 92
#define weave_head_node_CLASS 93
#define weave_body_node_CLASS 94
#define weave_tail_node_CLASS 95
#define weave_section_header_node_CLASS 96
#define weave_section_footer_node_CLASS 97
#define weave_chapter_header_node_CLASS 98
#define weave_chapter_footer_node_CLASS 99
#define weave_verbatim_node_CLASS 100
#define weave_section_purpose_node_CLASS 101
#define weave_subheading_node_CLASS 102
#define weave_bar_node_CLASS 103
#define weave_linebreak_node_CLASS 104
#define weave_pagebreak_node_CLASS 105
#define weave_paragraph_heading_node_CLASS 106
#define weave_endnote_node_CLASS 107
#define weave_material_node_CLASS 108
#define weave_figure_node_CLASS 109
#define weave_extract_node_CLASS 110
#define weave_audio_node_CLASS 111
#define weave_download_node_CLASS 112
#define weave_video_node_CLASS 113
#define weave_embed_node_CLASS 114
#define weave_pmac_node_CLASS 115
#define weave_vskip_node_CLASS 116
#define weave_chapter_node_CLASS 117
#define weave_section_node_CLASS 118
#define weave_code_line_node_CLASS 119
#define weave_function_usage_node_CLASS 120
#define weave_commentary_node_CLASS 121
#define weave_carousel_slide_node_CLASS 122
#define weave_toc_node_CLASS 123
#define weave_toc_line_node_CLASS 124
#define weave_chapter_title_page_node_CLASS 125
#define weave_defn_node_CLASS 126
#define weave_source_code_node_CLASS 127
#define weave_url_node_CLASS 128
#define weave_footnote_cue_node_CLASS 129
#define weave_begin_footnote_text_node_CLASS 130
#define weave_display_line_node_CLASS 131
#define weave_function_defn_node_CLASS 132
#define weave_item_node_CLASS 133
#define weave_grammar_index_node_CLASS 134
#define weave_inline_node_CLASS 135
#define weave_locale_node_CLASS 136
#define weave_maths_node_CLASS 137
#define NO_MODE 0
#define ANALYSE_MODE 1
#define TANGLE_MODE 2
#define WEAVE_MODE 3
#define TRANSLATE_MODE 4
#define SWARM_OFF_SWM 0
#define SWARM_INDEX_SWM 1
#define SWARM_CHAPTERS_SWM 2
#define SWARM_SECTIONS_SWM 3
#define VERBOSE_CLSW 7
#define IMPORT_FROM_CLSW 8
#define LANGUAGES_CLSG 2
#define LANGUAGE_CLSW 9
#define LANGUAGES_CLSW 10
#define SHOW_LANGUAGES_CLSW 11
#define TEST_LANGUAGE_CLSW 12
#define TEST_LANGUAGE_ON_CLSW 13
#define ANALYSIS_CLSG 3
#define CATALOGUE_CLSW 14
#define FUNCTIONS_CLSW 15
#define STRUCTURES_CLSW 16
#define ADVANCE_CLSW 17
#define GITIGNORE_CLSW 18
#define MAKEFILE_CLSW 19
#define WRITEME_CLSW 20
#define PLATFORM_CLSW 21
#define ADVANCE_FILE_CLSW 22
#define PROTOTYPE_CLSW 23
#define SCAN_CLSW 24
#define WEAVING_CLSG 4
#define WEAVE_CLSW 25
#define WEAVE_INTO_CLSW 26
#define WEAVE_TO_CLSW 27
#define OPEN_CLSW 28
#define WEAVE_AS_CLSW 29
#define WEAVE_TAG_CLSW 30
#define BREADCRUMB_CLSW 31
#define NAVIGATION_CLSW 32
#define TANGLING_CLSG 5
#define TANGLE_CLSW 33
#define TANGLE_TO_CLSW 34
#define CTAGS_TO_CLSW 35
#define CTAGS_CLSW 36
#define COLONIAL_CLSG 6
#define COLONY_CLSW 37
#define MEMBER_CLSW 38
#define EMBED_ASSET_METHOD 1
#define COPY_ASSET_METHOD 2
#define PRIVATE_COPY_ASSET_METHOD 3
#define COLLATE_ASSET_METHOD 4
#define LOOP_WITHIN_TANGLE(C, S, T)\
    	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)\
    		LOOP_OVER_LINKED_LIST(S, section, C->sections)\
    			if (S->sect_target == T)\
    				for (source_line *L = S->first_line; L; L = L->next_line)
#define NO_LCAT 0
#define BAR_LCAT 1
#define BEGIN_CODE_LCAT 2
#define BEGIN_DEFINITION_LCAT 3
#define C_LIBRARY_INCLUDE_LCAT 4
#define CHAPTER_HEADING_LCAT 5
#define CODE_BODY_LCAT 6
#define COMMAND_LCAT 7
#define COMMENT_BODY_LCAT 8
#define CONT_DEFINITION_LCAT 9
#define DEFINITIONS_LCAT 10
#define END_EXTRACT_LCAT 11
#define FOOTNOTE_TEXT_LCAT 12
#define HEADING_START_LCAT 13
#define INTERFACE_BODY_LCAT 14
#define INTERFACE_LCAT 15
#define MACRO_DEFINITION_LCAT 16
#define PARAGRAPH_START_LCAT 17
#define PREFORM_GRAMMAR_LCAT 18
#define PREFORM_LCAT 19
#define PURPOSE_BODY_LCAT 20
#define PURPOSE_LCAT 21
#define SECTION_HEADING_LCAT 22
#define SOURCE_DISPLAY_LCAT 23
#define TEXT_EXTRACT_LCAT 24
#define TYPEDEF_LCAT 25
#define NO_CMD 0
#define PAGEBREAK_CMD 1
#define GRAMMAR_INDEX_CMD 2
#define FIGURE_CMD 3
#define AUDIO_CMD 4
#define VIDEO_CMD 5
#define DOWNLOAD_CMD 6
#define CAROUSEL_CMD 7
#define CAROUSEL_ABOVE_CMD 8
#define CAROUSEL_BELOW_CMD 9
#define CAROUSEL_UNCAPTIONED_CMD 10
#define CAROUSEL_END_CMD 11
#define EMBED_CMD 12
#define TAG_CMD 13
#define HTML_CMD 14
#define ORDINARY_WEIGHT 0 /* an ordinary paragraph has this "weight" */
#define SUBHEADING_WEIGHT 1 /* a heading paragraph */
#define POINTS_PER_CM 72
#define BASIC_SECTIONCAT 1
#define STRUCTURES_SECTIONCAT 2
#define FUNCTIONS_SECTIONCAT 3
#define ELEMENT_ACCESS_USAGE 0x00000001 /* C-like languages: access via |->| or |.| operators to structure element */
#define FCALL_USAGE 0x00000002 /* C-like languages: function call made using brackets, |name(args)| */
#define PREFORM_IN_CODE_USAGE 0x00000004 /* InC only: use of a Preform nonterminal as a C "constant" */
#define PREFORM_IN_GRAMMAR_USAGE 0x00000008 /* InC only: ditto, but within Preform production rather than C code */
#define MISC_USAGE 0x00000010 /* any other appearance as an identifier */
#define ANY_USAGE 0x7fffffff /* any of the above */
#define TRACE_COLLATER_EXECUTION FALSE /* set true for debugging */
#define MAX_TEMPLATE_LINES 8192 /* maximum number of lines in template */
#define CI_STACK_CAPACITY 8 /* maximum recursion of chapter/section iteration */
#define MODULE_LEVEL 1
#define CHAPTER_LEVEL 2
#define SECTION_LEVEL 3
#define IF_TRUE_LEVEL 4
#define IF_FALSE_LEVEL 5
#define COMMENTARY_MATERIAL 1
#define MACRO_MATERIAL 2
#define DEFINITION_MATERIAL 3
#define CODE_MATERIAL 4
#define ENDNOTES_MATERIAL 5
#define FOOTNOTES_MATERIAL 6
#define LOOP_OVER_PARAGRAPHS(C, S, T, P)\
    	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)\
    		LOOP_OVER_LINKED_LIST(S, section, C->sections)\
    			if (S->sect_target == T)\
    				LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
#define MAX_EXTRACT_FILES 10
#define PARSE_TYPES_PAR_MTID 6
#define PARSE_FUNCTIONS_PAR_MTID 7
#define FURTHER_PARSING_PAR_MTID 8
#define SUBCATEGORISE_LINE_PAR_MTID 9
#define PARSE_COMMENT_TAN_MTID 10
#define SHEBANG_TAN_MTID 11
#define SUPPRESS_DISCLAIMER_TAN_MTID 12
#define ADDITIONAL_EARLY_MATTER_TAN_MTID 13
#define START_DEFN_TAN_MTID 14
#define PROLONG_DEFN_TAN_MTID 15
#define END_DEFN_TAN_MTID 16
#define ADDITIONAL_PREDECLARATIONS_TAN_MTID 17
#define SUPPRESS_EXPANSION_TAN_MTID 18
#define TANGLE_COMMAND_TAN_MTID 19
#define WILL_TANGLE_EXTRA_LINE_TAN_MTID 20
#define TANGLE_EXTRA_LINE_TAN_MTID 21
#define INSERT_LINE_MARKER_TAN_MTID 22
#define BEFORE_MACRO_EXPANSION_TAN_MTID 23
#define AFTER_MACRO_EXPANSION_TAN_MTID 24
#define OPEN_IFDEF_TAN_MTID 25
#define CLOSE_IFDEF_TAN_MTID 26
#define COMMENT_TAN_MTID 27
#define TANGLE_LINE_UNUSUALLY_TAN_MTID 28
#define GNABEHS_TAN_MTID 29
#define ADDITIONAL_TANGLING_TAN_MTID 30
#define BEGIN_WEAVE_WEA_MTID 31
#define SKIP_IN_WEAVING_WEA_MTID 32
#define RESET_SYNTAX_COLOURING_WEA_MTID 33
#define SYNTAX_COLOUR_WEA_MTID 34
#define WEAVE_CODE_LINE_WEA_MTID 35
#define NOTIFY_NEW_TAG_WEA_MTID 36
#define ANALYSIS_ANA_MTID 37
#define POST_ANALYSIS_ANA_MTID 38
#define SHARE_ELEMENT_ANA_MTID 39
#define MAX_CONDITIONAL_COMPILATION_STACK 8
#define MAX_ARG_LINES 32 /* maximum number of lines over which a function's header can extend */
#define NOT_A_NONTERMINAL -4
#define A_FLEXIBLE_NONTERMINAL -3
#define A_VORACIOUS_NONTERMINAL -2
#define A_GRAMMAR_NONTERMINAL -1
#define INFINITE_WORD_COUNT 1000000000
#define MAX_PREFORM_RESULT_CLAUSES 10
#define SPACES_PER_TAB_IN_WOVEN_CODE 4
#define BEGIN_WEAVING_FOR_MTID 40
#define END_WEAVING_FOR_MTID 41
#define RENDER_FOR_MTID 42
#define PREFORM_DOCUMENT_FOR_MTID 43
#define POST_PROCESS_POS_MTID 44
#define POST_PROCESS_REPORT_POS_MTID 45
#define POST_PROCESS_SUBSTITUTE_POS_MTID 46
#define PDFTEX_TEX_FORM 1
#define NO_DEFINED_CLSW_VALUES 39
#define NO_DEFINED_DA_VALUES 4
#define NO_DEFINED_CLASS_VALUES 138
#define NO_DEFINED_MREASON_VALUES 5
#define NO_DEFINED_LOCALE_VALUES 2
#define NO_DEFINED_MTID_VALUES 46
#define NO_DEFINED_CLSF_VALUES 5
#define NO_DEFINED_CLSG_VALUES 7
#define NO_DEFINED_UFBHM_VALUES 3
#define NO_DEFINED_JSONTYPE_VALUES 8
#define NO_DEFINED_MIT_VALUES 38
#define NO_DEFINED_MDINTERPRETATION_VALUES 11
#define NO_DEFINED_MDHTMLC_VALUES 7
#define NO_DEFINED_MARKDOWNFEATURE_VALUES 34
#define NO_DEFINED_SEMVERPART_VALUES 3
#define NO_DEFINED_END_VALUES 4
#define NO_DEFINED_SYNTAX_VALUES 2
#define NO_DEFINED_MOM_VALUES 4
#define NO_DEFINED_MODE_VALUES 5
#define NO_DEFINED_SWM_VALUES 4
#define NO_DEFINED_METHOD_VALUES 4
#define NO_DEFINED_LCAT_VALUES 26
#define NO_DEFINED_CMD_VALUES 15
#define NO_DEFINED_SECTIONCAT_VALUES 3
#define NO_DEFINED_MATERIAL_VALUES 6
#define NO_DEFINED_FORM_VALUES 1
#line 41 "inweb/foundation-module/Chapter 2/Debugging Log.w"
typedef struct debugging_aspect {
	struct text_stream *hyphenated_name; /* e.g., "memory-usage" */
	struct text_stream *negated_name; /* e.g., "no-memory-usage" */
	struct text_stream *unhyphenated_name; /* e.g., "memory usage" */
	int on_or_off; /* whether or not active when writing to debugging log */
	int alternate; /* whether or not active when writing in trace mode */
	CLASS_DEFINITION
} debugging_aspect;
#line 58 "inweb/foundation-module/Chapter 2/Memory.w"
typedef struct allocation_status_structure {
	/* actually needed for allocation purposes: */
	int objects_allocated; /* total number of objects (or arrays) ever allocated */
	void *first_in_memory; /* head of doubly linked list */
	void *last_in_memory; /* tail of doubly linked list */

	/* used only to provide statistics for the debugging log: */
	char *name_of_type; /* e.g., |"index_lexicon_entry_CLASS"| */
	int bytes_allocated; /* total allocation for this type of object, not counting overhead */
	int objects_count; /* total number currently in existence (i.e., undeleted) */
	int no_allocated_together; /* number of objects in each array of this type of object */
} allocation_status_structure;
#line 136 "inweb/foundation-module/Chapter 2/Memory.w"
typedef struct memblock_header {
	int block_number;
	struct memblock_header *next;
	char *the_memory;
} memblock_header;
#line 217 "inweb/foundation-module/Chapter 2/Memory.w"
typedef struct memory_frame {
	int integrity_check; /* this should always contain the |INTEGRITY_NUMBER| */
	struct memory_frame *next_frame; /* next frame in the list of memory frames */
	int mem_type; /* type of object stored in this frame */
	int allocation_id; /* allocation ID number of object stored in this frame */
} memory_frame;
#line 743 "inweb/foundation-module/Chapter 2/Memory.w"
typedef struct general_pointer {
	void *pointer_to_data;
	int run_time_type_code;
} general_pointer;
#line 235 "inweb/foundation-module/Chapter 2/Streams.w"
typedef struct text_stream {
	int stream_flags; /* bitmap of the |*_STRF| values above */
	FILE *write_to_file; /* for an open stream, exactly one of these is |NULL| */
	struct HTML_file_state *as_HTML; /* relevant only to the |HTML::| section */
	inchar32_t *write_to_memory;
	struct filename *file_written; /* ditto */
	int chars_written; /* number of characters sent, counting |\n| as 1 */
	int chars_capacity; /* maximum number the stream can accept without claiming more resources */
	struct text_stream *stream_continues; /* if one memory stream is extended by another */
} text_stream;
#line 27 "inweb/foundation-module/Chapter 2/Methods.w"
typedef struct method_set {
	struct method *first_method;
	CLASS_DEFINITION
} method_set;
#line 69 "inweb/foundation-module/Chapter 2/Methods.w"
typedef struct method {
	int method_id;
	void *method_function;
	struct method *next_method;
	CLASS_DEFINITION
} method;
#line 24 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
typedef struct linked_list_item {
	void *item_contents;
	struct linked_list_item *next_list_item;
} linked_list_item;
#line 15 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
typedef struct linked_list {
	struct linked_list_item *first_list_item;
	struct linked_list_item *last_list_item;
	int linked_list_length;
	int early_items_used;
	struct linked_list_item early_items[NO_LL_EARLY_ITEMS];
	CLASS_DEFINITION
} linked_list;
#line 13 "inweb/foundation-module/Chapter 2/Dictionaries.w"
typedef struct dictionary {
	int textual; /* values are texts? */
	int no_entries; /* total number of key-value pairs currently stored here */
	int hash_table_size; /* size of array... */
	struct dict_entry *hash_table; /* ...of linked lists of dictionary entries */
	CLASS_DEFINITION
} dictionary;
#line 21 "inweb/foundation-module/Chapter 2/Dictionaries.w"
typedef struct dict_entry {
	int vacant; /* a "vacant" entry is not currently used to store a k-v pair */
	struct text_stream *key; /* for non-vacant entries only: the key text */
	void *value; /* for non-vacant entries only: the value, some kind of pointer */
	struct dict_entry *next_in_entry;
} dict_entry;
#line 11 "inweb/foundation-module/Chapter 2/Trees.w"
typedef struct heterogeneous_tree {
	struct tree_type *type;
	struct tree_node *root;
	CLASS_DEFINITION
} heterogeneous_tree;
#line 26 "inweb/foundation-module/Chapter 2/Trees.w"
typedef struct tree_node {
	struct heterogeneous_tree *owner;
	struct tree_node_type *type;
	struct general_pointer content;
	struct tree_node *next;
	struct tree_node *parent;
	struct tree_node *child;
	CLASS_DEFINITION
} tree_node;
#line 74 "inweb/foundation-module/Chapter 2/Trees.w"
typedef struct tree_type {
	struct text_stream *name;
	int (*verify_root)(struct tree_node *); /* function to vet the root node */
	CLASS_DEFINITION
} tree_type;
#line 92 "inweb/foundation-module/Chapter 2/Trees.w"
typedef struct tree_node_type {
	struct text_stream *node_type_name; /* text such as |TL_IS_0| */
	int required_CLASS; /* if any; or negative for no restriction */
	int (*verify_children)(struct tree_node *); /* function to vet the children */
	CLASS_DEFINITION
} tree_node_type;
#line 38 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
typedef struct command_line_switch {
	int switch_id;
	struct text_stream *switch_name; /* e.g., |no-verbose| */
	struct text_stream *switch_sort_name; /* e.g., |verbose| */
	struct text_stream *help_text;
	int valency; /* 1 for bare, 2 for one argument follows */
	int form; /* one of the |*_CLSF| values above */
	int switch_group; /* one of the |*_CLSG| valyes above */
	int active_by_default; /* relevant only for booleans */
	struct command_line_switch *negates; /* relevant only for booleans */
	CLASS_DEFINITION
} command_line_switch;
#line 171 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
typedef struct clf_reader_state {
	void *state;
	void (*f)(int, int, text_stream *, void *);
	void (*g)(int, text_stream *, void *);
	int subs;
	int nrt;
} clf_reader_state;
#line 38 "inweb/foundation-module/Chapter 3/Pathnames.w"
typedef struct pathname {
	struct text_stream *intermediate;
	struct pathname *pathname_of_parent;
	int known_to_exist; /* corresponds to a directory in the filing system */
	CLASS_DEFINITION
} pathname;
#line 12 "inweb/foundation-module/Chapter 3/Filenames.w"
typedef struct filename {
	struct pathname *pathname_of_location;
	struct text_stream *leafname;
	CLASS_DEFINITION
} filename;
#line 8 "inweb/foundation-module/Chapter 3/Directories.w"
typedef struct scan_directory {
	void *directory_handle;
	char directory_name_written_out[4*MAX_FILENAME_LENGTH];
	CLASS_DEFINITION
} scan_directory;
#line 129 "inweb/foundation-module/Chapter 3/Time.w"
typedef struct stopwatch_timer {
	int running; /* set if this has been started but not stopped */
	struct text_stream *event;
	clock_t start_time;
	clock_t end_time;
	int time_taken; /* measured in centiseconds of CPU time */
	linked_list *stages_chronological; /* of |stopwatch_timer| */
	linked_list *stages_sorted; /* of |stopwatch_timer| */
	CLASS_DEFINITION
} stopwatch_timer;
#line 123 "inweb/foundation-module/Chapter 4/C Strings.w"
typedef struct string_storage_area {
	char *storage_at;
	int capacity;
	CLASS_DEFINITION
} string_storage_area;
#line 161 "inweb/foundation-module/Chapter 4/String Manipulation.w"
typedef struct string_position {
	struct text_stream *S;
	int index;
} string_position;
#line 17 "inweb/foundation-module/Chapter 4/Tab Stops.w"
typedef struct tabbed_string_iterator {
	struct text_stream *line;
	int read_index;
	int line_position;
	int tab_spacing;
} tabbed_string_iterator;
#line 233 "inweb/foundation-module/Chapter 4/Text Files.w"
typedef struct unicode_file_buffer {
	char unicode_feed_buffer[32]; /* holds a single escape such as "[unicode 3106]" */
	int ufb_counter; /* position in the unicode feed buffer */
	int handling_mode; /* one of the above */
} unicode_file_buffer;
#line 39 "inweb/foundation-module/Chapter 4/Text Files.w"
typedef struct text_file_position {
	struct filename *text_file_filename;
	FILE *handle_when_open;
	struct unicode_file_buffer ufb;
	int line_count; /* counting from 1 */
	int line_position;
	int skip_terminator;
	int actively_scanning; /* whether we are still interested in the rest of the file */
} text_file_position;
#line 71 "inweb/foundation-module/Chapter 4/Preprocessor.w"
typedef struct preprocessor_loop {
	struct text_stream *loop_var_name;
	struct linked_list *iterations; /* of |text_stream| */
	int repeat_is_block;
	struct text_stream *repeat_saved_dest;
} preprocessor_loop;
#line 56 "inweb/foundation-module/Chapter 4/Preprocessor.w"
typedef struct preprocessor_state {
	struct text_stream *dest;
	struct preprocessor_macro *defining; /* a "define" body being scanned */
	int repeat_sp;
	int shadow_sp;
	struct preprocessor_loop repeat_data[MAX_PREPROCESSOR_LOOP_DEPTH];
	int suppress_newline; /* at the end of this line */
	int last_line_was_blank; /* used to suppress runs of multiple blank lines */
	struct preprocessor_variable_set *global_variables;
	struct preprocessor_variable_set *stack_frame;
	struct linked_list *known_macros; /* of |preprocessor_macro| */
	struct general_pointer specifics;
	inchar32_t comment_character;
} preprocessor_state;
#line 471 "inweb/foundation-module/Chapter 4/Preprocessor.w"
typedef struct preprocessor_variable {
	struct text_stream *name;
	struct text_stream *value;
	CLASS_DEFINITION
} preprocessor_variable;
#line 491 "inweb/foundation-module/Chapter 4/Preprocessor.w"
typedef struct preprocessor_variable_set {
	struct linked_list *variables; /* of |preprocessor_variable| */
	struct preprocessor_variable_set *outer;
	CLASS_DEFINITION
} preprocessor_variable_set;
#line 564 "inweb/foundation-module/Chapter 4/Preprocessor.w"
typedef struct preprocessor_macro {
	/* syntax */
	struct text_stream *identifier;
	struct preprocessor_macro_parameter *parameters[MAX_PP_MACRO_PARAMETERS];
	int no_parameters;

	/* meaning */
	struct text_stream *lines[MAX_PP_MACRO_LINES];
	int no_lines;
	void (*expander)(struct preprocessor_macro *, struct preprocessor_state *, struct text_stream **, struct preprocessor_loop *, struct text_file_position *);

	/* loop construct if any */
	int begins_loop;               /* |TRUE| for e.g. |repeat-block| or |repeat-span| */
	int ends_loop;                 /* |TRUE| for e.g. |end-repeat-block| */
	struct text_stream *loop_name; /* e.g. |repeat| */
	int span;                      /* |TRUE| for e.g. |end-repeat-span| or |repeat-span| */

	/* textual behaviour */
	int suppress_newline_after_expanding;
	int suppress_whitespace_when_expanding;

	CLASS_DEFINITION
} preprocessor_macro;
#line 588 "inweb/foundation-module/Chapter 4/Preprocessor.w"
typedef struct preprocessor_macro_parameter {
	struct text_stream *name;
	struct text_stream *definition_token;
	int optional;
	CLASS_DEFINITION
} preprocessor_macro_parameter;
#line 42 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
typedef struct match_trie {
	int match_character; /* or one of the special cases above */
	inchar32_t group_characters[MAX_TRIE_GROUP_SIZE+1];
	inchar32_t *match_outcome;
	struct match_trie *on_success;
	struct match_trie *next;
} match_trie;
#line 284 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
typedef struct match_avinue {
	struct match_trie *the_trie;
	struct match_avinue *next;
} match_avinue;
#line 109 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
typedef struct match_position {
	int tpos; /* position within text being matched */
	int ppos; /* position within pattern */
	int bc; /* count of bracketed subexpressions so far begun */
	int bl; /* bracket indentation level */
	int bracket_nesting[MAX_BRACKETED_SUBEXPRESSIONS];
	/* which subexpression numbers (0, 1, 2, 3) correspond to which nesting */
	int brackets_start[MAX_BRACKETED_SUBEXPRESSIONS], brackets_end[MAX_BRACKETED_SUBEXPRESSIONS];
	/* positions in text being matched, inclusive */
} match_position;
#line 126 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
typedef struct match_result {
	inchar32_t match_text_storage[MATCH_TEXT_INITIAL_ALLOCATION];
	struct text_stream match_text_struct;
} match_result;
#line 130 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
typedef struct match_results {
	int no_matched_texts;
	struct match_result exp_storage[MAX_BRACKETED_SUBEXPRESSIONS];
	struct text_stream *exp[MAX_BRACKETED_SUBEXPRESSIONS];
	int exp_at[MAX_BRACKETED_SUBEXPRESSIONS];
} match_results;
#line 64 "inweb/foundation-module/Chapter 4/JSON.w"
typedef struct JSON_value {
	int JSON_type;
	int if_integer;
	double if_double;
	struct text_stream *if_string;
	int if_boolean;
	struct linked_list *if_list; /* of |JSON_value| */
	struct dictionary *dictionary_if_object; /* to |JSON_value| */
	struct linked_list *list_if_object; /* of |text_stream| */
	struct text_stream *if_error;
	CLASS_DEFINITION
} JSON_value;
#line 607 "inweb/foundation-module/Chapter 4/JSON.w"
typedef struct JSON_requirement {
	struct linked_list *alternatives; /* of |JSON_single_requirement| */
	CLASS_DEFINITION
} JSON_requirement;
#line 631 "inweb/foundation-module/Chapter 4/JSON.w"
typedef struct JSON_single_requirement {
	struct JSON_requirement *this_requirement;
	struct JSON_value *this_value;
	struct JSON_type *this_type;
	CLASS_DEFINITION
} JSON_single_requirement;
#line 669 "inweb/foundation-module/Chapter 4/JSON.w"
typedef struct JSON_type {
	int JSON_type;

	struct linked_list *if_list; /* of |JSON_requirement| */
	struct JSON_requirement *all_if_list;

	struct dictionary *dictionary_if_object; /* to |JSON_pair_requirement| */
	struct linked_list *list_if_object; /* of |text_stream| */

	struct text_stream *if_error;
	CLASS_DEFINITION
} JSON_type;
#line 682 "inweb/foundation-module/Chapter 4/JSON.w"
typedef struct JSON_pair_requirement {
	struct JSON_requirement *req;
	int optional;
	CLASS_DEFINITION
} JSON_pair_requirement;
#line 1352 "inweb/foundation-module/Chapter 4/JSON.w"
typedef struct JSON_rrf_state {
	struct text_stream *name;
	struct text_stream *defn;
	struct dictionary *dict;
	struct text_file_position at;
} JSON_rrf_state;
#line 56 "inweb/foundation-module/Chapter 5/HTML.w"
typedef struct HTML_file_state {
	int XHTML_flag; /* writing strict XHTML for use in epubs */
	struct lifo_stack *tag_stack; /* of |HTML_tag|: those currently open */
	int CSS_included;
	int JS_included;
	CLASS_DEFINITION
} HTML_file_state;
#line 79 "inweb/foundation-module/Chapter 5/HTML.w"
typedef struct HTML_tag {
	char *tag_name;
	int tag_xref;
	char *from_filename;
	int from_line;
	CLASS_DEFINITION
} HTML_tag;
#line 699 "inweb/foundation-module/Chapter 5/HTML.w"
typedef struct colour_translation {
	inchar32_t *chip_name;
	inchar32_t *html_colour;
} colour_translation;
#line 340 "inweb/foundation-module/Chapter 5/Markdown.w"
typedef struct markdown_type_metadata {
	struct text_stream *name;
	int is_container;
	int is_block;
	int is_inline;
	int is_plainish;
	int is_quasiplainish;
} markdown_type_metadata;
#line 489 "inweb/foundation-module/Chapter 5/Markdown.w"
typedef struct markdown_item {
	int type; /* one of the |*_MIT| types above */

	/* text storage for inline items */
	struct text_stream *sliced_from;
	int from; /*inline nodes only */
	int to; /*inline nodes only */

	/* text storage for block items */
	struct text_stream *stashed;

	/* relevant for block nodes only */
	int whitespace_follows;
	struct text_stream *info_string;
	int details;
	int open;

	/* tree position of this item */
	struct markdown_item *next;
	struct markdown_item *down;
	struct markdown_item *copied_from;

	general_pointer user_state; /* for users of this API to annotate the tree */

	int cycle_count; /* used only for tracing the tree when debugging */
	int id;          /* used only for tracing the tree when debugging */
	CLASS_DEFINITION
} markdown_item;
#line 825 "inweb/foundation-module/Chapter 5/Markdown.w"
typedef struct md_charpos {
	struct markdown_item *md;
	int at;
} md_charpos;
#line 1050 "inweb/foundation-module/Chapter 5/Markdown.w"
typedef struct md_links_dictionary {
	struct dictionary *dict;
	CLASS_DEFINITION
} md_links_dictionary;
#line 1055 "inweb/foundation-module/Chapter 5/Markdown.w"
typedef struct md_link_dictionary_entry {
	struct text_stream *destination;
	struct text_stream *title;
	CLASS_DEFINITION
} md_link_dictionary_entry;
#line 229 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
typedef struct positional_marker {
	int item_type; /* |BLOCK_QUOTE_MIT|, |ORDERED_LIST_ITEM_MIT| or |UNORDERED_LIST_ITEM_MIT| */
	int indent;                /* minimum required indentation for subsequent lines to continue */
	int at;                    /* character position (not string index) of the start of the marker */
	int width;                 /* for example, 2 for |7) | or |7. |: the non-whitespace chars only */
	int list_item_value;       /* for example, 7 for |7) | or |7. | */
	inchar32_t list_item_flavour; /* for example, |')'| for |7) | and |'.'| for |7. | */

	int continues_from_earlier_line;
	int blank_counts;
} positional_marker;
#line 182 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
typedef struct md_fencing_data {
	inchar32_t material; /* character used in the fence syntax */
	int width;
	struct markdown_item *fenced_code;
	int left_margin; /* measured as a position, not a string index */
} md_fencing_data;
#line 53 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
typedef struct md_doc_state {
	struct markdown_variation *variation;
	struct markdown_item *tree_head;
	struct md_links_dictionary *link_references;

	struct markdown_item *containers[MAX_MARKDOWN_CONTAINER_DEPTH];
	int container_sp;

	struct positional_marker markers[MAX_MARKDOWN_CONTAINER_DEPTH];
	int marker_sp;
	int temporary_marker_limit;

	struct markdown_item *receiving_PARAGRAPH;
	struct markdown_item *receiving_CODE_ITEM;
	struct markdown_item *receiving_HTML;
	struct text_stream *blank_matter_after_receiver;

	struct md_fencing_data fencing;

	int HTML_end_condition;

	CLASS_DEFINITION
} md_doc_state;
#line 878 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
typedef struct md_link_parse {
	int is_link; /* |TRUE| for link, |FALSE| for image, |NOT_APPLICABLE| for fail */
	struct md_charpos first;                  /* leftmost character of the whole construct */
	struct md_charpos link_text_from;         /* leftmost character inside the squares */
	struct md_charpos link_text_to;           /* ...and so on */
	int link_text_empty;                      /* |TRUE| or |FALSE| */
	struct md_charpos link_destination_from;
	struct md_charpos link_destination_to;
	int link_destination_empty;
	struct md_charpos link_title_from;
	struct md_charpos link_title_to;
	int link_title_empty;
	struct md_link_dictionary_entry *link_reference; /* or |NULL| if it's not by reference */
	struct md_charpos last; /* rightmost character of the whole construct */
} md_link_parse;
#line 1437 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
typedef struct md_emphasis_delimiter {
	struct md_charpos pos; /* first character in the run */
	int width;             /* for example, 7 for a run of seven asterisks */
	int type;              /* 1 for asterisks, -1 for underscores, 0 for tildes */
	int can_open;          /* result of |MDInlineParser::can_open_emphasis| on it */
	int can_close;         /* result of |MDInlineParser::can_close_emphasis| on it */
	CLASS_DEFINITION
} md_emphasis_delimiter;
#line 41 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
typedef struct markdown_variation {
	struct text_stream *name;
	int active_built_in_features[NO_DEFINED_MARKDOWNFEATURE_VALUES];
	struct method_set *methods;
	CLASS_DEFINITION
} markdown_variation;
#line 75 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
typedef struct markdown_feature {
	struct text_stream *name;
	int feature_ID;
	struct method_set *methods;
	CLASS_DEFINITION
} markdown_feature;
#line 411 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
typedef struct IFM_example {
	struct text_stream *name;
	struct text_stream *description;
	struct markdown_item *header;
	struct markdown_item *cue;
	int star_count;
	int number;
	struct text_stream *insignia;
	struct text_stream *ex_index;
	struct text_stream *ex_subtitle;
	CLASS_DEFINITION
} IFM_example;
#line 23 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook {
	struct linked_list *metadata_list; /* of |ebook_datum|: DCMI-standard bibliographic data */
	char *prefix; /* to apply to the page leafnames */
	struct filename *CSS_file_throughout; /* where to find a CSS file to be used for all volumes */

	struct filename *eventual_epub; /* filename of the final |*.epub| to be made */
	struct pathname *holder; /* directory to put the ingredients into */
	struct pathname *OEBPS_path; /* subdirectory which mysteriously has to be called |OEBPS| */

	struct linked_list *ebook_volume_list; /* of |ebook_volume| */
	struct ebook_volume *current_volume; /* the one to which chapters are now being added */

	struct linked_list *ebook_chapter_list; /* of |ebook_chapter| */
	struct ebook_chapter *current_chapter; /* the one to which pages are now being added */

	struct linked_list *ebook_page_list; /* of |book_page| */
	struct linked_list *ebook_image_list; /* of |ebook_image| */
	CLASS_DEFINITION
} ebook;
#line 48 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook_datum {
	struct text_stream *key;
	struct text_stream *value;
	CLASS_DEFINITION
} ebook_datum;
#line 57 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook_volume {
	struct text_stream *volume_title;
	struct ebook_page *volume_starts; /* on which page the volume starts */
	struct filename *CSS_file; /* where to find the CSS file to be included */
	CLASS_DEFINITION
} ebook_volume;
#line 64 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook_chapter {
	struct text_stream *chapter_title;
	struct ebook_volume *in_volume; /* to which volume this chapter belongs */
	struct ebook_page *chapter_starts; /* on which page the chapter starts */
	struct linked_list *ebook_mark_list; /* of |ebook_mark|: for when multiple navigable points exist within this */
	struct text_stream *start_URL;
	CLASS_DEFINITION
} ebook_chapter;
#line 77 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook_page {
	struct text_stream *page_title;
	struct text_stream *page_type;
	struct text_stream *page_ID;

	struct filename *relative_URL; /* eventual URL of this page within the ebook */

	struct ebook_volume *in_volume; /* to which volume this page belongs */
	struct ebook_chapter *in_chapter; /* to which chapter this page belongs */

	int nav_entry_written; /* keep track of what we've written to the navigation tree */
	CLASS_DEFINITION
} ebook_page;
#line 91 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook_mark {
	struct text_stream *mark_text;
	struct text_stream *mark_URL;
	CLASS_DEFINITION
} ebook_mark;
#line 97 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
typedef struct ebook_image {
	struct text_stream *image_ID;
	struct filename *relative_URL; /* eventual URL of this image within the ebook */
	CLASS_DEFINITION
} ebook_image;
#line 60 "inweb/foundation-module/Chapter 7/Version Numbers.w"
typedef struct semantic_version_number {
	int version_numbers[SEMVER_NUMBER_DEPTH];
	struct linked_list *prerelease_segments; /* of |text_stream| */
	struct text_stream *build_metadata;
} semantic_version_number;
#line 66 "inweb/foundation-module/Chapter 7/Version Numbers.w"
typedef struct semantic_version_number_holder {
	struct semantic_version_number version;
	CLASS_DEFINITION
} semantic_version_number_holder;
#line 24 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
typedef struct range_end {
	int end_type;
	struct semantic_version_number end_value;
} range_end;
#line 29 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
typedef struct semver_range {
	struct range_end lower;
	struct range_end upper;
	CLASS_DEFINITION
} semver_range;
#line 27 "inweb/foundation-module/Chapter 8/Web Structure.w"
typedef struct web_md {
	struct pathname *path_to_web; /* relative to the current working directory */
	struct filename *single_file; /* relative to the current working directory */
	struct linked_list *bibliographic_data; /* of |web_bibliographic_datum| */
	struct semantic_version_number version_number; /* as deduced from bibliographic data */
	int default_syntax; /* which version syntax the sections will have */
	int chaptered; /* has the author explicitly divided it into named chapters? */
	struct text_stream *main_language_name; /* in which most of the sections are written */

	struct module *as_module; /* the root of a small dependency graph */

	struct filename *contents_filename; /* or |NULL| for a single-file web */
	struct linked_list *tangle_target_names; /* of |text_stream| */
	struct linked_list *header_filenames; /* of |filename| */

	struct linked_list *chapters_md; /* of |chapter_md| */
	struct linked_list *sections_md; /* of |section_md| */
	CLASS_DEFINITION
} web_md;
#line 50 "inweb/foundation-module/Chapter 8/Web Structure.w"
typedef struct chapter_md {
	struct text_stream *ch_range; /* e.g., |P| for Preliminaries, |7| for Chapter 7, |C| for Appendix C */
	struct text_stream *ch_title; /* e.g., "Chapter 3: Fresh Water Fish" */
	struct text_stream *ch_basic_title; /* e.g., "Chapter 3" */
	struct text_stream *ch_decorated_title; /* e.g., "Fresh Water Fish" */
	struct text_stream *rubric; /* optional; without double-quotation marks */

	struct text_stream *ch_language_name; /* in which most of the sections are written */

	int imported; /* from a different web? */

	struct linked_list *sections_md; /* of |section_md| */
	CLASS_DEFINITION
} chapter_md;
#line 68 "inweb/foundation-module/Chapter 8/Web Structure.w"
typedef struct section_md {
	struct text_stream *sect_title; /* e.g., "Program Control" */
	struct text_stream *sect_range; /* e.g., "2/ct" */
	int using_syntax; /* which syntax the web is written in */
	int is_a_singleton; /* is this the only section in its entire web? */

	struct filename *source_file_for_section;

	struct text_stream *tag_name;
	struct text_stream *sect_independent_language;
	struct text_stream *sect_language_name;
	struct text_stream *titling_line_to_insert;

	struct module *owning_module;
	CLASS_DEFINITION
} section_md;
#line 246 "inweb/foundation-module/Chapter 8/Web Structure.w"
typedef struct reader_state {
	struct web_md *Wm;
	struct filename *contents_filename;
	int in_biblio;
	int in_purpose; /* Reading the bit just after the new chapter? */
	struct chapter_md *chapter_being_scanned;
	struct text_stream *chapter_dir_name; /* Where sections in the current chapter live */
	struct text_stream *titling_line_to_insert; /* To be inserted automagically */
	struct pathname *path_to; /* Where web material is being read from */
	struct module *reading_from;
	struct module_search *import_from; /* Where imported webs are */
	struct pathname *path_to_inweb;
	int scan_verbosely;
	int including_modules;
	int main_web_not_module; /* Reading the original web, or an included one? */
	int halt_at_at; /* Used for reading contents pages of single-file webs */
	int halted; /* Set when such a halt has occurred */
	int section_count;
	struct section_md *last_section;
} reader_state;
#line 11 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
typedef struct web_bibliographic_datum {
	struct text_stream *key;
	struct text_stream *value;
	int declaration_permitted; /* is the contents page of the web allowed to set this? */
	int declaration_mandatory; /* is it positively required to? */
	int on_or_off; /* boolean: which we handle as the string "On" or "Off" */
	struct web_bibliographic_datum *alias;
	CLASS_DEFINITION
} web_bibliographic_datum;
#line 19 "inweb/foundation-module/Chapter 8/Web Modules.w"
typedef struct module {
	struct pathname *module_location;
	struct text_stream *module_name;
	struct linked_list *dependencies; /* of |module|: which other modules does this need? */
	struct text_stream *module_tag;
	int origin_marker; /* one of the |*_MOM| values above */
	struct linked_list *chapters_md; /* of |chapter_md|: just the ones in this module */
	struct linked_list *sections_md; /* of |section_md|: just the ones in this module */
	CLASS_DEFINITION
} module;
#line 73 "inweb/foundation-module/Chapter 8/Web Modules.w"
typedef struct module_search {
	struct pathname *path_to_search;
	CLASS_DEFINITION
} module_search;
#line 21 "inweb/foundation-module/Chapter 8/Build Files.w"
typedef struct build_file_data {
	struct text_stream *prerelease_text;
	struct text_stream *build_code;
	struct text_stream *build_date;
} build_file_data;
#line 20 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
typedef struct simple_tangle_docket {
	void (*raw_callback)(struct text_stream *, struct simple_tangle_docket *);
	void (*command_callback)(struct text_stream *, struct text_stream *,
		struct text_stream *, struct simple_tangle_docket *);
	void (*bplus_callback)(struct text_stream *, struct simple_tangle_docket *);
	void (*source_marker_callback)(struct text_stream *, struct simple_tangle_docket *);
	void (*error_callback)(char *, struct text_stream *);
	void *state;
	struct pathname *web_path;
	struct filename *current_filename;
	int current_start_line;
} simple_tangle_docket;
#line 42 "inweb/foundation-module/Chapter 9/Reserved Words.w"
typedef struct hash_table {
	struct linked_list *analysis_hash[HASH_TAB_SIZE]; /* of |hash_table_entry| */
	int safety_code; /* when we start up, array's contents are undefined, so... */
} hash_table;
#line 102 "inweb/foundation-module/Chapter 9/Programming Languages.w"
typedef struct programming_language {
	text_stream *language_name; /* identifies it: see above */

	/* then a great many fields set directly in the definition file: */
	text_stream *file_extension; /* by default output to a file whose name has this extension */
	text_stream *language_details; /* brief explanation of what language is */
	int supports_namespaces;
	text_stream *line_comment;
	text_stream *whole_line_comment;
	text_stream *multiline_comment_open;
	text_stream *multiline_comment_close;
	text_stream *string_literal;
	text_stream *string_literal_escape;
	text_stream *character_literal;
	text_stream *character_literal_escape;
	text_stream *binary_literal_prefix;
	text_stream *octal_literal_prefix;
	text_stream *hexadecimal_literal_prefix;
	text_stream *negative_literal_prefix;
	text_stream *shebang;
	text_stream *line_marker;
	text_stream *before_macro_expansion;
	text_stream *after_macro_expansion;
	text_stream *start_definition;
	text_stream *prolong_definition;
	text_stream *end_definition;
	text_stream *start_ifdef;
	text_stream *end_ifdef;
	text_stream *start_ifndef;
	text_stream *end_ifndef;
	inchar32_t type_notation[MAX_ILDF_REGEXP_LENGTH];
	inchar32_t function_notation[MAX_ILDF_REGEXP_LENGTH];

	int suppress_disclaimer;
	int C_like; /* languages with this set have access to extra features */

	struct linked_list *reserved_words; /* of |reserved_word| */
	struct hash_table built_in_keywords;
	struct colouring_language_block *program; /* algorithm for syntax colouring */
	struct method_set *methods;
	CLASS_DEFINITION
} programming_language;
#line 152 "inweb/foundation-module/Chapter 9/Programming Languages.w"
typedef struct language_reader_state {
	struct programming_language *defining;
	struct colouring_language_block *current_block;
} language_reader_state;
#line 392 "inweb/foundation-module/Chapter 9/Programming Languages.w"
typedef struct colouring_language_block {
	struct linked_list *rules; /* of |colouring_rule| */
	struct colouring_language_block *parent; /* or |NULL| for the topmost one */
	int run; /* one of the |*_CRULE_RUN| values, or else a colour */
	struct text_stream *run_instance; /* used only for |INSTANCES_CRULE_RUN| */
	struct text_stream *char_set; /* used only for |CHARACTERS_IN_CRULE_RUN| */
	inchar32_t match_regexp_text[MAX_ILDF_REGEXP_LENGTH]; /* used for |MATCHES_CRULE_RUN|, |BRACKETS_CRULE_RUN| */

	/* workspace during painting */
	struct match_results mr; /* of a regular expression */
	CLASS_DEFINITION
} colouring_language_block;
#line 436 "inweb/foundation-module/Chapter 9/Programming Languages.w"
typedef struct colouring_rule {
	/* the premiss: */
	int sense; /* |FALSE| to negate the condition */
	inchar32_t match_colour; /* for |coloured C|, or else |NOT_A_COLOUR| */
	inchar32_t match_keyword_of_colour; /* for |keyword C|, or else |NOT_A_COLOUR| */
	struct text_stream *match_text; /* or length 0 to mean "anything" */
	int match_prefix; /* one of the |*_RULE_PREFIX| values above */
	inchar32_t match_regexp_text[MAX_ILDF_REGEXP_LENGTH];
	int number; /* for |number N| rules; 0 for others */
	int number_of; /* for |number N of M| rules; 0 for others */

	/* the conclusion: */
	struct colouring_language_block *execute_block; /* or |NULL|, in which case... */
	inchar32_t set_to_colour; /* ...paint the snippet in this colour */
	inchar32_t set_prefix_to_colour; /* ...also paint this (same for suffix) */
	int debug; /* ...or print debugging text to console */

	/* workspace during painting */
	int fix_position; /* where the prefix or suffix started */
	struct match_results mr; /* of a regular expression */
	CLASS_DEFINITION
} colouring_rule;
#line 558 "inweb/foundation-module/Chapter 9/Programming Languages.w"
typedef struct reserved_word {
	struct text_stream *word;
	int colour;
	CLASS_DEFINITION
} reserved_word;
#line 55 "inweb/foundation-module/Chapter 9/Reserved Words.w"
typedef struct hash_table_entry {
	text_stream *hash_key;
	int language_reserved_word; /* in the language currently being woven, that is */
	struct linked_list *usages; /* of |hash_table_entry_usage| */
	struct source_line *definition_line; /* or null, if it's not a constant, function or type name */
	struct language_function *as_function; /* for function names only */
	CLASS_DEFINITION
} hash_table_entry;
#line 11 "inweb/Chapter 1/Configuration.w"
typedef struct inweb_instructions {
	int inweb_mode; /* our main mode of operation: one of the |*_MODE| constants */
	struct pathname *chosen_web; /* project folder relative to cwd */
	struct filename *chosen_file; /* or, single file relative to cwd */
	struct text_stream *chosen_range; /* which subset of this web we apply to (often, all of it) */
	int chosen_range_actually_chosen; /* rather than being a default choice */

	int swarm_mode; /* relevant to weaving only: one of the |*_SWARM| constants */
	struct text_stream *tag_setting; /* |-weave-tag X|: weave, but only the material tagged X */
	struct text_stream *weave_pattern; /* |-weave-as X|: for example, |-weave-to HTML| */

	int show_languages_switch; /* |-show-languages|: print list of available PLs */
	int catalogue_switch; /* |-catalogue|: print catalogue of sections */
	int functions_switch; /* |-functions|: print catalogue of functions within sections */
	int structures_switch; /* |-structures|: print catalogue of structures within sections */
	int advance_switch; /* |-advance-build|: advance build file for web */
	int scan_switch; /* |-scan|: simply show the syntactic scan of the source */
	int ctags_switch; /* |-ctags|: generate a set of Universal Ctags on each tangle */
	struct filename *weave_to_setting; /* |-weave-to X|: the pathname X, if supplied */
	struct pathname *weave_into_setting; /* |-weave-into X|: the pathname X, if supplied */
	int sequential; /* give the sections sequential sigils */
	struct filename *tangle_setting; /* |-tangle-to X|: the pathname X, if supplied */
	struct filename *ctags_setting; /* |-ctags-to X|: the pathname X, if supplied */
	struct filename *makefile_setting; /* |-makefile X|: the filename X, if supplied */
	struct filename *gitignore_setting; /* |-gitignore X|: the filename X, if supplied */
	struct filename *advance_setting; /* |-advance-build-file X|: advance build file X */
	struct filename *writeme_setting; /* |-write-me X|: advance build file X */
	struct filename *prototype_setting; /* |-prototype X|: the pathname X, if supplied */
	struct filename *navigation_setting; /* |-navigation X|: the filename X, if supplied */
	struct filename *colony_setting; /* |-colony X|: the filename X, if supplied */
	struct text_stream *member_setting; /* |-member X|: sets web to member X of colony */
	struct linked_list *breadcrumb_setting; /* of |breadcrumb_request| */
	struct text_stream *platform_setting; /* |-platform X|: sets prevailing platform to X */
	int verbose_switch; /* |-verbose|: print names of files read to stdout */
	int targets; /* used only for parsing */

	struct programming_language *test_language_setting; /* |-test-language X| */
	struct filename *test_language_on_setting; /* |-test-language-on X| */

	struct pathname *import_setting; /* |-import X|: where to find imported webs */
} inweb_instructions;
#line 70 "inweb/Chapter 1/The Swarm.w"
typedef struct weave_order {
	struct web *weave_web; /* which web we weave */
	struct text_stream *weave_range; /* which parts of the web in this weave */
	struct theme_tag *theme_match; /* pick out only paragraphs with this theme */
	struct text_stream *booklet_title;
	struct weave_pattern *pattern; /* which pattern is to be followed */
	struct filename *weave_to; /* where to put it */
	struct weave_format *format; /* plain text, say, or HTML */
	void *post_processing_results; /* optional typesetting diagnostics after running through */
	int self_contained; /* make a self-contained file if possible */
	struct linked_list *breadcrumbs; /* non-standard breadcrumb trail, if any */
	struct filename *navigation; /* navigation links, or |NULL| if not supplied */
	struct linked_list *plugins; /* of |weave_plugin|: these are for HTML extensions */
	struct linked_list *colour_schemes; /* of |colour_scheme|: these are for HTML */

	/* used for workspace during an actual weave: */
	struct source_line *current_weave_line;
	CLASS_DEFINITION
} weave_order;
#line 11 "inweb/Chapter 1/Patterns.w"
typedef struct weave_pattern {
	struct text_stream *pattern_name; /* such as |HTML| */
	struct pathname *pattern_location; /* the directory */
	struct weave_pattern *based_on; /* inherit from which other pattern? */

	struct weave_format *pattern_format; /* such as |DVI|: the desired final format */
	struct linked_list *plugins; /* of |weave_plugin|: any extras needed */
	struct linked_list *colour_schemes; /* of |colour_scheme|: any extras needed */

	struct text_stream *mathematics_plugin; /* name only, not a |weave_pattern *| */
	struct text_stream *footnotes_plugin; /* name only, not a |weave_pattern *| */

	struct text_stream *initial_extension; /* filename extension, that is */
	struct linked_list *post_commands; /* of |text_stream| */
	struct linked_list *blocked_templates; /* of |text_stream| */

	struct linked_list *asset_rules; /* of |asset_rule| */
	int show_abbrevs; /* show section range abbreviations in the weave? */
	int number_sections; /* insert section numbers into the weave? */
	struct text_stream *default_range; /* for example, |sections| */

	struct web *patterned_for; /* the web which caused this to be read in */

	int commands;
	int name_command_given;
	CLASS_DEFINITION
} weave_pattern;
#line 12 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
typedef struct weave_plugin {
	struct text_stream *plugin_name;
	int last_included_in_round;
	CLASS_DEFINITION
} weave_plugin;
#line 34 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
typedef struct colour_scheme {
	struct text_stream *scheme_name;
	struct text_stream *prefix;
	struct filename *at;
	int last_included_in_round;
	CLASS_DEFINITION
} colour_scheme;
#line 168 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
typedef struct asset_rule {
	struct text_stream *applies_to;
	int method; /* one of the |*_ASSET_METHOD| values above */
	struct text_stream *pre;
	struct text_stream *post;
	int transform_names;
	CLASS_DEFINITION
} asset_rule;
#line 348 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
typedef struct css_file_transformation {
	struct text_stream *OUT;
	struct text_stream *trans;
} css_file_transformation;
#line 28 "inweb/Chapter 2/The Reader.w"
typedef struct web {
	struct web_md *md;
	struct linked_list *chapters; /* of |chapter| (including Sections, Preliminaries, etc.) */

	int web_extent; /* total lines in literate source, excluding contents */
	int no_paragraphs; /* this will be at least 1 */

	struct programming_language *main_language; /* in which most of the sections are written */
	struct linked_list *tangle_targets; /* of |tangle_target| */

	struct linked_list *headers; /* of |filename|: additional header files */
	int analysed; /* has this been scanned for function usage and such? */
	struct linked_list *language_types; /* of |language_type|: used only for C-like languages */

	struct ebook *as_ebook; /* when being woven to an ebook */
	struct pathname *redirect_weaves_to; /* ditto */

	CLASS_DEFINITION
} web;
#line 51 "inweb/Chapter 2/The Reader.w"
typedef struct chapter {
	struct chapter_md *md;
	struct web *owning_web;
	struct linked_list *sections; /* of |section| */

	struct weave_order *ch_weave; /* |NULL| unless this chapter produces a weave of its own */
	int titling_line_inserted; /* has an interleaved chapter heading been added yet? */
	struct programming_language *ch_language; /* in which this chapter is written */
	CLASS_DEFINITION
} chapter;
#line 65 "inweb/Chapter 2/The Reader.w"
typedef struct section {
	struct section_md *md;
	struct web *owning_web;
	struct chapter *owning_chapter;

	struct text_stream *sect_namespace; /* e.g., "Text::Languages::" */
	struct text_stream *sect_purpose; /* e.g., "To manage the zoo, and feed all penguins" */
	int barred; /* if version 1 syntax, contains a dividing bar? */
	struct programming_language *sect_language; /* in which this section is written */
	struct tangle_target *sect_target; /* |NULL| unless this section produces a tangle of its own */
	struct weave_order *sect_weave; /* |NULL| unless this section produces a weave of its own */

	int sect_extent; /* total number of lines in this section */
	struct source_line *first_line; /* for efficiency's sake not held as a |linked_list|, */
	struct source_line *last_line; /* but that's what it is, all the same */

	int sect_paragraphs; /* total number of paragraphs in this section */
	struct linked_list *paragraphs; /* of |paragraph|: the content of this section */
	struct theme_tag *tag_with; /* automatically tag paras in this section thus */

	struct linked_list *macros; /* of |para_macro|: those defined in this section */

	int scratch_flag; /* temporary workspace */
	int paused_until_at; /* ignore the top half of the file, until the first |@| sign */
	int printed_number; /* temporary again: sometimes used in weaving */
	CLASS_DEFINITION
} section;
#line 384 "inweb/Chapter 2/The Reader.w"
typedef struct tangle_target {
	struct programming_language *tangle_language; /* common to the entire contents */
	struct hash_table symbols; /* a table of identifiable names in this program */
	CLASS_DEFINITION
} tangle_target;
#line 20 "inweb/Chapter 2/Line Categories.w"
typedef struct source_line {
	struct text_stream *text; /* the text as read in */
	struct text_stream *text_operand; /* meaning depends on category */
	struct text_stream *text_operand2; /* meaning depends on category */

	int category; /* what sort of line this is: an |*_LCAT| value */
	int command_code; /* used only for |COMMAND_LCAT| lines: a |*_CMD| value */
	int default_defn; /* used only for |BEGIN_DEFINITION_LCAT| lines */
	int plainer; /* used only for |BEGIN_CODE_LCAT| lines: suppresses box */
	int enable_hyperlinks; /* used only for |CODE_BODY_LCAT| lines: link URLs in weave */
	struct programming_language *colour_as; /* used only for |TEXT_EXTRACT_LCAT| lines */
	struct text_stream *extract_to; /* used only for |TEXT_EXTRACT_LCAT| lines */
	int is_commentary; /* flag */
	struct language_function *function_defined; /* if any C-like function is defined on this line */
	struct preform_nonterminal *preform_nonterminal_defined; /* similarly */
	int suppress_tangling; /* if e.g., lines are tangled out of order */
	int interface_line_identified; /* only relevant during parsing of Interface lines */
	struct footnote *footnote_text; /* which fn this is the text of, if it is at all */

	struct text_file_position source; /* which file this was read in from, if any */

	struct section *owning_section; /* for interleaved title lines, it's the one about to start */
	struct source_line *next_line; /* within the owning section's linked list */
	struct paragraph *owning_paragraph; /* for lines falling under paragraphs; |NULL| if not */
} source_line;
#line 756 "inweb/Chapter 2/The Parser.w"
typedef struct paragraph {
	int above_bar; /* placed above the dividing bar in its section (in Version 1 syntax) */
	int placed_early; /* should appear early in the tangled code */
	int placed_very_early; /* should appear very early in the tangled code */
	int invisible; /* do not render paragraph number */
	struct text_stream *heading_text; /* if any - many paras have none */
	struct text_stream *ornament; /* a "P" for a pilcrow or "S" for section-marker */
	struct text_stream *paragraph_number; /* used in combination with the ornament */
	int next_child_number; /* used when working out paragraph numbers */
	struct paragraph *parent_paragraph; /* ditto */

	int weight; /* typographic prominence: one of the |*_WEIGHT| values */
	int starts_on_new_page; /* relevant for weaving to TeX only, of course */

	struct para_macro *defines_macro; /* there can only be one */
	struct linked_list *functions; /* of |function|: those defined in this para */
	struct linked_list *structures; /* of |language_type|: similarly */
	struct linked_list *taggings; /* of |paragraph_tagging| */
	struct linked_list *footnotes; /* of |footnote| */
	struct source_line *first_line_in_paragraph;
	struct section *under_section;
	CLASS_DEFINITION
} paragraph;
#line 874 "inweb/Chapter 2/The Parser.w"
typedef struct footnote {
	int footnote_cue_number; /* used only for |FOOTNOTE_TEXT_LCAT| lines */
	int footnote_text_number; /* used only for |FOOTNOTE_TEXT_LCAT| lines */
	struct text_stream *cue_text;
	int cued_already;
	CLASS_DEFINITION
} footnote;
#line 8 "inweb/Chapter 2/Paragraph Macros.w"
typedef struct para_macro {
	struct text_stream *macro_name; /* usually long, like "Create a paragraph macro here" */
	struct paragraph *defining_paragraph; /* as printed in small type after the name in any usage */
	struct source_line *defn_start; /* it ends at the end of its defining paragraph */
	struct linked_list *macro_usages; /* of |macro_usage|: only computed for weaves */
	CLASS_DEFINITION
} para_macro;
#line 10 "inweb/Chapter 2/Tags.w"
typedef struct theme_tag {
	struct text_stream *tag_name;
	int ifdef_positive;
	struct text_stream *ifdef_symbol;
	CLASS_DEFINITION
} theme_tag;
#line 50 "inweb/Chapter 2/Tags.w"
typedef struct paragraph_tagging {
	struct theme_tag *the_tag;
	struct text_stream *caption;
	CLASS_DEFINITION
} paragraph_tagging;
#line 14 "inweb/Chapter 2/Enumerated Constants.w"
typedef struct enumeration_set {
	struct text_stream *postfix;
	struct text_stream *stub;
	int first_value;
	int next_free_value;
	struct source_line *last_observed_at;
	CLASS_DEFINITION
} enumeration_set;
#line 61 "inweb/Chapter 2/Paragraph Numbering.w"
typedef struct macro_usage {
	struct paragraph *used_in_paragraph;
	int multiplicity; /* for example, 2 if it's used twice in this paragraph */
	CLASS_DEFINITION
} macro_usage;
#line 265 "inweb/Chapter 3/The Analyser.w"
typedef struct hash_table_entry_usage {
	struct paragraph *usage_recorded_at;
	int form_of_usage; /* bitmap of the |*_USAGE| constants defined above */
	CLASS_DEFINITION
} hash_table_entry_usage;
#line 48 "inweb/Chapter 3/The Collater.w"
typedef struct collater_state {
	struct web *for_web;
	struct text_stream *tlines[MAX_TEMPLATE_LINES];
	int no_tlines;
	int repeat_stack_level[CI_STACK_CAPACITY];
	struct linked_list_item *repeat_stack_variable[CI_STACK_CAPACITY];
	struct linked_list_item *repeat_stack_threshold[CI_STACK_CAPACITY];
	int repeat_stack_startpos[CI_STACK_CAPACITY];
	int sp; /* And this is our stack pointer for tracking of loops */
	struct text_stream *restrict_to_range;
	struct weave_pattern *nav_pattern;
	struct filename *nav_file;
	struct linked_list *crumbs;
	int inside_navigation_submenu;
	struct filename *errors_at;
	struct weave_order *wv;
	struct filename *into_file;
	struct linked_list *modules; /* of |module| */
} collater_state;
#line 113 "inweb/Chapter 3/The Weaver.w"
typedef struct weaver_state {
	int kind_of_material; /* one of the enumerated |*_MATERIAL| constants above */
	int line_break_pending; /* insert a line break before the next woven line? */
	int next_heading_without_vertical_skip;
	int horizontal_rule_just_drawn;
	struct section *last_extract_from;
	struct tree_node *body_node;
	struct tree_node *chapter_node;
	struct tree_node *section_node;
	struct tree_node *para_node;
	struct tree_node *carousel_node;
	struct tree_node *material_node;
	struct tree_node *ap;
} weaver_state;
#line 8 "inweb/Chapter 4/Types and Functions.w"
typedef struct language_type {
	struct text_stream *structure_name;
	int tangled; /* whether the structure definition has been tangled out */
	struct source_line *structure_header_at; /* opening line of |typedef| */
	struct source_line *typedef_ends; /* closing line, where |}| appears */
	struct linked_list *incorporates; /* of |language_type| */
	struct linked_list *elements; /* of |structure_element| */
	struct language_type *next_cst_alphabetically;
	CLASS_DEFINITION
} language_type;
#line 78 "inweb/Chapter 4/Types and Functions.w"
typedef struct structure_element {
	struct text_stream *element_name;
	struct source_line *element_created_at;
	int allow_sharing;
	CLASS_DEFINITION
} structure_element;
#line 112 "inweb/Chapter 4/Types and Functions.w"
typedef struct language_function {
	struct text_stream *function_name; /* e.g., |"cultivate"| */
	struct text_stream *function_type; /* e.g., |"tree *"| */
	struct text_stream *function_arguments; /* e.g., |"int rainfall)"|: note |)| */
	struct source_line *function_header_at; /* where the first line of the header begins */
	int within_namespace; /* written using InC namespace dividers */
	int called_from_other_sections;
	int call_freely;
	int usage_described;
	int no_conditionals;
	struct source_line *within_conditionals[MAX_CONDITIONAL_COMPILATION_STACK];
	CLASS_DEFINITION
} language_function;
#line 105 "inweb/Chapter 4/InC Support.w"
typedef struct preform_nonterminal {
	struct text_stream *nt_name; /* e.g., |<action-clause>| */
	struct text_stream *unangled_name; /* e.g., |action-clause| */
	struct text_stream *as_C_identifier; /* e.g., |action_clause_NTM| */
	int as_function; /* defined internally, that is, parsed by a C language_function */
	int voracious; /* a voracious nonterminal: see "The English Syntax of Inform" */
	int min_word_count; /* for internals only */
	int max_word_count;
	int takes_pointer_result; /* right-hand formula defines |*XP|, not |*X| */
	struct source_line *where_defined;
	struct preform_nonterminal *next_pnt_alphabetically;
	CLASS_DEFINITION
} preform_nonterminal;
#line 280 "inweb/Chapter 4/InC Support.w"
typedef struct nonterminal_variable {
	struct text_stream *ntv_name; /* e.g., |"num"| */
	struct text_stream *ntv_type; /* e.g., |"int"| */
	struct text_stream *ntv_identifier; /* e.g., |"num_NTMV"| */
	struct source_line *first_mention; /* first usage */
	CLASS_DEFINITION
} nonterminal_variable;
#line 332 "inweb/Chapter 4/InC Support.w"
typedef struct text_literal {
	struct text_stream *tl_identifier;
	struct text_stream *tl_content;
	CLASS_DEFINITION
} text_literal;
#line 6 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_document_node {
	struct weave_order *wv;
	CLASS_DEFINITION
} weave_document_node;
#line 11 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_head_node {
	struct text_stream *banner;
	CLASS_DEFINITION
} weave_head_node;
#line 16 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_body_node {
	CLASS_DEFINITION
} weave_body_node;
#line 20 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_tail_node {
	struct text_stream *rennab;
	CLASS_DEFINITION
} weave_tail_node;
#line 25 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_chapter_header_node {
	struct chapter *chap;
	CLASS_DEFINITION
} weave_chapter_header_node;
#line 30 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_chapter_footer_node {
	struct chapter *chap;
	CLASS_DEFINITION
} weave_chapter_footer_node;
#line 35 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_section_header_node {
	struct section *sect;
	CLASS_DEFINITION
} weave_section_header_node;
#line 40 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_section_footer_node {
	struct section *sect;
	CLASS_DEFINITION
} weave_section_footer_node;
#line 45 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_section_purpose_node {
	struct text_stream *purpose;
	CLASS_DEFINITION
} weave_section_purpose_node;
#line 50 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_subheading_node {
	struct text_stream *text;
	CLASS_DEFINITION
} weave_subheading_node;
#line 55 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_bar_node {
	CLASS_DEFINITION
} weave_bar_node;
#line 59 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_pagebreak_node {
	CLASS_DEFINITION
} weave_pagebreak_node;
#line 63 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_linebreak_node {
	CLASS_DEFINITION
} weave_linebreak_node;
#line 67 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_paragraph_heading_node {
	struct paragraph *para;
	int no_skip;
	CLASS_DEFINITION
} weave_paragraph_heading_node;
#line 73 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_endnote_node {
	CLASS_DEFINITION
} weave_endnote_node;
#line 77 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_figure_node {
	struct text_stream *figname;
	int w;
	int h;
	CLASS_DEFINITION
} weave_figure_node;
#line 84 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_extract_node {
	struct text_stream *extract;
	CLASS_DEFINITION
} weave_extract_node;
#line 89 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_audio_node {
	struct text_stream *audio_name;
	int w;
	CLASS_DEFINITION
} weave_audio_node;
#line 95 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_video_node {
	struct text_stream *video_name;
	int w;
	int h;
	CLASS_DEFINITION
} weave_video_node;
#line 102 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_download_node {
	struct text_stream *download_name;
	struct text_stream *filetype;
	CLASS_DEFINITION
} weave_download_node;
#line 108 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_material_node {
	int material_type;
	int plainly;
	struct programming_language *styling;
	struct text_stream *endnote;
	CLASS_DEFINITION
} weave_material_node;
#line 116 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_embed_node {
	struct text_stream *service;
	struct text_stream *ID;
	int w;
	int h;
	CLASS_DEFINITION
} weave_embed_node;
#line 124 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_pmac_node {
	struct para_macro *pmac;
	int defn;
	CLASS_DEFINITION
} weave_pmac_node;
#line 130 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_vskip_node {
	int in_comment;
	CLASS_DEFINITION
} weave_vskip_node;
#line 135 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_chapter_node {
	struct chapter *chap;
	CLASS_DEFINITION
} weave_chapter_node;
#line 140 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_section_node {
	struct section *sect;
	CLASS_DEFINITION
} weave_section_node;
#line 145 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_code_line_node {
	CLASS_DEFINITION
} weave_code_line_node;
#line 149 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_function_usage_node {
	struct text_stream *url;
	struct language_function *fn;
	CLASS_DEFINITION
} weave_function_usage_node;
#line 155 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_commentary_node {
	struct text_stream *text;
	int in_code;
	CLASS_DEFINITION
} weave_commentary_node;
#line 161 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_carousel_slide_node {
	struct text_stream *caption;
	int caption_command;
	CLASS_DEFINITION
} weave_carousel_slide_node;
#line 167 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_toc_node {
	struct text_stream *text1;
	CLASS_DEFINITION
} weave_toc_node;
#line 172 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_toc_line_node {
	struct text_stream *text1;
	struct text_stream *text2;
	struct paragraph *para;
	CLASS_DEFINITION
} weave_toc_line_node;
#line 179 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_chapter_title_page_node {
	CLASS_DEFINITION
} weave_chapter_title_page_node;
#line 183 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_defn_node {
	struct text_stream *keyword;
	CLASS_DEFINITION
} weave_defn_node;
#line 188 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_inline_node {
	CLASS_DEFINITION
} weave_inline_node;
#line 192 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_locale_node {
	struct paragraph *par1;
	struct paragraph *par2;
	CLASS_DEFINITION
} weave_locale_node;
#line 198 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_source_code_node {
	struct text_stream *matter;
	struct text_stream *colouring;
	CLASS_DEFINITION
} weave_source_code_node;
#line 204 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_url_node {
	struct text_stream *url;
	struct text_stream *content;
	int external;
	CLASS_DEFINITION
} weave_url_node;
#line 211 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_footnote_cue_node {
	struct text_stream *cue_text;
	CLASS_DEFINITION
} weave_footnote_cue_node;
#line 216 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_begin_footnote_text_node {
	struct text_stream *cue_text;
	CLASS_DEFINITION
} weave_begin_footnote_text_node;
#line 221 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_display_line_node {
	struct text_stream *text;
	CLASS_DEFINITION
} weave_display_line_node;
#line 226 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_function_defn_node {
	struct language_function *fn;
	CLASS_DEFINITION
} weave_function_defn_node;
#line 231 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_item_node {
	int depth;
	struct text_stream *label;
	CLASS_DEFINITION
} weave_item_node;
#line 237 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_grammar_index_node {
	CLASS_DEFINITION
} weave_grammar_index_node;
#line 241 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_maths_node {
	struct text_stream *content;
	int displayed;
	CLASS_DEFINITION
} weave_maths_node;
#line 247 "inweb/Chapter 5/Weave Tree.w"
typedef struct weave_verbatim_node {
	struct text_stream *content;
	CLASS_DEFINITION
} weave_verbatim_node;
#line 11 "inweb/Chapter 5/Format Methods.w"
typedef struct weave_format {
	struct text_stream *format_name;
	struct text_stream *woven_extension;
	struct method_set *methods;
	CLASS_DEFINITION
} weave_format;
#line 18 "inweb/Chapter 5/Plain Text Format.w"
typedef struct PlainText_render_state {
	struct text_stream *OUT;
	struct weave_order *wv;
} PlainText_render_state;
#line 33 "inweb/Chapter 5/TeX Format.w"
typedef struct TeX_render_state {
	struct text_stream *OUT;
	struct weave_order *wv;
	int TeX_form;
} TeX_render_state;
#line 29 "inweb/Chapter 5/HTML Formats.w"
typedef struct HTML_render_state {
	struct text_stream *OUT;
	struct filename *into_file;
	struct weave_order *wv;
	struct colour_scheme *colours;
	int EPUB_flag;
	int popup_counter;
	int carousel_number;
	int slide_number;
	int slide_of;
	struct asset_rule *copy_rule;
} HTML_render_state;
#line 18 "inweb/Chapter 5/Debugging Format.w"
typedef struct debugging_render_state {
	struct text_stream *OUT;
	struct weave_order *wv;
} debugging_render_state;
#line 20 "inweb/Chapter 5/TeX Utilities.w"
typedef struct tex_results {
	int overfull_hbox_count;
	int tex_error_count;
	int page_count;
	int pdf_size;
	struct filename *PDF_filename;
	CLASS_DEFINITION
} tex_results;
#line 51 "inweb/Chapter 6/Makefiles.w"
typedef struct makefile_specifics {
	struct web *for_web; /* if one has been set at the command line */
	struct dictionary *tools_dictionary;   /* components with |type: tool| */
	struct dictionary *webs_dictionary;    /* components with |type: web| */
	struct dictionary *modules_dictionary; /* components with |type: module| */
	struct module_search *search_path;
	struct text_stream *which_platform;
	CLASS_DEFINITION
} makefile_specifics;
#line 173 "inweb/Chapter 6/Ctags Support.w"
typedef struct defined_constant {
	struct text_stream *name;
	struct source_line *at;
	CLASS_DEFINITION
} defined_constant;
#line 41 "inweb/Chapter 6/Readme Writeme.w"
typedef struct writeme_asset {
	struct text_stream *name;
	struct web_md *if_web;
	struct text_stream *date;
	struct text_stream *version;
	int next_is_version;
	CLASS_DEFINITION
} writeme_asset;
#line 21 "inweb/Chapter 6/Colonies.w"
typedef struct colony {
	struct linked_list *members; /* of |colony_member| */
	struct text_stream *home; /* path of home repository */
	struct pathname *assets_path; /* where assets shared between weaves live */
	struct pathname *patterns_path; /* where additional patterns live */
	CLASS_DEFINITION
} colony;
#line 39 "inweb/Chapter 6/Colonies.w"
typedef struct colony_member {
	int web_rather_than_module; /* |TRUE| for a web, |FALSE| for a module */
	struct text_stream *name; /* the |N| in |N at P in W| */
	struct text_stream *path; /* the |P| in |N at P in W| */
	struct pathname *weave_path; /* the |W| in |N at P in W| */
	struct text_stream *home_leaf; /* usually |index.html|, but not for single-file webs */
	struct text_stream *default_weave_pattern; /* for use when weaving */

	struct web_md *loaded; /* metadata on its sections, lazily evaluated */
	struct filename *navigation; /* navigation sidebar HTML */
	struct linked_list *breadcrumb_tail; /* of |breadcrumb_request| */
	CLASS_DEFINITION
} colony_member;
#line 59 "inweb/Chapter 6/Colonies.w"
typedef struct colony_reader_state {
	struct colony *province;
	struct filename *nav;
	struct linked_list *crumbs; /* of |breadcrumb_request| */
	struct text_stream *pattern;
} colony_reader_state;
#line 163 "inweb/Chapter 6/Colonies.w"
typedef struct breadcrumb_request {
	struct text_stream *breadcrumb_text;
	struct text_stream *breadcrumb_link;
	CLASS_DEFINITION
} breadcrumb_request;
typedef uintptr_t pointer_sized_int;
typedef void (*writer_function)(text_stream *, char *, void *);
typedef void (*writer_function_I)(text_stream *, char *, int);
typedef void (*log_function)(text_stream *, void *);
typedef void (*log_function_I)(text_stream *, int);
typedef char string[MAX_STRING_LENGTH+1];
#line 91 "inweb/foundation-module/Chapter 1/Foundation Module.w"
void  Foundation__start(int argc, char **argv) ;
#line 176 "inweb/foundation-module/Chapter 1/Foundation Module.w"
void  Foundation__end(void) ;
#ifdef PLATFORM_POSIX
#line 81 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__is_folder_separator(inchar32_t c) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 102 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
char * Platform__getenv(const char *name) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#line 115 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__where_am_i(inchar32_t *p, size_t length) ;
#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_UNIX
#ifdef PLATFORM_POSIX
#line 166 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__where_am_i(inchar32_t *p, size_t length) ;
#endif /* PLATFORM_UNIX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#line 173 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__where_am_i(inchar32_t *p, size_t length) ;
#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifndef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 186 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__system(const char *cmd) ;
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 216 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__system(const char *cmd) ;
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 233 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__mkdir(char *transcoded_pathname) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 241 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void * Platform__opendir(char *dir_name) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 246 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__readdir(void *D, char *dir_name, char *leafname) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 265 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__closedir(void *D) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 273 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__rename_file(char *old_transcoded_pathname, char *new_transcoded_pathname) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 279 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__rename_directory(char *old_transcoded_pathname, char *new_transcoded_pathname) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 288 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__copy_file(char *from_transcoded_pathname, char *to_transcoded_pathname) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 305 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
time_t  Platform__never_time(void) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 309 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
time_t  Platform__timestamp(char *transcoded_filename) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 315 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
off_t  Platform__size(char *transcoded_filename) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 329 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__rsync(char *transcoded_source, char *transcoded_dest) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 338 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__quote_text(char *quoted, char *raw, int terminate) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 354 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__sleep(int seconds) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 370 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__notification(text_stream *text, int happy) ;
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifndef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 383 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__notification(text_stream *text, int happy) ;
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 396 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__configure_terminal(void) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 408 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__create_thread(foundation_thread *pt, 	const foundation_thread_attributes *pa, void *(*fn)(void *), void *arg) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 413 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__join_thread(foundation_thread pt, void** rv) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 417 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void  Platform__init_thread(foundation_thread_attributes *pa, size_t size) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 422 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
size_t  Platform__get_thread_stack_size(foundation_thread_attributes *pa) ;
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#line 443 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__get_core_count(void) ;
#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 457 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__get_core_count(void) ;
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#line 469 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int  Platform__get_core_count(void) ;
#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_WINDOWS
#line 38 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__is_folder_separator(inchar32_t c) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 70 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__where_am_i(inchar32_t *p, size_t length) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 178 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__mkdir(char *transcoded_pathname) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 186 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void * Platform__opendir(char *dir_name) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 191 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__readdir(void *D, char *dir_name, 	char *leafname) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 208 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__closedir(void *D) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 216 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__rename_file(char *old_transcoded_pathname, char *new_transcoded_pathname) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 222 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__rename_directory(char *old_transcoded_pathname, char *new_transcoded_pathname) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 231 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__copy_file(char *from_transcoded_pathname, char *to_transcoded_pathname) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 238 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__path_add(const char* base, const char* add, char* path) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 248 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__rsync(char *transcoded_source, char *transcoded_dest) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 327 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__sleep(int seconds) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 334 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__notification(text_stream *text, int happy) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 352 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__Win32_ResetConsole(void) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 361 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__configure_terminal(void) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 403 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__create_thread(foundation_thread *pt, const foundation_thread_attributes *pa, 	void *(*fn)(void *), void *arg) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 418 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__join_thread(foundation_thread pt, void** rv) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 422 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void  Platform__init_thread(foundation_thread_attributes* pa, size_t size) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 425 "inweb/foundation-module/Chapter 1/Windows Platform.w"
size_t  Platform__get_thread_stack_size(foundation_thread_attributes* pa) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 435 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int  Platform__get_core_count(void) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 456 "inweb/foundation-module/Chapter 1/Windows Platform.w"
time_t  Platform__never_time(void) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 460 "inweb/foundation-module/Chapter 1/Windows Platform.w"
time_t  Platform__timestamp(char *transcoded_filename) ;
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 466 "inweb/foundation-module/Chapter 1/Windows Platform.w"
off_t  Platform__size(char *transcoded_filename) ;
#endif /* PLATFORM_WINDOWS */
#line 64 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__declare_aspect(int a, inchar32_t *name, int def, int alt) ;
#line 111 "inweb/foundation-module/Chapter 2/Debugging Log.w"
filename * Log__get_debug_log_filename(void) ;
#line 115 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__set_debug_log_filename(filename *F) ;
#line 119 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int  Log__open(void) ;
#line 131 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int  Log__open_alternative(filename *F, text_stream *at) ;
#line 140 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__close(void) ;
#line 155 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__new_phase(char *p, text_stream *q) ;
#line 164 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__new_stage(text_stream *p) ;
#line 178 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int  Log__aspect_switched_on(int aspect) ;
#line 185 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__set_aspect(int aspect, int state) ;
#line 192 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__set_all_aspects(int new_state) ;
#line 210 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int  Log__set_aspect_from_command_line(text_stream *name, int give_error) ;
#line 241 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__tracing_on(int starred, text_stream *heading) ;
#line 261 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__show_debugging_settings_with_state(int state) ;
#line 274 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void  Log__show_debugging_contents(void) ;
#line 78 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__start(void) ;
#line 156 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__allocate_another_block(void) ;
#line 196 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__free(void) ;
#line 241 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__check_memory_integrity(void) ;
#line 252 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__debug_memory_frames(int from, int to) ;
#line 269 "inweb/foundation-module/Chapter 2/Memory.w"
void * Memory__allocate(int mem_type, int extent) ;
#line 470 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__name_fundamental_reasons(void) ;
#line 483 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__reason_name(int r, char *reason) ;
#line 488 "inweb/foundation-module/Chapter 2/Memory.w"
char * Memory__description_of_reason(int r) ;
#line 513 "inweb/foundation-module/Chapter 2/Memory.w"
void * Memory__calloc(int how_many, int size_in_bytes, int reason) ;
#line 516 "inweb/foundation-module/Chapter 2/Memory.w"
void * Memory__malloc(int size_in_bytes, int reason) ;
#line 523 "inweb/foundation-module/Chapter 2/Memory.w"
void * Memory__alloc_inner(int N, int S, int R) ;
#line 574 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__I7_free(void *pointer, int R, int bytes_freed) ;
#line 583 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__I7_array_free(void *pointer, int R, int num_cells, size_t cell_size) ;
#line 591 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__log_statistics(void) ;
#line 673 "inweb/foundation-module/Chapter 2/Memory.w"
int  Memory__log_usage(int total) ;
#line 693 "inweb/foundation-module/Chapter 2/Memory.w"
int  Memory__compare_usage(const void *ent1, const void *ent2) ;
#line 703 "inweb/foundation-module/Chapter 2/Memory.w"
void  Memory__log_percentage(int bytes, int total) ;
#line 716 "inweb/foundation-module/Chapter 2/Memory.w"
void * Memory__paranoid_calloc(size_t N, size_t S) ;
#line 748 "inweb/foundation-module/Chapter 2/Memory.w"
general_pointer  Memory__store_gp_null(void) ;
#line 754 "inweb/foundation-module/Chapter 2/Memory.w"
int  Memory__test_gp_null(general_pointer gp) ;
#line 12 "inweb/foundation-module/Chapter 2/Locales.w"
char * Locales__name(int L) ;
#line 20 "inweb/foundation-module/Chapter 2/Locales.w"
int  Locales__parse_locale(char *name) ;
#line 35 "inweb/foundation-module/Chapter 2/Locales.w"
int  Locales__get(int L) ;
#line 42 "inweb/foundation-module/Chapter 2/Locales.w"
void  Locales__set(int L, int E) ;
#line 60 "inweb/foundation-module/Chapter 2/Locales.w"
int  Locales__parse_encoding(char *name) ;
#line 72 "inweb/foundation-module/Chapter 2/Locales.w"
void  Locales__write_locales(OUTPUT_STREAM) ;
#line 82 "inweb/foundation-module/Chapter 2/Locales.w"
void  Locales__write_locale(OUTPUT_STREAM, int L) ;
#line 98 "inweb/foundation-module/Chapter 2/Locales.w"
int  Locales__platform_locale(void) ;
#line 118 "inweb/foundation-module/Chapter 2/Locales.w"
int  Locales__set_locales(char *text) ;
#line 274 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__initialise(text_stream *stream, int from) ;
#line 292 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__enable_XML_escapes(text_stream *stream) ;
#line 296 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__disable_XML_escapes(text_stream *stream) ;
#line 302 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__enable_I6_escapes(text_stream *stream) ;
#line 307 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__disable_I6_escapes(text_stream *stream) ;
#line 313 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__I6_escapes_enabled(text_stream *stream) ;
#line 317 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__enable_debugging(text_stream *stream) ;
#line 321 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__disable_debugging(text_stream *stream) ;
#line 326 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__mark_as_read_only(text_stream *stream) ;
#line 330 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__declare_as_HTML(text_stream *stream, HTML_file_state *hs) ;
#line 334 "inweb/foundation-module/Chapter 2/Streams.w"
HTML_file_state * Streams__get_HTML_file_state(text_stream *stream) ;
#line 341 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__log(OUTPUT_STREAM, void *vS) ;
#line 364 "inweb/foundation-module/Chapter 2/Streams.w"
text_stream * Streams__get_stdout(void) ;
#line 383 "inweb/foundation-module/Chapter 2/Streams.w"
text_stream * Streams__get_stderr(void) ;
#line 400 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_to_file(text_stream *stream, filename *name, int encoding) ;
#line 419 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_to_file_append(text_stream *stream, filename *name, int encoding) ;
#line 440 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_to_memory(text_stream *stream, int capacity) ;
#line 456 "inweb/foundation-module/Chapter 2/Streams.w"
text_stream  Streams__new_buffer(int capacity, inchar32_t *at) ;
#line 474 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_from_wide_string(text_stream *stream, const inchar32_t *c_string, int capacity) ;
#line 481 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_wide_string(text_stream *stream, const inchar32_t *c_string) ;
#line 489 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_from_ISO_string(text_stream *stream, const char *c_string) ;
#line 497 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_ISO_string(text_stream *stream, const char *c_string) ;
#line 504 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_from_UTF8_string(text_stream *stream, const char *c_string) ;
#line 512 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_UTF8_string(text_stream *stream, const char *c_string) ;
#line 531 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_as_wide_string(inchar32_t *C_string, text_stream *stream, int buffer_size) ;
#line 550 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_as_ISO_string(char *C_string, text_stream *stream, int buffer_size) ;
#line 567 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_as_UTF8_string(char *C_string, text_stream *stream, int buffer_size) ;
#line 607 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__open_from_locale_string(text_stream *stream, const char *C_string) ;
#line 616 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_as_locale_string(char *C_string, text_stream *stream, int buffer_size) ;
#line 624 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__write_locale_string(text_stream *stream, char *C_string) ;
#line 637 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__flush(text_stream *stream) ;
#line 645 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__close(text_stream *stream) ;
#line 696 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__putc(inchar32_t c, text_stream *stream) ;
#line 744 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__putci(int c_int, text_stream *stream) ;
#line 817 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__literal(text_stream *stream, char *p) ;
#line 831 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__indent(text_stream *stream) ;
#line 836 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__outdent(text_stream *stream) ;
#line 845 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__set_indentation(text_stream *stream, int N) ;
#line 852 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__get_indentation(text_stream *stream) ;
#line 864 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__get_position(text_stream *stream) ;
#line 878 "inweb/foundation-module/Chapter 2/Streams.w"
int  Streams__latest(text_stream *stream) ;
#line 894 "inweb/foundation-module/Chapter 2/Streams.w"
inchar32_t  Streams__get_char_at_index(text_stream *stream, int position) ;
#line 906 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__put_char_at_index(text_stream *stream, int position, inchar32_t C) ;
#line 932 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__set_position(text_stream *stream, int position) ;
#line 956 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__copy(text_stream *to, text_stream *from) ;
#line 973 "inweb/foundation-module/Chapter 2/Streams.w"
void  Streams__writer(OUTPUT_STREAM, char *format_string, void *vS) ;
#line 51 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__log_escape_usage(void) ;
#line 67 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__register_writer(int esc, void (*f)(text_stream *, char *, void *)) ;
#line 70 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__register_logger(int esc, void (*f)(text_stream *, void *)) ;
#line 73 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__register_writer_I(int esc, void (*f)(text_stream *, char *, int)) ;
#line 76 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__register_logger_I(int esc, void (*f)(text_stream *, int)) ;
#line 87 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__register_writer_p(int set, int esc, void *f, int cat) ;
#line 130 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void  Writers__printf(text_stream *stream, char *fmt, ...) ;
#line 32 "inweb/foundation-module/Chapter 2/Methods.w"
method_set * Methods__new_set(void) ;
#line 76 "inweb/foundation-module/Chapter 2/Methods.w"
void  Methods__add(method_set *S, int ID, void *function) ;
#line 90 "inweb/foundation-module/Chapter 2/Methods.w"
int  Methods__provided(method_set *S, int ID) ;
#line 30 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
linked_list * LinkedLists__new(void) ;
#line 36 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void  LinkedLists__empty(linked_list *ll) ;
#line 47 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void  LinkedLists__add(linked_list *L, void *P, int to_end) ;
#line 75 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void * LinkedLists__remove_from_front(linked_list *L) ;
#line 88 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void * LinkedLists__delete(int N, linked_list *L) ;
#line 112 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void  LinkedLists__insert(linked_list *L, int N, void *P) ;
#line 140 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
int  LinkedLists__len(linked_list *L) ;
#line 143 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
linked_list_item * LinkedLists__first(linked_list *L) ;
#line 146 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void * LinkedLists__entry(int N, linked_list *L) ;
#line 153 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void  LinkedLists__set_entry(int N, linked_list *L, void *P) ;
#line 160 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
linked_list_item * LinkedLists__last(linked_list *L) ;
#line 163 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
linked_list_item * LinkedLists__next(linked_list_item *I) ;
#line 166 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void * LinkedLists__content(linked_list_item *I) ;
#line 33 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dictionary * Dictionaries__new(int S, int textual) ;
#line 51 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void  Dictionaries__log(OUTPUT_STREAM, dictionary *D) ;
#line 71 "inweb/foundation-module/Chapter 2/Dictionaries.w"
int  Dictionaries__hash(text_stream *K, int N) ;
#line 85 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry * Dictionaries__find(dictionary *D, text_stream *K) ;
#line 88 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry * Dictionaries__create(dictionary *D, text_stream *K) ;
#line 91 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void  Dictionaries__destroy(dictionary *D, text_stream *K) ;
#line 100 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry * Dictionaries__find_literal(dictionary *D, inchar32_t *lit) ;
#line 107 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry * Dictionaries__create_literal(dictionary *D, inchar32_t *lit) ;
#line 114 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void  Dictionaries__destroy_literal(dictionary *D, inchar32_t *lit) ;
#line 125 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry * Dictionaries__find_p(dictionary *D, text_stream *K, int change) ;
#line 202 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void * Dictionaries__value_for_entry(dict_entry *de) ;
#line 207 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void * Dictionaries__read_value(dictionary *D, text_stream *key) ;
#line 215 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void * Dictionaries__read_value_literal(dictionary *D, inchar32_t *key) ;
#line 224 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void  Dictionaries__write_value(dictionary *D, text_stream *key, void *val) ;
#line 232 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void  Dictionaries__write_value_literal(dictionary *D, inchar32_t *key, void *val) ;
#line 245 "inweb/foundation-module/Chapter 2/Dictionaries.w"
text_stream * Dictionaries__create_text(dictionary *D, text_stream *key) ;
#line 251 "inweb/foundation-module/Chapter 2/Dictionaries.w"
text_stream * Dictionaries__create_text_literal(dictionary *D, inchar32_t *lit) ;
#line 262 "inweb/foundation-module/Chapter 2/Dictionaries.w"
text_stream * Dictionaries__get_text(dictionary *D, text_stream *key) ;
#line 270 "inweb/foundation-module/Chapter 2/Dictionaries.w"
text_stream * Dictionaries__get_text_literal(dictionary *D, inchar32_t *lit) ;
#line 283 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void  Dictionaries__dispose_of(dictionary *D) ;
#line 18 "inweb/foundation-module/Chapter 2/Trees.w"
heterogeneous_tree * Trees__new(tree_type *type) ;
#line 40 "inweb/foundation-module/Chapter 2/Trees.w"
tree_node * Trees__new_node(heterogeneous_tree *T, tree_node_type *type, general_pointer wrapping) ;
#line 61 "inweb/foundation-module/Chapter 2/Trees.w"
tree_node * Trees__new_child(tree_node *of, tree_node_type *type, general_pointer wrapping) ;
#line 81 "inweb/foundation-module/Chapter 2/Trees.w"
tree_type * Trees__new_type(text_stream *name, int (*verifier)(tree_node *)) ;
#line 100 "inweb/foundation-module/Chapter 2/Trees.w"
tree_node_type * Trees__new_node_type(text_stream *name, int req, 	int (*verifier)(tree_node *)) ;
#line 114 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__make_root(heterogeneous_tree *T, tree_node *N) ;
#line 126 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__remove_root(heterogeneous_tree *T) ;
#line 134 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__make_child(tree_node *N, tree_node *of) ;
#line 151 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__make_eldest_child(tree_node *N, tree_node *of) ;
#line 162 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__make_sibling(tree_node *N, tree_node *of) ;
#line 179 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__remove(tree_node *N) ;
#line 194 "inweb/foundation-module/Chapter 2/Trees.w"
int  Trees__verify_children(tree_node *N) ;
#line 210 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__traverse_tree(heterogeneous_tree *T, 	int (*visitor)(tree_node *, void *, int L), void *state) ;
#line 216 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__traverse_from(tree_node *N, 	int (*visitor)(tree_node *, void *, int L), void *state, int L) ;
#line 223 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__traverse(tree_node *N, 	int (*visitor)(tree_node *, void *, int L), void *state, int L) ;
#line 233 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__prune_tree(heterogeneous_tree *T, 	int (*visitor)(tree_node *, void *), void *state) ;
#line 239 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__prune_from(tree_node *N, 	int (*visitor)(tree_node *, void *), void *state) ;
#line 249 "inweb/foundation-module/Chapter 2/Trees.w"
void  Trees__prune(tree_node *N, 	int (*visitor)(tree_node *, void *), void *state) ;
#line 13 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__set_handler(int (*f)(text_stream *, int)) ;
#line 16 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__set_internal_handler(void (*f)(void *, char *, char *, int)) ;
#line 21 "inweb/foundation-module/Chapter 3/Error Messages.w"
int  Errors__have_occurred(void) ;
#line 26 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__issue(text_stream *message, int fatality) ;
#line 43 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__fatal(char *message) ;
#line 50 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__fatal_with_C_string(char *message, char *parameter) ;
#line 59 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__fatal_with_text(char *message, text_stream *parameter) ;
#line 68 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__fatal_with_file(char *message, filename *F) ;
#line 75 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__fatal_with_path(char *message, pathname *P) ;
#line 91 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__internal_error_handler(void *p, char *message, char *f, int lc) ;
#line 106 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__enter_debugger_mode(void) ;
#line 111 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__die(void) ;
#line 127 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__nowhere(char *message) ;
#line 131 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__in_text_file(char *message, text_file_position *here) ;
#line 138 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__in_text_file_S(text_stream *message, text_file_position *here) ;
#line 148 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__at_position(char *message, filename *file, int line) ;
#line 157 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__at_position_S(text_stream *message, filename *file, int line) ;
#line 169 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__with_file(char *message, filename *F) ;
#line 176 "inweb/foundation-module/Chapter 3/Error Messages.w"
void  Errors__with_text(char *message, text_stream *T) ;
#line 65 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__begin_group(int id, text_stream *name) ;
#line 71 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__end_group(void) ;
#line 74 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
command_line_switch * CommandLine__declare_switch(int id, 	inchar32_t *name_literal, int val, inchar32_t *help_literal) ;
#line 80 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
command_line_switch * CommandLine__declare_switch_p(int id, 	text_stream *name, int val, text_stream *help_literal) ;
#line 117 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
command_line_switch * CommandLine__declare_boolean_switch(int id, 	inchar32_t *name_literal, int val, inchar32_t *help_literal, int active) ;
#line 136 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__declare_numerical_switch(int id, 	inchar32_t *name_literal, int val, inchar32_t *help_literal) ;
#line 143 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__declare_textual_switch(int id, 	inchar32_t *name_literal, int val, inchar32_t *help_literal) ;
#line 179 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int  CommandLine__read(int argc, char **argv, void *state, 	void (*f)(int, int, text_stream *, void *), void (*g)(int, text_stream *, void *)) ;
#line 189 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__set_locale(int argc, char **argv) ;
#line 198 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__read_array(clf_reader_state *crs, int argc, char **argv) ;
#line 225 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__also_read_file(filename *F) ;
#line 236 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__record_log(text_stream *line) ;
#line 242 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__play_back_log(void) ;
#line 259 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__read_file(clf_reader_state *crs) ;
#line 271 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__read_file_helper(text_stream *text, text_file_position *tfp, void *state) ;
#line 300 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__read_one(clf_reader_state *crs, text_stream *opt) ;
#line 308 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int  CommandLine__read_pair(clf_reader_state *crs, text_stream *opt, text_stream *arg) ;
#line 332 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int  CommandLine__read_pair_p(text_stream *opt, text_stream *opt_val, int N, 	text_stream *arg, void *state, 	void (*f)(int, int, text_stream *, void *), int *substantive) ;
#line 424 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__declare_heading(inchar32_t *heading_text_literal) ;
#line 428 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void  CommandLine__write_help(OUTPUT_STREAM) ;
#line 486 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int  CommandLine__compare_names(const void *ent1, const void *ent2) ;
#line 51 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__start(void) ;
#line 64 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__set_installation_path(pathname *P) ;
#line 67 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname * Pathnames__installation_path(const char *V, text_stream *def) ;
#line 96 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname * Pathnames__down(pathname *P, text_stream *dir_name) ;
#line 100 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname * Pathnames__primitive(text_stream *str, int from, int to, pathname *par) ;
#line 120 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname * Pathnames__from_text(text_stream *path) ;
#line 124 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname * Pathnames__from_text_relative(pathname *P, text_stream *path) ;
#line 141 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__writer(OUTPUT_STREAM, char *format_string, void *vP) ;
#line 148 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__writer_r(OUTPUT_STREAM, pathname *P, inchar32_t divider) ;
#line 178 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__to_text_relative(OUTPUT_STREAM, pathname *P, pathname *R) ;
#line 193 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname * Pathnames__up(pathname *P) ;
#line 198 "inweb/foundation-module/Chapter 3/Pathnames.w"
text_stream * Pathnames__directory_name(pathname *P) ;
#line 209 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__relative_URL(OUTPUT_STREAM, pathname *from, pathname *to) ;
#line 245 "inweb/foundation-module/Chapter 3/Pathnames.w"
int  Pathnames__create_in_file_system(pathname *P) ;
#line 263 "inweb/foundation-module/Chapter 3/Pathnames.w"
void  Pathnames__rsync(pathname *source, pathname *dest) ;
#line 280 "inweb/foundation-module/Chapter 3/Pathnames.w"
int  Pathnames__move_directory(pathname *from, pathname *to) ;
#line 22 "inweb/foundation-module/Chapter 3/Filenames.w"
filename * Filenames__in(pathname *P, text_stream *file_name) ;
#line 26 "inweb/foundation-module/Chapter 3/Filenames.w"
filename * Filenames__primitive(text_stream *S, int from, int to, pathname *P) ;
#line 42 "inweb/foundation-module/Chapter 3/Filenames.w"
filename * Filenames__from_text(text_stream *path) ;
#line 58 "inweb/foundation-module/Chapter 3/Filenames.w"
filename * Filenames__from_text_relative(pathname *from, text_stream *path) ;
#line 75 "inweb/foundation-module/Chapter 3/Filenames.w"
void  Filenames__writer(OUTPUT_STREAM, char *format_string, void *vF) ;
#line 91 "inweb/foundation-module/Chapter 3/Filenames.w"
void  Filenames__to_text_relative(OUTPUT_STREAM, filename *F, pathname *P) ;
#line 115 "inweb/foundation-module/Chapter 3/Filenames.w"
pathname * Filenames__up(filename *F) ;
#line 123 "inweb/foundation-module/Chapter 3/Filenames.w"
filename * Filenames__without_path(filename *F) ;
#line 127 "inweb/foundation-module/Chapter 3/Filenames.w"
text_stream * Filenames__get_leafname(filename *F) ;
#line 132 "inweb/foundation-module/Chapter 3/Filenames.w"
void  Filenames__write_unextended_leafname(OUTPUT_STREAM, filename *F) ;
#line 148 "inweb/foundation-module/Chapter 3/Filenames.w"
void  Filenames__write_extension(OUTPUT_STREAM, filename *F) ;
#line 157 "inweb/foundation-module/Chapter 3/Filenames.w"
filename * Filenames__set_extension(filename *F, text_stream *extension) ;
#line 190 "inweb/foundation-module/Chapter 3/Filenames.w"
int  Filenames__guess_format(filename *F) ;
#line 234 "inweb/foundation-module/Chapter 3/Filenames.w"
FILE * Filenames__fopen(filename *F, char *usage) ;
#line 243 "inweb/foundation-module/Chapter 3/Filenames.w"
FILE * Filenames__fopen_caseless(filename *F, char *usage) ;
#line 258 "inweb/foundation-module/Chapter 3/Filenames.w"
int  Filenames__eq(filename *F1, filename *F2) ;
#line 273 "inweb/foundation-module/Chapter 3/Filenames.w"
time_t  Filenames__timestamp(filename *F) ;
#line 283 "inweb/foundation-module/Chapter 3/Filenames.w"
int  Filenames__size(filename *F) ;
#line 298 "inweb/foundation-module/Chapter 3/Filenames.w"
int  Filenames__rename(filename *F, text_stream *new_name) ;
#line 323 "inweb/foundation-module/Chapter 3/Filenames.w"
void  Filenames__copy_file(filename *from, filename *to) ;
#line 340 "inweb/foundation-module/Chapter 3/Filenames.w"
int  Filenames__move_file(filename *from, filename *to) ;
#ifdef PLATFORM_POSIX
#line 50 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
FILE * CIFilingSystem__fopen(const char *path, const char *mode) ;
#endif /* PLATFORM_POSIX */
#line 205 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
char * CIFilingSystem__strrchr(const char *p) ;
#line 225 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
int  CIFilingSystem__match_in_directory(void *vd, 	char *name, char *last_match) ;
#ifndef PLATFORM_POSIX
#line 245 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
FILE * CIFilingSystem__fopen(const char *path, const char *mode) ;
#endif /* PLATFORM_POSIX */
#line 14 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__quote_path(OUTPUT_STREAM, pathname *P) ;
#line 21 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__quote_file(OUTPUT_STREAM, filename *F) ;
#line 28 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__plain(OUTPUT_STREAM, char *raw) ;
#line 32 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__plain_text(OUTPUT_STREAM, text_stream *raw) ;
#line 36 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__quote_text(OUTPUT_STREAM, text_stream *raw) ;
#line 50 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__apply(char *command, filename *F) ;
#line 58 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__apply_S(text_stream *command, filename *F) ;
#line 70 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__rm(filename *F) ;
#line 74 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__copy(filename *F, pathname *T, char *options) ;
#line 89 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__redirect(OUTPUT_STREAM, filename *F) ;
#line 106 "inweb/foundation-module/Chapter 3/Shell.w"
void  Shell__verbose(void) ;
#line 110 "inweb/foundation-module/Chapter 3/Shell.w"
int  Shell__run(OUTPUT_STREAM) ;
#line 19 "inweb/foundation-module/Chapter 3/Directories.w"
scan_directory * Directories__open_from(text_stream *name) ;
#line 27 "inweb/foundation-module/Chapter 3/Directories.w"
scan_directory * Directories__open(pathname *P) ;
#line 35 "inweb/foundation-module/Chapter 3/Directories.w"
int  Directories__next(scan_directory *D, text_stream *leafname) ;
#line 47 "inweb/foundation-module/Chapter 3/Directories.w"
void  Directories__close(scan_directory *D) ;
#line 55 "inweb/foundation-module/Chapter 3/Directories.w"
int  Directories__exists(pathname *P) ;
#line 74 "inweb/foundation-module/Chapter 3/Directories.w"
linked_list * Directories__listing(pathname *P) ;
#line 102 "inweb/foundation-module/Chapter 3/Directories.w"
int  Directories__compare_names(const void *ent1, const void *ent2) ;
#line 114 "inweb/foundation-module/Chapter 3/Directories.w"
int  Directories__rename(pathname *P, text_stream *new_name) ;
#line 13 "inweb/foundation-module/Chapter 3/Time.w"
void  Time__begin(void) ;
#line 26 "inweb/foundation-module/Chapter 3/Time.w"
void  Time__fix(void) ;
#line 35 "inweb/foundation-module/Chapter 3/Time.w"
int  Time__fixed(void) ;
#line 79 "inweb/foundation-module/Chapter 3/Time.w"
void  Time__easter(int year, int *d, int *m) ;
#line 102 "inweb/foundation-module/Chapter 3/Time.w"
int  Time__feast(void) ;
#line 145 "inweb/foundation-module/Chapter 3/Time.w"
stopwatch_timer * Time__start_stopwatch(stopwatch_timer *within, text_stream *name) ;
#line 166 "inweb/foundation-module/Chapter 3/Time.w"
int  Time__stop_stopwatch(stopwatch_timer *st) ;
#line 193 "inweb/foundation-module/Chapter 3/Time.w"
int  Time__compare_watches(const void *w1, const void *w2) ;
#line 208 "inweb/foundation-module/Chapter 3/Time.w"
void  Time__resume_stopwatch(stopwatch_timer *st) ;
#line 220 "inweb/foundation-module/Chapter 3/Time.w"
void  Time__log_timing(stopwatch_timer *st, int total) ;
#line 8 "inweb/foundation-module/Chapter 4/Characters.w"
inchar32_t  Characters__tolower(inchar32_t c) ;
#line 11 "inweb/foundation-module/Chapter 4/Characters.w"
inchar32_t  Characters__toupper(inchar32_t c) ;
#line 14 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__isalpha(inchar32_t c) ;
#line 17 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__isdigit(inchar32_t c) ;
#line 20 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__isupper(inchar32_t c) ;
#line 23 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__islower(inchar32_t c) ;
#line 26 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__isalnum(inchar32_t c) ;
#line 29 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__iscntrl(inchar32_t c) ;
#line 32 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__vowel(inchar32_t c) ;
#line 40 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_space_or_tab(inchar32_t c) ;
#line 44 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_whitespace(inchar32_t c) ;
#line 54 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_babel_whitespace(inchar32_t c) ;
#line 64 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_Unicode_whitespace(inchar32_t c) ;
#line 93 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_ASCII_punctuation(inchar32_t c) ;
#line 106 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_Unicode_punctuation(inchar32_t c) ;
#line 937 "inweb/foundation-module/Chapter 4/Characters.w"
void  Characters__full_Unicode_fold(inchar32_t c, inchar32_t *F) ;
#line 1754 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_ASCII_letter(inchar32_t c) ;
#line 1760 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_ASCII_digit(inchar32_t c) ;
#line 1765 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__is_control_character(inchar32_t c) ;
#line 1778 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__combine_accent(inchar32_t accent, inchar32_t letter) ;
#line 1832 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__make_filename_safe(int charcode) ;
#line 1838 "inweb/foundation-module/Chapter 4/Characters.w"
inchar32_t  Characters__make_wchar_t_filename_safe(inchar32_t charcode) ;
#line 1847 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__remove_accent(int charcode) ;
#line 1874 "inweb/foundation-module/Chapter 4/Characters.w"
inchar32_t  Characters__remove_wchar_t_accent(inchar32_t charcode) ;
#line 1881 "inweb/foundation-module/Chapter 4/Characters.w"
int  Characters__isalphabetic(int letter) ;
#line 25 "inweb/foundation-module/Chapter 4/C Strings.w"
int  CStrings__strlen_unbounded(const char *p) ;
#line 35 "inweb/foundation-module/Chapter 4/C Strings.w"
int  CStrings__check_len(int n) ;
#line 44 "inweb/foundation-module/Chapter 4/C Strings.w"
int  CStrings__len(char *str) ;
#line 55 "inweb/foundation-module/Chapter 4/C Strings.w"
void  CStrings__copy(char *to, char *from) ;
#line 65 "inweb/foundation-module/Chapter 4/C Strings.w"
int  CStrings__eq(char *A, char *B) ;
#line 69 "inweb/foundation-module/Chapter 4/C Strings.w"
int  CStrings__ne(char *A, char *B) ;
#line 76 "inweb/foundation-module/Chapter 4/C Strings.w"
int  CStrings__cmp(char *A, char *B) ;
#line 89 "inweb/foundation-module/Chapter 4/C Strings.w"
void  CStrings__transcode_ISO_string_to_UTF8(char *p, char *dest) ;
#line 110 "inweb/foundation-module/Chapter 4/C Strings.w"
void  CStrings__truncated_strcpy(char *to, char *from, int max) ;
#line 130 "inweb/foundation-module/Chapter 4/C Strings.w"
char * CStrings__park_string(char *from) ;
#line 141 "inweb/foundation-module/Chapter 4/C Strings.w"
void  CStrings__free_ssas(void) ;
#line 11 "inweb/foundation-module/Chapter 4/Wide Strings.w"
int  Wide__len(const inchar32_t *p) ;
#line 20 "inweb/foundation-module/Chapter 4/Wide Strings.w"
int  Wide__cmp(inchar32_t *A, inchar32_t *B) ;
#line 32 "inweb/foundation-module/Chapter 4/Wide Strings.w"
int  Wide__atoi(inchar32_t *p) ;
#line 37 "inweb/foundation-module/Chapter 4/Wide Strings.w"
void  Wide__copy(inchar32_t *to, inchar32_t *from) ;
#line 38 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__new(void) ;
#line 42 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__new_with_capacity(int c) ;
#line 48 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__dispose_of(text_stream *text) ;
#line 57 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__duplicate(text_stream *E) ;
#line 73 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__new_from_wide_string(const inchar32_t *C_string) ;
#line 80 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__new_from_ISO_string(const char *C_string) ;
#line 86 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__new_from_UTF8_string(const char *C_string) ;
#line 92 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__new_from_locale_string(const char *C_string) ;
#line 101 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__from_wide_string(text_stream *S, inchar32_t *c_string) ;
#line 107 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__from_locale_string(text_stream *S, char *c_string) ;
#line 115 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_to_ISO_string(char *C_string, text_stream *S, int buffer_size) ;
#line 119 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_to_UTF8_string(char *C_string, text_stream *S, int buffer_size) ;
#line 123 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_to_wide_string(inchar32_t *C_string, text_stream *S, int buffer_size) ;
#line 127 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_to_locale_string(char *C_string, text_stream *S, int buffer_size) ;
#line 134 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__atoi(text_stream *S, int index) ;
#line 148 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__len(text_stream *S) ;
#line 169 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position  Str__start(text_stream *S) ;
#line 173 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position  Str__at(text_stream *S, int i) ;
#line 179 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position  Str__end(text_stream *S) ;
#line 186 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position  Str__back(string_position P) ;
#line 190 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position  Str__forward(string_position P) ;
#line 194 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position  Str__plus(string_position P, int increment) ;
#line 198 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__width_between(string_position P1, string_position P2) ;
#line 203 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__in_range(string_position P) ;
#line 208 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__index(string_position P) ;
#line 224 "inweb/foundation-module/Chapter 4/String Manipulation.w"
inchar32_t  Str__get(string_position P) ;
#line 229 "inweb/foundation-module/Chapter 4/String Manipulation.w"
inchar32_t  Str__get_at(text_stream *S, int index) ;
#line 234 "inweb/foundation-module/Chapter 4/String Manipulation.w"
inchar32_t  Str__get_first_char(text_stream *S) ;
#line 238 "inweb/foundation-module/Chapter 4/String Manipulation.w"
inchar32_t  Str__get_last_char(text_stream *S) ;
#line 245 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__put(string_position P, inchar32_t C) ;
#line 257 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__put_at(text_stream *S, int index, inchar32_t C) ;
#line 264 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__clear(text_stream *S) ;
#line 268 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__truncate(text_stream *S, int len) ;
#line 276 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__remove_indentation(text_stream *S, int spaces_per_tab) ;
#line 302 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__rectify_indentation(text_stream *S, int spaces_per_tab) ;
#line 315 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__concatenate(text_stream *S1, text_stream *S2) ;
#line 319 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy(text_stream *S1, text_stream *S2) ;
#line 325 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_tail(text_stream *S1, text_stream *S2, int from) ;
#line 336 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_ISO_string(text_stream *S, char *C_string) ;
#line 341 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_UTF8_string(text_stream *S, char *C_string) ;
#line 346 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__copy_wide_string(text_stream *S, inchar32_t *C_string) ;
#line 355 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__eq(text_stream *S1, text_stream *S2) ;
#line 360 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__eq_insensitive(text_stream *S1, text_stream *S2) ;
#line 365 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__ne(text_stream *S1, text_stream *S2) ;
#line 370 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__ne_insensitive(text_stream *S1, text_stream *S2) ;
#line 392 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__cmp(text_stream *S1, text_stream *S2) ;
#line 402 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__cmp_insensitive(text_stream *S1, text_stream *S2) ;
#line 423 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__prefix_eq(text_stream *S1, text_stream *S2, int N) ;
#line 432 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__suffix_eq(text_stream *S1, text_stream *S2, int N) ;
#line 441 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__begins_with(text_stream *S1, text_stream *S2) ;
#line 445 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__ends_with(text_stream *S1, text_stream *S2) ;
#line 449 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__begins_with_wide_string(text_stream *S, inchar32_t *prefix) ;
#line 458 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__ends_with_wide_string(text_stream *S, inchar32_t *suffix) ;
#line 468 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__eq_wide_string(text_stream *S1, inchar32_t *S2) ;
#line 479 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__eq_narrow_string(text_stream *S1, char *S2) ;
#line 490 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__ne_wide_string(text_stream *S1, inchar32_t *S2) ;
#line 497 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__is_whitespace(text_stream *S) ;
#line 507 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__trim_white_space(text_stream *S) ;
#line 536 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__trim_white_space_at_end(text_stream *S) ;
#line 547 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__trim_all_white_space_at_end(text_stream *S) ;
#line 561 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__delete_first_character(text_stream *S) ;
#line 565 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__delete_last_character(text_stream *S) ;
#line 570 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__delete_nth_character(text_stream *S, int n) ;
#line 575 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__delete_n_characters(text_stream *S, int n) ;
#line 588 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void  Str__substr(OUTPUT_STREAM, string_position from, string_position to) ;
#line 594 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__includes_character(text_stream *S, inchar32_t c) ;
#line 602 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__includes_wide_string_at(text_stream *S, inchar32_t *prefix, int j) ;
#line 611 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__includes_wide_string_at_insensitive(text_stream *S, inchar32_t *prefix, int j) ;
#line 620 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__includes(text_stream *S, text_stream *T) ;
#line 635 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__includes_insensitive(text_stream *S, text_stream *T) ;
#line 651 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int  Str__includes_at(text_stream *line, int i, text_stream *pattern) ;
#line 674 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream * Str__literal(inchar32_t *wide_C_string) ;
#line 24 "inweb/foundation-module/Chapter 4/Tab Stops.w"
tabbed_string_iterator  TabbedStr__new(text_stream *line, int tab_spacing) ;
#line 37 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__get_index(tabbed_string_iterator *mdw) ;
#line 41 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__get_position(tabbed_string_iterator *mdw) ;
#line 50 "inweb/foundation-module/Chapter 4/Tab Stops.w"
inchar32_t  TabbedStr__get_character(tabbed_string_iterator *mdw) ;
#line 60 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__at_whole_character(tabbed_string_iterator *mdw) ;
#line 70 "inweb/foundation-module/Chapter 4/Tab Stops.w"
void  TabbedStr__advance(tabbed_string_iterator *mdw) ;
#line 75 "inweb/foundation-module/Chapter 4/Tab Stops.w"
void  TabbedStr__advance_by(tabbed_string_iterator *mdw, int N) ;
#line 84 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__seek(tabbed_string_iterator *mdw, int pos) ;
#line 97 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__eat_space(tabbed_string_iterator *mdw) ;
#line 106 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__eat_spaces(int N, tabbed_string_iterator *mdw) ;
#line 120 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__spaces_available(tabbed_string_iterator *mdw) ;
#line 130 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int  TabbedStr__blank_from_here(tabbed_string_iterator *mdw) ;
#line 20 "inweb/foundation-module/Chapter 4/Text Files.w"
int  TextFiles__exists(filename *F) ;
#line 52 "inweb/foundation-module/Chapter 4/Text Files.w"
int  TextFiles__get_line_count(text_file_position *tfp) ;
#line 60 "inweb/foundation-module/Chapter 4/Text Files.w"
text_file_position  TextFiles__nowhere(void) ;
#line 70 "inweb/foundation-module/Chapter 4/Text Files.w"
text_file_position  TextFiles__at(filename *F, int line) ;
#line 84 "inweb/foundation-module/Chapter 4/Text Files.w"
int  TextFiles__read(filename *F, int escape_oddities, char *message, int serious, 	void (iterator)(text_stream *, text_file_position *, void *), 	text_file_position *start_at, void *state) ;
#line 177 "inweb/foundation-module/Chapter 4/Text Files.w"
void  TextFiles__read_line(OUTPUT_STREAM, int escape_oddities, text_file_position *tfp) ;
#line 201 "inweb/foundation-module/Chapter 4/Text Files.w"
void  TextFiles__lose_interest(text_file_position *tfp) ;
#line 239 "inweb/foundation-module/Chapter 4/Text Files.w"
unicode_file_buffer  TextFiles__create_ufb(void) ;
#line 246 "inweb/foundation-module/Chapter 4/Text Files.w"
unicode_file_buffer  TextFiles__create_filtered_ufb(int mode) ;
#line 252 "inweb/foundation-module/Chapter 4/Text Files.w"
int  TextFiles__utf8_fgetc(FILE *from, const char **or_from, unicode_file_buffer *ufb) ;
#line 344 "inweb/foundation-module/Chapter 4/Text Files.w"
int  TextFiles__write_file_contents(OUTPUT_STREAM, filename *F) ;
#line 349 "inweb/foundation-module/Chapter 4/Text Files.w"
void  TextFiles__write_file_contents_helper(text_stream *text, text_file_position *tfp, 	void *state) ;
#line 28 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__preprocess(filename *prototype, filename *F, text_stream *header, 	linked_list *special_macros, general_pointer specifics, inchar32_t comment_char, 	int encoding) ;
#line 95 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__set_loop_var_name(preprocessor_loop *loop, text_stream *name) ;
#line 98 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__add_loop_iteration(preprocessor_loop *loop, text_stream *value) ;
#line 110 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__scan_line(text_stream *line, text_file_position *tfp, void *X) ;
#line 218 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__expand(text_stream *text, text_file_position *tfp, preprocessor_state *PPS) ;
#line 457 "inweb/foundation-module/Chapter 4/Preprocessor.w"
int  Preprocessor__acceptable_variable_name(text_stream *name) ;
#line 477 "inweb/foundation-module/Chapter 4/Preprocessor.w"
text_stream * Preprocessor__read_variable(preprocessor_variable *var) ;
#line 481 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__write_variable(preprocessor_variable *var, text_stream *val) ;
#line 497 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_variable_set * Preprocessor__new_variable_set(preprocessor_variable_set *outer) ;
#line 504 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_variable * Preprocessor__find_variable_in_one(text_stream *name, 	preprocessor_variable_set *set) ;
#line 514 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_variable * Preprocessor__find_variable(text_stream *name, 	preprocessor_variable_set *set) ;
#line 528 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_variable * Preprocessor__ensure_variable(text_stream *name, 	preprocessor_variable_set *in_set) ;
#line 605 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_macro * Preprocessor__new_macro(linked_list *L, text_stream *name, 	text_stream *parameter_specification, 	void (*expander)(preprocessor_macro *, preprocessor_state *, text_stream **, preprocessor_loop *, text_file_position *), 	text_file_position *tfp) ;
#line 665 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__add_line_to_macro(preprocessor_macro *mm, text_stream *line, 	text_file_position *tfp) ;
#line 683 "inweb/foundation-module/Chapter 4/Preprocessor.w"
linked_list * Preprocessor__list_of_reserved_macros(linked_list *special_macros) ;
#line 696 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__do_not_suppress_whitespace(preprocessor_macro *mm) ;
#line 701 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__new_loop_macro(linked_list *L, text_stream *name, 	text_stream *parameter_specification, 	void (*expander)(preprocessor_macro *, preprocessor_state *, text_stream **, preprocessor_loop *, text_file_position *), 	text_file_position *tfp) ;
#line 740 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_macro * Preprocessor__find_macro(linked_list *L, text_stream *name) ;
#line 755 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__default_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 772 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__set_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 787 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__repeat_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 816 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void  Preprocessor__end_loop_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 77 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
inchar32_t * Tries__search(match_trie *T, text_stream *p, inchar32_t *add_outcome) ;
#line 237 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
int  Tries__matches(match_trie *pos, inchar32_t c) ;
#line 257 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
int  Tries__is_ambiguous(match_trie *pos) ;
#line 267 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
match_trie * Tries__new(int mc) ;
#line 293 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
match_avinue * Tries__new_avinue(int from_start) ;
#line 300 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
void  Tries__add_to_avinue(match_avinue *mt, text_stream *from, inchar32_t *to) ;
#line 309 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
match_avinue * Tries__duplicate_avinue(match_avinue *A) ;
#line 327 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
inchar32_t * Tries__search_avinue(match_avinue *T, text_stream *p) ;
#line 339 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
void  Tries__log_avinue(OUTPUT_STREAM, void *vA) ;
#line 352 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
void  Tries__log(OUTPUT_STREAM, match_trie *T) ;
#line 10 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__white_space(inchar32_t c) ;
#line 20 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__identifier_char(inchar32_t c) ;
#line 35 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__find_expansion(text_stream *text, inchar32_t on1, inchar32_t on2, 	inchar32_t off1, inchar32_t off2, int *len) ;
#line 51 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__find_open_brace(text_stream *text) ;
#line 62 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__string_is_white_space(text_stream *text) ;
#line 144 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
match_results  Regexp__create_mr(void) ;
#line 154 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
void  Regexp__dispose_of(match_results *mr) ;
#line 168 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__match(match_results *mr, text_stream *text, inchar32_t *pattern) ;
#line 175 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__match_from(match_results *mr, text_stream *text, inchar32_t *pattern, 	int x, int allow_partial) ;
#line 191 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
void  Regexp__prepare(match_results *mr) ;
#line 207 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__match_r(match_results *mr, text_stream *text, inchar32_t *pattern, 	match_position *scan_from, int allow_partial) ;
#line 338 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__get_cclass(inchar32_t *pattern, int ppos, int *len, int *from, int *to, int *reverse) ;
#line 368 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__test_cclass(inchar32_t c, int chcl, int range_from, int range_to, inchar32_t *drawn_from, int reverse) ;
#line 415 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int  Regexp__replace(text_stream *text, inchar32_t *pattern, inchar32_t *replacement, int options) ;
#line 47 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__write_type(OUTPUT_STREAM, int t) ;
#line 80 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_null(void) ;
#line 94 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_boolean(int b) ;
#line 102 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_number(int b) ;
#line 109 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_double(double d) ;
#line 116 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_string(text_stream *S) ;
#line 127 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_array(void) ;
#line 134 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__add_to_array(JSON_value *array, JSON_value *new_entry) ;
#line 148 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__new_object(void) ;
#line 156 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__add_to_object(JSON_value *obj, text_stream *key, JSON_value *value) ;
#line 173 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__look_up_object(JSON_value *obj, text_stream *key) ;
#line 185 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__change_object(JSON_value *obj, text_stream *key, JSON_value *val) ;
#line 198 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__error(text_stream *msg) ;
#line 209 "inweb/foundation-module/Chapter 4/JSON.w"
int  JSON__eq(JSON_value *val1, JSON_value *val2) ;
#line 233 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode(text_stream *T, text_file_position *tfp) ;
#line 237 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_error(text_stream *err, text_file_position *tfp) ;
#line 246 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_error_q(text_stream *err, text_file_position *tfp, 	text_stream *T, int from, int to) ;
#line 272 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_range(text_stream *T, int from, int to, text_file_position *tfp) ;
#line 319 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_array(JSON_value *array, text_stream *T, int from, int to, 	text_file_position *tfp) ;
#line 347 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_array_entry(JSON_value *array, text_stream *T, int from, int to, 	text_file_position *tfp) ;
#line 356 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_object(JSON_value *obj, text_stream *T, int from, int to, 	text_file_position *tfp) ;
#line 392 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_object_entry(JSON_value *obj, text_stream *T, int from, int to, 	text_file_position *tfp) ;
#line 430 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_number(text_stream *T, int from, int to, text_file_position *tfp) ;
#line 467 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value * JSON__decode_string(text_stream *T, int from, int to, text_file_position *tfp) ;
#line 519 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__encode(OUTPUT_STREAM, JSON_value *J) ;
#line 579 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__encode_string(OUTPUT_STREAM, text_stream *T) ;
#line 612 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__single_choice(JSON_single_requirement *sing) ;
#line 619 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__add_alternative(JSON_requirement *so_far, 	JSON_single_requirement *sing) ;
#line 642 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__require_requirement(JSON_requirement *req) ;
#line 650 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__require_value(JSON_value *value) ;
#line 658 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__require_type(int t) ;
#line 688 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_type * JSON__new_type_requirement(int t) ;
#line 716 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__require_array_of(JSON_requirement *E_req) ;
#line 727 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__require_entry(JSON_single_requirement *array_sr, JSON_requirement *entry_sr) ;
#line 739 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__require_pair(JSON_single_requirement *obj_sr, text_stream *key, JSON_requirement *req) ;
#line 743 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__allow_pair(JSON_single_requirement *obj_sr, text_stream *key, JSON_requirement *req) ;
#line 747 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__require_pair_inner(JSON_single_requirement *obj_sr, text_stream *key, 	JSON_requirement *req, int opt) ;
#line 766 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_pair_requirement * JSON__look_up_pair(JSON_single_requirement *obj_sr, text_stream *key) ;
#line 779 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__error_sr(text_stream *msg) ;
#line 797 "inweb/foundation-module/Chapter 4/JSON.w"
int  JSON__validate(JSON_value *val, JSON_requirement *req, linked_list *errs) ;
#line 808 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__validation_error(linked_list *errs, text_stream *err, lifo_stack *location) ;
#line 831 "inweb/foundation-module/Chapter 4/JSON.w"
int  JSON__validate_r(JSON_value *val, JSON_requirement *req, linked_list *errs, 	lifo_stack *location) ;
#line 850 "inweb/foundation-module/Chapter 4/JSON.w"
int  JSON__validate_single_r(JSON_value *val, JSON_single_requirement *req, 	linked_list *errs, lifo_stack *location) ;
#line 1000 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__decode_req(text_stream *T, dictionary *known_names) ;
#line 1008 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__decode_req_range(text_stream *T, int from, int to, 	dictionary *known_names) ;
#line 1041 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__decode_req_alternative(JSON_requirement *req, text_stream *T, 	int from, int to, dictionary *known_names) ;
#line 1053 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__decode_sreq_range(text_stream *T, int from, int to, 	dictionary *known_names) ;
#line 1140 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__decode_req_array(JSON_single_requirement *array_sr, 	text_stream *T, int from, int to, dictionary *known_names) ;
#line 1173 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__decode_req_array_entry(JSON_single_requirement *array_sr, 	text_stream *T, int from, int to, dictionary *known_names) ;
#line 1183 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__decode_req_object(JSON_single_requirement *obj, 	text_stream *T, int from, int to, dictionary *known_names) ;
#line 1211 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement * JSON__decode_req_object_entry(JSON_single_requirement *obj, 	text_stream *T, int from, int to, dictionary *known_names) ;
#line 1259 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__encode_req(OUTPUT_STREAM, JSON_requirement *req) ;
#line 1263 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__encode_req_r(OUTPUT_STREAM, JSON_requirement *req) ;
#line 1276 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__encode_sreq_r(OUTPUT_STREAM, JSON_single_requirement *sing) ;
#line 1282 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__encode_type(OUTPUT_STREAM, JSON_type *type) ;
#line 1359 "inweb/foundation-module/Chapter 4/JSON.w"
dictionary * JSON__read_requirements_file(dictionary *known, filename *F) ;
#line 1371 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__read_requirements_file_helper(text_stream *text, text_file_position *tfp, 	void *v_state) ;
#line 1395 "inweb/foundation-module/Chapter 4/JSON.w"
void  JSON__process_req_defn(JSON_rrf_state *state) ;
#line 1408 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__decode_printing_errors(text_stream *defn, dictionary *dict, 	text_file_position *tfp) ;
#line 1427 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement * JSON__look_up_requirements(dictionary *known, text_stream *name) ;
#line 8 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__header(OUTPUT_STREAM, text_stream *title, filename *css1, filename *css2, 	filename *js1, filename *js2, void *state) ;
#line 25 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__footer(OUTPUT_STREAM) ;
#line 64 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__declare_as_HTML(OUTPUT_STREAM, int XHTML) ;
#line 87 "inweb/foundation-module/Chapter 5/HTML.w"
int  HTML__push_tag(OUTPUT_STREAM, char *tag, char *fn, int lc) ;
#line 102 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__pop_tag(OUTPUT_STREAM, char *tag, char *fn, int lc) ;
#line 122 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__completed(OUTPUT_STREAM) ;
#line 154 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__tag(OUTPUT_STREAM, char *tag, text_stream *details) ;
#line 163 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__tag_sc(OUTPUT_STREAM, char *tag, text_stream *details) ;
#line 170 "inweb/foundation-module/Chapter 5/HTML.w"
int  HTML__tag_formatting(char *tag) ;
#line 179 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__open(OUTPUT_STREAM, char *tag, text_stream *details, char *fn, int lc) ;
#line 188 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__close(OUTPUT_STREAM, char *tag, char *fn, int lc) ;
#line 197 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__open_indented_p(OUTPUT_STREAM, int depth, char *class) ;
#line 205 "inweb/foundation-module/Chapter 5/HTML.w"
int  HTML__pair_formatting(char *tag) ;
#line 227 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_head(OUTPUT_STREAM, filename *CSS_file) ;
#line 245 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_head(OUTPUT_STREAM) ;
#line 250 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__title(OUTPUT_STREAM, text_stream *title) ;
#line 259 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__open_javascript(OUTPUT_STREAM, int define_project) ;
#line 268 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__close_javascript(OUTPUT_STREAM) ;
#line 274 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_javascript(OUTPUT_STREAM, int define_project, filename *M) ;
#line 294 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_javascript_from_file(OUTPUT_STREAM, filename *M) ;
#line 301 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__open_CSS(OUTPUT_STREAM) ;
#line 306 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__close_CSS(OUTPUT_STREAM) ;
#line 311 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_CSS(OUTPUT_STREAM, filename *M) ;
#line 329 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_CSS_from_file(OUTPUT_STREAM, filename *M) ;
#line 336 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_HTML(OUTPUT_STREAM, filename *M) ;
#line 352 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_HTML_from_file(OUTPUT_STREAM, filename *M) ;
#line 360 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__incorporate_helper(text_stream *line_of_template, 	text_file_position *tfp, void *OUT) ;
#line 368 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_body(OUTPUT_STREAM, text_stream *class) ;
#line 373 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_body(OUTPUT_STREAM) ;
#line 381 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_div_with_id(OUTPUT_STREAM, char *id) ;
#line 385 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_div_with_class(OUTPUT_STREAM, char *cl) ;
#line 389 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_div_with_class_and_id(OUTPUT_STREAM, char *cl, char *id, int hide) ;
#line 394 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_div_with_id_S(OUTPUT_STREAM, text_stream *id, char *fn, int lc) ;
#line 401 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_div_with_class_S(OUTPUT_STREAM, text_stream *cl, char *fn, int lc) ;
#line 408 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_div_with_class_and_id_S(OUTPUT_STREAM, text_stream *cl, 	text_stream *id, int hide, char *fn, int lc) ;
#line 417 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_div(OUTPUT_STREAM) ;
#line 424 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__image(OUTPUT_STREAM, filename *F) ;
#line 428 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__image_to_dimensions(OUTPUT_STREAM, filename *F, int w, int h) ;
#line 449 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__icon_with_tooltip(OUTPUT_STREAM, text_stream *icon_name, 	text_stream *tip, text_stream *tip2) ;
#line 465 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__anchor(OUTPUT_STREAM, text_stream *id) ;
#line 469 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__anchor_with_class(OUTPUT_STREAM, text_stream *id, text_stream *cl) ;
#line 473 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_link(OUTPUT_STREAM, text_stream *to) ;
#line 477 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_download_link(OUTPUT_STREAM, text_stream *to) ;
#line 481 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_link_with_class(OUTPUT_STREAM, text_stream *cl, text_stream *to) ;
#line 485 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_link_with_class_title(OUTPUT_STREAM, text_stream *cl, text_stream *to, text_stream *ti) ;
#line 489 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_link_with_class_onclick(OUTPUT_STREAM, text_stream *cl, text_stream *to, text_stream *on) ;
#line 493 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_link_with_class_title_onclick(OUTPUT_STREAM, text_stream *cl, text_stream *to, text_stream *ti, text_stream *on) ;
#line 500 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_link(OUTPUT_STREAM) ;
#line 509 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__set_link_abbreviation_path(pathname *P) ;
#line 512 "inweb/foundation-module/Chapter 5/HTML.w"
pathname * HTML__get_link_abbreviation_path(void) ;
#line 520 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_plain_html_table(OUTPUT_STREAM) ;
#line 524 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_wide_html_table(OUTPUT_STREAM) ;
#line 531 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_html_table(OUTPUT_STREAM, text_stream *classname, int full_width, 	int border, int cellspacing, int cellpadding, int height, int width) ;
#line 543 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_html_table_bg(OUTPUT_STREAM, text_stream *classname, int full_width, 	int border, int cellspacing, int cellpadding, int height, int width, text_stream *bg) ;
#line 556 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__first_html_column(OUTPUT_STREAM, int width) ;
#line 561 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__first_html_column_nowrap(OUTPUT_STREAM, int width, text_stream *classname) ;
#line 572 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__first_html_column_spaced(OUTPUT_STREAM, int width) ;
#line 580 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__first_html_column_coloured(OUTPUT_STREAM, int width, text_stream *classname, 	int cs) ;
#line 593 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column(OUTPUT_STREAM, int width) ;
#line 599 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_centred(OUTPUT_STREAM, int width) ;
#line 605 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_spanning(OUTPUT_STREAM, int width, int sp) ;
#line 611 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_nowrap(OUTPUT_STREAM, int width) ;
#line 617 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_spaced(OUTPUT_STREAM, int width) ;
#line 623 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_nw(OUTPUT_STREAM, int width) ;
#line 629 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_w(OUTPUT_STREAM, int width) ;
#line 635 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__next_html_column_right_justified(OUTPUT_STREAM, int width) ;
#line 640 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_html_row(OUTPUT_STREAM) ;
#line 644 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_html_table(OUTPUT_STREAM) ;
#line 655 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__open_coloured_box(OUTPUT_STREAM, text_stream *classname, int rounding) ;
#line 663 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__close_coloured_box(OUTPUT_STREAM, text_stream *classname, int rounding) ;
#line 669 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__box_corner(OUTPUT_STREAM, text_stream *classname, text_stream *corner) ;
#line 679 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__comment(OUTPUT_STREAM, text_stream *text) ;
#line 683 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__heading(OUTPUT_STREAM, char *tag, text_stream *text) ;
#line 690 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__hr(OUTPUT_STREAM, char *class) ;
#line 855 "inweb/foundation-module/Chapter 5/HTML.w"
inchar32_t * HTML__translate_colour_name(inchar32_t *original) ;
#line 863 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_colour(OUTPUT_STREAM, text_stream *col) ;
#line 866 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_colour(OUTPUT_STREAM) ;
#line 873 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__begin_span(OUTPUT_STREAM, text_stream *class_name) ;
#line 880 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__end_span(OUTPUT_STREAM) ;
#line 888 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__write_xml_safe_text(OUTPUT_STREAM, text_stream *txt) ;
#line 919 "inweb/foundation-module/Chapter 5/HTML.w"
void  HTML__put(OUTPUT_STREAM, inchar32_t charcode) ;
#line 16 "inweb/foundation-module/Chapter 5/HTML Entities.w"
int  HTMLEntities__parse(text_stream *entity, inchar32_t *A, inchar32_t *B) ;
#line 57 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_tracing(int state) ;
#line 99 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse(text_stream *text) ;
#line 103 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_using(text_stream *text, md_links_dictionary *dict) ;
#line 107 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_block_structure(text_stream *text) ;
#line 111 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_block_structure_using(text_stream *text, 	md_links_dictionary *dict) ;
#line 116 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_inline(text_stream *text) ;
#line 120 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_inline_using(text_stream *text, md_links_dictionary *dict) ;
#line 124 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_all_blocks_inline(markdown_item *tree, text_stream *text) ;
#line 128 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_all_blocks_inline_using(markdown_item *tree, 	text_stream *text, md_links_dictionary *dict) ;
#line 133 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_extended(text_stream *text, markdown_variation *variation) ;
#line 137 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_using_extended(text_stream *text, md_links_dictionary *dict, 	markdown_variation *variation) ;
#line 142 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_block_structure_extended(text_stream *text, 	markdown_variation *variation) ;
#line 147 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_block_structure_using_extended(text_stream *text, 	md_links_dictionary *dict, markdown_variation *variation) ;
#line 152 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_inline_extended(text_stream *text, 	markdown_variation *variation) ;
#line 157 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_inline_using_extended(text_stream *text, 	md_links_dictionary *dict, markdown_variation *variation) ;
#line 162 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_all_blocks_inline_extended(markdown_item *tree, 	text_stream *text, markdown_variation *variation) ;
#line 167 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_all_blocks_inline_using_extended(markdown_item *tree, 	text_stream *text, md_links_dictionary *dict, markdown_variation *variation) ;
#line 176 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__parse_general(markdown_item *tree, text_stream *text, 	md_links_dictionary *dict, int phase_I, int phase_II, markdown_variation *variation) ;
#line 253 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__render(OUTPUT_STREAM, markdown_item *tree) ;
#line 257 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__render_extended(OUTPUT_STREAM, markdown_item *tree, 	markdown_variation *variation) ;
#line 349 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__new_item_type(int mit, text_stream *name) ;
#line 358 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__new_container_block_type(int mit, text_stream *name) ;
#line 364 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__new_leaf_block_type(int mit, text_stream *name) ;
#line 369 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__new_inline_type(int mit, text_stream *name) ;
#line 374 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__new_plainish_inline_type(int mit, text_stream *name) ;
#line 381 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__new_quasiplainish_inline_type(int mit, text_stream *name) ;
#line 387 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__create_item_types(void) ;
#line 433 "inweb/foundation-module/Chapter 5/Markdown.w"
text_stream * Markdown__item_type_name(int t) ;
#line 438 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__item_type_container_block(int t) ;
#line 443 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__item_type_leaf_block(int t) ;
#line 452 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__item_type_inline(int t) ;
#line 460 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__plainish(markdown_item *md) ;
#line 465 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__item_type_plainish(int t) ;
#line 473 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__quasi_plainish(markdown_item *md) ;
#line 478 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__item_type_quasi_plainish(int t) ;
#line 519 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__new_item(int type) ;
#line 546 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__deep_copy(markdown_item *md) ;
#line 565 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__add_to(markdown_item *md, markdown_item *owner) ;
#line 575 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_heading_level(markdown_item *md) ;
#line 580 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_heading_level(markdown_item *md, int L) ;
#line 589 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_column_count(markdown_item *md) ;
#line 594 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_column_count(markdown_item *md, int L) ;
#line 603 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_alignment(markdown_item *md) ;
#line 608 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_alignment(markdown_item *md, int L) ;
#line 617 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_filtered_state(markdown_item *md) ;
#line 622 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_filtered_state(markdown_item *md, int L) ;
#line 628 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__tag_should_be_filtered(text_stream *tag) ;
#line 644 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_add_protocol_state(markdown_item *md) ;
#line 651 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_add_protocol_state(markdown_item *md, int L) ;
#line 662 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_tick_state(markdown_item *md) ;
#line 667 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_tick_state(markdown_item *md, int L) ;
#line 677 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_backtick_count(markdown_item *md) ;
#line 682 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_backtick_count(markdown_item *md, int L) ;
#line 691 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__get_item_number(markdown_item *md) ;
#line 697 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t  Markdown__get_item_flavour(markdown_item *md) ;
#line 708 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__set_item_number_and_flavour(markdown_item *md, int L, inchar32_t f) ;
#line 728 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t  Markdown__get_unescaped(md_charpos pos, int offset) ;
#line 741 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__unescaped_run(md_charpos pos, inchar32_t of) ;
#line 751 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__new_file_marker(filename *F) ;
#line 757 "inweb/foundation-module/Chapter 5/Markdown.w"
filename * Markdown__get_filename(markdown_item *md) ;
#line 769 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item * Markdown__new_slice(int type, text_stream *text, int from, int to) ;
#line 783 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t  Markdown__get_at(markdown_item *md, int at) ;
#line 794 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__width(markdown_item *md) ;
#line 833 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__nowhere(void) ;
#line 840 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__pos(markdown_item *md, int at) ;
#line 848 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__somewhere(md_charpos pos) ;
#line 856 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__pos_eq(md_charpos A, md_charpos B) ;
#line 867 "inweb/foundation-module/Chapter 5/Markdown.w"
int  Markdown__is_in(md_charpos pos, markdown_item *md) ;
#line 879 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__left_edge_of(markdown_item *md) ;
#line 889 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__advance(md_charpos pos) ;
#line 902 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__advance_plainish_only(md_charpos pos) ;
#line 914 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__advance_quasi_plainish_only(md_charpos pos) ;
#line 926 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__advance_up_to(md_charpos pos, md_charpos end) ;
#line 933 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__advance_up_to_plainish_only(md_charpos pos, md_charpos end) ;
#line 940 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos  Markdown__advance_up_to_quasi_plainish_only(md_charpos pos, md_charpos end) ;
#line 950 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t  Markdown__get(md_charpos pos) ;
#line 954 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t  Markdown__get_offset(md_charpos pos, int by) ;
#line 959 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__put(md_charpos pos, inchar32_t c) ;
#line 963 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__put_offset(md_charpos pos, int by, inchar32_t c) ;
#line 976 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__cut_to_just_before(markdown_item *chain_from, md_charpos cut_point, 	markdown_item **left_segment, markdown_item **right_segment) ;
#line 1006 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__cut_to_just_at(markdown_item *chain_from, md_charpos cut_point, 	markdown_item **left_segment, markdown_item **right_segment) ;
#line 1036 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__cut_interval(markdown_item *chain_from, md_charpos A, md_charpos B, 	markdown_item **left_segment, markdown_item **middle_segment, markdown_item **right_segment) ;
#line 1061 "inweb/foundation-module/Chapter 5/Markdown.w"
md_links_dictionary * Markdown__new_links_dictionary(void) ;
#line 1074 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__create(md_links_dictionary *dict, text_stream *label, 	text_stream *destination, text_stream *title) ;
#line 1097 "inweb/foundation-module/Chapter 5/Markdown.w"
md_link_dictionary_entry * Markdown__look_up(md_links_dictionary *dict, text_stream *label) ;
#line 1118 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__normalise_link_label(text_stream *label) ;
#line 1141 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_char(OUTPUT_STREAM, inchar32_t c) ;
#line 1152 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_char_briefly(OUTPUT_STREAM, inchar32_t c) ;
#line 1162 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_pos(OUTPUT_STREAM, md_charpos A) ;
#line 1171 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_interval(OUTPUT_STREAM, md_charpos A, md_charpos B) ;
#line 1186 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_item(OUTPUT_STREAM, markdown_item *md) ;
#line 1231 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_subtree(OUTPUT_STREAM, markdown_item *md) ;
#line 1236 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_chain(OUTPUT_STREAM, markdown_item *md) ;
#line 1240 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_chain_label(OUTPUT_STREAM, markdown_item *md, text_stream *label) ;
#line 1257 "inweb/foundation-module/Chapter 5/Markdown.w"
void  Markdown__debug_item_r(OUTPUT_STREAM, markdown_item *md) ;
#line 77 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
md_doc_state * MDBlockParser__initialise(markdown_variation *variation, 	markdown_item *head, md_links_dictionary *dict) ;
#line 123 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
markdown_item * MDBlockParser__latest_paragraph(md_doc_state *state) ;
#line 127 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
markdown_item * MDBlockParser__latest_HTML_block(md_doc_state *state) ;
#line 131 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
markdown_item * MDBlockParser__latest_code_block(md_doc_state *state) ;
#line 134 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
markdown_item * MDBlockParser__latest_receiver(md_doc_state *state, int type) ;
#line 146 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__make_receiver(md_doc_state *state, markdown_item *block) ;
#line 157 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__remove_receiver(md_doc_state *state, markdown_item *block) ;
#line 189 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__clear_fencing_data(md_doc_state *state) ;
#line 200 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__clear_HTML_data(md_doc_state *state) ;
#line 241 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__clear_marker(positional_marker *marker) ;
#line 265 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__impose_marker_limit(md_doc_state *state, int limit) ;
#line 269 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__lift_marker_limit(md_doc_state *state) ;
#line 278 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
positional_marker * MDBlockParser__new_marker_at(md_doc_state *state, int position, int type) ;
#line 293 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
positional_marker * MDBlockParser__marker_at(md_doc_state *state, int position) ;
#line 303 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__debug_positional_stack(OUTPUT_STREAM, 	md_doc_state *state) ;
#line 314 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__debug_marker(OUTPUT_STREAM, positional_marker *marker, int in_full) ;
#line 337 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
tabbed_string_iterator  MDBlockParser__block_quote_marker(tabbed_string_iterator line_scanner) ;
#line 346 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
tabbed_string_iterator  MDBlockParser__bullet_list_marker(tabbed_string_iterator line_scanner, 	inchar32_t *flavour) ;
#line 365 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
tabbed_string_iterator  MDBlockParser__ordered_list_marker(tabbed_string_iterator line_scanner, 	int *v, inchar32_t *flavour) ;
#line 394 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__thematic_marker(text_stream *line, int index) ;
#line 427 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__parse_positional_markers(md_doc_state *state, tabbed_string_iterator *line_scanner) ;
#line 595 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
positional_marker * MDBlockParser__innermost_marker(md_doc_state *state) ;
#line 600 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__marker_is_list_entry(positional_marker *marker) ;
#line 608 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__marker_is_new_list_entry(positional_marker *marker) ;
#line 624 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__change_type(md_doc_state *state, markdown_item *block, int t) ;
#line 642 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__mark_block_with_ws(md_doc_state *state, markdown_item *block) ;
#line 657 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__open_block(md_doc_state *state, markdown_item *block) ;
#line 665 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__close_block(md_doc_state *state, markdown_item *at) ;
#line 688 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__turn_over_a_new_leaf(md_doc_state *state, markdown_item *block) ;
#line 699 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__container_will_change(md_doc_state *state) ;
#line 729 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__add_to_document(md_doc_state *state, text_stream *line) ;
#line 1507 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__can_interpret_as(md_doc_state *state, text_stream *line, 	int indentation, int content_index, int which, text_stream *text_details, int *int_detail) ;
#line 1922 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__advance_past_spacing(text_stream *tag, int i) ;
#line 1940 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__remove_link_references(md_doc_state *state, markdown_item *at) ;
#line 2106 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__count_cells(text_stream *line, int is_delimiter_row, 	markdown_item *table_item) ;
#line 2191 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__gather_lists(md_doc_state *state, markdown_item *at) ;
#line 2210 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int  MDBlockParser__in_same_list(markdown_item *A, markdown_item *B) ;
#line 2224 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__propagate_white_space_follows(md_doc_state *state, markdown_item *at) ;
#line 2244 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void  MDBlockParser__task_list_items(md_doc_state *state, markdown_item *at) ;
#line 14 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
void  MDInlineParser__inline_recursion(markdown_variation *variation, 	md_links_dictionary *link_refs, markdown_item *at) ;
#line 53 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
markdown_item * MDInlineParser__inline(markdown_variation *variation, 	md_links_dictionary *link_refs, text_stream *text) ;
#line 69 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
markdown_item * MDInlineParser__make_inline_chain(markdown_variation *variation, 	markdown_item *owner, text_stream *text) ;
#line 107 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__backtick_string(text_stream *text, int at) ;
#line 559 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__extended_autolink_domain_char(inchar32_t c) ;
#line 568 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__extended_autolink_email_char(inchar32_t c) ;
#line 576 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__extended_autolink_xmpp_resource_char(inchar32_t c) ;
#line 585 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__extended_autolink_trailing_punctuation_char(inchar32_t c) ;
#line 824 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
void  MDInlineParser__links_and_images(markdown_variation *variation, 	md_links_dictionary *link_refs, markdown_item *owner, int images_only) ;
#line 960 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
md_link_parse  MDInlineParser__first_valid_link(markdown_variation *variation, 	md_links_dictionary *link_refs, md_charpos from, md_charpos to, 	int images_only, int links_only) ;
#line 1274 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
void  MDInlineParser__emphasis(markdown_variation *variation, markdown_item *owner, 	int mask) ;
#line 1304 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__delimiter_run(md_charpos pos, int mask) ;
#line 1335 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__left_flanking(md_charpos pos, int count) ;
#line 1347 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__right_flanking(md_charpos pos, int count) ;
#line 1362 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__can_open_emphasis(md_charpos pos, int count) ;
#line 1371 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__can_close_emphasis(md_charpos pos, int count) ;
#line 1676 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int  MDInlineParser__penalty(markdown_item *md) ;
#line 25 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void  MDRenderer__render_extended(OUTPUT_STREAM, markdown_item *md, 	markdown_variation *variation) ;
#line 33 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void  MDRenderer__recurse(OUTPUT_STREAM, markdown_item *md, int mode, 	markdown_variation *variation) ;
#line 388 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void  MDRenderer__slice(OUTPUT_STREAM, markdown_item *md, int mode) ;
#line 430 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void  MDRenderer__char(OUTPUT_STREAM, inchar32_t c, int mode) ;
#line 484 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void  MDRenderer__hex_digit(OUTPUT_STREAM, unsigned int x) ;
#line 15 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__start(void) ;
#line 24 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_variation * MarkdownVariations__CommonMark(void) ;
#line 28 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_variation * MarkdownVariations__GitHub_flavored_Markdown(void) ;
#line 48 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_variation * MarkdownVariations__new(text_stream *name) ;
#line 58 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__add_feature(markdown_variation *variation, int feature_id) ;
#line 62 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__remove_feature(markdown_variation *variation, int feature_id) ;
#line 66 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__copy_features_of(markdown_variation *to, markdown_variation *from) ;
#line 83 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_feature * MarkdownVariations__new_feature(text_stream *name, int id) ;
#line 98 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
int  MarkdownVariations__supports(markdown_variation *variation, int feature_id) ;
#line 148 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__define_CommonMark(void) ;
#line 173 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__make_baseline_features_active(markdown_variation *variation) ;
#line 214 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__define_GFM(void) ;
#line 225 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__make_GitHub_features_active(markdown_variation *variation) ;
#line 244 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
int  MarkdownVariations__intervene_in_rendering(markdown_variation *variation, 	text_stream *OUT, markdown_item *md, int mode) ;
#line 268 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__intervene_after_Phase_I(markdown_variation *variation, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 277 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__intervene_after_Phase_II(markdown_variation *variation, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 297 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
int  MarkdownVariations__multifile_mode(markdown_variation *variation, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 334 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void  MarkdownVariations__multifile_r(markdown_item *md, md_links_dictionary *link_references, 	markdown_item *headings[7], markdown_item *file_item) ;
#line 386 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
text_stream * MarkdownVariations__URL_for_heading(markdown_item *md) ;
#line 12 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_variation * InformFlavouredMarkdown__variation(void) ;
#line 53 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_item * InformFlavouredMarkdown__error_item(text_stream *text) ;
#line 59 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__render_errors(markdown_feature *feature, text_stream *OUT, 	markdown_item *md, int mode) ;
#line 94 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__OIH_intervene_after_Phase_I(markdown_feature *feature, 	markdown_item *md, md_links_dictionary *link_references) ;
#line 143 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__Inform_headings_intervene_after_Phase_I(markdown_feature *feature, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 155 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__Inform_headings_r(markdown_item *md) ;
#line 183 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__number_headings_r(markdown_item *md, 	int *section_number, int *chapter_number, text_stream *latest, int level) ;
#line 223 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_item * InformFlavouredMarkdown__find_section(markdown_item *tree, text_stream *name) ;
#line 230 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__find_s(markdown_item *md, text_stream *name, markdown_item **result) ;
#line 254 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__render_descriptive_headings(markdown_feature *feature, 	text_stream *OUT, markdown_item *md, int mode) ;
#line 317 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__EE_intervene_after_Phase_I(markdown_feature *feature, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 324 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__detect_embedded_examples_r(markdown_item *md, int *example_number) ;
#line 361 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__regroup_examples_r(markdown_item *md, int *example_number) ;
#line 388 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_item * InformFlavouredMarkdown__find_example(markdown_item *tree, int eg) ;
#line 396 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__find_e(markdown_item *md, int eg, markdown_item **result, 	int *counter) ;
#line 424 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
IFM_example * InformFlavouredMarkdown__new_example(text_stream *title, text_stream *desc, 	int star_count, int ecount) ;
#line 445 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__EE_render(markdown_feature *feature, 	text_stream *OUT, markdown_item *md, int mode) ;
#line 455 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__render_example_heading(OUTPUT_STREAM, IFM_example *E, 	int in_stand_alone_file) ;
#line 522 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__paste_buttons_intervene_after_Phase_I(markdown_feature *feature, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 527 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__pbiapi_r(markdown_item *md) ;
#line 575 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__PD_render(markdown_feature *feature, text_stream *OUT, 	markdown_item *md, int mode) ;
#line 631 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__HM_intervene_after_Phase_I(markdown_feature *feature, 	markdown_item *md, md_links_dictionary *link_references) ;
#line 668 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__PG_intervene_after_Phase_I(markdown_feature *feature, 	markdown_item *md, md_links_dictionary *link_references) ;
#line 690 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__expand_gate(markdown_item *md) ;
#line 711 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__set_gatekeeper_function(int (gatekeeper)(text_stream *)) ;
#line 715 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__PG_render(markdown_feature *feature, text_stream *OUT, 	markdown_item *md, int mode) ;
#line 739 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__IFD_multifile(markdown_feature *feature, 	markdown_item *tree, md_links_dictionary *link_references) ;
#line 768 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int  InformFlavouredMarkdown__SC_render(markdown_feature *feature, text_stream *OUT, 	markdown_item *md, int mode) ;
#line 1026 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__syntax_coloured_code(OUTPUT_STREAM, text_stream *text, 	text_stream *colouring, int from, int to, int mode) ;
#line 1060 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void  InformFlavouredMarkdown__render_text(OUTPUT_STREAM, text_stream *text) ;
#line 106 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
ebook * Epub__new(text_stream *title, char *prefix) ;
#line 122 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
void  Epub__use_CSS_throughout(ebook *B, filename *F) ;
#line 126 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
void  Epub__use_CSS(ebook_volume *V, filename *F) ;
#line 130 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
text_stream * Epub__attach_metadata(ebook *B, inchar32_t *K, text_stream *V) ;
#line 144 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
text_stream * Epub__get_metadata(ebook *B, inchar32_t *K) ;
#line 152 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
text_stream * Epub__ensure_metadata(ebook *B, inchar32_t *K) ;
#line 158 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
ebook_page * Epub__note_page(ebook *B, filename *F, text_stream *title, text_stream *type) ;
#line 178 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
void  Epub__note_image(ebook *B, filename *F) ;
#line 186 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
ebook_volume * Epub__starts_volume(ebook *B, ebook_page *P, text_stream *title) ;
#line 197 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
ebook_chapter * Epub__starts_chapter(ebook *B, ebook_page *P, text_stream *title, text_stream *URL) ;
#line 210 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
void  Epub__set_mark_in_chapter(ebook_chapter *C, text_stream *text, text_stream *URL) ;
#line 223 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
pathname * Epub__begin_construction(ebook *B, pathname *P, filename *cover_image) ;
#line 307 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
void  Epub__end_construction(ebook *B) ;
#line 10 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int8(FILE *binary_file, unsigned int *result) ;
#line 18 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int16(FILE *binary_file, unsigned int *result) ;
#line 29 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int32(FILE *binary_file, unsigned int *result) ;
#line 44 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_int64(FILE *binary_file, unsigned long long *result) ;
#line 70 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__write_int32(FILE *binary_file, unsigned int val) ;
#line 87 "inweb/foundation-module/Chapter 6/Binary Files.w"
void  BinaryFiles__swap_bytes32(unsigned int *value) ;
#line 95 "inweb/foundation-module/Chapter 6/Binary Files.w"
void  BinaryFiles__swap_bytes64(unsigned long long *value) ;
#line 113 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_variable_length_integer(FILE *binary_file, unsigned int *result) ;
#line 130 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_float80(FILE *binary_file, unsigned int *result) ;
#line 155 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__read_string(FILE *binary_file, char *string, unsigned int length) ;
#line 167 "inweb/foundation-module/Chapter 6/Binary Files.w"
long int  BinaryFiles__size(filename *F) ;
#line 184 "inweb/foundation-module/Chapter 6/Binary Files.w"
FILE * BinaryFiles__open_for_reading(filename *F) ;
#line 190 "inweb/foundation-module/Chapter 6/Binary Files.w"
FILE * BinaryFiles__try_to_open_for_reading(filename *F) ;
#line 194 "inweb/foundation-module/Chapter 6/Binary Files.w"
FILE * BinaryFiles__open_for_writing(filename *F) ;
#line 200 "inweb/foundation-module/Chapter 6/Binary Files.w"
FILE * BinaryFiles__try_to_open_for_writing(filename *F) ;
#line 204 "inweb/foundation-module/Chapter 6/Binary Files.w"
void  BinaryFiles__close(FILE *handle) ;
#line 213 "inweb/foundation-module/Chapter 6/Binary Files.w"
int  BinaryFiles__copy(filename *from, filename *to, int suppress_error) ;
#line 259 "inweb/foundation-module/Chapter 6/Binary Files.w"
void  BinaryFiles__md5(OUTPUT_STREAM, filename *F, int (*mask)(uint64_t)) ;
#line 383 "inweb/foundation-module/Chapter 6/Binary Files.w"
uint32_t  BinaryFiles__rotate(uint32_t value, uint32_t shift) ;
#line 24 "inweb/foundation-module/Chapter 6/Image Dimensions.w"
int  ImageFiles__get_JPEG_dimensions(FILE *JPEG_file, unsigned int *width, unsigned int *height) ;
#line 77 "inweb/foundation-module/Chapter 6/Image Dimensions.w"
int  ImageFiles__get_PNG_dimensions(FILE *PNG_file, unsigned int *width, unsigned int *height) ;
#line 12 "inweb/foundation-module/Chapter 6/Sound Durations.w"
int  SoundFiles__get_AIFF_duration(FILE *pFile, unsigned int *pDuration, 	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) ;
#line 59 "inweb/foundation-module/Chapter 6/Sound Durations.w"
int  SoundFiles__get_OggVorbis_duration(FILE *pFile, unsigned int *pDuration, 	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) ;
#line 181 "inweb/foundation-module/Chapter 6/Sound Durations.w"
int  SoundFiles__get_MIDI_information(FILE *pFile, unsigned int *pType, 	unsigned int *pNumTracks) ;
#line 77 "inweb/foundation-module/Chapter 7/Version Numbers.w"
semantic_version_number  VersionNumbers__null(void) ;
#line 88 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__is_null(semantic_version_number V) ;
#line 102 "inweb/foundation-module/Chapter 7/Version Numbers.w"
void  VersionNumbers__to_text(OUTPUT_STREAM, semantic_version_number V) ;
#line 125 "inweb/foundation-module/Chapter 7/Version Numbers.w"
void  VersionNumbers__writer(OUTPUT_STREAM, char *format_string, void *vE) ;
#line 143 "inweb/foundation-module/Chapter 7/Version Numbers.w"
semantic_version_number  VersionNumbers__from_text(text_stream *T) ;
#line 218 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__le(semantic_version_number V1, semantic_version_number V2) ;
#line 256 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__floor(int N) ;
#line 266 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__strict_atoi(text_stream *T) ;
#line 282 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__eq(semantic_version_number V1, semantic_version_number V2) ;
#line 288 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__ne(semantic_version_number V1, semantic_version_number V2) ;
#line 292 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__gt(semantic_version_number V1, semantic_version_number V2) ;
#line 296 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__ge(semantic_version_number V1, semantic_version_number V2) ;
#line 300 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__lt(semantic_version_number V1, semantic_version_number V2) ;
#line 307 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int  VersionNumbers__cmp(semantic_version_number V1, semantic_version_number V2) ;
#line 39 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
void  VersionNumberRanges__write_range(OUTPUT_STREAM, semver_range *R) ;
#line 58 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range * VersionNumberRanges__any_range(void) ;
#line 67 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int  VersionNumberRanges__is_any_range(semver_range *R) ;
#line 87 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range * VersionNumberRanges__compatibility_range(semantic_version_number V) ;
#line 106 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range * VersionNumberRanges__at_least_range(semantic_version_number V) ;
#line 113 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range * VersionNumberRanges__at_most_range(semantic_version_number V) ;
#line 123 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int  VersionNumberRanges__version_ge_end(semantic_version_number V, range_end E) ;
#line 139 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int  VersionNumberRanges__version_le_end(semantic_version_number V, range_end E) ;
#line 158 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int  VersionNumberRanges__in_range(semantic_version_number V, semver_range *R) ;
#line 178 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int  VersionNumberRanges__stricter(range_end E1, range_end E2, int lower) ;
#line 202 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int  VersionNumberRanges__intersect_range(semver_range *R1, semver_range *R2) ;
#line 92 "inweb/foundation-module/Chapter 8/Web Structure.w"
web_md * WebMetadata__get_without_modules(pathname *P, filename *alt_F) ;
#line 96 "inweb/foundation-module/Chapter 8/Web Structure.w"
web_md * WebMetadata__get(pathname *P, filename *alt_F, int syntax_version, 	module_search *I, int verbosely, int including_modules, pathname *path_to_inweb) ;
#line 267 "inweb/foundation-module/Chapter 8/Web Structure.w"
void  WebMetadata__read_contents_page(web_md *Wm, module *of_module, 	module_search *import_path, int verbosely, 	int including_modules, pathname *path, pathname *X) ;
#line 322 "inweb/foundation-module/Chapter 8/Web Structure.w"
void  WebMetadata__read_contents_line(text_stream *line, text_file_position *tfp, void *X) ;
#line 662 "inweb/foundation-module/Chapter 8/Web Structure.w"
int  WebMetadata__directory_looks_like_a_web(pathname *P) ;
#line 666 "inweb/foundation-module/Chapter 8/Web Structure.w"
filename * WebMetadata__contents_filename(pathname *P) ;
#line 673 "inweb/foundation-module/Chapter 8/Web Structure.w"
int  WebMetadata__chapter_count(web_md *Wm) ;
#line 679 "inweb/foundation-module/Chapter 8/Web Structure.w"
int  WebMetadata__section_count(web_md *Wm) ;
#line 29 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
int  Bibliographic__datum_can_be_declared(web_md *Wm, text_stream *key) ;
#line 35 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
int  Bibliographic__datum_on_or_off(web_md *Wm, text_stream *key) ;
#line 45 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
void  Bibliographic__initialise_data(web_md *Wm) ;
#line 86 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
void  Bibliographic__check_required_data(web_md *Wm) ;
#line 99 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
text_stream * Bibliographic__get_datum(web_md *Wm, text_stream *key) ;
#line 105 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
int  Bibliographic__data_exists(web_md *Wm, text_stream *key) ;
#line 111 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
web_bibliographic_datum * Bibliographic__look_up_datum(web_md *Wm, text_stream *key) ;
#line 126 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
web_bibliographic_datum * Bibliographic__set_datum(web_md *Wm, text_stream *key, text_stream *val) ;
#line 31 "inweb/foundation-module/Chapter 8/Web Modules.w"
module * WebModules__new(text_stream *name, pathname *at, int m) ;
#line 52 "inweb/foundation-module/Chapter 8/Web Modules.w"
module * WebModules__create_main_module(web_md *WS) ;
#line 63 "inweb/foundation-module/Chapter 8/Web Modules.w"
void  WebModules__dependency(module *A, module *B) ;
#line 79 "inweb/foundation-module/Chapter 8/Web Modules.w"
module_search * WebModules__make_search_path(pathname *ext_path) ;
#line 89 "inweb/foundation-module/Chapter 8/Web Modules.w"
module * WebModules__find(web_md *WS, module_search *ms, text_stream *name, pathname *X) ;
#line 119 "inweb/foundation-module/Chapter 8/Web Modules.w"
int  WebModules__exists(pathname *P) ;
#line 142 "inweb/foundation-module/Chapter 8/Web Modules.w"
int  WebModules__named_reference(module **return_M, section_md **return_Sm, 	int *named_as_module, text_stream *title, module *from_M, text_stream *text, 	int list, int sections_only) ;
#line 10 "inweb/foundation-module/Chapter 8/Build Files.w"
filename * BuildFiles__build_file_for_web(web_md *WS) ;
#line 30 "inweb/foundation-module/Chapter 8/Build Files.w"
build_file_data  BuildFiles__read(filename *F) ;
#line 40 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__build_file_helper(text_stream *text, text_file_position *tfp, void *state) ;
#line 59 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__write(build_file_data bfd, filename *F) ;
#line 77 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__set_bibliographic_data_for(web_md *WS) ;
#line 99 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__deduce_semver(web_md *WS) ;
#line 129 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__advance_for_web(web_md *WS) ;
#line 135 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__advance(filename *F) ;
#line 148 "inweb/foundation-module/Chapter 8/Build Files.w"
int  BuildFiles__dated_today(text_stream *dateline) ;
#line 174 "inweb/foundation-module/Chapter 8/Build Files.w"
void  BuildFiles__increment(text_stream *T) ;
#line 34 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
simple_tangle_docket  SimpleTangler__new_docket( 	void (*A)(struct text_stream *, struct simple_tangle_docket *), 	void (*B)(struct text_stream *, struct text_stream *, 		struct text_stream *, struct simple_tangle_docket *), 	void (*C)(struct text_stream *, struct simple_tangle_docket *), 	void (*D)(struct text_stream *, struct simple_tangle_docket *), 	void (*E)(char *, struct text_stream *), 	pathname *web_path, void *initial_state) ;
#line 60 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_text(simple_tangle_docket *docket, text_stream *text) ;
#line 64 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_file(simple_tangle_docket *docket, filename *F) ;
#line 68 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_section(simple_tangle_docket *docket, text_stream *leafname) ;
#line 72 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_web(simple_tangle_docket *docket) ;
#line 77 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_L1(simple_tangle_docket *docket, text_stream *text, 	filename *F, text_stream *leafname, int whole_web) ;
#line 88 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_L2(OUTPUT_STREAM, text_stream *text, filename *F, 	text_stream *leafname, simple_tangle_docket *docket, int whole_web) ;
#line 109 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void  SimpleTangler__tangle_L3(OUTPUT_STREAM, text_stream *text, 	text_stream *leafname, simple_tangle_docket *docket, filename *F) ;
#line 12 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void  Languages__set_default_directory(pathname *P) ;
#line 16 "inweb/foundation-module/Chapter 9/Programming Languages.w"
programming_language * Languages__find_by_name(text_stream *lname, pathname *P, 	int error_if_not_found) ;
#line 57 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void  Languages__show(OUTPUT_STREAM) ;
#line 74 "inweb/foundation-module/Chapter 9/Programming Languages.w"
int  Languages__compare_names(const void *ent1, const void *ent2) ;
#line 83 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void  Languages__read_definitions(pathname *P) ;
#line 157 "inweb/foundation-module/Chapter 9/Programming Languages.w"
programming_language * Languages__read_definition(filename *F) ;
#line 224 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void  Languages__read_definition_line(text_stream *line, text_file_position *tfp, void *v_state) ;
#line 406 "inweb/foundation-module/Chapter 9/Programming Languages.w"
colouring_language_block * Languages__new_block(colouring_language_block *within, int r) ;
#line 460 "inweb/foundation-module/Chapter 9/Programming Languages.w"
colouring_rule * Languages__new_rule(colouring_language_block *within) ;
#line 484 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void  Languages__parse_rule(language_reader_state *state, text_stream *premiss, 	text_stream *action, text_file_position *tfp) ;
#line 564 "inweb/foundation-module/Chapter 9/Programming Languages.w"
reserved_word * Languages__reserved(programming_language *pl, text_stream *W, inchar32_t C, 	text_file_position *tfp) ;
#line 601 "inweb/foundation-module/Chapter 9/Programming Languages.w"
inchar32_t  Languages__colour(text_stream *T, text_file_position *tfp) ;
#line 626 "inweb/foundation-module/Chapter 9/Programming Languages.w"
int  Languages__boolean(text_stream *T, text_file_position *tfp) ;
#line 640 "inweb/foundation-module/Chapter 9/Programming Languages.w"
text_stream * Languages__text(text_stream *T, text_file_position *tfp, int allow) ;
#line 727 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void  Languages__regexp(inchar32_t *write_to, text_stream *T, text_file_position *tfp) ;
#line 777 "inweb/foundation-module/Chapter 9/Programming Languages.w"
int  Languages__add_to_regexp(inchar32_t *write_to, int i, inchar32_t c) ;
#line 782 "inweb/foundation-module/Chapter 9/Programming Languages.w"
int  Languages__add_escape_to_regexp(inchar32_t *write_to, int i, inchar32_t c) ;
#line 17 "inweb/foundation-module/Chapter 9/Reserved Words.w"
int  ReservedWords__hash_code_from_word(text_stream *text) ;
#line 47 "inweb/foundation-module/Chapter 9/Reserved Words.w"
void  ReservedWords__initialise_hash_table(hash_table *HT) ;
#line 70 "inweb/foundation-module/Chapter 9/Reserved Words.w"
hash_table_entry * ReservedWords__find_hash_entry(hash_table *HT, text_stream *text, int create) ;
#line 101 "inweb/foundation-module/Chapter 9/Reserved Words.w"
hash_table_entry * ReservedWords__mark_reserved_word(hash_table *HT, text_stream *p, int e) ;
#line 109 "inweb/foundation-module/Chapter 9/Reserved Words.w"
int  ReservedWords__is_reserved_word(hash_table *HT, text_stream *p, int e) ;
#line 18 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__reset_syntax_colouring(programming_language *pl) ;
#line 39 "inweb/foundation-module/Chapter 9/The Painter.w"
int  Painter__syntax_colour(programming_language *pl, 	hash_table *HT, text_stream *matter, text_stream *colouring, int with_comments) ;
#line 67 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__syntax_colour_inner(programming_language *pl, 	hash_table *HT, text_stream *matter, text_stream *colouring, int from, int to) ;
#line 196 "inweb/foundation-module/Chapter 9/The Painter.w"
int  Painter__identifier_at(programming_language *pl, 	text_stream *matter, text_stream *colouring, int i) ;
#line 229 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__execute(hash_table *HT, colouring_language_block *block, text_stream *matter, 	text_stream *colouring, int from, int to, int N) ;
#line 310 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__execute_rule(hash_table *HT, colouring_rule *rule, text_stream *matter, 	text_stream *colouring, int from, int to, int N) ;
#line 326 "inweb/foundation-module/Chapter 9/The Painter.w"
int  Painter__satisfies(hash_table *HT, colouring_rule *rule, text_stream *matter, 	text_stream *colouring, int from, int to, int N) ;
#line 390 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__follow(hash_table *HT, colouring_rule *rule, text_stream *matter, 	text_stream *colouring, int from, int to) ;
#line 417 "inweb/foundation-module/Chapter 9/The Painter.w"
linked_list * Painter__lines(filename *F) ;
#line 439 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__text_file_helper(text_stream *text, text_file_position *tfp, void *state) ;
#line 444 "inweb/foundation-module/Chapter 9/The Painter.w"
void  Painter__colour_file(programming_language *pl, filename *F, text_stream *to, text_stream *coloured) ;
#line 476 "inweb/foundation-module/Chapter 9/The Painter.w"
int  Painter__parse_comment(programming_language *pl, 	text_stream *line, text_stream *part_before_comment, text_stream *part_within_comment) ;
#line 64 "inweb/Chapter 1/Program Control.w"
int  main(int argc, char **argv) ;
#line 96 "inweb/Chapter 1/Program Control.w"
void  Main__follow_instructions(inweb_instructions *ins) ;
#line 276 "inweb/Chapter 1/Program Control.w"
void  Main__error_in_web(text_stream *message, source_line *sl) ;
#line 59 "inweb/Chapter 1/Configuration.w"
inweb_instructions  Configuration__read(int argc, char **argv) ;
#line 271 "inweb/Chapter 1/Configuration.w"
void  Configuration__switch(int id, int val, text_stream *arg, void *state) ;
#line 383 "inweb/Chapter 1/Configuration.w"
void  Configuration__member_and_colony(inweb_instructions *args) ;
#line 409 "inweb/Chapter 1/Configuration.w"
void  Configuration__bareword(int id, text_stream *opt, void *state) ;
#line 424 "inweb/Chapter 1/Configuration.w"
void  Configuration__set_range(inweb_instructions *args, text_stream *opt) ;
#line 456 "inweb/Chapter 1/Configuration.w"
void  Configuration__set_fundamental_mode(inweb_instructions *args, int new_material) ;
#line 20 "inweb/Chapter 1/The Swarm.w"
void  Swarm__weave(web *W, text_stream *range, int swarm_mode, theme_tag *tag, 	weave_pattern *pattern, filename *to, pathname *into, 	linked_list *breadcrumbs, filename *navigation) ;
#line 51 "inweb/Chapter 1/The Swarm.w"
weave_order * Swarm__weave_subset(web *W, text_stream *range, int open_afterwards, 	theme_tag *tag, weave_pattern *pattern, filename *to, pathname *into, 	linked_list *breadcrumbs, filename *navigation) ;
#line 190 "inweb/Chapter 1/The Swarm.w"
void  Swarm__ensure_plugin(weave_order *wv, text_stream *name) ;
#line 199 "inweb/Chapter 1/The Swarm.w"
colour_scheme * Swarm__ensure_colour_scheme(weave_order *wv, text_stream *name, 	text_stream *pre) ;
#line 219 "inweb/Chapter 1/The Swarm.w"
void  Swarm__include_plugins(OUTPUT_STREAM, web *W, weave_order *wv, filename *from) ;
#line 231 "inweb/Chapter 1/The Swarm.w"
void  Swarm__weave_index_templates(web *W, text_stream *range, weave_pattern *pattern, 	pathname *into, filename *nav, linked_list *crumbs) ;
#line 42 "inweb/Chapter 1/Patterns.w"
weave_pattern * Patterns__find(web *W, text_stream *name) ;
#line 106 "inweb/Chapter 1/Patterns.w"
void  Patterns__scan_pattern_line(text_stream *line, text_file_position *tfp, void *X) ;
#line 184 "inweb/Chapter 1/Patterns.w"
int  Patterns__yes_or_no(text_stream *arg, text_file_position *tfp) ;
#line 191 "inweb/Chapter 1/Patterns.w"
text_stream * Patterns__plugin_name(text_stream *arg, text_file_position *tfp) ;
#line 208 "inweb/Chapter 1/Patterns.w"
void  Patterns__post_process(weave_pattern *pattern, weave_order *wv) ;
#line 252 "inweb/Chapter 1/Patterns.w"
filename * Patterns__find_template(weave_pattern *pattern, text_stream *leafname) ;
#line 267 "inweb/Chapter 1/Patterns.w"
filename * Patterns__find_file_in_subdirectory(weave_pattern *pattern, 	text_stream *dirname, text_stream *leafname) ;
#line 278 "inweb/Chapter 1/Patterns.w"
void  Patterns__include_plugins(OUTPUT_STREAM, web *W, weave_pattern *pattern, filename *from) ;
#line 19 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
weave_plugin * Assets__new(text_stream *name) ;
#line 43 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
colour_scheme * Assets__find_colour_scheme(weave_pattern *pattern, 	text_stream *name, text_stream *pre) ;
#line 71 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void  Assets__include_relevant_plugins(text_stream *OUT, weave_pattern *pattern, 	web *W, weave_order *wv, filename *from) ;
#line 94 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void  Assets__include_plugin(OUTPUT_STREAM, web *W, weave_plugin *wp, 	weave_pattern *pattern, filename *from) ;
#line 135 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void  Assets__include_colour_scheme(OUTPUT_STREAM, web *W, colour_scheme *cs, 	weave_pattern *pattern, filename *from) ;
#line 184 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
linked_list * Assets__new_asset_rules_list(void) ;
#line 194 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void  Assets__add_asset_rule(linked_list *L, text_stream *ext, text_stream *line, 	text_file_position *tfp) ;
#line 200 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
asset_rule * Assets__new_rule(linked_list *L, text_stream *ext, text_stream *line, 	text_file_position *tfp) ;
#line 252 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
asset_rule * Assets__applicable_rule(weave_pattern *pattern, filename *F) ;
#line 274 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
pathname * Assets__include_asset(OUTPUT_STREAM, asset_rule *R, web *W, filename *F, 	text_stream *trans, weave_pattern *pattern, filename *from) ;
#line 353 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void  Assets__transform(text_stream *OUT, filename *F, text_stream *trans) ;
#line 361 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void  Assets__transformer(text_stream *line, text_file_position *tfp, void *X) ;
#line 97 "inweb/Chapter 2/The Reader.w"
web_md * Reader__load_web_md(pathname *P, filename *alt_F, module_search *I, 	int including_modules) ;
#line 103 "inweb/Chapter 2/The Reader.w"
web * Reader__load_web(pathname *P, filename *alt_F, module_search *I, 	int including_modules) ;
#line 205 "inweb/Chapter 2/The Reader.w"
void  Reader__read_web(web *W) ;
#line 219 "inweb/Chapter 2/The Reader.w"
void  Reader__read_file(web *W, chapter *C, filename *F, text_stream *titling_line, 	section *S, int disregard_top) ;
#line 269 "inweb/Chapter 2/The Reader.w"
void  Reader__scan_source_line(text_stream *line, text_file_position *tfp, void *state) ;
#line 296 "inweb/Chapter 2/The Reader.w"
pathname * Reader__woven_folder(web *W) ;
#line 302 "inweb/Chapter 2/The Reader.w"
pathname * Reader__tangled_folder(web *W) ;
#line 317 "inweb/Chapter 2/The Reader.w"
chapter * Reader__get_chapter_for_range(web *W, text_stream *range) ;
#line 326 "inweb/Chapter 2/The Reader.w"
section * Reader__get_section_for_range(web *W, text_stream *range) ;
#line 340 "inweb/Chapter 2/The Reader.w"
section * Reader__section_by_filename(web *W, text_stream *filename) ;
#line 362 "inweb/Chapter 2/The Reader.w"
int  Reader__range_within(text_stream *range1, text_stream *range2) ;
#line 391 "inweb/Chapter 2/The Reader.w"
tangle_target * Reader__add_tangle_target(web *W, programming_language *language) ;
#line 415 "inweb/Chapter 2/The Reader.w"
void  Reader__add_imported_header(web *W, filename *HF) ;
#line 422 "inweb/Chapter 2/The Reader.w"
int  Reader__web_has_one_section(web *W) ;
#line 430 "inweb/Chapter 2/The Reader.w"
void  Reader__print_web_statistics(web *W) ;
#line 47 "inweb/Chapter 2/Line Categories.w"
source_line * Lines__new_source_line_in(text_stream *line, text_file_position *tfp, 	section *S) ;
#line 118 "inweb/Chapter 2/Line Categories.w"
char * Lines__category_name(int cat) ;
#line 17 "inweb/Chapter 2/The Parser.w"
void  Parser__parse_web(web *W, int inweb_mode) ;
#line 856 "inweb/Chapter 2/The Parser.w"
text_stream * Parser__extract_purpose(text_stream *prologue, source_line *XL, section *S, source_line **adjust) ;
#line 928 "inweb/Chapter 2/The Parser.w"
int  Parser__detect_footnote(web *W, text_stream *matter, text_stream *before, 	text_stream *cue, text_stream *after) ;
#line 971 "inweb/Chapter 2/The Parser.w"
footnote * Parser__find_footnote_in_para(paragraph *P, text_stream *cue) ;
#line 988 "inweb/Chapter 2/The Parser.w"
text_stream * Parser__dimensions(text_stream *item, int *w, int *h, source_line *L) ;
#line 1036 "inweb/Chapter 2/The Parser.w"
void  Parser__wrong_version(int using, source_line *L, char *feature, int need) ;
#line 20 "inweb/Chapter 2/Paragraph Macros.w"
para_macro * Macros__create(section *S, paragraph *P, source_line *L, text_stream *name) ;
#line 38 "inweb/Chapter 2/Paragraph Macros.w"
para_macro * Macros__find_by_name(text_stream *name, section *scope) ;
#line 22 "inweb/Chapter 2/Tags.w"
theme_tag * Tags__find_by_name(text_stream *name, int creating_if_necessary) ;
#line 56 "inweb/Chapter 2/Tags.w"
void  Tags__add_to_paragraph(paragraph *P, theme_tag *tag, text_stream *caption) ;
#line 71 "inweb/Chapter 2/Tags.w"
theme_tag * Tags__add_by_name(paragraph *P, text_stream *text) ;
#line 91 "inweb/Chapter 2/Tags.w"
text_stream * Tags__retrieve_caption(paragraph *P, theme_tag *tag) ;
#line 107 "inweb/Chapter 2/Tags.w"
int  Tags__tagged_with(paragraph *P, theme_tag *tag) ;
#line 119 "inweb/Chapter 2/Tags.w"
void  Tags__open_ifdefs(OUTPUT_STREAM, paragraph *P) ;
#line 127 "inweb/Chapter 2/Tags.w"
void  Tags__close_ifdefs(OUTPUT_STREAM, paragraph *P) ;
#line 135 "inweb/Chapter 2/Tags.w"
void  Tags__show_endnote_on_ifdefs(heterogeneous_tree *tree, tree_node *ap, paragraph *P) ;
#line 27 "inweb/Chapter 2/Enumerated Constants.w"
enumeration_set * Enumerations__find(text_stream *post) ;
#line 40 "inweb/Chapter 2/Enumerated Constants.w"
void  Enumerations__define(OUTPUT_STREAM, text_stream *symbol, 	text_stream *from, source_line *L) ;
#line 95 "inweb/Chapter 2/Enumerated Constants.w"
void  Enumerations__define_extents(OUTPUT_STREAM, tangle_target *target, programming_language *lang) ;
#line 19 "inweb/Chapter 2/Paragraph Numbering.w"
void  Numbering__number_web(web *W) ;
#line 149 "inweb/Chapter 2/Paragraph Numbering.w"
void  Numbering__settle_paragraph_number(paragraph *P) ;
#line 160 "inweb/Chapter 2/Paragraph Numbering.w"
void  Numbering__set_parent(paragraph *of, paragraph *to) ;
#line 11 "inweb/Chapter 3/The Analyser.w"
void  Analyser__scan_line_categories(web *W, text_stream *range) ;
#line 52 "inweb/Chapter 3/The Analyser.w"
void  Analyser__catalogue_the_sections(web *W, text_stream *range, int form) ;
#line 106 "inweb/Chapter 3/The Analyser.w"
void  Analyser__analyse_code(web *W) ;
#line 185 "inweb/Chapter 3/The Analyser.w"
void  Analyser__analyse_as_code(web *W, source_line *L, text_stream *text, int mask, int transf) ;
#line 224 "inweb/Chapter 3/The Analyser.w"
hash_table_entry * Analyser__find_hash_entry_for_section(section *S, text_stream *text, 	int create) ;
#line 229 "inweb/Chapter 3/The Analyser.w"
void  Analyser__mark_reserved_word_for_section(section *S, text_stream *p, int e) ;
#line 233 "inweb/Chapter 3/The Analyser.w"
hash_table_entry * Analyser__mark_reserved_word_at_line(source_line *L, text_stream *p, int e) ;
#line 241 "inweb/Chapter 3/The Analyser.w"
int  Analyser__is_reserved_word_for_section(section *S, text_stream *p, int e) ;
#line 245 "inweb/Chapter 3/The Analyser.w"
source_line * Analyser__get_defn_line(section *S, text_stream *p, int e) ;
#line 251 "inweb/Chapter 3/The Analyser.w"
language_function * Analyser__get_function(section *S, text_stream *p, int e) ;
#line 274 "inweb/Chapter 3/The Analyser.w"
void  Analyser__analyse_find(web *W, source_line *L, text_stream *identifier, int u) ;
#line 297 "inweb/Chapter 3/The Analyser.w"
void  Analyser__write_makefile(web *W, filename *F, module_search *I, text_stream *platform) ;
#line 312 "inweb/Chapter 3/The Analyser.w"
void  Analyser__write_gitignore(web *W, filename *F) ;
#line 330 "inweb/Chapter 3/The Analyser.w"
programming_language * Analyser__default_language(web *W) ;
#line 334 "inweb/Chapter 3/The Analyser.w"
programming_language * Analyser__find_by_name(text_stream *lname, web *W, 	int error_if_not_found) ;
#line 19 "inweb/Chapter 3/The Collater.w"
void  Collater__for_web_and_pattern(text_stream *OUT, web *W, 	weave_pattern *pattern, filename *F, filename *into) ;
#line 24 "inweb/Chapter 3/The Collater.w"
void  Collater__for_order(text_stream *OUT, weave_order *wv, 	filename *F, filename *into) ;
#line 30 "inweb/Chapter 3/The Collater.w"
void  Collater__collate(text_stream *OUT, web *W, text_stream *range, 	filename *template_filename, weave_pattern *pattern, filename *nav_file, 	linked_list *crumbs, weave_order *wv, filename *into) ;
#line 73 "inweb/Chapter 3/The Collater.w"
collater_state  Collater__initial_state(web *W, text_stream *range, 	filename *template_filename, weave_pattern *pattern, filename *nav_file, 	linked_list *crumbs, weave_order *wv, filename *into) ;
#line 118 "inweb/Chapter 3/The Collater.w"
void  Collater__temp_line(text_stream *line, text_file_position *tfp, void *v_ies) ;
#line 127 "inweb/Chapter 3/The Collater.w"
void  Collater__process(text_stream *OUT, collater_state *cls) ;
#line 423 "inweb/Chapter 3/The Collater.w"
linked_list_item * Collater__heading_topmost_on_stack(collater_state *cls, int level) ;
#line 440 "inweb/Chapter 3/The Collater.w"
void  Collater__start_CI_loop(collater_state *cls, int level, 	linked_list_item *from, linked_list_item *to, int pos) ;
#line 450 "inweb/Chapter 3/The Collater.w"
void  Collater__end_CI_loop(collater_state *cls) ;
#line 750 "inweb/Chapter 3/The Collater.w"
text_stream * Collater__module_owner(const module *M, web *W) ;
#line 766 "inweb/Chapter 3/The Collater.w"
void  Collater__sort_web(web *W) ;
#line 769 "inweb/Chapter 3/The Collater.w"
int  Collater__sort_comparison(const void *ent1, const void *ent2) ;
#line 779 "inweb/Chapter 3/The Collater.w"
int  Collater__cmp_owners(text_stream *O1, text_stream *O2) ;
#line 16 "inweb/Chapter 3/The Weaver.w"
int  Weaver__weave(weave_order *wv) ;
#line 42 "inweb/Chapter 3/The Weaver.w"
int  Weaver__weave_inner(weave_order *wv, heterogeneous_tree *tree, tree_node *body) ;
#line 579 "inweb/Chapter 3/The Weaver.w"
void  Weaver__show_endnotes_on_previous_paragraph(heterogeneous_tree *tree, 	weave_order *wv, tree_node *ap, paragraph *P) ;
#line 694 "inweb/Chapter 3/The Weaver.w"
void  Weaver__show_function_usage(heterogeneous_tree *tree, weave_order *wv, 	tree_node *ap, paragraph *P, language_function *fn, int as_list) ;
#line 759 "inweb/Chapter 3/The Weaver.w"
void  Weaver__weave_subheading(heterogeneous_tree *tree, weave_order *wv, 	tree_node *ap, text_stream *text) ;
#line 765 "inweb/Chapter 3/The Weaver.w"
void  Weaver__change_material(heterogeneous_tree *tree, 	weaver_state *state, int new_material, int plainly, programming_language *pl, 	text_stream *note) ;
#line 778 "inweb/Chapter 3/The Weaver.w"
void  Weaver__change_material_for_para(heterogeneous_tree *tree, weaver_state *state) ;
#line 786 "inweb/Chapter 3/The Weaver.w"
void  Weaver__figure(heterogeneous_tree *tree, weave_order *wv, 	tree_node *ap, text_stream *figname, int w, int h) ;
#line 792 "inweb/Chapter 3/The Weaver.w"
void  Weaver__commentary_text(heterogeneous_tree *tree, weave_order *wv, 	tree_node *ap, text_stream *matter) ;
#line 802 "inweb/Chapter 3/The Weaver.w"
int  Weaver__weave_table_of_contents(heterogeneous_tree *tree, 	tree_node *ap, section *S) ;
#line 12 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__commentary_text(heterogeneous_tree *tree, tree_node *ap, text_stream *matter) ;
#line 15 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__comment_text_in_code(heterogeneous_tree *tree, tree_node *ap, text_stream *matter) ;
#line 19 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__commentary_r(heterogeneous_tree *tree, tree_node *ap, text_stream *matter, 	int within, int in_code) ;
#line 200 "inweb/Chapter 3/The Weaver of Text.w"
int  TextWeaver__boundary_character(int before, inchar32_t c) ;
#line 210 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__commentary_fragment(heterogeneous_tree *tree, tree_node *ap, 	text_stream *fragment, int in_code) ;
#line 216 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__inline_code_fragment(heterogeneous_tree *tree, tree_node *ap, text_stream *fragment) ;
#line 229 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__source_code(heterogeneous_tree *tree, tree_node *ap, 	text_stream *matter, text_stream *colouring, int linked) ;
#line 334 "inweb/Chapter 3/The Weaver of Text.w"
void  TextWeaver__source_code_piece(heterogeneous_tree *tree, tree_node *ap, 	text_stream *matter, text_stream *colouring, int from, int to) ;
#line 14 "inweb/Chapter 3/The Tangler.w"
void  Tangler__tangle(web *W, tangle_target *target, filename *dest_file) ;
#line 141 "inweb/Chapter 3/The Tangler.w"
void  Tangler__tangle_paragraph(OUTPUT_STREAM, paragraph *P) ;
#line 176 "inweb/Chapter 3/The Tangler.w"
void  Tangler__tangle_line(OUTPUT_STREAM, text_stream *original, section *S, source_line *L) ;
#line 273 "inweb/Chapter 3/The Tangler.w"
tangle_target * Tangler__primary_target(web *W) ;
#line 22 "inweb/Chapter 4/Types and Functions.w"
language_type * Functions__new_struct(web *W, text_stream *name, source_line *L) ;
#line 86 "inweb/Chapter 4/Types and Functions.w"
structure_element * Functions__new_element(language_type *str, text_stream *elname, 	source_line *L) ;
#line 100 "inweb/Chapter 4/Types and Functions.w"
language_type * Functions__find_structure(web *W, text_stream *name) ;
#line 127 "inweb/Chapter 4/Types and Functions.w"
language_function * Functions__new_function(text_stream *fname, source_line *L) ;
#line 209 "inweb/Chapter 4/Types and Functions.w"
int  Functions__used_elsewhere(language_function *fn) ;
#line 230 "inweb/Chapter 4/Types and Functions.w"
void  Functions__catalogue(section *S, int functions_too) ;
#line 37 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__parse_types(web *W, programming_language *pl) ;
#line 47 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__parse_functions(web *W, programming_language *pl) ;
#line 59 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__further_parsing(web *W, programming_language *pl) ;
#line 72 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__subcategorise_line(programming_language *pl, source_line *L) ;
#line 86 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__parse_comment(programming_language *pl, 	text_stream *line, text_stream *before, text_stream *within) ;
#line 105 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__shebang(OUTPUT_STREAM, programming_language *pl, web *W, tangle_target *target) ;
#line 116 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__disclaimer(text_stream *OUT, programming_language *pl, web *W, tangle_target *target) ;
#line 130 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__additional_early_matter(text_stream *OUT, programming_language *pl, web *W, tangle_target *target) ;
#line 149 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__start_definition(OUTPUT_STREAM, programming_language *pl, 	text_stream *term, text_stream *start, section *S, source_line *L) ;
#line 157 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__prolong_definition(OUTPUT_STREAM, programming_language *pl, 	text_stream *more, section *S, source_line *L) ;
#line 165 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__end_definition(OUTPUT_STREAM, programming_language *pl, 	section *S, source_line *L) ;
#line 178 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__additional_predeclarations(OUTPUT_STREAM, programming_language *pl, web *W) ;
#line 191 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__allow_expansion(programming_language *pl, text_stream *material) ;
#line 206 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__special_tangle_command(OUTPUT_STREAM, programming_language *pl, text_stream *data) ;
#line 223 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__will_insert_in_tangle(programming_language *pl, source_line *L) ;
#line 228 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__insert_in_tangle(OUTPUT_STREAM, programming_language *pl, source_line *L) ;
#line 241 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__insert_line_marker(OUTPUT_STREAM, programming_language *pl, source_line *L) ;
#line 255 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__before_macro_expansion(OUTPUT_STREAM, programming_language *pl, para_macro *pmac) ;
#line 258 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__after_macro_expansion(OUTPUT_STREAM, programming_language *pl, para_macro *pmac) ;
#line 272 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__open_ifdef(OUTPUT_STREAM, programming_language *pl, text_stream *symbol, int sense) ;
#line 275 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__close_ifdef(OUTPUT_STREAM, programming_language *pl, text_stream *symbol, int sense) ;
#line 285 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__comment(OUTPUT_STREAM, programming_language *pl, text_stream *comm) ;
#line 297 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__tangle_line(OUTPUT_STREAM, programming_language *pl, text_stream *original) ;
#line 309 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__gnabehs(OUTPUT_STREAM, programming_language *pl, web *W) ;
#line 321 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__additional_tangling(programming_language *pl, web *W, tangle_target *target) ;
#line 333 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__begin_weave(section *S, weave_order *wv) ;
#line 343 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__skip_in_weaving(programming_language *pl, weave_order *wv, source_line *L) ;
#line 358 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__reset_syntax_colouring(programming_language *pl) ;
#line 369 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__syntax_colour(programming_language *pl, 	weave_order *wv, source_line *L, text_stream *matter, text_stream *colouring) ;
#line 396 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__weave_code_line(OUTPUT_STREAM, programming_language *pl, weave_order *wv, 	web *W, chapter *C, section *S, source_line *L, text_stream *matter, text_stream *concluding_comment) ;
#line 409 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__new_tag_declared(theme_tag *tag) ;
#line 432 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__early_preweave_analysis(programming_language *pl, web *W) ;
#line 435 "inweb/Chapter 4/Language Methods.w"
void  LanguageMethods__late_preweave_analysis(programming_language *pl, web *W) ;
#line 446 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__share_element(programming_language *pl, text_stream *element_name) ;
#line 455 "inweb/Chapter 4/Language Methods.w"
int  LanguageMethods__supports_definitions(programming_language *pl) ;
#line 16 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__add_fallbacks(programming_language *pl) ;
#line 62 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__expand(OUTPUT_STREAM, text_stream *prototype, text_stream *S, 	int N, filename *F) ;
#line 86 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__shebang(programming_language *pl, text_stream *OUT, web *W, 	tangle_target *target) ;
#line 91 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__before_macro_expansion(programming_language *pl, 	OUTPUT_STREAM, para_macro *pmac) ;
#line 96 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__after_macro_expansion(programming_language *pl, 	OUTPUT_STREAM, para_macro *pmac) ;
#line 101 "inweb/Chapter 4/ACME Support.w"
int  ACMESupport__start_definition(programming_language *pl, text_stream *OUT, 	text_stream *term, text_stream *start, section *S, source_line *L) ;
#line 110 "inweb/Chapter 4/ACME Support.w"
int  ACMESupport__prolong_definition(programming_language *pl, 	text_stream *OUT, text_stream *more, section *S, source_line *L) ;
#line 119 "inweb/Chapter 4/ACME Support.w"
int  ACMESupport__end_definition(programming_language *pl, 	text_stream *OUT, section *S, source_line *L) ;
#line 127 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__I6_open_ifdef(programming_language *pl, 	text_stream *OUT, text_stream *symbol, int sense) ;
#line 133 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__I6_close_ifdef(programming_language *pl, 	text_stream *OUT, text_stream *symbol, int sense) ;
#line 139 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__insert_line_marker(programming_language *pl, 	text_stream *OUT, source_line *L) ;
#line 145 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__comment(programming_language *pl, 	text_stream *OUT, text_stream *comm) ;
#line 164 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__parse_types(programming_language *self, web *W) ;
#line 183 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__parse_functions(programming_language *self, web *W) ;
#line 208 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__post_analysis(programming_language *self, web *W) ;
#line 244 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__analyse_code(programming_language *self, web *W) ;
#line 262 "inweb/Chapter 4/ACME Support.w"
int  ACMESupport__suppress_disclaimer(programming_language *pl) ;
#line 269 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__begin_weave(programming_language *pl, section *S, weave_order *wv) ;
#line 278 "inweb/Chapter 4/ACME Support.w"
void  ACMESupport__reset_syntax_colouring(programming_language *pl) ;
#line 282 "inweb/Chapter 4/ACME Support.w"
int  ACMESupport__syntax_colour(programming_language *pl, 	weave_order *wv, source_line *L, text_stream *matter, text_stream *colouring) ;
#line 9 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__make_c_like(programming_language *pl) ;
#line 24 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__parse_types(programming_language *self, web *W) ;
#line 187 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__parse_functions(programming_language *self, web *W) ;
#line 316 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__subcategorise_code(programming_language *self, source_line *L) ;
#line 345 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__additional_early_matter(programming_language *self, text_stream *OUT, web *W, tangle_target *target) ;
#line 364 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__additional_predeclarations(programming_language *self, text_stream *OUT, web *W) ;
#line 402 "inweb/Chapter 4/C-Like Languages.w"
void  CLike__tangle_structure(OUTPUT_STREAM, programming_language *self, language_type *str) ;
#line 10 "inweb/Chapter 4/InC Support.w"
void  InCSupport__add_features(programming_language *pl) ;
#line 41 "inweb/Chapter 4/InC Support.w"
void  InCSupport__further_parsing(programming_language *self, web *W) ;
#line 368 "inweb/Chapter 4/InC Support.w"
int  InCSupport__suppress_expansion(programming_language *self, text_stream *material) ;
#line 392 "inweb/Chapter 4/InC Support.w"
int  InCSupport__special_tangle_command(programming_language *me, OUTPUT_STREAM, text_stream *data) ;
#line 416 "inweb/Chapter 4/InC Support.w"
void  InCSupport__additional_predeclarations(programming_language *self, text_stream *OUT, web *W) ;
#line 445 "inweb/Chapter 4/InC Support.w"
void  InCSupport__gnabehs(programming_language *self, text_stream *OUT, web *W) ;
#line 479 "inweb/Chapter 4/InC Support.w"
int  InCSupport__will_insert_in_tangle(programming_language *self, source_line *L) ;
#line 500 "inweb/Chapter 4/InC Support.w"
void  InCSupport__insert_in_tangle(programming_language *self, text_stream *OUT, source_line *L) ;
#line 633 "inweb/Chapter 4/InC Support.w"
void  InCSupport__expand_formula(text_stream *OUT, source_line *AL, preform_nonterminal *pnt, 	text_stream *formula, int full) ;
#line 661 "inweb/Chapter 4/InC Support.w"
int  InCSupport__tangle_line(programming_language *self, text_stream *OUT, text_stream *original) ;
#line 666 "inweb/Chapter 4/InC Support.w"
void  InCSupport__tangle_line_inner(text_stream *OUT, source_line *AL, preform_nonterminal *pnt, text_stream *original) ;
#line 917 "inweb/Chapter 4/InC Support.w"
preform_nonterminal * InCSupport__nonterminal_by_name(text_stream *name) ;
#line 931 "inweb/Chapter 4/InC Support.w"
text_stream * InCSupport__nonterminal_variable_identifier(text_stream *name) ;
#line 952 "inweb/Chapter 4/InC Support.w"
void  InCSupport__additional_tangling(programming_language *self, web *W, tangle_target *target) ;
#line 1015 "inweb/Chapter 4/InC Support.w"
void  InCSupport__weave_grammar_index(OUTPUT_STREAM) ;
#line 1093 "inweb/Chapter 4/InC Support.w"
int  InCSupport__skip_in_weaving(programming_language *self, weave_order *wv, source_line *L) ;
#line 1108 "inweb/Chapter 4/InC Support.w"
int  InCSupport__weave_code_line(programming_language *self, text_stream *OUT, 	weave_order *wv, web *W, chapter *C, section *S, source_line *L, 	text_stream *matter, text_stream *concluding_comment) ;
#line 1122 "inweb/Chapter 4/InC Support.w"
void  InCSupport__new_tag_declared(programming_language *self, theme_tag *tag) ;
#line 1129 "inweb/Chapter 4/InC Support.w"
void  InCSupport__analyse_code(programming_language *self, web *W) ;
#line 1136 "inweb/Chapter 4/InC Support.w"
int  InCSupport__share_element(programming_language *self, text_stream *elname) ;
#line 301 "inweb/Chapter 5/Weave Tree.w"
heterogeneous_tree * WeaveTree__new_tree(weave_order *wv) ;
#line 404 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__document(heterogeneous_tree *tree, weave_order *wv) ;
#line 411 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__head(heterogeneous_tree *tree, text_stream *banner) ;
#line 418 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__body(heterogeneous_tree *tree) ;
#line 424 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__tail(heterogeneous_tree *tree, text_stream *rennab) ;
#line 431 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__verbatim(heterogeneous_tree *tree, text_stream *content) ;
#line 438 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__section_header(heterogeneous_tree *tree, section *S) ;
#line 445 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__section_footer(heterogeneous_tree *tree, section *S) ;
#line 452 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__chapter(heterogeneous_tree *tree, chapter *Ch) ;
#line 458 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__chapter_header(heterogeneous_tree *tree, chapter *Ch) ;
#line 465 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__chapter_footer(heterogeneous_tree *tree, chapter *Ch) ;
#line 472 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__purpose(heterogeneous_tree *tree, text_stream *P) ;
#line 479 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__subheading(heterogeneous_tree *tree, text_stream *P) ;
#line 486 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__pagebreak(heterogeneous_tree *tree) ;
#line 492 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__linebreak(heterogeneous_tree *tree) ;
#line 498 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__bar(heterogeneous_tree *tree) ;
#line 504 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__paragraph_heading(heterogeneous_tree *tree, paragraph *P, int no_skip) ;
#line 512 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__endnote(heterogeneous_tree *tree) ;
#line 518 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__figure(heterogeneous_tree *tree, 	text_stream *figname, int w, int h) ;
#line 528 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__raw_extract(heterogeneous_tree *tree, 	text_stream *extract) ;
#line 536 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__audio(heterogeneous_tree *tree, 	text_stream *audio_name, int w) ;
#line 545 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__video(heterogeneous_tree *tree, 	text_stream *video_name, int w, int h) ;
#line 554 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__download(heterogeneous_tree *tree, 	text_stream *download_name, text_stream *filetype) ;
#line 563 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__material(heterogeneous_tree *tree, int material_type, int plainly, 	programming_language *styling, text_stream *endnote) ;
#line 573 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__embed(heterogeneous_tree *tree, 	text_stream *service, text_stream *ID, int w, int h) ;
#line 588 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__pmac(heterogeneous_tree *tree, para_macro *pmac, int defn) ;
#line 600 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__vskip(heterogeneous_tree *tree, int in_comment) ;
#line 606 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__section(heterogeneous_tree *tree, section *sect) ;
#line 612 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__code_line(heterogeneous_tree *tree) ;
#line 617 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__function_usage(heterogeneous_tree *tree, 	text_stream *url, language_function *fn) ;
#line 625 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__commentary(heterogeneous_tree *tree, text_stream *text, int in_code) ;
#line 632 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__carousel_slide(heterogeneous_tree *tree, text_stream *caption, int c) ;
#line 639 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__table_of_contents(heterogeneous_tree *tree, text_stream *text1) ;
#line 645 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__contents_line(heterogeneous_tree *tree, 	text_stream *text1, text_stream *text2, paragraph *P) ;
#line 654 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__weave_chapter_title_page_node(heterogeneous_tree *tree) ;
#line 659 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__weave_defn_node(heterogeneous_tree *tree, text_stream *keyword) ;
#line 676 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__source_code(heterogeneous_tree *tree, 	text_stream *matter, text_stream *colouring) ;
#line 708 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__url(heterogeneous_tree *tree, text_stream *url, 	text_stream *content, int external) ;
#line 717 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__footnote_cue(heterogeneous_tree *tree, text_stream *cue) ;
#line 723 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__footnote(heterogeneous_tree *tree, text_stream *cue) ;
#line 733 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__function_defn(heterogeneous_tree *tree, language_function *fn) ;
#line 743 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__display_line(heterogeneous_tree *tree, text_stream *text) ;
#line 762 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__weave_item_node(heterogeneous_tree *tree, int depth, text_stream *label) ;
#line 769 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__grammar_index(heterogeneous_tree *tree) ;
#line 774 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__inline(heterogeneous_tree *tree) ;
#line 779 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__locale(heterogeneous_tree *tree, paragraph *par1, paragraph *par2) ;
#line 786 "inweb/Chapter 5/Weave Tree.w"
tree_node * WeaveTree__mathematics(heterogeneous_tree *tree, text_stream *content, int displayed) ;
#line 793 "inweb/Chapter 5/Weave Tree.w"
void  WeaveTree__show(text_stream *OUT, heterogeneous_tree *T) ;
#line 800 "inweb/Chapter 5/Weave Tree.w"
void  WeaveTree__prune(heterogeneous_tree *T) ;
#line 804 "inweb/Chapter 5/Weave Tree.w"
int  WeaveTree__prune_visit(tree_node *N, void *state) ;
#line 18 "inweb/Chapter 5/Format Methods.w"
weave_format * Formats__create_weave_format(text_stream *name, text_stream *ext) ;
#line 26 "inweb/Chapter 5/Format Methods.w"
weave_format * Formats__find_by_name(text_stream *name) ;
#line 40 "inweb/Chapter 5/Format Methods.w"
text_stream * Formats__file_extension(weave_format *wf) ;
#line 48 "inweb/Chapter 5/Format Methods.w"
void  Formats__create_weave_formats(void) ;
#line 72 "inweb/Chapter 5/Format Methods.w"
int  Formats__begin_weaving(web *W, weave_pattern *pattern) ;
#line 78 "inweb/Chapter 5/Format Methods.w"
void  Formats__end_weaving(web *W, weave_pattern *pattern) ;
#line 95 "inweb/Chapter 5/Format Methods.w"
void  Formats__render(text_stream *OUT, heterogeneous_tree *tree, filename *into) ;
#line 120 "inweb/Chapter 5/Format Methods.w"
int  Formats__preform_document(OUTPUT_STREAM, weave_order *wv, web *W, 	chapter *C, section *S, source_line *L, text_stream *matter, 	text_stream *concluding_comment) ;
#line 139 "inweb/Chapter 5/Format Methods.w"
void  Formats__post_process_weave(weave_order *wv, int open_afterwards) ;
#line 151 "inweb/Chapter 5/Format Methods.w"
void  Formats__report_on_post_processing(weave_order *wv) ;
#line 164 "inweb/Chapter 5/Format Methods.w"
int  Formats__substitute_post_processing_data(OUTPUT_STREAM, weave_order *wv, 	text_stream *detail, weave_pattern *pattern) ;
#line 9 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__create(void) ;
#line 23 "inweb/Chapter 5/Plain Text Format.w"
void  PlainText__render(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) ;
#line 31 "inweb/Chapter 5/Plain Text Format.w"
int  PlainText__render_visit(tree_node *N, void *state, int L) ;
#line 9 "inweb/Chapter 5/TeX Format.w"
void  TeX__create(void) ;
#line 25 "inweb/Chapter 5/TeX Format.w"
void  TeX__render_TeX(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) ;
#line 39 "inweb/Chapter 5/TeX Format.w"
void  TeX__render_inner(text_stream *OUT, heterogeneous_tree *tree, int form) ;
#line 51 "inweb/Chapter 5/TeX Format.w"
int  TeX__render_visit(tree_node *N, void *state, int L) ;
#line 399 "inweb/Chapter 5/TeX Format.w"
void  TeX__general_heading(text_stream *OUT, weave_order *wv, 	section *S, paragraph *P, text_stream *heading_text, int weight, int no_skip) ;
#line 496 "inweb/Chapter 5/TeX Format.w"
void  TeX__source_code(text_stream *OUT, weave_order *wv, 	text_stream *matter, text_stream *colouring, int starts) ;
#line 515 "inweb/Chapter 5/TeX Format.w"
void  TeX__change_colour_PDF(text_stream *OUT, int col, int in_code) ;
#line 538 "inweb/Chapter 5/TeX Format.w"
void  TeX__para_macro(text_stream *OUT, weave_order *wv, para_macro *pmac, int defn) ;
#line 558 "inweb/Chapter 5/TeX Format.w"
void  TeX__commentary_text(text_stream *OUT, weave_order *wv, text_stream *id) ;
#line 583 "inweb/Chapter 5/TeX Format.w"
int  TeX__preform_document(weave_format *self, text_stream *OUT, web *W, 	weave_order *wv, chapter *C, section *S, source_line *L, text_stream *matter, 	text_stream *concluding_comment) ;
#line 9 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__create(void) ;
#line 45 "inweb/Chapter 5/HTML Formats.w"
HTML_render_state  HTMLFormat__initial_state(text_stream *OUT, weave_order *wv, 	int EPUB_mode, filename *into) ;
#line 67 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__render(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) ;
#line 74 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__render_EPUB(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) ;
#line 86 "inweb/Chapter 5/HTML Formats.w"
int  HTMLFormat__render_visit(tree_node *N, void *state, int L) ;
#line 917 "inweb/Chapter 5/HTML Formats.w"
int  HTMLFormat__interior_material(tree_node *N) ;
#line 931 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__go_to_depth(HTML_render_state *hrs, int from_depth, int to_depth) ;
#line 949 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__paragraph_number(text_stream *OUT, paragraph *P) ;
#line 964 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__change_colour(text_stream *OUT, int col, colour_scheme *cs) ;
#line 988 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__escape_text(text_stream *OUT, text_stream *id) ;
#line 1000 "inweb/Chapter 5/HTML Formats.w"
int  HTMLFormat__begin_weaving_EPUB(weave_format *wf, web *W, weave_pattern *pattern) ;
#line 1015 "inweb/Chapter 5/HTML Formats.w"
void  HTMLFormat__end_weaving_EPUB(weave_format *wf, web *W, weave_pattern *pattern) ;
#line 9 "inweb/Chapter 5/Debugging Format.w"
void  Debugging__create(void) ;
#line 23 "inweb/Chapter 5/Debugging Format.w"
void  Debugging__render(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) ;
#line 31 "inweb/Chapter 5/Debugging Format.w"
int  Debugging__render_visit(tree_node *N, void *state, int L) ;
#line 274 "inweb/Chapter 5/Debugging Format.w"
void  Debugging__show_text(text_stream *OUT, text_stream *text, int limit) ;
#line 285 "inweb/Chapter 5/Debugging Format.w"
void  Debugging__show_para(text_stream *OUT, paragraph *P) ;
#line 290 "inweb/Chapter 5/Debugging Format.w"
void  Debugging__show_mat(text_stream *OUT, int m) ;
#line 30 "inweb/Chapter 5/TeX Utilities.w"
tex_results * TeXUtilities__new_results(weave_order *wv, filename *CF) ;
#line 44 "inweb/Chapter 5/TeX Utilities.w"
void  TeXUtilities__post_process_weave(weave_order *wv, filename *CF) ;
#line 52 "inweb/Chapter 5/TeX Utilities.w"
void  TeXUtilities__scan_console_line(text_stream *line, text_file_position *tfp, 	void *res_V) ;
#line 72 "inweb/Chapter 5/TeX Utilities.w"
void  TeXUtilities__report_on_post_processing(weave_order *wv) ;
#line 86 "inweb/Chapter 5/TeX Utilities.w"
int  TeXUtilities__substitute_post_processing_data(text_stream *to, weave_order *wv, 	text_stream *detail) ;
#line 126 "inweb/Chapter 5/TeX Utilities.w"
void  TeXUtilities__remove_math_mode(OUTPUT_STREAM, text_stream *text) ;
#line 133 "inweb/Chapter 5/TeX Utilities.w"
void  TeXUtilities__remove_math_mode_range(OUTPUT_STREAM, text_stream *text, int from, int to) ;
#line 12 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__write(web *W, filename *prototype, filename *F, module_search *I, 	text_stream *platform) ;
#line 72 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__identity_settings_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 94 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__platform_settings_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 119 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__seek_INWEBPLATFORM(text_stream *line, text_file_position *tfp, void *X) ;
#line 129 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__modify_filenames_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 186 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__component_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 236 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__components_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 269 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__dependent_files_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 325 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__pattern(OUTPUT_STREAM, linked_list *L, filename *F) ;
#line 366 "inweb/Chapter 6/Makefiles.w"
void  Makefiles__pathname_slashed(OUTPUT_STREAM, pathname *P) ;
#line 8 "inweb/Chapter 6/Git Support.w"
void  Git__write_gitignore(web *W, filename *prototype, filename *F) ;
#line 22 "inweb/Chapter 6/Git Support.w"
void  Git__basics_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 35 "inweb/Chapter 6/Ctags Support.w"
void  Ctags__write(web *W, filename *F) ;
#line 146 "inweb/Chapter 6/Ctags Support.w"
void  Ctags__write_line_ref(OUTPUT_STREAM, source_line *L, pathname *P) ;
#line 182 "inweb/Chapter 6/Ctags Support.w"
void  Ctags__note_defined_constant(source_line *L, text_stream *name) ;
#line 10 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__write(filename *prototype, filename *F) ;
#line 23 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__bibliographic_expander(preprocessor_macro *mm, preprocessor_state *PPS, 	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) ;
#line 50 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__write_var(text_stream *OUT, text_stream *program, text_stream *datum) ;
#line 60 "inweb/Chapter 6/Readme Writeme.w"
writeme_asset * Readme__find_asset(text_stream *program) ;
#line 111 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__extension_harvester(text_stream *text, text_file_position *tfp, void *state) ;
#line 123 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__header_harvester(text_stream *text, text_file_position *tfp, void *state) ;
#line 137 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__template_harvester(text_stream *text, text_file_position *tfp, void *state) ;
#line 153 "inweb/Chapter 6/Readme Writeme.w"
void  Readme__readme_harvester(text_stream *text, text_file_position *tfp, void *state) ;
#line 66 "inweb/Chapter 6/Colonies.w"
void  Colonies__load(filename *F) ;
#line 84 "inweb/Chapter 6/Colonies.w"
void  Colonies__read_line(text_stream *line, text_file_position *tfp, void *v_crs) ;
#line 151 "inweb/Chapter 6/Colonies.w"
void  Colonies__add_crumb(linked_list *L, text_stream *spec, text_file_position *tfp) ;
#line 169 "inweb/Chapter 6/Colonies.w"
breadcrumb_request * Colonies__request_breadcrumb(text_stream *arg) ;
#line 184 "inweb/Chapter 6/Colonies.w"
void  Colonies__drop_initial_breadcrumbs(OUTPUT_STREAM, filename *F, linked_list *crumbs) ;
#line 194 "inweb/Chapter 6/Colonies.w"
void  Colonies__write_breadcrumb(OUTPUT_STREAM, text_stream *text, text_stream *link) ;
#line 215 "inweb/Chapter 6/Colonies.w"
colony_member * Colonies__find(text_stream *T) ;
#line 233 "inweb/Chapter 6/Colonies.w"
module * Colonies__as_module(colony_member *CM, source_line *L, web_md *Wm) ;
#line 270 "inweb/Chapter 6/Colonies.w"
text_stream * Colonies__home(void) ;
#line 277 "inweb/Chapter 6/Colonies.w"
pathname * Colonies__assets_path(void) ;
#line 284 "inweb/Chapter 6/Colonies.w"
pathname * Colonies__patterns_path(void) ;
#line 310 "inweb/Chapter 6/Colonies.w"
int  Colonies__resolve_reference_in_weave(text_stream *url, text_stream *title, 	filename *for_HTML_file, text_stream *text, web_md *Wm, source_line *L, int *ext) ;
#line 327 "inweb/Chapter 6/Colonies.w"
int  Colonies__resolve_reference_in_weave_inner(text_stream *url, text_stream *title, 	filename *for_HTML_file, text_stream *text, web_md *Wm, source_line *L, int *ext) ;
#line 468 "inweb/Chapter 6/Colonies.w"
void  Colonies__link_URL(OUTPUT_STREAM, text_stream *link_text, filename *F) ;
#line 477 "inweb/Chapter 6/Colonies.w"
void  Colonies__reference_URL(OUTPUT_STREAM, text_stream *link_text, filename *F) ;
#line 488 "inweb/Chapter 6/Colonies.w"
void  Colonies__section_URL(OUTPUT_STREAM, section_md *Sm) ;
#line 498 "inweb/Chapter 6/Colonies.w"
void  Colonies__paragraph_URL(OUTPUT_STREAM, paragraph *P, filename *from) ;
#line 519 "inweb/Chapter 6/Colonies.w"
void  Colonies__paragraph_anchor(OUTPUT_STREAM, paragraph *P) ;
void register_tangled_nonterminals(void);
text_stream *TL_IS_0 = NULL;
text_stream *TL_IS_1 = NULL;
text_stream *TL_IS_2 = NULL;
text_stream *TL_IS_3 = NULL;
text_stream *TL_IS_4 = NULL;
text_stream *TL_IS_5 = NULL;
text_stream *TL_IS_6 = NULL;
text_stream *TL_IS_7 = NULL;
text_stream *TL_IS_8 = NULL;
text_stream *TL_IS_9 = NULL;
text_stream *TL_IS_10 = NULL;
text_stream *TL_IS_11 = NULL;
text_stream *TL_IS_12 = NULL;
text_stream *TL_IS_13 = NULL;
text_stream *TL_IS_14 = NULL;
text_stream *TL_IS_15 = NULL;
text_stream *TL_IS_16 = NULL;
text_stream *TL_IS_17 = NULL;
text_stream *TL_IS_18 = NULL;
text_stream *TL_IS_19 = NULL;
text_stream *TL_IS_20 = NULL;
text_stream *TL_IS_21 = NULL;
text_stream *TL_IS_22 = NULL;
text_stream *TL_IS_23 = NULL;
text_stream *TL_IS_24 = NULL;
text_stream *TL_IS_25 = NULL;
text_stream *TL_IS_26 = NULL;
text_stream *TL_IS_27 = NULL;
text_stream *TL_IS_28 = NULL;
text_stream *TL_IS_29 = NULL;
text_stream *TL_IS_30 = NULL;
text_stream *TL_IS_31 = NULL;
text_stream *TL_IS_32 = NULL;
text_stream *TL_IS_33 = NULL;
text_stream *TL_IS_34 = NULL;
text_stream *TL_IS_35 = NULL;
text_stream *TL_IS_36 = NULL;
text_stream *TL_IS_37 = NULL;
text_stream *TL_IS_38 = NULL;
text_stream *TL_IS_39 = NULL;
text_stream *TL_IS_40 = NULL;
text_stream *TL_IS_41 = NULL;
text_stream *TL_IS_42 = NULL;
text_stream *TL_IS_43 = NULL;
text_stream *TL_IS_44 = NULL;
text_stream *TL_IS_45 = NULL;
text_stream *TL_IS_46 = NULL;
text_stream *TL_IS_47 = NULL;
text_stream *TL_IS_48 = NULL;
text_stream *TL_IS_49 = NULL;
text_stream *TL_IS_50 = NULL;
text_stream *TL_IS_51 = NULL;
text_stream *TL_IS_52 = NULL;
text_stream *TL_IS_53 = NULL;
text_stream *TL_IS_54 = NULL;
text_stream *TL_IS_55 = NULL;
text_stream *TL_IS_56 = NULL;
text_stream *TL_IS_57 = NULL;
text_stream *TL_IS_58 = NULL;
text_stream *TL_IS_59 = NULL;
text_stream *TL_IS_60 = NULL;
text_stream *TL_IS_61 = NULL;
text_stream *TL_IS_62 = NULL;
text_stream *TL_IS_63 = NULL;
text_stream *TL_IS_64 = NULL;
text_stream *TL_IS_65 = NULL;
text_stream *TL_IS_66 = NULL;
text_stream *TL_IS_67 = NULL;
text_stream *TL_IS_68 = NULL;
text_stream *TL_IS_69 = NULL;
text_stream *TL_IS_70 = NULL;
text_stream *TL_IS_71 = NULL;
text_stream *TL_IS_72 = NULL;
text_stream *TL_IS_73 = NULL;
text_stream *TL_IS_74 = NULL;
text_stream *TL_IS_75 = NULL;
text_stream *TL_IS_76 = NULL;
text_stream *TL_IS_77 = NULL;
text_stream *TL_IS_78 = NULL;
text_stream *TL_IS_79 = NULL;
text_stream *TL_IS_80 = NULL;
text_stream *TL_IS_81 = NULL;
text_stream *TL_IS_82 = NULL;
text_stream *TL_IS_83 = NULL;
text_stream *TL_IS_84 = NULL;
text_stream *TL_IS_85 = NULL;
text_stream *TL_IS_86 = NULL;
text_stream *TL_IS_87 = NULL;
text_stream *TL_IS_88 = NULL;
text_stream *TL_IS_89 = NULL;
text_stream *TL_IS_90 = NULL;
text_stream *TL_IS_91 = NULL;
text_stream *TL_IS_92 = NULL;
text_stream *TL_IS_93 = NULL;
text_stream *TL_IS_94 = NULL;
text_stream *TL_IS_95 = NULL;
text_stream *TL_IS_96 = NULL;
text_stream *TL_IS_97 = NULL;
text_stream *TL_IS_98 = NULL;
text_stream *TL_IS_99 = NULL;
text_stream *TL_IS_100 = NULL;
text_stream *TL_IS_101 = NULL;
text_stream *TL_IS_102 = NULL;
text_stream *TL_IS_103 = NULL;
text_stream *TL_IS_104 = NULL;
text_stream *TL_IS_105 = NULL;
text_stream *TL_IS_106 = NULL;
text_stream *TL_IS_107 = NULL;
text_stream *TL_IS_108 = NULL;
text_stream *TL_IS_109 = NULL;
text_stream *TL_IS_110 = NULL;
text_stream *TL_IS_111 = NULL;
text_stream *TL_IS_112 = NULL;
text_stream *TL_IS_113 = NULL;
text_stream *TL_IS_114 = NULL;
text_stream *TL_IS_115 = NULL;
text_stream *TL_IS_116 = NULL;
text_stream *TL_IS_117 = NULL;
text_stream *TL_IS_118 = NULL;
text_stream *TL_IS_119 = NULL;
text_stream *TL_IS_120 = NULL;
text_stream *TL_IS_121 = NULL;
text_stream *TL_IS_122 = NULL;
text_stream *TL_IS_123 = NULL;
text_stream *TL_IS_124 = NULL;
text_stream *TL_IS_125 = NULL;
text_stream *TL_IS_126 = NULL;
text_stream *TL_IS_127 = NULL;
text_stream *TL_IS_128 = NULL;
text_stream *TL_IS_129 = NULL;
text_stream *TL_IS_130 = NULL;
text_stream *TL_IS_131 = NULL;
text_stream *TL_IS_132 = NULL;
text_stream *TL_IS_133 = NULL;
text_stream *TL_IS_134 = NULL;
text_stream *TL_IS_135 = NULL;
text_stream *TL_IS_136 = NULL;
text_stream *TL_IS_137 = NULL;
text_stream *TL_IS_138 = NULL;
text_stream *TL_IS_139 = NULL;
text_stream *TL_IS_140 = NULL;
text_stream *TL_IS_141 = NULL;
text_stream *TL_IS_142 = NULL;
text_stream *TL_IS_143 = NULL;
text_stream *TL_IS_144 = NULL;
text_stream *TL_IS_145 = NULL;
text_stream *TL_IS_146 = NULL;
text_stream *TL_IS_147 = NULL;
text_stream *TL_IS_148 = NULL;
text_stream *TL_IS_149 = NULL;
text_stream *TL_IS_150 = NULL;
text_stream *TL_IS_151 = NULL;
text_stream *TL_IS_152 = NULL;
text_stream *TL_IS_153 = NULL;
text_stream *TL_IS_154 = NULL;
text_stream *TL_IS_155 = NULL;
text_stream *TL_IS_156 = NULL;
text_stream *TL_IS_157 = NULL;
text_stream *TL_IS_158 = NULL;
text_stream *TL_IS_159 = NULL;
text_stream *TL_IS_160 = NULL;
text_stream *TL_IS_161 = NULL;
text_stream *TL_IS_162 = NULL;
text_stream *TL_IS_163 = NULL;
text_stream *TL_IS_164 = NULL;
text_stream *TL_IS_165 = NULL;
text_stream *TL_IS_166 = NULL;
text_stream *TL_IS_167 = NULL;
text_stream *TL_IS_168 = NULL;
text_stream *TL_IS_169 = NULL;
text_stream *TL_IS_170 = NULL;
text_stream *TL_IS_171 = NULL;
text_stream *TL_IS_172 = NULL;
text_stream *TL_IS_173 = NULL;
text_stream *TL_IS_174 = NULL;
text_stream *TL_IS_175 = NULL;
text_stream *TL_IS_176 = NULL;
text_stream *TL_IS_177 = NULL;
text_stream *TL_IS_178 = NULL;
text_stream *TL_IS_179 = NULL;
text_stream *TL_IS_180 = NULL;
text_stream *TL_IS_181 = NULL;
text_stream *TL_IS_182 = NULL;
text_stream *TL_IS_183 = NULL;
text_stream *TL_IS_184 = NULL;
text_stream *TL_IS_185 = NULL;
text_stream *TL_IS_186 = NULL;
text_stream *TL_IS_187 = NULL;
text_stream *TL_IS_188 = NULL;
text_stream *TL_IS_189 = NULL;
text_stream *TL_IS_190 = NULL;
text_stream *TL_IS_191 = NULL;
text_stream *TL_IS_192 = NULL;
text_stream *TL_IS_193 = NULL;
text_stream *TL_IS_194 = NULL;
text_stream *TL_IS_195 = NULL;
text_stream *TL_IS_196 = NULL;
text_stream *TL_IS_197 = NULL;
text_stream *TL_IS_198 = NULL;
text_stream *TL_IS_199 = NULL;
text_stream *TL_IS_200 = NULL;
text_stream *TL_IS_201 = NULL;
text_stream *TL_IS_202 = NULL;
text_stream *TL_IS_203 = NULL;
text_stream *TL_IS_204 = NULL;
text_stream *TL_IS_205 = NULL;
text_stream *TL_IS_206 = NULL;
text_stream *TL_IS_207 = NULL;
text_stream *TL_IS_208 = NULL;
text_stream *TL_IS_209 = NULL;
text_stream *TL_IS_210 = NULL;
text_stream *TL_IS_211 = NULL;
text_stream *TL_IS_212 = NULL;
text_stream *TL_IS_213 = NULL;
text_stream *TL_IS_214 = NULL;
text_stream *TL_IS_215 = NULL;
text_stream *TL_IS_216 = NULL;
text_stream *TL_IS_217 = NULL;
text_stream *TL_IS_218 = NULL;
text_stream *TL_IS_219 = NULL;
text_stream *TL_IS_220 = NULL;
text_stream *TL_IS_221 = NULL;
text_stream *TL_IS_222 = NULL;
text_stream *TL_IS_223 = NULL;
text_stream *TL_IS_224 = NULL;
text_stream *TL_IS_225 = NULL;
text_stream *TL_IS_226 = NULL;
text_stream *TL_IS_227 = NULL;
text_stream *TL_IS_228 = NULL;
text_stream *TL_IS_229 = NULL;
text_stream *TL_IS_230 = NULL;
text_stream *TL_IS_231 = NULL;
text_stream *TL_IS_232 = NULL;
text_stream *TL_IS_233 = NULL;
text_stream *TL_IS_234 = NULL;
text_stream *TL_IS_235 = NULL;
text_stream *TL_IS_236 = NULL;
text_stream *TL_IS_237 = NULL;
text_stream *TL_IS_238 = NULL;
text_stream *TL_IS_239 = NULL;
text_stream *TL_IS_240 = NULL;
text_stream *TL_IS_241 = NULL;
text_stream *TL_IS_242 = NULL;
text_stream *TL_IS_243 = NULL;
text_stream *TL_IS_244 = NULL;
text_stream *TL_IS_245 = NULL;
text_stream *TL_IS_246 = NULL;
text_stream *TL_IS_247 = NULL;
text_stream *TL_IS_248 = NULL;
text_stream *TL_IS_249 = NULL;
text_stream *TL_IS_250 = NULL;
text_stream *TL_IS_251 = NULL;
text_stream *TL_IS_252 = NULL;
text_stream *TL_IS_253 = NULL;
text_stream *TL_IS_254 = NULL;
text_stream *TL_IS_255 = NULL;
text_stream *TL_IS_256 = NULL;
text_stream *TL_IS_257 = NULL;
text_stream *TL_IS_258 = NULL;
text_stream *TL_IS_259 = NULL;
text_stream *TL_IS_260 = NULL;
text_stream *TL_IS_261 = NULL;
text_stream *TL_IS_262 = NULL;
text_stream *TL_IS_263 = NULL;
text_stream *TL_IS_264 = NULL;
text_stream *TL_IS_265 = NULL;
text_stream *TL_IS_266 = NULL;
text_stream *TL_IS_267 = NULL;
text_stream *TL_IS_268 = NULL;
text_stream *TL_IS_269 = NULL;
text_stream *TL_IS_270 = NULL;
text_stream *TL_IS_271 = NULL;
text_stream *TL_IS_272 = NULL;
text_stream *TL_IS_273 = NULL;
text_stream *TL_IS_274 = NULL;
text_stream *TL_IS_275 = NULL;
text_stream *TL_IS_276 = NULL;
text_stream *TL_IS_277 = NULL;
text_stream *TL_IS_278 = NULL;
text_stream *TL_IS_279 = NULL;
text_stream *TL_IS_280 = NULL;
text_stream *TL_IS_281 = NULL;
text_stream *TL_IS_282 = NULL;
text_stream *TL_IS_283 = NULL;
text_stream *TL_IS_284 = NULL;
text_stream *TL_IS_285 = NULL;
text_stream *TL_IS_286 = NULL;
text_stream *TL_IS_287 = NULL;
text_stream *TL_IS_288 = NULL;
text_stream *TL_IS_289 = NULL;
text_stream *TL_IS_290 = NULL;
text_stream *TL_IS_291 = NULL;
text_stream *TL_IS_292 = NULL;
text_stream *TL_IS_293 = NULL;
text_stream *TL_IS_294 = NULL;
text_stream *TL_IS_295 = NULL;
text_stream *TL_IS_296 = NULL;
text_stream *TL_IS_297 = NULL;
text_stream *TL_IS_298 = NULL;
text_stream *TL_IS_299 = NULL;
text_stream *TL_IS_300 = NULL;
text_stream *TL_IS_301 = NULL;
text_stream *TL_IS_302 = NULL;
text_stream *TL_IS_303 = NULL;
text_stream *TL_IS_304 = NULL;
text_stream *TL_IS_305 = NULL;
text_stream *TL_IS_306 = NULL;
text_stream *TL_IS_307 = NULL;
text_stream *TL_IS_308 = NULL;
text_stream *TL_IS_309 = NULL;
text_stream *TL_IS_310 = NULL;
text_stream *TL_IS_311 = NULL;
text_stream *TL_IS_312 = NULL;
text_stream *TL_IS_313 = NULL;
text_stream *TL_IS_314 = NULL;
text_stream *TL_IS_315 = NULL;
text_stream *TL_IS_316 = NULL;
text_stream *TL_IS_317 = NULL;
text_stream *TL_IS_318 = NULL;
text_stream *TL_IS_319 = NULL;
text_stream *TL_IS_320 = NULL;
text_stream *TL_IS_321 = NULL;
text_stream *TL_IS_322 = NULL;
text_stream *TL_IS_323 = NULL;
text_stream *TL_IS_324 = NULL;
text_stream *TL_IS_325 = NULL;
text_stream *TL_IS_326 = NULL;
text_stream *TL_IS_327 = NULL;
text_stream *TL_IS_328 = NULL;
text_stream *TL_IS_329 = NULL;
text_stream *TL_IS_330 = NULL;
text_stream *TL_IS_331 = NULL;
text_stream *TL_IS_332 = NULL;
text_stream *TL_IS_333 = NULL;
text_stream *TL_IS_334 = NULL;
text_stream *TL_IS_335 = NULL;
text_stream *TL_IS_336 = NULL;
text_stream *TL_IS_337 = NULL;
text_stream *TL_IS_338 = NULL;
text_stream *TL_IS_339 = NULL;
text_stream *TL_IS_340 = NULL;
text_stream *TL_IS_341 = NULL;
text_stream *TL_IS_342 = NULL;
text_stream *TL_IS_343 = NULL;
text_stream *TL_IS_344 = NULL;
text_stream *TL_IS_345 = NULL;
text_stream *TL_IS_346 = NULL;
text_stream *TL_IS_347 = NULL;
text_stream *TL_IS_348 = NULL;
text_stream *TL_IS_349 = NULL;
text_stream *TL_IS_350 = NULL;
text_stream *TL_IS_351 = NULL;
text_stream *TL_IS_352 = NULL;
text_stream *TL_IS_353 = NULL;
text_stream *TL_IS_354 = NULL;
text_stream *TL_IS_355 = NULL;
text_stream *TL_IS_356 = NULL;
text_stream *TL_IS_357 = NULL;
text_stream *TL_IS_358 = NULL;
text_stream *TL_IS_359 = NULL;
text_stream *TL_IS_360 = NULL;
text_stream *TL_IS_361 = NULL;
text_stream *TL_IS_362 = NULL;
text_stream *TL_IS_363 = NULL;
text_stream *TL_IS_364 = NULL;
text_stream *TL_IS_365 = NULL;
text_stream *TL_IS_366 = NULL;
text_stream *TL_IS_367 = NULL;
text_stream *TL_IS_368 = NULL;
text_stream *TL_IS_369 = NULL;
text_stream *TL_IS_370 = NULL;
text_stream *TL_IS_371 = NULL;
text_stream *TL_IS_372 = NULL;
text_stream *TL_IS_373 = NULL;
text_stream *TL_IS_374 = NULL;
text_stream *TL_IS_375 = NULL;
text_stream *TL_IS_376 = NULL;
text_stream *TL_IS_377 = NULL;
text_stream *TL_IS_378 = NULL;
text_stream *TL_IS_379 = NULL;
text_stream *TL_IS_380 = NULL;
text_stream *TL_IS_381 = NULL;
text_stream *TL_IS_382 = NULL;
text_stream *TL_IS_383 = NULL;
text_stream *TL_IS_384 = NULL;
text_stream *TL_IS_385 = NULL;
text_stream *TL_IS_386 = NULL;
text_stream *TL_IS_387 = NULL;
text_stream *TL_IS_388 = NULL;
text_stream *TL_IS_389 = NULL;
text_stream *TL_IS_390 = NULL;
text_stream *TL_IS_391 = NULL;
text_stream *TL_IS_392 = NULL;
text_stream *TL_IS_393 = NULL;
text_stream *TL_IS_394 = NULL;
text_stream *TL_IS_395 = NULL;
text_stream *TL_IS_396 = NULL;
text_stream *TL_IS_397 = NULL;
text_stream *TL_IS_398 = NULL;
text_stream *TL_IS_399 = NULL;
text_stream *TL_IS_400 = NULL;
text_stream *TL_IS_401 = NULL;
text_stream *TL_IS_402 = NULL;
text_stream *TL_IS_403 = NULL;
text_stream *TL_IS_404 = NULL;
text_stream *TL_IS_405 = NULL;
text_stream *TL_IS_406 = NULL;
text_stream *TL_IS_407 = NULL;
text_stream *TL_IS_408 = NULL;
text_stream *TL_IS_409 = NULL;
text_stream *TL_IS_410 = NULL;
text_stream *TL_IS_411 = NULL;
text_stream *TL_IS_412 = NULL;
text_stream *TL_IS_413 = NULL;
text_stream *TL_IS_414 = NULL;
text_stream *TL_IS_415 = NULL;
text_stream *TL_IS_416 = NULL;
text_stream *TL_IS_417 = NULL;
text_stream *TL_IS_418 = NULL;
text_stream *TL_IS_419 = NULL;
text_stream *TL_IS_420 = NULL;
text_stream *TL_IS_421 = NULL;
text_stream *TL_IS_422 = NULL;
text_stream *TL_IS_423 = NULL;
text_stream *TL_IS_424 = NULL;
text_stream *TL_IS_425 = NULL;
text_stream *TL_IS_426 = NULL;
text_stream *TL_IS_427 = NULL;
text_stream *TL_IS_428 = NULL;
text_stream *TL_IS_429 = NULL;
text_stream *TL_IS_430 = NULL;
text_stream *TL_IS_431 = NULL;
text_stream *TL_IS_432 = NULL;
text_stream *TL_IS_433 = NULL;
text_stream *TL_IS_434 = NULL;
text_stream *TL_IS_435 = NULL;
text_stream *TL_IS_436 = NULL;
text_stream *TL_IS_437 = NULL;
text_stream *TL_IS_438 = NULL;
text_stream *TL_IS_439 = NULL;
text_stream *TL_IS_440 = NULL;
text_stream *TL_IS_441 = NULL;
text_stream *TL_IS_442 = NULL;
text_stream *TL_IS_443 = NULL;
text_stream *TL_IS_444 = NULL;
text_stream *TL_IS_445 = NULL;
text_stream *TL_IS_446 = NULL;
text_stream *TL_IS_447 = NULL;
text_stream *TL_IS_448 = NULL;
text_stream *TL_IS_449 = NULL;
text_stream *TL_IS_450 = NULL;
text_stream *TL_IS_451 = NULL;
text_stream *TL_IS_452 = NULL;
text_stream *TL_IS_453 = NULL;
text_stream *TL_IS_454 = NULL;
text_stream *TL_IS_455 = NULL;
text_stream *TL_IS_456 = NULL;
text_stream *TL_IS_457 = NULL;
text_stream *TL_IS_458 = NULL;
text_stream *TL_IS_459 = NULL;
text_stream *TL_IS_460 = NULL;
text_stream *TL_IS_461 = NULL;
text_stream *TL_IS_462 = NULL;
text_stream *TL_IS_463 = NULL;
text_stream *TL_IS_464 = NULL;
text_stream *TL_IS_465 = NULL;
text_stream *TL_IS_466 = NULL;
text_stream *TL_IS_467 = NULL;
text_stream *TL_IS_468 = NULL;
text_stream *TL_IS_469 = NULL;
text_stream *TL_IS_470 = NULL;
text_stream *TL_IS_471 = NULL;
text_stream *TL_IS_472 = NULL;
text_stream *TL_IS_473 = NULL;
text_stream *TL_IS_474 = NULL;
text_stream *TL_IS_475 = NULL;
text_stream *TL_IS_476 = NULL;
text_stream *TL_IS_477 = NULL;
text_stream *TL_IS_478 = NULL;
text_stream *TL_IS_479 = NULL;
text_stream *TL_IS_480 = NULL;
text_stream *TL_IS_481 = NULL;
text_stream *TL_IS_482 = NULL;
text_stream *TL_IS_483 = NULL;
text_stream *TL_IS_484 = NULL;
text_stream *TL_IS_485 = NULL;
text_stream *TL_IS_486 = NULL;
text_stream *TL_IS_487 = NULL;
text_stream *TL_IS_488 = NULL;
text_stream *TL_IS_489 = NULL;
text_stream *TL_IS_490 = NULL;
text_stream *TL_IS_491 = NULL;
text_stream *TL_IS_492 = NULL;
text_stream *TL_IS_493 = NULL;
text_stream *TL_IS_494 = NULL;
text_stream *TL_IS_495 = NULL;
text_stream *TL_IS_496 = NULL;
text_stream *TL_IS_497 = NULL;
text_stream *TL_IS_498 = NULL;
text_stream *TL_IS_499 = NULL;
text_stream *TL_IS_500 = NULL;
text_stream *TL_IS_501 = NULL;
text_stream *TL_IS_502 = NULL;
text_stream *TL_IS_503 = NULL;
text_stream *TL_IS_504 = NULL;
text_stream *TL_IS_505 = NULL;
text_stream *TL_IS_506 = NULL;
text_stream *TL_IS_507 = NULL;
text_stream *TL_IS_508 = NULL;
text_stream *TL_IS_509 = NULL;
text_stream *TL_IS_510 = NULL;
text_stream *TL_IS_511 = NULL;
text_stream *TL_IS_512 = NULL;
text_stream *TL_IS_513 = NULL;
text_stream *TL_IS_514 = NULL;
text_stream *TL_IS_515 = NULL;
text_stream *TL_IS_516 = NULL;
text_stream *TL_IS_517 = NULL;
text_stream *TL_IS_518 = NULL;
text_stream *TL_IS_519 = NULL;
text_stream *TL_IS_520 = NULL;
text_stream *TL_IS_521 = NULL;
text_stream *TL_IS_522 = NULL;
text_stream *TL_IS_523 = NULL;
text_stream *TL_IS_524 = NULL;
text_stream *TL_IS_525 = NULL;
text_stream *TL_IS_526 = NULL;
text_stream *TL_IS_527 = NULL;
text_stream *TL_IS_528 = NULL;
text_stream *TL_IS_529 = NULL;
text_stream *TL_IS_530 = NULL;
text_stream *TL_IS_531 = NULL;
text_stream *TL_IS_532 = NULL;
text_stream *TL_IS_533 = NULL;
text_stream *TL_IS_534 = NULL;
text_stream *TL_IS_535 = NULL;
text_stream *TL_IS_536 = NULL;
text_stream *TL_IS_537 = NULL;
text_stream *TL_IS_538 = NULL;
text_stream *TL_IS_539 = NULL;
text_stream *TL_IS_540 = NULL;
text_stream *TL_IS_541 = NULL;
text_stream *TL_IS_542 = NULL;
text_stream *TL_IS_543 = NULL;
text_stream *TL_IS_544 = NULL;
text_stream *TL_IS_545 = NULL;
text_stream *TL_IS_546 = NULL;
text_stream *TL_IS_547 = NULL;
text_stream *TL_IS_548 = NULL;
text_stream *TL_IS_549 = NULL;
text_stream *TL_IS_550 = NULL;
text_stream *TL_IS_551 = NULL;
text_stream *TL_IS_552 = NULL;
text_stream *TL_IS_553 = NULL;
text_stream *TL_IS_554 = NULL;
text_stream *TL_IS_555 = NULL;
text_stream *TL_IS_556 = NULL;
text_stream *TL_IS_557 = NULL;
text_stream *TL_IS_558 = NULL;
text_stream *TL_IS_559 = NULL;
text_stream *TL_IS_560 = NULL;
text_stream *TL_IS_561 = NULL;
text_stream *TL_IS_562 = NULL;
text_stream *TL_IS_563 = NULL;
text_stream *TL_IS_564 = NULL;
text_stream *TL_IS_565 = NULL;
text_stream *TL_IS_566 = NULL;
text_stream *TL_IS_567 = NULL;
text_stream *TL_IS_568 = NULL;
text_stream *TL_IS_569 = NULL;
text_stream *TL_IS_570 = NULL;
text_stream *TL_IS_571 = NULL;
text_stream *TL_IS_572 = NULL;
text_stream *TL_IS_573 = NULL;
text_stream *TL_IS_574 = NULL;
text_stream *TL_IS_575 = NULL;
text_stream *TL_IS_576 = NULL;
text_stream *TL_IS_577 = NULL;
text_stream *TL_IS_578 = NULL;
text_stream *TL_IS_579 = NULL;
text_stream *TL_IS_580 = NULL;
text_stream *TL_IS_581 = NULL;
text_stream *TL_IS_582 = NULL;
text_stream *TL_IS_583 = NULL;
text_stream *TL_IS_584 = NULL;
text_stream *TL_IS_585 = NULL;
text_stream *TL_IS_586 = NULL;
text_stream *TL_IS_587 = NULL;
text_stream *TL_IS_588 = NULL;
text_stream *TL_IS_589 = NULL;
text_stream *TL_IS_590 = NULL;
text_stream *TL_IS_591 = NULL;
text_stream *TL_IS_592 = NULL;
text_stream *TL_IS_593 = NULL;
text_stream *TL_IS_594 = NULL;
text_stream *TL_IS_595 = NULL;
text_stream *TL_IS_596 = NULL;
text_stream *TL_IS_597 = NULL;
text_stream *TL_IS_598 = NULL;
text_stream *TL_IS_599 = NULL;
text_stream *TL_IS_600 = NULL;
text_stream *TL_IS_601 = NULL;
text_stream *TL_IS_602 = NULL;
text_stream *TL_IS_603 = NULL;
text_stream *TL_IS_604 = NULL;
text_stream *TL_IS_605 = NULL;
text_stream *TL_IS_606 = NULL;
text_stream *TL_IS_607 = NULL;
text_stream *TL_IS_608 = NULL;
text_stream *TL_IS_609 = NULL;
text_stream *TL_IS_610 = NULL;
text_stream *TL_IS_611 = NULL;
text_stream *TL_IS_612 = NULL;
text_stream *TL_IS_613 = NULL;
text_stream *TL_IS_614 = NULL;
text_stream *TL_IS_615 = NULL;
text_stream *TL_IS_616 = NULL;
text_stream *TL_IS_617 = NULL;
text_stream *TL_IS_618 = NULL;
text_stream *TL_IS_619 = NULL;
text_stream *TL_IS_620 = NULL;
text_stream *TL_IS_621 = NULL;
text_stream *TL_IS_622 = NULL;
text_stream *TL_IS_623 = NULL;
text_stream *TL_IS_624 = NULL;
text_stream *TL_IS_625 = NULL;
text_stream *TL_IS_626 = NULL;
text_stream *TL_IS_627 = NULL;
text_stream *TL_IS_628 = NULL;
text_stream *TL_IS_629 = NULL;
text_stream *TL_IS_630 = NULL;
text_stream *TL_IS_631 = NULL;
text_stream *TL_IS_632 = NULL;
text_stream *TL_IS_633 = NULL;
text_stream *TL_IS_634 = NULL;
text_stream *TL_IS_635 = NULL;
text_stream *TL_IS_636 = NULL;
text_stream *TL_IS_637 = NULL;
text_stream *TL_IS_638 = NULL;
text_stream *TL_IS_639 = NULL;
text_stream *TL_IS_640 = NULL;
text_stream *TL_IS_641 = NULL;
text_stream *TL_IS_642 = NULL;
text_stream *TL_IS_643 = NULL;
text_stream *TL_IS_644 = NULL;
text_stream *TL_IS_645 = NULL;
text_stream *TL_IS_646 = NULL;
text_stream *TL_IS_647 = NULL;
text_stream *TL_IS_648 = NULL;
text_stream *TL_IS_649 = NULL;
text_stream *TL_IS_650 = NULL;
text_stream *TL_IS_651 = NULL;
text_stream *TL_IS_652 = NULL;
text_stream *TL_IS_653 = NULL;
text_stream *TL_IS_654 = NULL;
text_stream *TL_IS_655 = NULL;
text_stream *TL_IS_656 = NULL;
text_stream *TL_IS_657 = NULL;
text_stream *TL_IS_658 = NULL;
text_stream *TL_IS_659 = NULL;
text_stream *TL_IS_660 = NULL;
text_stream *TL_IS_661 = NULL;
text_stream *TL_IS_662 = NULL;
text_stream *TL_IS_663 = NULL;
text_stream *TL_IS_664 = NULL;
text_stream *TL_IS_665 = NULL;
text_stream *TL_IS_666 = NULL;
text_stream *TL_IS_667 = NULL;
text_stream *TL_IS_668 = NULL;
text_stream *TL_IS_669 = NULL;
text_stream *TL_IS_670 = NULL;
text_stream *TL_IS_671 = NULL;
text_stream *TL_IS_672 = NULL;
text_stream *TL_IS_673 = NULL;
text_stream *TL_IS_674 = NULL;
text_stream *TL_IS_675 = NULL;
text_stream *TL_IS_676 = NULL;
text_stream *TL_IS_677 = NULL;
text_stream *TL_IS_678 = NULL;
text_stream *TL_IS_679 = NULL;
text_stream *TL_IS_680 = NULL;
text_stream *TL_IS_681 = NULL;
text_stream *TL_IS_682 = NULL;
text_stream *TL_IS_683 = NULL;
text_stream *TL_IS_684 = NULL;
text_stream *TL_IS_685 = NULL;
text_stream *TL_IS_686 = NULL;
text_stream *TL_IS_687 = NULL;
text_stream *TL_IS_688 = NULL;
text_stream *TL_IS_689 = NULL;
text_stream *TL_IS_690 = NULL;
text_stream *TL_IS_691 = NULL;
text_stream *TL_IS_692 = NULL;
text_stream *TL_IS_693 = NULL;
text_stream *TL_IS_694 = NULL;
text_stream *TL_IS_695 = NULL;
text_stream *TL_IS_696 = NULL;
text_stream *TL_IS_697 = NULL;
text_stream *TL_IS_698 = NULL;
text_stream *TL_IS_699 = NULL;
text_stream *TL_IS_700 = NULL;
text_stream *TL_IS_701 = NULL;
text_stream *TL_IS_702 = NULL;
text_stream *TL_IS_703 = NULL;
text_stream *TL_IS_704 = NULL;
text_stream *TL_IS_705 = NULL;
text_stream *TL_IS_706 = NULL;
text_stream *TL_IS_707 = NULL;
text_stream *TL_IS_708 = NULL;
text_stream *TL_IS_709 = NULL;
text_stream *TL_IS_710 = NULL;
text_stream *TL_IS_711 = NULL;
text_stream *TL_IS_712 = NULL;
text_stream *TL_IS_713 = NULL;
text_stream *TL_IS_714 = NULL;
text_stream *TL_IS_715 = NULL;
text_stream *TL_IS_716 = NULL;
text_stream *TL_IS_717 = NULL;
text_stream *TL_IS_718 = NULL;
text_stream *TL_IS_719 = NULL;
text_stream *TL_IS_720 = NULL;
text_stream *TL_IS_721 = NULL;
text_stream *TL_IS_722 = NULL;
text_stream *TL_IS_723 = NULL;
text_stream *TL_IS_724 = NULL;
text_stream *TL_IS_725 = NULL;
text_stream *TL_IS_726 = NULL;
text_stream *TL_IS_727 = NULL;
text_stream *TL_IS_728 = NULL;
text_stream *TL_IS_729 = NULL;
text_stream *TL_IS_730 = NULL;
text_stream *TL_IS_731 = NULL;
text_stream *TL_IS_732 = NULL;
text_stream *TL_IS_733 = NULL;
text_stream *TL_IS_734 = NULL;
text_stream *TL_IS_735 = NULL;
text_stream *TL_IS_736 = NULL;
text_stream *TL_IS_737 = NULL;
text_stream *TL_IS_738 = NULL;
text_stream *TL_IS_739 = NULL;
text_stream *TL_IS_740 = NULL;
text_stream *TL_IS_741 = NULL;
text_stream *TL_IS_742 = NULL;
text_stream *TL_IS_743 = NULL;
text_stream *TL_IS_744 = NULL;
text_stream *TL_IS_745 = NULL;
text_stream *TL_IS_746 = NULL;
text_stream *TL_IS_747 = NULL;
text_stream *TL_IS_748 = NULL;
text_stream *TL_IS_749 = NULL;
text_stream *TL_IS_750 = NULL;
text_stream *TL_IS_751 = NULL;
text_stream *TL_IS_752 = NULL;
text_stream *TL_IS_753 = NULL;
text_stream *TL_IS_754 = NULL;
text_stream *TL_IS_755 = NULL;
text_stream *TL_IS_756 = NULL;
text_stream *TL_IS_757 = NULL;
text_stream *TL_IS_758 = NULL;
text_stream *TL_IS_759 = NULL;
text_stream *TL_IS_760 = NULL;
text_stream *TL_IS_761 = NULL;
text_stream *TL_IS_762 = NULL;
text_stream *TL_IS_763 = NULL;
text_stream *TL_IS_764 = NULL;
text_stream *TL_IS_765 = NULL;
text_stream *TL_IS_766 = NULL;
text_stream *TL_IS_767 = NULL;
text_stream *TL_IS_768 = NULL;
text_stream *TL_IS_769 = NULL;
text_stream *TL_IS_770 = NULL;
text_stream *TL_IS_771 = NULL;
text_stream *TL_IS_772 = NULL;
text_stream *TL_IS_773 = NULL;
text_stream *TL_IS_774 = NULL;
text_stream *TL_IS_775 = NULL;
text_stream *TL_IS_776 = NULL;
text_stream *TL_IS_777 = NULL;
text_stream *TL_IS_778 = NULL;
text_stream *TL_IS_779 = NULL;
text_stream *TL_IS_780 = NULL;
text_stream *TL_IS_781 = NULL;
text_stream *TL_IS_782 = NULL;
text_stream *TL_IS_783 = NULL;
text_stream *TL_IS_784 = NULL;
text_stream *TL_IS_785 = NULL;
text_stream *TL_IS_786 = NULL;
text_stream *TL_IS_787 = NULL;
text_stream *TL_IS_788 = NULL;
text_stream *TL_IS_789 = NULL;
text_stream *TL_IS_790 = NULL;
text_stream *TL_IS_791 = NULL;
text_stream *TL_IS_792 = NULL;
text_stream *TL_IS_793 = NULL;
text_stream *TL_IS_794 = NULL;
text_stream *TL_IS_795 = NULL;
text_stream *TL_IS_796 = NULL;
text_stream *TL_IS_797 = NULL;
text_stream *TL_IS_798 = NULL;
text_stream *TL_IS_799 = NULL;
text_stream *TL_IS_800 = NULL;
text_stream *TL_IS_801 = NULL;
text_stream *TL_IS_802 = NULL;
text_stream *TL_IS_803 = NULL;
text_stream *TL_IS_804 = NULL;
text_stream *TL_IS_805 = NULL;
text_stream *TL_IS_806 = NULL;
text_stream *TL_IS_807 = NULL;
text_stream *TL_IS_808 = NULL;
text_stream *TL_IS_809 = NULL;
text_stream *TL_IS_810 = NULL;
text_stream *TL_IS_811 = NULL;
text_stream *TL_IS_812 = NULL;
text_stream *TL_IS_813 = NULL;
text_stream *TL_IS_814 = NULL;
text_stream *TL_IS_815 = NULL;
text_stream *TL_IS_816 = NULL;
text_stream *TL_IS_817 = NULL;
text_stream *TL_IS_818 = NULL;
text_stream *TL_IS_819 = NULL;
text_stream *TL_IS_820 = NULL;
text_stream *TL_IS_821 = NULL;
text_stream *TL_IS_822 = NULL;
text_stream *TL_IS_823 = NULL;
text_stream *TL_IS_824 = NULL;
text_stream *TL_IS_825 = NULL;
text_stream *TL_IS_826 = NULL;
text_stream *TL_IS_827 = NULL;
text_stream *TL_IS_828 = NULL;
text_stream *TL_IS_829 = NULL;
text_stream *TL_IS_830 = NULL;
text_stream *TL_IS_831 = NULL;
text_stream *TL_IS_832 = NULL;
text_stream *TL_IS_833 = NULL;
text_stream *TL_IS_834 = NULL;
text_stream *TL_IS_835 = NULL;
text_stream *TL_IS_836 = NULL;
text_stream *TL_IS_837 = NULL;
text_stream *TL_IS_838 = NULL;
text_stream *TL_IS_839 = NULL;
text_stream *TL_IS_840 = NULL;
text_stream *TL_IS_841 = NULL;
text_stream *TL_IS_842 = NULL;
text_stream *TL_IS_843 = NULL;
text_stream *TL_IS_844 = NULL;
text_stream *TL_IS_845 = NULL;
text_stream *TL_IS_846 = NULL;
text_stream *TL_IS_847 = NULL;
text_stream *TL_IS_848 = NULL;
text_stream *TL_IS_849 = NULL;
text_stream *TL_IS_850 = NULL;
text_stream *TL_IS_851 = NULL;
text_stream *TL_IS_852 = NULL;
text_stream *TL_IS_853 = NULL;
text_stream *TL_IS_854 = NULL;
text_stream *TL_IS_855 = NULL;
text_stream *TL_IS_856 = NULL;
text_stream *TL_IS_857 = NULL;
text_stream *TL_IS_858 = NULL;
text_stream *TL_IS_859 = NULL;
text_stream *TL_IS_860 = NULL;
text_stream *TL_IS_861 = NULL;
text_stream *TL_IS_862 = NULL;
text_stream *TL_IS_863 = NULL;
text_stream *TL_IS_864 = NULL;
text_stream *TL_IS_865 = NULL;
text_stream *TL_IS_866 = NULL;
text_stream *TL_IS_867 = NULL;
text_stream *TL_IS_868 = NULL;
text_stream *TL_IS_869 = NULL;
text_stream *TL_IS_870 = NULL;
text_stream *TL_IS_871 = NULL;
text_stream *TL_IS_872 = NULL;
text_stream *TL_IS_873 = NULL;
text_stream *TL_IS_874 = NULL;
text_stream *TL_IS_875 = NULL;
text_stream *TL_IS_876 = NULL;
text_stream *TL_IS_877 = NULL;
text_stream *TL_IS_878 = NULL;
text_stream *TL_IS_879 = NULL;
text_stream *TL_IS_880 = NULL;
text_stream *TL_IS_881 = NULL;
text_stream *TL_IS_882 = NULL;
text_stream *TL_IS_883 = NULL;
text_stream *TL_IS_884 = NULL;
text_stream *TL_IS_885 = NULL;
text_stream *TL_IS_886 = NULL;
text_stream *TL_IS_887 = NULL;
text_stream *TL_IS_888 = NULL;
text_stream *TL_IS_889 = NULL;
text_stream *TL_IS_890 = NULL;
text_stream *TL_IS_891 = NULL;
text_stream *TL_IS_892 = NULL;
text_stream *TL_IS_893 = NULL;
text_stream *TL_IS_894 = NULL;
text_stream *TL_IS_895 = NULL;
text_stream *TL_IS_896 = NULL;
text_stream *TL_IS_897 = NULL;
text_stream *TL_IS_898 = NULL;
text_stream *TL_IS_899 = NULL;
text_stream *TL_IS_900 = NULL;
text_stream *TL_IS_901 = NULL;
text_stream *TL_IS_902 = NULL;
text_stream *TL_IS_903 = NULL;
text_stream *TL_IS_904 = NULL;
text_stream *TL_IS_905 = NULL;
text_stream *TL_IS_906 = NULL;
text_stream *TL_IS_907 = NULL;
text_stream *TL_IS_908 = NULL;
text_stream *TL_IS_909 = NULL;
text_stream *TL_IS_910 = NULL;
text_stream *TL_IS_911 = NULL;
text_stream *TL_IS_912 = NULL;
text_stream *TL_IS_913 = NULL;
text_stream *TL_IS_914 = NULL;
text_stream *TL_IS_915 = NULL;
text_stream *TL_IS_916 = NULL;
text_stream *TL_IS_917 = NULL;
text_stream *TL_IS_918 = NULL;
text_stream *TL_IS_919 = NULL;
text_stream *TL_IS_920 = NULL;
text_stream *TL_IS_921 = NULL;
text_stream *TL_IS_922 = NULL;
text_stream *TL_IS_923 = NULL;
text_stream *TL_IS_924 = NULL;
text_stream *TL_IS_925 = NULL;
text_stream *TL_IS_926 = NULL;
text_stream *TL_IS_927 = NULL;
text_stream *TL_IS_928 = NULL;
text_stream *TL_IS_929 = NULL;
text_stream *TL_IS_930 = NULL;
text_stream *TL_IS_931 = NULL;
text_stream *TL_IS_932 = NULL;
text_stream *TL_IS_933 = NULL;
text_stream *TL_IS_934 = NULL;
text_stream *TL_IS_935 = NULL;
text_stream *TL_IS_936 = NULL;
text_stream *TL_IS_937 = NULL;
text_stream *TL_IS_938 = NULL;
text_stream *TL_IS_939 = NULL;
text_stream *TL_IS_940 = NULL;
text_stream *TL_IS_941 = NULL;
text_stream *TL_IS_942 = NULL;
text_stream *TL_IS_943 = NULL;
text_stream *TL_IS_944 = NULL;
text_stream *TL_IS_945 = NULL;
text_stream *TL_IS_946 = NULL;
text_stream *TL_IS_947 = NULL;
text_stream *TL_IS_948 = NULL;
text_stream *TL_IS_949 = NULL;
text_stream *TL_IS_950 = NULL;
text_stream *TL_IS_951 = NULL;
text_stream *TL_IS_952 = NULL;
text_stream *TL_IS_953 = NULL;
text_stream *TL_IS_954 = NULL;
text_stream *TL_IS_955 = NULL;
text_stream *TL_IS_956 = NULL;
text_stream *TL_IS_957 = NULL;
text_stream *TL_IS_958 = NULL;
text_stream *TL_IS_959 = NULL;
text_stream *TL_IS_960 = NULL;
text_stream *TL_IS_961 = NULL;
text_stream *TL_IS_962 = NULL;
text_stream *TL_IS_963 = NULL;
text_stream *TL_IS_964 = NULL;
text_stream *TL_IS_965 = NULL;
text_stream *TL_IS_966 = NULL;
text_stream *TL_IS_967 = NULL;
text_stream *TL_IS_968 = NULL;
text_stream *TL_IS_969 = NULL;
text_stream *TL_IS_970 = NULL;
text_stream *TL_IS_971 = NULL;
text_stream *TL_IS_972 = NULL;
text_stream *TL_IS_973 = NULL;
text_stream *TL_IS_974 = NULL;
text_stream *TL_IS_975 = NULL;
text_stream *TL_IS_976 = NULL;
text_stream *TL_IS_977 = NULL;
text_stream *TL_IS_978 = NULL;
text_stream *TL_IS_979 = NULL;
text_stream *TL_IS_980 = NULL;
text_stream *TL_IS_981 = NULL;
text_stream *TL_IS_982 = NULL;
text_stream *TL_IS_983 = NULL;
text_stream *TL_IS_984 = NULL;
text_stream *TL_IS_985 = NULL;
text_stream *TL_IS_986 = NULL;
text_stream *TL_IS_987 = NULL;
text_stream *TL_IS_988 = NULL;
text_stream *TL_IS_989 = NULL;
text_stream *TL_IS_990 = NULL;
text_stream *TL_IS_991 = NULL;
text_stream *TL_IS_992 = NULL;
text_stream *TL_IS_993 = NULL;
text_stream *TL_IS_994 = NULL;
text_stream *TL_IS_995 = NULL;
text_stream *TL_IS_996 = NULL;
text_stream *TL_IS_997 = NULL;
text_stream *TL_IS_998 = NULL;
text_stream *TL_IS_999 = NULL;
text_stream *TL_IS_1000 = NULL;
text_stream *TL_IS_1001 = NULL;
text_stream *TL_IS_1002 = NULL;
text_stream *TL_IS_1003 = NULL;
text_stream *TL_IS_1004 = NULL;
text_stream *TL_IS_1005 = NULL;
text_stream *TL_IS_1006 = NULL;
text_stream *TL_IS_1007 = NULL;
text_stream *TL_IS_1008 = NULL;
text_stream *TL_IS_1009 = NULL;
text_stream *TL_IS_1010 = NULL;
text_stream *TL_IS_1011 = NULL;
text_stream *TL_IS_1012 = NULL;
text_stream *TL_IS_1013 = NULL;
text_stream *TL_IS_1014 = NULL;
text_stream *TL_IS_1015 = NULL;
text_stream *TL_IS_1016 = NULL;
text_stream *TL_IS_1017 = NULL;
text_stream *TL_IS_1018 = NULL;
text_stream *TL_IS_1019 = NULL;
text_stream *TL_IS_1020 = NULL;
text_stream *TL_IS_1021 = NULL;
text_stream *TL_IS_1022 = NULL;
text_stream *TL_IS_1023 = NULL;
text_stream *TL_IS_1024 = NULL;
text_stream *TL_IS_1025 = NULL;
text_stream *TL_IS_1026 = NULL;
text_stream *TL_IS_1027 = NULL;
text_stream *TL_IS_1028 = NULL;
text_stream *TL_IS_1029 = NULL;
text_stream *TL_IS_1030 = NULL;
text_stream *TL_IS_1031 = NULL;
text_stream *TL_IS_1032 = NULL;
text_stream *TL_IS_1033 = NULL;
text_stream *TL_IS_1034 = NULL;
text_stream *TL_IS_1035 = NULL;
text_stream *TL_IS_1036 = NULL;
text_stream *TL_IS_1037 = NULL;
text_stream *TL_IS_1038 = NULL;
text_stream *TL_IS_1039 = NULL;
text_stream *TL_IS_1040 = NULL;
text_stream *TL_IS_1041 = NULL;
text_stream *TL_IS_1042 = NULL;
text_stream *TL_IS_1043 = NULL;
text_stream *TL_IS_1044 = NULL;
text_stream *TL_IS_1045 = NULL;
text_stream *TL_IS_1046 = NULL;
text_stream *TL_IS_1047 = NULL;
text_stream *TL_IS_1048 = NULL;
text_stream *TL_IS_1049 = NULL;
text_stream *TL_IS_1050 = NULL;
text_stream *TL_IS_1051 = NULL;
text_stream *TL_IS_1052 = NULL;
text_stream *TL_IS_1053 = NULL;
text_stream *TL_IS_1054 = NULL;
text_stream *TL_IS_1055 = NULL;
text_stream *TL_IS_1056 = NULL;
text_stream *TL_IS_1057 = NULL;
text_stream *TL_IS_1058 = NULL;
text_stream *TL_IS_1059 = NULL;
text_stream *TL_IS_1060 = NULL;
text_stream *TL_IS_1061 = NULL;
text_stream *TL_IS_1062 = NULL;
text_stream *TL_IS_1063 = NULL;
text_stream *TL_IS_1064 = NULL;
text_stream *TL_IS_1065 = NULL;
text_stream *TL_IS_1066 = NULL;
text_stream *TL_IS_1067 = NULL;
text_stream *TL_IS_1068 = NULL;
text_stream *TL_IS_1069 = NULL;
text_stream *TL_IS_1070 = NULL;
text_stream *TL_IS_1071 = NULL;
text_stream *TL_IS_1072 = NULL;
text_stream *TL_IS_1073 = NULL;
text_stream *TL_IS_1074 = NULL;
text_stream *TL_IS_1075 = NULL;
text_stream *TL_IS_1076 = NULL;
text_stream *TL_IS_1077 = NULL;
text_stream *TL_IS_1078 = NULL;
text_stream *TL_IS_1079 = NULL;
text_stream *TL_IS_1080 = NULL;
text_stream *TL_IS_1081 = NULL;
text_stream *TL_IS_1082 = NULL;
text_stream *TL_IS_1083 = NULL;
text_stream *TL_IS_1084 = NULL;
text_stream *TL_IS_1085 = NULL;
text_stream *TL_IS_1086 = NULL;
text_stream *TL_IS_1087 = NULL;
text_stream *TL_IS_1088 = NULL;
text_stream *TL_IS_1089 = NULL;
text_stream *TL_IS_1090 = NULL;
text_stream *TL_IS_1091 = NULL;
text_stream *TL_IS_1092 = NULL;
text_stream *TL_IS_1093 = NULL;
text_stream *TL_IS_1094 = NULL;
text_stream *TL_IS_1095 = NULL;
text_stream *TL_IS_1096 = NULL;
text_stream *TL_IS_1097 = NULL;
text_stream *TL_IS_1098 = NULL;
text_stream *TL_IS_1099 = NULL;
text_stream *TL_IS_1100 = NULL;
text_stream *TL_IS_1101 = NULL;
text_stream *TL_IS_1102 = NULL;
text_stream *TL_IS_1103 = NULL;
text_stream *TL_IS_1104 = NULL;
text_stream *TL_IS_1105 = NULL;
text_stream *TL_IS_1106 = NULL;
text_stream *TL_IS_1107 = NULL;
text_stream *TL_IS_1108 = NULL;
text_stream *TL_IS_1109 = NULL;
text_stream *TL_IS_1110 = NULL;
text_stream *TL_IS_1111 = NULL;
text_stream *TL_IS_1112 = NULL;
text_stream *TL_IS_1113 = NULL;
text_stream *TL_IS_1114 = NULL;
text_stream *TL_IS_1115 = NULL;
text_stream *TL_IS_1116 = NULL;
text_stream *TL_IS_1117 = NULL;
text_stream *TL_IS_1118 = NULL;
text_stream *TL_IS_1119 = NULL;
text_stream *TL_IS_1120 = NULL;
text_stream *TL_IS_1121 = NULL;
text_stream *TL_IS_1122 = NULL;
text_stream *TL_IS_1123 = NULL;
text_stream *TL_IS_1124 = NULL;
text_stream *TL_IS_1125 = NULL;
text_stream *TL_IS_1126 = NULL;
text_stream *TL_IS_1127 = NULL;
text_stream *TL_IS_1128 = NULL;
text_stream *TL_IS_1129 = NULL;
text_stream *TL_IS_1130 = NULL;
text_stream *TL_IS_1131 = NULL;
text_stream *TL_IS_1132 = NULL;
text_stream *TL_IS_1133 = NULL;
text_stream *TL_IS_1134 = NULL;
text_stream *TL_IS_1135 = NULL;
text_stream *TL_IS_1136 = NULL;
text_stream *TL_IS_1137 = NULL;
text_stream *TL_IS_1138 = NULL;
text_stream *TL_IS_1139 = NULL;
text_stream *TL_IS_1140 = NULL;
text_stream *TL_IS_1141 = NULL;
text_stream *TL_IS_1142 = NULL;
text_stream *TL_IS_1143 = NULL;
text_stream *TL_IS_1144 = NULL;
text_stream *TL_IS_1145 = NULL;
text_stream *TL_IS_1146 = NULL;
text_stream *TL_IS_1147 = NULL;
text_stream *TL_IS_1148 = NULL;
text_stream *TL_IS_1149 = NULL;
text_stream *TL_IS_1150 = NULL;
text_stream *TL_IS_1151 = NULL;
text_stream *TL_IS_1152 = NULL;
text_stream *TL_IS_1153 = NULL;
text_stream *TL_IS_1154 = NULL;
text_stream *TL_IS_1155 = NULL;
text_stream *TL_IS_1156 = NULL;
text_stream *TL_IS_1157 = NULL;
text_stream *TL_IS_1158 = NULL;
text_stream *TL_IS_1159 = NULL;
text_stream *TL_IS_1160 = NULL;
text_stream *TL_IS_1161 = NULL;
text_stream *TL_IS_1162 = NULL;
text_stream *TL_IS_1163 = NULL;
text_stream *TL_IS_1164 = NULL;
text_stream *TL_IS_1165 = NULL;
text_stream *TL_IS_1166 = NULL;
text_stream *TL_IS_1167 = NULL;
text_stream *TL_IS_1168 = NULL;
text_stream *TL_IS_1169 = NULL;
text_stream *TL_IS_1170 = NULL;
text_stream *TL_IS_1171 = NULL;
text_stream *TL_IS_1172 = NULL;
text_stream *TL_IS_1173 = NULL;
text_stream *TL_IS_1174 = NULL;
text_stream *TL_IS_1175 = NULL;
text_stream *TL_IS_1176 = NULL;
text_stream *TL_IS_1177 = NULL;
text_stream *TL_IS_1178 = NULL;
text_stream *TL_IS_1179 = NULL;
text_stream *TL_IS_1180 = NULL;
text_stream *TL_IS_1181 = NULL;
text_stream *TL_IS_1182 = NULL;
text_stream *TL_IS_1183 = NULL;
text_stream *TL_IS_1184 = NULL;
text_stream *TL_IS_1185 = NULL;
text_stream *TL_IS_1186 = NULL;
text_stream *TL_IS_1187 = NULL;
text_stream *TL_IS_1188 = NULL;
text_stream *TL_IS_1189 = NULL;
text_stream *TL_IS_1190 = NULL;
text_stream *TL_IS_1191 = NULL;
text_stream *TL_IS_1192 = NULL;
text_stream *TL_IS_1193 = NULL;
text_stream *TL_IS_1194 = NULL;
text_stream *TL_IS_1195 = NULL;
text_stream *TL_IS_1196 = NULL;
text_stream *TL_IS_1197 = NULL;
text_stream *TL_IS_1198 = NULL;
text_stream *TL_IS_1199 = NULL;
text_stream *TL_IS_1200 = NULL;
text_stream *TL_IS_1201 = NULL;
text_stream *TL_IS_1202 = NULL;
text_stream *TL_IS_1203 = NULL;
text_stream *TL_IS_1204 = NULL;
text_stream *TL_IS_1205 = NULL;
text_stream *TL_IS_1206 = NULL;
text_stream *TL_IS_1207 = NULL;
text_stream *TL_IS_1208 = NULL;
text_stream *TL_IS_1209 = NULL;
text_stream *TL_IS_1210 = NULL;
text_stream *TL_IS_1211 = NULL;
text_stream *TL_IS_1212 = NULL;
text_stream *TL_IS_1213 = NULL;
text_stream *TL_IS_1214 = NULL;
text_stream *TL_IS_1215 = NULL;
text_stream *TL_IS_1216 = NULL;
text_stream *TL_IS_1217 = NULL;
text_stream *TL_IS_1218 = NULL;
text_stream *TL_IS_1219 = NULL;
text_stream *TL_IS_1220 = NULL;
text_stream *TL_IS_1221 = NULL;
text_stream *TL_IS_1222 = NULL;
text_stream *TL_IS_1223 = NULL;
text_stream *TL_IS_1224 = NULL;
text_stream *TL_IS_1225 = NULL;
text_stream *TL_IS_1226 = NULL;
text_stream *TL_IS_1227 = NULL;
text_stream *TL_IS_1228 = NULL;
text_stream *TL_IS_1229 = NULL;
text_stream *TL_IS_1230 = NULL;
text_stream *TL_IS_1231 = NULL;
text_stream *TL_IS_1232 = NULL;
text_stream *TL_IS_1233 = NULL;
text_stream *TL_IS_1234 = NULL;
text_stream *TL_IS_1235 = NULL;
text_stream *TL_IS_1236 = NULL;
text_stream *TL_IS_1237 = NULL;
text_stream *TL_IS_1238 = NULL;
text_stream *TL_IS_1239 = NULL;
text_stream *TL_IS_1240 = NULL;
text_stream *TL_IS_1241 = NULL;
text_stream *TL_IS_1242 = NULL;
text_stream *TL_IS_1243 = NULL;
text_stream *TL_IS_1244 = NULL;
text_stream *TL_IS_1245 = NULL;
text_stream *TL_IS_1246 = NULL;
text_stream *TL_IS_1247 = NULL;
text_stream *TL_IS_1248 = NULL;
text_stream *TL_IS_1249 = NULL;
text_stream *TL_IS_1250 = NULL;
text_stream *TL_IS_1251 = NULL;
text_stream *TL_IS_1252 = NULL;
text_stream *TL_IS_1253 = NULL;
text_stream *TL_IS_1254 = NULL;
text_stream *TL_IS_1255 = NULL;
text_stream *TL_IS_1256 = NULL;
text_stream *TL_IS_1257 = NULL;
text_stream *TL_IS_1258 = NULL;
text_stream *TL_IS_1259 = NULL;
text_stream *TL_IS_1260 = NULL;
text_stream *TL_IS_1261 = NULL;
text_stream *TL_IS_1262 = NULL;
text_stream *TL_IS_1263 = NULL;
text_stream *TL_IS_1264 = NULL;
text_stream *TL_IS_1265 = NULL;
text_stream *TL_IS_1266 = NULL;
text_stream *TL_IS_1267 = NULL;
text_stream *TL_IS_1268 = NULL;
text_stream *TL_IS_1269 = NULL;
text_stream *TL_IS_1270 = NULL;
text_stream *TL_IS_1271 = NULL;
text_stream *TL_IS_1272 = NULL;
text_stream *TL_IS_1273 = NULL;
text_stream *TL_IS_1274 = NULL;
text_stream *TL_IS_1275 = NULL;
text_stream *TL_IS_1276 = NULL;
text_stream *TL_IS_1277 = NULL;
text_stream *TL_IS_1278 = NULL;
text_stream *TL_IS_1279 = NULL;
text_stream *TL_IS_1280 = NULL;
text_stream *TL_IS_1281 = NULL;
text_stream *TL_IS_1282 = NULL;
text_stream *TL_IS_1283 = NULL;
text_stream *TL_IS_1284 = NULL;
text_stream *TL_IS_1285 = NULL;
text_stream *TL_IS_1286 = NULL;
text_stream *TL_IS_1287 = NULL;
text_stream *TL_IS_1288 = NULL;
text_stream *TL_IS_1289 = NULL;
text_stream *TL_IS_1290 = NULL;
text_stream *TL_IS_1291 = NULL;
text_stream *TL_IS_1292 = NULL;
text_stream *TL_IS_1293 = NULL;
text_stream *TL_IS_1294 = NULL;
text_stream *TL_IS_1295 = NULL;
text_stream *TL_IS_1296 = NULL;
text_stream *TL_IS_1297 = NULL;
text_stream *TL_IS_1298 = NULL;
text_stream *TL_IS_1299 = NULL;
text_stream *TL_IS_1300 = NULL;
text_stream *TL_IS_1301 = NULL;
text_stream *TL_IS_1302 = NULL;
text_stream *TL_IS_1303 = NULL;
text_stream *TL_IS_1304 = NULL;
text_stream *TL_IS_1305 = NULL;
text_stream *TL_IS_1306 = NULL;
text_stream *TL_IS_1307 = NULL;
text_stream *TL_IS_1308 = NULL;
text_stream *TL_IS_1309 = NULL;
text_stream *TL_IS_1310 = NULL;
text_stream *TL_IS_1311 = NULL;
text_stream *TL_IS_1312 = NULL;
text_stream *TL_IS_1313 = NULL;
text_stream *TL_IS_1314 = NULL;
text_stream *TL_IS_1315 = NULL;
text_stream *TL_IS_1316 = NULL;
text_stream *TL_IS_1317 = NULL;
text_stream *TL_IS_1318 = NULL;
text_stream *TL_IS_1319 = NULL;
text_stream *TL_IS_1320 = NULL;
text_stream *TL_IS_1321 = NULL;
text_stream *TL_IS_1322 = NULL;
text_stream *TL_IS_1323 = NULL;
text_stream *TL_IS_1324 = NULL;
text_stream *TL_IS_1325 = NULL;
text_stream *TL_IS_1326 = NULL;
text_stream *TL_IS_1327 = NULL;
text_stream *TL_IS_1328 = NULL;
text_stream *TL_IS_1329 = NULL;
text_stream *TL_IS_1330 = NULL;
text_stream *TL_IS_1331 = NULL;
text_stream *TL_IS_1332 = NULL;
text_stream *TL_IS_1333 = NULL;
text_stream *TL_IS_1334 = NULL;
text_stream *TL_IS_1335 = NULL;
text_stream *TL_IS_1336 = NULL;
text_stream *TL_IS_1337 = NULL;
text_stream *TL_IS_1338 = NULL;
text_stream *TL_IS_1339 = NULL;
text_stream *TL_IS_1340 = NULL;
text_stream *TL_IS_1341 = NULL;
text_stream *TL_IS_1342 = NULL;
text_stream *TL_IS_1343 = NULL;
text_stream *TL_IS_1344 = NULL;
text_stream *TL_IS_1345 = NULL;
text_stream *TL_IS_1346 = NULL;
text_stream *TL_IS_1347 = NULL;
text_stream *TL_IS_1348 = NULL;
text_stream *TL_IS_1349 = NULL;
text_stream *TL_IS_1350 = NULL;
text_stream *TL_IS_1351 = NULL;
text_stream *TL_IS_1352 = NULL;
text_stream *TL_IS_1353 = NULL;
text_stream *TL_IS_1354 = NULL;
text_stream *TL_IS_1355 = NULL;
text_stream *TL_IS_1356 = NULL;
text_stream *TL_IS_1357 = NULL;
text_stream *TL_IS_1358 = NULL;
text_stream *TL_IS_1359 = NULL;
text_stream *TL_IS_1360 = NULL;
text_stream *TL_IS_1361 = NULL;
text_stream *TL_IS_1362 = NULL;
text_stream *TL_IS_1363 = NULL;
text_stream *TL_IS_1364 = NULL;
text_stream *TL_IS_1365 = NULL;
text_stream *TL_IS_1366 = NULL;
text_stream *TL_IS_1367 = NULL;
text_stream *TL_IS_1368 = NULL;
text_stream *TL_IS_1369 = NULL;
text_stream *TL_IS_1370 = NULL;
text_stream *TL_IS_1371 = NULL;
text_stream *TL_IS_1372 = NULL;
text_stream *TL_IS_1373 = NULL;
text_stream *TL_IS_1374 = NULL;
text_stream *TL_IS_1375 = NULL;
text_stream *TL_IS_1376 = NULL;
text_stream *TL_IS_1377 = NULL;
text_stream *TL_IS_1378 = NULL;
text_stream *TL_IS_1379 = NULL;
text_stream *TL_IS_1380 = NULL;
text_stream *TL_IS_1381 = NULL;
text_stream *TL_IS_1382 = NULL;
text_stream *TL_IS_1383 = NULL;
text_stream *TL_IS_1384 = NULL;
text_stream *TL_IS_1385 = NULL;
text_stream *TL_IS_1386 = NULL;
text_stream *TL_IS_1387 = NULL;
text_stream *TL_IS_1388 = NULL;
text_stream *TL_IS_1389 = NULL;
text_stream *TL_IS_1390 = NULL;
text_stream *TL_IS_1391 = NULL;
text_stream *TL_IS_1392 = NULL;
text_stream *TL_IS_1393 = NULL;
text_stream *TL_IS_1394 = NULL;
text_stream *TL_IS_1395 = NULL;
text_stream *TL_IS_1396 = NULL;
text_stream *TL_IS_1397 = NULL;
text_stream *TL_IS_1398 = NULL;
text_stream *TL_IS_1399 = NULL;
text_stream *TL_IS_1400 = NULL;
text_stream *TL_IS_1401 = NULL;
text_stream *TL_IS_1402 = NULL;
text_stream *TL_IS_1403 = NULL;
text_stream *TL_IS_1404 = NULL;
text_stream *TL_IS_1405 = NULL;
text_stream *TL_IS_1406 = NULL;
text_stream *TL_IS_1407 = NULL;
text_stream *TL_IS_1408 = NULL;
text_stream *TL_IS_1409 = NULL;
text_stream *TL_IS_1410 = NULL;
text_stream *TL_IS_1411 = NULL;
text_stream *TL_IS_1412 = NULL;
text_stream *TL_IS_1413 = NULL;
text_stream *TL_IS_1414 = NULL;
text_stream *TL_IS_1415 = NULL;
text_stream *TL_IS_1416 = NULL;
text_stream *TL_IS_1417 = NULL;
text_stream *TL_IS_1418 = NULL;
text_stream *TL_IS_1419 = NULL;
text_stream *TL_IS_1420 = NULL;
text_stream *TL_IS_1421 = NULL;
text_stream *TL_IS_1422 = NULL;
text_stream *TL_IS_1423 = NULL;
text_stream *TL_IS_1424 = NULL;
text_stream *TL_IS_1425 = NULL;
text_stream *TL_IS_1426 = NULL;
text_stream *TL_IS_1427 = NULL;
text_stream *TL_IS_1428 = NULL;
text_stream *TL_IS_1429 = NULL;
text_stream *TL_IS_1430 = NULL;
text_stream *TL_IS_1431 = NULL;
text_stream *TL_IS_1432 = NULL;
text_stream *TL_IS_1433 = NULL;
text_stream *TL_IS_1434 = NULL;
text_stream *TL_IS_1435 = NULL;
text_stream *TL_IS_1436 = NULL;
text_stream *TL_IS_1437 = NULL;
text_stream *TL_IS_1438 = NULL;
text_stream *TL_IS_1439 = NULL;
text_stream *TL_IS_1440 = NULL;
text_stream *TL_IS_1441 = NULL;
text_stream *TL_IS_1442 = NULL;
text_stream *TL_IS_1443 = NULL;
text_stream *TL_IS_1444 = NULL;
text_stream *TL_IS_1445 = NULL;
text_stream *TL_IS_1446 = NULL;
text_stream *TL_IS_1447 = NULL;
text_stream *TL_IS_1448 = NULL;
text_stream *TL_IS_1449 = NULL;
text_stream *TL_IS_1450 = NULL;
text_stream *TL_IS_1451 = NULL;
text_stream *TL_IS_1452 = NULL;
text_stream *TL_IS_1453 = NULL;
text_stream *TL_IS_1454 = NULL;
text_stream *TL_IS_1455 = NULL;
text_stream *TL_IS_1456 = NULL;
text_stream *TL_IS_1457 = NULL;
text_stream *TL_IS_1458 = NULL;
text_stream *TL_IS_1459 = NULL;
text_stream *TL_IS_1460 = NULL;
text_stream *TL_IS_1461 = NULL;
text_stream *TL_IS_1462 = NULL;
text_stream *TL_IS_1463 = NULL;
text_stream *TL_IS_1464 = NULL;
text_stream *TL_IS_1465 = NULL;
text_stream *TL_IS_1466 = NULL;
text_stream *TL_IS_1467 = NULL;
text_stream *TL_IS_1468 = NULL;
text_stream *TL_IS_1469 = NULL;
text_stream *TL_IS_1470 = NULL;
text_stream *TL_IS_1471 = NULL;
text_stream *TL_IS_1472 = NULL;
text_stream *TL_IS_1473 = NULL;
text_stream *TL_IS_1474 = NULL;
text_stream *TL_IS_1475 = NULL;
text_stream *TL_IS_1476 = NULL;
text_stream *TL_IS_1477 = NULL;
text_stream *TL_IS_1478 = NULL;
text_stream *TL_IS_1479 = NULL;
text_stream *TL_IS_1480 = NULL;
text_stream *TL_IS_1481 = NULL;
text_stream *TL_IS_1482 = NULL;
text_stream *TL_IS_1483 = NULL;
text_stream *TL_IS_1484 = NULL;
text_stream *TL_IS_1485 = NULL;
text_stream *TL_IS_1486 = NULL;
text_stream *TL_IS_1487 = NULL;
text_stream *TL_IS_1488 = NULL;
text_stream *TL_IS_1489 = NULL;
text_stream *TL_IS_1490 = NULL;
text_stream *TL_IS_1491 = NULL;
text_stream *TL_IS_1492 = NULL;
text_stream *TL_IS_1493 = NULL;
text_stream *TL_IS_1494 = NULL;
text_stream *TL_IS_1495 = NULL;
text_stream *TL_IS_1496 = NULL;
text_stream *TL_IS_1497 = NULL;
text_stream *TL_IS_1498 = NULL;
text_stream *TL_IS_1499 = NULL;
text_stream *TL_IS_1500 = NULL;
text_stream *TL_IS_1501 = NULL;
text_stream *TL_IS_1502 = NULL;
text_stream *TL_IS_1503 = NULL;
text_stream *TL_IS_1504 = NULL;
text_stream *TL_IS_1505 = NULL;
text_stream *TL_IS_1506 = NULL;
text_stream *TL_IS_1507 = NULL;
text_stream *TL_IS_1508 = NULL;
text_stream *TL_IS_1509 = NULL;
text_stream *TL_IS_1510 = NULL;
text_stream *TL_IS_1511 = NULL;
text_stream *TL_IS_1512 = NULL;
text_stream *TL_IS_1513 = NULL;
text_stream *TL_IS_1514 = NULL;
text_stream *TL_IS_1515 = NULL;
text_stream *TL_IS_1516 = NULL;
text_stream *TL_IS_1517 = NULL;
text_stream *TL_IS_1518 = NULL;
text_stream *TL_IS_1519 = NULL;
text_stream *TL_IS_1520 = NULL;
text_stream *TL_IS_1521 = NULL;
text_stream *TL_IS_1522 = NULL;
text_stream *TL_IS_1523 = NULL;
text_stream *TL_IS_1524 = NULL;
text_stream *TL_IS_1525 = NULL;
text_stream *TL_IS_1526 = NULL;
text_stream *TL_IS_1527 = NULL;
text_stream *TL_IS_1528 = NULL;
text_stream *TL_IS_1529 = NULL;
text_stream *TL_IS_1530 = NULL;
text_stream *TL_IS_1531 = NULL;
text_stream *TL_IS_1532 = NULL;
text_stream *TL_IS_1533 = NULL;
text_stream *TL_IS_1534 = NULL;
text_stream *TL_IS_1535 = NULL;
text_stream *TL_IS_1536 = NULL;
text_stream *TL_IS_1537 = NULL;
text_stream *TL_IS_1538 = NULL;
text_stream *TL_IS_1539 = NULL;
text_stream *TL_IS_1540 = NULL;
text_stream *TL_IS_1541 = NULL;
text_stream *TL_IS_1542 = NULL;
text_stream *TL_IS_1543 = NULL;
text_stream *TL_IS_1544 = NULL;
text_stream *TL_IS_1545 = NULL;
text_stream *TL_IS_1546 = NULL;
text_stream *TL_IS_1547 = NULL;
text_stream *TL_IS_1548 = NULL;
text_stream *TL_IS_1549 = NULL;
text_stream *TL_IS_1550 = NULL;
text_stream *TL_IS_1551 = NULL;
text_stream *TL_IS_1552 = NULL;
text_stream *TL_IS_1553 = NULL;
text_stream *TL_IS_1554 = NULL;
text_stream *TL_IS_1555 = NULL;
text_stream *TL_IS_1556 = NULL;
text_stream *TL_IS_1557 = NULL;
text_stream *TL_IS_1558 = NULL;
text_stream *TL_IS_1559 = NULL;
text_stream *TL_IS_1560 = NULL;
text_stream *TL_IS_1561 = NULL;
text_stream *TL_IS_1562 = NULL;
text_stream *TL_IS_1563 = NULL;
text_stream *TL_IS_1564 = NULL;
text_stream *TL_IS_1565 = NULL;
text_stream *TL_IS_1566 = NULL;
text_stream *TL_IS_1567 = NULL;
text_stream *TL_IS_1568 = NULL;
text_stream *TL_IS_1569 = NULL;
text_stream *TL_IS_1570 = NULL;
text_stream *TL_IS_1571 = NULL;
text_stream *TL_IS_1572 = NULL;
text_stream *TL_IS_1573 = NULL;
text_stream *TL_IS_1574 = NULL;
text_stream *TL_IS_1575 = NULL;
text_stream *TL_IS_1576 = NULL;
text_stream *TL_IS_1577 = NULL;
text_stream *TL_IS_1578 = NULL;
text_stream *TL_IS_1579 = NULL;
text_stream *TL_IS_1580 = NULL;
text_stream *TL_IS_1581 = NULL;
text_stream *TL_IS_1582 = NULL;
text_stream *TL_IS_1583 = NULL;
text_stream *TL_IS_1584 = NULL;
text_stream *TL_IS_1585 = NULL;
text_stream *TL_IS_1586 = NULL;
text_stream *TL_IS_1587 = NULL;
text_stream *TL_IS_1588 = NULL;
text_stream *TL_IS_1589 = NULL;
text_stream *TL_IS_1590 = NULL;
text_stream *TL_IS_1591 = NULL;
text_stream *TL_IS_1592 = NULL;
text_stream *TL_IS_1593 = NULL;
text_stream *TL_IS_1594 = NULL;
text_stream *TL_IS_1595 = NULL;
text_stream *TL_IS_1596 = NULL;
text_stream *TL_IS_1597 = NULL;
text_stream *TL_IS_1598 = NULL;
text_stream *TL_IS_1599 = NULL;
text_stream *TL_IS_1600 = NULL;
text_stream *TL_IS_1601 = NULL;
text_stream *TL_IS_1602 = NULL;
text_stream *TL_IS_1603 = NULL;
text_stream *TL_IS_1604 = NULL;
text_stream *TL_IS_1605 = NULL;
text_stream *TL_IS_1606 = NULL;
text_stream *TL_IS_1607 = NULL;
text_stream *TL_IS_1608 = NULL;
text_stream *TL_IS_1609 = NULL;
text_stream *TL_IS_1610 = NULL;
text_stream *TL_IS_1611 = NULL;
text_stream *TL_IS_1612 = NULL;
text_stream *TL_IS_1613 = NULL;
text_stream *TL_IS_1614 = NULL;
text_stream *TL_IS_1615 = NULL;
text_stream *TL_IS_1616 = NULL;
text_stream *TL_IS_1617 = NULL;
text_stream *TL_IS_1618 = NULL;
text_stream *TL_IS_1619 = NULL;
text_stream *TL_IS_1620 = NULL;
text_stream *TL_IS_1621 = NULL;
text_stream *TL_IS_1622 = NULL;
text_stream *TL_IS_1623 = NULL;
text_stream *TL_IS_1624 = NULL;
text_stream *TL_IS_1625 = NULL;
text_stream *TL_IS_1626 = NULL;
text_stream *TL_IS_1627 = NULL;
text_stream *TL_IS_1628 = NULL;
text_stream *TL_IS_1629 = NULL;
text_stream *TL_IS_1630 = NULL;
text_stream *TL_IS_1631 = NULL;
text_stream *TL_IS_1632 = NULL;
text_stream *TL_IS_1633 = NULL;
text_stream *TL_IS_1634 = NULL;
text_stream *TL_IS_1635 = NULL;
text_stream *TL_IS_1636 = NULL;
text_stream *TL_IS_1637 = NULL;
text_stream *TL_IS_1638 = NULL;
text_stream *TL_IS_1639 = NULL;
text_stream *TL_IS_1640 = NULL;
text_stream *TL_IS_1641 = NULL;
text_stream *TL_IS_1642 = NULL;
text_stream *TL_IS_1643 = NULL;
text_stream *TL_IS_1644 = NULL;
text_stream *TL_IS_1645 = NULL;
text_stream *TL_IS_1646 = NULL;
text_stream *TL_IS_1647 = NULL;
text_stream *TL_IS_1648 = NULL;
text_stream *TL_IS_1649 = NULL;
text_stream *TL_IS_1650 = NULL;
text_stream *TL_IS_1651 = NULL;
text_stream *TL_IS_1652 = NULL;
text_stream *TL_IS_1653 = NULL;
text_stream *TL_IS_1654 = NULL;
text_stream *TL_IS_1655 = NULL;
text_stream *TL_IS_1656 = NULL;
text_stream *TL_IS_1657 = NULL;
text_stream *TL_IS_1658 = NULL;
text_stream *TL_IS_1659 = NULL;
text_stream *TL_IS_1660 = NULL;
text_stream *TL_IS_1661 = NULL;
text_stream *TL_IS_1662 = NULL;
text_stream *TL_IS_1663 = NULL;
text_stream *TL_IS_1664 = NULL;
text_stream *TL_IS_1665 = NULL;
text_stream *TL_IS_1666 = NULL;
text_stream *TL_IS_1667 = NULL;
text_stream *TL_IS_1668 = NULL;
text_stream *TL_IS_1669 = NULL;
text_stream *TL_IS_1670 = NULL;
text_stream *TL_IS_1671 = NULL;
text_stream *TL_IS_1672 = NULL;
text_stream *TL_IS_1673 = NULL;
text_stream *TL_IS_1674 = NULL;
text_stream *TL_IS_1675 = NULL;
text_stream *TL_IS_1676 = NULL;
text_stream *TL_IS_1677 = NULL;
text_stream *TL_IS_1678 = NULL;
text_stream *TL_IS_1679 = NULL;
text_stream *TL_IS_1680 = NULL;
text_stream *TL_IS_1681 = NULL;
text_stream *TL_IS_1682 = NULL;
text_stream *TL_IS_1683 = NULL;
text_stream *TL_IS_1684 = NULL;
text_stream *TL_IS_1685 = NULL;
text_stream *TL_IS_1686 = NULL;
text_stream *TL_IS_1687 = NULL;
text_stream *TL_IS_1688 = NULL;
text_stream *TL_IS_1689 = NULL;
text_stream *TL_IS_1690 = NULL;
text_stream *TL_IS_1691 = NULL;
text_stream *TL_IS_1692 = NULL;
text_stream *TL_IS_1693 = NULL;
text_stream *TL_IS_1694 = NULL;
text_stream *TL_IS_1695 = NULL;
text_stream *TL_IS_1696 = NULL;
text_stream *TL_IS_1697 = NULL;
text_stream *TL_IS_1698 = NULL;
text_stream *TL_IS_1699 = NULL;
text_stream *TL_IS_1700 = NULL;
text_stream *TL_IS_1701 = NULL;
text_stream *TL_IS_1702 = NULL;
text_stream *TL_IS_1703 = NULL;
text_stream *TL_IS_1704 = NULL;
text_stream *TL_IS_1705 = NULL;
text_stream *TL_IS_1706 = NULL;
text_stream *TL_IS_1707 = NULL;
text_stream *TL_IS_1708 = NULL;
text_stream *TL_IS_1709 = NULL;
text_stream *TL_IS_1710 = NULL;
text_stream *TL_IS_1711 = NULL;
text_stream *TL_IS_1712 = NULL;
text_stream *TL_IS_1713 = NULL;
text_stream *TL_IS_1714 = NULL;
text_stream *TL_IS_1715 = NULL;
text_stream *TL_IS_1716 = NULL;
text_stream *TL_IS_1717 = NULL;
text_stream *TL_IS_1718 = NULL;
text_stream *TL_IS_1719 = NULL;
text_stream *TL_IS_1720 = NULL;
text_stream *TL_IS_1721 = NULL;
text_stream *TL_IS_1722 = NULL;
text_stream *TL_IS_1723 = NULL;
text_stream *TL_IS_1724 = NULL;
text_stream *TL_IS_1725 = NULL;
text_stream *TL_IS_1726 = NULL;
text_stream *TL_IS_1727 = NULL;
text_stream *TL_IS_1728 = NULL;
text_stream *TL_IS_1729 = NULL;
text_stream *TL_IS_1730 = NULL;
text_stream *TL_IS_1731 = NULL;
text_stream *TL_IS_1732 = NULL;
text_stream *TL_IS_1733 = NULL;
text_stream *TL_IS_1734 = NULL;
text_stream *TL_IS_1735 = NULL;
text_stream *TL_IS_1736 = NULL;
text_stream *TL_IS_1737 = NULL;
text_stream *TL_IS_1738 = NULL;
text_stream *TL_IS_1739 = NULL;
text_stream *TL_IS_1740 = NULL;
text_stream *TL_IS_1741 = NULL;
text_stream *TL_IS_1742 = NULL;
text_stream *TL_IS_1743 = NULL;
text_stream *TL_IS_1744 = NULL;
text_stream *TL_IS_1745 = NULL;
text_stream *TL_IS_1746 = NULL;
text_stream *TL_IS_1747 = NULL;
text_stream *TL_IS_1748 = NULL;
text_stream *TL_IS_1749 = NULL;
text_stream *TL_IS_1750 = NULL;
text_stream *TL_IS_1751 = NULL;
text_stream *TL_IS_1752 = NULL;
text_stream *TL_IS_1753 = NULL;
text_stream *TL_IS_1754 = NULL;
text_stream *TL_IS_1755 = NULL;
text_stream *TL_IS_1756 = NULL;
text_stream *TL_IS_1757 = NULL;
text_stream *TL_IS_1758 = NULL;
text_stream *TL_IS_1759 = NULL;
text_stream *TL_IS_1760 = NULL;
text_stream *TL_IS_1761 = NULL;
text_stream *TL_IS_1762 = NULL;
text_stream *TL_IS_1763 = NULL;
text_stream *TL_IS_1764 = NULL;
text_stream *TL_IS_1765 = NULL;
text_stream *TL_IS_1766 = NULL;
text_stream *TL_IS_1767 = NULL;
text_stream *TL_IS_1768 = NULL;
text_stream *TL_IS_1769 = NULL;
text_stream *TL_IS_1770 = NULL;
text_stream *TL_IS_1771 = NULL;
text_stream *TL_IS_1772 = NULL;
text_stream *TL_IS_1773 = NULL;
text_stream *TL_IS_1774 = NULL;
text_stream *TL_IS_1775 = NULL;
text_stream *TL_IS_1776 = NULL;
text_stream *TL_IS_1777 = NULL;
text_stream *TL_IS_1778 = NULL;
text_stream *TL_IS_1779 = NULL;
text_stream *TL_IS_1780 = NULL;
text_stream *TL_IS_1781 = NULL;
text_stream *TL_IS_1782 = NULL;
text_stream *TL_IS_1783 = NULL;
text_stream *TL_IS_1784 = NULL;
text_stream *TL_IS_1785 = NULL;
text_stream *TL_IS_1786 = NULL;
text_stream *TL_IS_1787 = NULL;
text_stream *TL_IS_1788 = NULL;
text_stream *TL_IS_1789 = NULL;
text_stream *TL_IS_1790 = NULL;
text_stream *TL_IS_1791 = NULL;
text_stream *TL_IS_1792 = NULL;
text_stream *TL_IS_1793 = NULL;
text_stream *TL_IS_1794 = NULL;
text_stream *TL_IS_1795 = NULL;
text_stream *TL_IS_1796 = NULL;
text_stream *TL_IS_1797 = NULL;
text_stream *TL_IS_1798 = NULL;
text_stream *TL_IS_1799 = NULL;
text_stream *TL_IS_1800 = NULL;
text_stream *TL_IS_1801 = NULL;
text_stream *TL_IS_1802 = NULL;
text_stream *TL_IS_1803 = NULL;
text_stream *TL_IS_1804 = NULL;
text_stream *TL_IS_1805 = NULL;
text_stream *TL_IS_1806 = NULL;
text_stream *TL_IS_1807 = NULL;
text_stream *TL_IS_1808 = NULL;
text_stream *TL_IS_1809 = NULL;
text_stream *TL_IS_1810 = NULL;
text_stream *TL_IS_1811 = NULL;
text_stream *TL_IS_1812 = NULL;
text_stream *TL_IS_1813 = NULL;
text_stream *TL_IS_1814 = NULL;
text_stream *TL_IS_1815 = NULL;
text_stream *TL_IS_1816 = NULL;
text_stream *TL_IS_1817 = NULL;
text_stream *TL_IS_1818 = NULL;
text_stream *TL_IS_1819 = NULL;
text_stream *TL_IS_1820 = NULL;
text_stream *TL_IS_1821 = NULL;
text_stream *TL_IS_1822 = NULL;
text_stream *TL_IS_1823 = NULL;
text_stream *TL_IS_1824 = NULL;
text_stream *TL_IS_1825 = NULL;
text_stream *TL_IS_1826 = NULL;
text_stream *TL_IS_1827 = NULL;
text_stream *TL_IS_1828 = NULL;
text_stream *TL_IS_1829 = NULL;
text_stream *TL_IS_1830 = NULL;
text_stream *TL_IS_1831 = NULL;
text_stream *TL_IS_1832 = NULL;
text_stream *TL_IS_1833 = NULL;
text_stream *TL_IS_1834 = NULL;
text_stream *TL_IS_1835 = NULL;
text_stream *TL_IS_1836 = NULL;
text_stream *TL_IS_1837 = NULL;
text_stream *TL_IS_1838 = NULL;
text_stream *TL_IS_1839 = NULL;
text_stream *TL_IS_1840 = NULL;
text_stream *TL_IS_1841 = NULL;
text_stream *TL_IS_1842 = NULL;
text_stream *TL_IS_1843 = NULL;
text_stream *TL_IS_1844 = NULL;
text_stream *TL_IS_1845 = NULL;
text_stream *TL_IS_1846 = NULL;
text_stream *TL_IS_1847 = NULL;
text_stream *TL_IS_1848 = NULL;
text_stream *TL_IS_1849 = NULL;
text_stream *TL_IS_1850 = NULL;
text_stream *TL_IS_1851 = NULL;
text_stream *TL_IS_1852 = NULL;
text_stream *TL_IS_1853 = NULL;
text_stream *TL_IS_1854 = NULL;
text_stream *TL_IS_1855 = NULL;
text_stream *TL_IS_1856 = NULL;
text_stream *TL_IS_1857 = NULL;
text_stream *TL_IS_1858 = NULL;
text_stream *TL_IS_1859 = NULL;
text_stream *TL_IS_1860 = NULL;
text_stream *TL_IS_1861 = NULL;
text_stream *TL_IS_1862 = NULL;
text_stream *TL_IS_1863 = NULL;
text_stream *TL_IS_1864 = NULL;
text_stream *TL_IS_1865 = NULL;
text_stream *TL_IS_1866 = NULL;
text_stream *TL_IS_1867 = NULL;
text_stream *TL_IS_1868 = NULL;
text_stream *TL_IS_1869 = NULL;
text_stream *TL_IS_1870 = NULL;
text_stream *TL_IS_1871 = NULL;
text_stream *TL_IS_1872 = NULL;
text_stream *TL_IS_1873 = NULL;
text_stream *TL_IS_1874 = NULL;
text_stream *TL_IS_1875 = NULL;
text_stream *TL_IS_1876 = NULL;
text_stream *TL_IS_1877 = NULL;
text_stream *TL_IS_1878 = NULL;
text_stream *TL_IS_1879 = NULL;
text_stream *TL_IS_1880 = NULL;
text_stream *TL_IS_1881 = NULL;
text_stream *TL_IS_1882 = NULL;
text_stream *TL_IS_1883 = NULL;
text_stream *TL_IS_1884 = NULL;
text_stream *TL_IS_1885 = NULL;
text_stream *TL_IS_1886 = NULL;
text_stream *TL_IS_1887 = NULL;
text_stream *TL_IS_1888 = NULL;
text_stream *TL_IS_1889 = NULL;
text_stream *TL_IS_1890 = NULL;
text_stream *TL_IS_1891 = NULL;
text_stream *TL_IS_1892 = NULL;
text_stream *TL_IS_1893 = NULL;
text_stream *TL_IS_1894 = NULL;
text_stream *TL_IS_1895 = NULL;
text_stream *TL_IS_1896 = NULL;
text_stream *TL_IS_1897 = NULL;
text_stream *TL_IS_1898 = NULL;
text_stream *TL_IS_1899 = NULL;
text_stream *TL_IS_1900 = NULL;
text_stream *TL_IS_1901 = NULL;
text_stream *TL_IS_1902 = NULL;
text_stream *TL_IS_1903 = NULL;
text_stream *TL_IS_1904 = NULL;
text_stream *TL_IS_1905 = NULL;
text_stream *TL_IS_1906 = NULL;
text_stream *TL_IS_1907 = NULL;
text_stream *TL_IS_1908 = NULL;
text_stream *TL_IS_1909 = NULL;
text_stream *TL_IS_1910 = NULL;
text_stream *TL_IS_1911 = NULL;
text_stream *TL_IS_1912 = NULL;
text_stream *TL_IS_1913 = NULL;
text_stream *TL_IS_1914 = NULL;
text_stream *TL_IS_1915 = NULL;
text_stream *TL_IS_1916 = NULL;
text_stream *TL_IS_1917 = NULL;
text_stream *TL_IS_1918 = NULL;
text_stream *TL_IS_1919 = NULL;
text_stream *TL_IS_1920 = NULL;
text_stream *TL_IS_1921 = NULL;
text_stream *TL_IS_1922 = NULL;
text_stream *TL_IS_1923 = NULL;
text_stream *TL_IS_1924 = NULL;
text_stream *TL_IS_1925 = NULL;
text_stream *TL_IS_1926 = NULL;
text_stream *TL_IS_1927 = NULL;
text_stream *TL_IS_1928 = NULL;
text_stream *TL_IS_1929 = NULL;
text_stream *TL_IS_1930 = NULL;
text_stream *TL_IS_1931 = NULL;
text_stream *TL_IS_1932 = NULL;
text_stream *TL_IS_1933 = NULL;
text_stream *TL_IS_1934 = NULL;
text_stream *TL_IS_1935 = NULL;
text_stream *TL_IS_1936 = NULL;
text_stream *TL_IS_1937 = NULL;
text_stream *TL_IS_1938 = NULL;
text_stream *TL_IS_1939 = NULL;
text_stream *TL_IS_1940 = NULL;
text_stream *TL_IS_1941 = NULL;
text_stream *TL_IS_1942 = NULL;
text_stream *TL_IS_1943 = NULL;
text_stream *TL_IS_1944 = NULL;
text_stream *TL_IS_1945 = NULL;
text_stream *TL_IS_1946 = NULL;
text_stream *TL_IS_1947 = NULL;
text_stream *TL_IS_1948 = NULL;
text_stream *TL_IS_1949 = NULL;
text_stream *TL_IS_1950 = NULL;
text_stream *TL_IS_1951 = NULL;
text_stream *TL_IS_1952 = NULL;
text_stream *TL_IS_1953 = NULL;
text_stream *TL_IS_1954 = NULL;
text_stream *TL_IS_1955 = NULL;
text_stream *TL_IS_1956 = NULL;
text_stream *TL_IS_1957 = NULL;
text_stream *TL_IS_1958 = NULL;
text_stream *TL_IS_1959 = NULL;
text_stream *TL_IS_1960 = NULL;
text_stream *TL_IS_1961 = NULL;
text_stream *TL_IS_1962 = NULL;
text_stream *TL_IS_1963 = NULL;
text_stream *TL_IS_1964 = NULL;
text_stream *TL_IS_1965 = NULL;
text_stream *TL_IS_1966 = NULL;
text_stream *TL_IS_1967 = NULL;
text_stream *TL_IS_1968 = NULL;
text_stream *TL_IS_1969 = NULL;
text_stream *TL_IS_1970 = NULL;
text_stream *TL_IS_1971 = NULL;
text_stream *TL_IS_1972 = NULL;
text_stream *TL_IS_1973 = NULL;
text_stream *TL_IS_1974 = NULL;
text_stream *TL_IS_1975 = NULL;
text_stream *TL_IS_1976 = NULL;
text_stream *TL_IS_1977 = NULL;
text_stream *TL_IS_1978 = NULL;
text_stream *TL_IS_1979 = NULL;
text_stream *TL_IS_1980 = NULL;
text_stream *TL_IS_1981 = NULL;
text_stream *TL_IS_1982 = NULL;
text_stream *TL_IS_1983 = NULL;
text_stream *TL_IS_1984 = NULL;
text_stream *TL_IS_1985 = NULL;
text_stream *TL_IS_1986 = NULL;
text_stream *TL_IS_1987 = NULL;
text_stream *TL_IS_1988 = NULL;
text_stream *TL_IS_1989 = NULL;
text_stream *TL_IS_1990 = NULL;
text_stream *TL_IS_1991 = NULL;
text_stream *TL_IS_1992 = NULL;
text_stream *TL_IS_1993 = NULL;
text_stream *TL_IS_1994 = NULL;
text_stream *TL_IS_1995 = NULL;
text_stream *TL_IS_1996 = NULL;
text_stream *TL_IS_1997 = NULL;
text_stream *TL_IS_1998 = NULL;
text_stream *TL_IS_1999 = NULL;
text_stream *TL_IS_2000 = NULL;
text_stream *TL_IS_2001 = NULL;
text_stream *TL_IS_2002 = NULL;
text_stream *TL_IS_2003 = NULL;
text_stream *TL_IS_2004 = NULL;
text_stream *TL_IS_2005 = NULL;
text_stream *TL_IS_2006 = NULL;
text_stream *TL_IS_2007 = NULL;
text_stream *TL_IS_2008 = NULL;
text_stream *TL_IS_2009 = NULL;
text_stream *TL_IS_2010 = NULL;
text_stream *TL_IS_2011 = NULL;
text_stream *TL_IS_2012 = NULL;
text_stream *TL_IS_2013 = NULL;
text_stream *TL_IS_2014 = NULL;
text_stream *TL_IS_2015 = NULL;
text_stream *TL_IS_2016 = NULL;
text_stream *TL_IS_2017 = NULL;
text_stream *TL_IS_2018 = NULL;
text_stream *TL_IS_2019 = NULL;
text_stream *TL_IS_2020 = NULL;
text_stream *TL_IS_2021 = NULL;
text_stream *TL_IS_2022 = NULL;
text_stream *TL_IS_2023 = NULL;
text_stream *TL_IS_2024 = NULL;
text_stream *TL_IS_2025 = NULL;
text_stream *TL_IS_2026 = NULL;
text_stream *TL_IS_2027 = NULL;
text_stream *TL_IS_2028 = NULL;
text_stream *TL_IS_2029 = NULL;
text_stream *TL_IS_2030 = NULL;
text_stream *TL_IS_2031 = NULL;
text_stream *TL_IS_2032 = NULL;
text_stream *TL_IS_2033 = NULL;
text_stream *TL_IS_2034 = NULL;
text_stream *TL_IS_2035 = NULL;
text_stream *TL_IS_2036 = NULL;
text_stream *TL_IS_2037 = NULL;
text_stream *TL_IS_2038 = NULL;
text_stream *TL_IS_2039 = NULL;
text_stream *TL_IS_2040 = NULL;
text_stream *TL_IS_2041 = NULL;
text_stream *TL_IS_2042 = NULL;
text_stream *TL_IS_2043 = NULL;
text_stream *TL_IS_2044 = NULL;
text_stream *TL_IS_2045 = NULL;
text_stream *TL_IS_2046 = NULL;
text_stream *TL_IS_2047 = NULL;
text_stream *TL_IS_2048 = NULL;
text_stream *TL_IS_2049 = NULL;
text_stream *TL_IS_2050 = NULL;
text_stream *TL_IS_2051 = NULL;
text_stream *TL_IS_2052 = NULL;
text_stream *TL_IS_2053 = NULL;
text_stream *TL_IS_2054 = NULL;
text_stream *TL_IS_2055 = NULL;
text_stream *TL_IS_2056 = NULL;
text_stream *TL_IS_2057 = NULL;
text_stream *TL_IS_2058 = NULL;
text_stream *TL_IS_2059 = NULL;
text_stream *TL_IS_2060 = NULL;
text_stream *TL_IS_2061 = NULL;
text_stream *TL_IS_2062 = NULL;
text_stream *TL_IS_2063 = NULL;
text_stream *TL_IS_2064 = NULL;
text_stream *TL_IS_2065 = NULL;
text_stream *TL_IS_2066 = NULL;
text_stream *TL_IS_2067 = NULL;
text_stream *TL_IS_2068 = NULL;
text_stream *TL_IS_2069 = NULL;
text_stream *TL_IS_2070 = NULL;
text_stream *TL_IS_2071 = NULL;
text_stream *TL_IS_2072 = NULL;
text_stream *TL_IS_2073 = NULL;
text_stream *TL_IS_2074 = NULL;
text_stream *TL_IS_2075 = NULL;
text_stream *TL_IS_2076 = NULL;
text_stream *TL_IS_2077 = NULL;
text_stream *TL_IS_2078 = NULL;
text_stream *TL_IS_2079 = NULL;
text_stream *TL_IS_2080 = NULL;
text_stream *TL_IS_2081 = NULL;
text_stream *TL_IS_2082 = NULL;
text_stream *TL_IS_2083 = NULL;
text_stream *TL_IS_2084 = NULL;
text_stream *TL_IS_2085 = NULL;
text_stream *TL_IS_2086 = NULL;
text_stream *TL_IS_2087 = NULL;
text_stream *TL_IS_2088 = NULL;
text_stream *TL_IS_2089 = NULL;
text_stream *TL_IS_2090 = NULL;
text_stream *TL_IS_2091 = NULL;
text_stream *TL_IS_2092 = NULL;
text_stream *TL_IS_2093 = NULL;
text_stream *TL_IS_2094 = NULL;
text_stream *TL_IS_2095 = NULL;
text_stream *TL_IS_2096 = NULL;
text_stream *TL_IS_2097 = NULL;
text_stream *TL_IS_2098 = NULL;
text_stream *TL_IS_2099 = NULL;
text_stream *TL_IS_2100 = NULL;
text_stream *TL_IS_2101 = NULL;
text_stream *TL_IS_2102 = NULL;
text_stream *TL_IS_2103 = NULL;
text_stream *TL_IS_2104 = NULL;
text_stream *TL_IS_2105 = NULL;
text_stream *TL_IS_2106 = NULL;
text_stream *TL_IS_2107 = NULL;
text_stream *TL_IS_2108 = NULL;
text_stream *TL_IS_2109 = NULL;
text_stream *TL_IS_2110 = NULL;
text_stream *TL_IS_2111 = NULL;
text_stream *TL_IS_2112 = NULL;
text_stream *TL_IS_2113 = NULL;
text_stream *TL_IS_2114 = NULL;
text_stream *TL_IS_2115 = NULL;
text_stream *TL_IS_2116 = NULL;
text_stream *TL_IS_2117 = NULL;
text_stream *TL_IS_2118 = NULL;
text_stream *TL_IS_2119 = NULL;
text_stream *TL_IS_2120 = NULL;
text_stream *TL_IS_2121 = NULL;
text_stream *TL_IS_2122 = NULL;
text_stream *TL_IS_2123 = NULL;
text_stream *TL_IS_2124 = NULL;
text_stream *TL_IS_2125 = NULL;
text_stream *TL_IS_2126 = NULL;
text_stream *TL_IS_2127 = NULL;
text_stream *TL_IS_2128 = NULL;
text_stream *TL_IS_2129 = NULL;
text_stream *TL_IS_2130 = NULL;
text_stream *TL_IS_2131 = NULL;
text_stream *TL_IS_2132 = NULL;
text_stream *TL_IS_2133 = NULL;
text_stream *TL_IS_2134 = NULL;
text_stream *TL_IS_2135 = NULL;
text_stream *TL_IS_2136 = NULL;
text_stream *TL_IS_2137 = NULL;
text_stream *TL_IS_2138 = NULL;
text_stream *TL_IS_2139 = NULL;
text_stream *TL_IS_2140 = NULL;
text_stream *TL_IS_2141 = NULL;
text_stream *TL_IS_2142 = NULL;
text_stream *TL_IS_2143 = NULL;
text_stream *TL_IS_2144 = NULL;
text_stream *TL_IS_2145 = NULL;
text_stream *TL_IS_2146 = NULL;
text_stream *TL_IS_2147 = NULL;
text_stream *TL_IS_2148 = NULL;
text_stream *TL_IS_2149 = NULL;
text_stream *TL_IS_2150 = NULL;
text_stream *TL_IS_2151 = NULL;
text_stream *TL_IS_2152 = NULL;
text_stream *TL_IS_2153 = NULL;
text_stream *TL_IS_2154 = NULL;
text_stream *TL_IS_2155 = NULL;
text_stream *TL_IS_2156 = NULL;
text_stream *TL_IS_2157 = NULL;
text_stream *TL_IS_2158 = NULL;
text_stream *TL_IS_2159 = NULL;
text_stream *TL_IS_2160 = NULL;
text_stream *TL_IS_2161 = NULL;
text_stream *TL_IS_2162 = NULL;
text_stream *TL_IS_2163 = NULL;
text_stream *TL_IS_2164 = NULL;
text_stream *TL_IS_2165 = NULL;
text_stream *TL_IS_2166 = NULL;
text_stream *TL_IS_2167 = NULL;
text_stream *TL_IS_2168 = NULL;
text_stream *TL_IS_2169 = NULL;
text_stream *TL_IS_2170 = NULL;
text_stream *TL_IS_2171 = NULL;
text_stream *TL_IS_2172 = NULL;
text_stream *TL_IS_2173 = NULL;
text_stream *TL_IS_2174 = NULL;
text_stream *TL_IS_2175 = NULL;
text_stream *TL_IS_2176 = NULL;
text_stream *TL_IS_2177 = NULL;
text_stream *TL_IS_2178 = NULL;
text_stream *TL_IS_2179 = NULL;
text_stream *TL_IS_2180 = NULL;
text_stream *TL_IS_2181 = NULL;
text_stream *TL_IS_2182 = NULL;
text_stream *TL_IS_2183 = NULL;
text_stream *TL_IS_2184 = NULL;
text_stream *TL_IS_2185 = NULL;
text_stream *TL_IS_2186 = NULL;
text_stream *TL_IS_2187 = NULL;
text_stream *TL_IS_2188 = NULL;
text_stream *TL_IS_2189 = NULL;
text_stream *TL_IS_2190 = NULL;
text_stream *TL_IS_2191 = NULL;
text_stream *TL_IS_2192 = NULL;
text_stream *TL_IS_2193 = NULL;
text_stream *TL_IS_2194 = NULL;
text_stream *TL_IS_2195 = NULL;
text_stream *TL_IS_2196 = NULL;
text_stream *TL_IS_2197 = NULL;
text_stream *TL_IS_2198 = NULL;
text_stream *TL_IS_2199 = NULL;
text_stream *TL_IS_2200 = NULL;
text_stream *TL_IS_2201 = NULL;
text_stream *TL_IS_2202 = NULL;
text_stream *TL_IS_2203 = NULL;
text_stream *TL_IS_2204 = NULL;
text_stream *TL_IS_2205 = NULL;
text_stream *TL_IS_2206 = NULL;
text_stream *TL_IS_2207 = NULL;
text_stream *TL_IS_2208 = NULL;
text_stream *TL_IS_2209 = NULL;
text_stream *TL_IS_2210 = NULL;
text_stream *TL_IS_2211 = NULL;
text_stream *TL_IS_2212 = NULL;
text_stream *TL_IS_2213 = NULL;
text_stream *TL_IS_2214 = NULL;
text_stream *TL_IS_2215 = NULL;
text_stream *TL_IS_2216 = NULL;
text_stream *TL_IS_2217 = NULL;
text_stream *TL_IS_2218 = NULL;
text_stream *TL_IS_2219 = NULL;
text_stream *TL_IS_2220 = NULL;
text_stream *TL_IS_2221 = NULL;
text_stream *TL_IS_2222 = NULL;
text_stream *TL_IS_2223 = NULL;
text_stream *TL_IS_2224 = NULL;
text_stream *TL_IS_2225 = NULL;
text_stream *TL_IS_2226 = NULL;
text_stream *TL_IS_2227 = NULL;
text_stream *TL_IS_2228 = NULL;
text_stream *TL_IS_2229 = NULL;
text_stream *TL_IS_2230 = NULL;
text_stream *TL_IS_2231 = NULL;
text_stream *TL_IS_2232 = NULL;
text_stream *TL_IS_2233 = NULL;
text_stream *TL_IS_2234 = NULL;
text_stream *TL_IS_2235 = NULL;
text_stream *TL_IS_2236 = NULL;
text_stream *TL_IS_2237 = NULL;
text_stream *TL_IS_2238 = NULL;
text_stream *TL_IS_2239 = NULL;
text_stream *TL_IS_2240 = NULL;
text_stream *TL_IS_2241 = NULL;
text_stream *TL_IS_2242 = NULL;
text_stream *TL_IS_2243 = NULL;
text_stream *TL_IS_2244 = NULL;
text_stream *TL_IS_2245 = NULL;
text_stream *TL_IS_2246 = NULL;
text_stream *TL_IS_2247 = NULL;
text_stream *TL_IS_2248 = NULL;
text_stream *TL_IS_2249 = NULL;
text_stream *TL_IS_2250 = NULL;
text_stream *TL_IS_2251 = NULL;
text_stream *TL_IS_2252 = NULL;
text_stream *TL_IS_2253 = NULL;
text_stream *TL_IS_2254 = NULL;
text_stream *TL_IS_2255 = NULL;
text_stream *TL_IS_2256 = NULL;
text_stream *TL_IS_2257 = NULL;
text_stream *TL_IS_2258 = NULL;
text_stream *TL_IS_2259 = NULL;
text_stream *TL_IS_2260 = NULL;
text_stream *TL_IS_2261 = NULL;
text_stream *TL_IS_2262 = NULL;
text_stream *TL_IS_2263 = NULL;
text_stream *TL_IS_2264 = NULL;
text_stream *TL_IS_2265 = NULL;
text_stream *TL_IS_2266 = NULL;
text_stream *TL_IS_2267 = NULL;
text_stream *TL_IS_2268 = NULL;
text_stream *TL_IS_2269 = NULL;
text_stream *TL_IS_2270 = NULL;
text_stream *TL_IS_2271 = NULL;
text_stream *TL_IS_2272 = NULL;
text_stream *TL_IS_2273 = NULL;
text_stream *TL_IS_2274 = NULL;
text_stream *TL_IS_2275 = NULL;
text_stream *TL_IS_2276 = NULL;
text_stream *TL_IS_2277 = NULL;
text_stream *TL_IS_2278 = NULL;
text_stream *TL_IS_2279 = NULL;
text_stream *TL_IS_2280 = NULL;
text_stream *TL_IS_2281 = NULL;
text_stream *TL_IS_2282 = NULL;
text_stream *TL_IS_2283 = NULL;
text_stream *TL_IS_2284 = NULL;
text_stream *TL_IS_2285 = NULL;
text_stream *TL_IS_2286 = NULL;
text_stream *TL_IS_2287 = NULL;
text_stream *TL_IS_2288 = NULL;
text_stream *TL_IS_2289 = NULL;
text_stream *TL_IS_2290 = NULL;
text_stream *TL_IS_2291 = NULL;
text_stream *TL_IS_2292 = NULL;
text_stream *TL_IS_2293 = NULL;
text_stream *TL_IS_2294 = NULL;
text_stream *TL_IS_2295 = NULL;
text_stream *TL_IS_2296 = NULL;
text_stream *TL_IS_2297 = NULL;
text_stream *TL_IS_2298 = NULL;
text_stream *TL_IS_2299 = NULL;
text_stream *TL_IS_2300 = NULL;
text_stream *TL_IS_2301 = NULL;
text_stream *TL_IS_2302 = NULL;
text_stream *TL_IS_2303 = NULL;
text_stream *TL_IS_2304 = NULL;
text_stream *TL_IS_2305 = NULL;
text_stream *TL_IS_2306 = NULL;
text_stream *TL_IS_2307 = NULL;
text_stream *TL_IS_2308 = NULL;
text_stream *TL_IS_2309 = NULL;
text_stream *TL_IS_2310 = NULL;
text_stream *TL_IS_2311 = NULL;
text_stream *TL_IS_2312 = NULL;
text_stream *TL_IS_2313 = NULL;
text_stream *TL_IS_2314 = NULL;
text_stream *TL_IS_2315 = NULL;
text_stream *TL_IS_2316 = NULL;
text_stream *TL_IS_2317 = NULL;
text_stream *TL_IS_2318 = NULL;
text_stream *TL_IS_2319 = NULL;
text_stream *TL_IS_2320 = NULL;
text_stream *TL_IS_2321 = NULL;
text_stream *TL_IS_2322 = NULL;
text_stream *TL_IS_2323 = NULL;
text_stream *TL_IS_2324 = NULL;
text_stream *TL_IS_2325 = NULL;
text_stream *TL_IS_2326 = NULL;
text_stream *TL_IS_2327 = NULL;
text_stream *TL_IS_2328 = NULL;
text_stream *TL_IS_2329 = NULL;
text_stream *TL_IS_2330 = NULL;
text_stream *TL_IS_2331 = NULL;
text_stream *TL_IS_2332 = NULL;
text_stream *TL_IS_2333 = NULL;
text_stream *TL_IS_2334 = NULL;
text_stream *TL_IS_2335 = NULL;
text_stream *TL_IS_2336 = NULL;
text_stream *TL_IS_2337 = NULL;
text_stream *TL_IS_2338 = NULL;
text_stream *TL_IS_2339 = NULL;
text_stream *TL_IS_2340 = NULL;
text_stream *TL_IS_2341 = NULL;
text_stream *TL_IS_2342 = NULL;
text_stream *TL_IS_2343 = NULL;
text_stream *TL_IS_2344 = NULL;
text_stream *TL_IS_2345 = NULL;
text_stream *TL_IS_2346 = NULL;
text_stream *TL_IS_2347 = NULL;
text_stream *TL_IS_2348 = NULL;
text_stream *TL_IS_2349 = NULL;
text_stream *TL_IS_2350 = NULL;
text_stream *TL_IS_2351 = NULL;
text_stream *TL_IS_2352 = NULL;
text_stream *TL_IS_2353 = NULL;
text_stream *TL_IS_2354 = NULL;
text_stream *TL_IS_2355 = NULL;
text_stream *TL_IS_2356 = NULL;
text_stream *TL_IS_2357 = NULL;
text_stream *TL_IS_2358 = NULL;
text_stream *TL_IS_2359 = NULL;
text_stream *TL_IS_2360 = NULL;
text_stream *TL_IS_2361 = NULL;
text_stream *TL_IS_2362 = NULL;
text_stream *TL_IS_2363 = NULL;
text_stream *TL_IS_2364 = NULL;
text_stream *TL_IS_2365 = NULL;
text_stream *TL_IS_2366 = NULL;
text_stream *TL_IS_2367 = NULL;
text_stream *TL_IS_2368 = NULL;
text_stream *TL_IS_2369 = NULL;
text_stream *TL_IS_2370 = NULL;
text_stream *TL_IS_2371 = NULL;
text_stream *TL_IS_2372 = NULL;
text_stream *TL_IS_2373 = NULL;
text_stream *TL_IS_2374 = NULL;
text_stream *TL_IS_2375 = NULL;
text_stream *TL_IS_2376 = NULL;
text_stream *TL_IS_2377 = NULL;
text_stream *TL_IS_2378 = NULL;
text_stream *TL_IS_2379 = NULL;
text_stream *TL_IS_2380 = NULL;
text_stream *TL_IS_2381 = NULL;
text_stream *TL_IS_2382 = NULL;
text_stream *TL_IS_2383 = NULL;
text_stream *TL_IS_2384 = NULL;
text_stream *TL_IS_2385 = NULL;
text_stream *TL_IS_2386 = NULL;
text_stream *TL_IS_2387 = NULL;
text_stream *TL_IS_2388 = NULL;
text_stream *TL_IS_2389 = NULL;
text_stream *TL_IS_2390 = NULL;
text_stream *TL_IS_2391 = NULL;
text_stream *TL_IS_2392 = NULL;
text_stream *TL_IS_2393 = NULL;
text_stream *TL_IS_2394 = NULL;
text_stream *TL_IS_2395 = NULL;
text_stream *TL_IS_2396 = NULL;
text_stream *TL_IS_2397 = NULL;
text_stream *TL_IS_2398 = NULL;
text_stream *TL_IS_2399 = NULL;
text_stream *TL_IS_2400 = NULL;
text_stream *TL_IS_2401 = NULL;
text_stream *TL_IS_2402 = NULL;
text_stream *TL_IS_2403 = NULL;
text_stream *TL_IS_2404 = NULL;
text_stream *TL_IS_2405 = NULL;
text_stream *TL_IS_2406 = NULL;
text_stream *TL_IS_2407 = NULL;
text_stream *TL_IS_2408 = NULL;
text_stream *TL_IS_2409 = NULL;
text_stream *TL_IS_2410 = NULL;
text_stream *TL_IS_2411 = NULL;
text_stream *TL_IS_2412 = NULL;
text_stream *TL_IS_2413 = NULL;
text_stream *TL_IS_2414 = NULL;
text_stream *TL_IS_2415 = NULL;
text_stream *TL_IS_2416 = NULL;
text_stream *TL_IS_2417 = NULL;
text_stream *TL_IS_2418 = NULL;
text_stream *TL_IS_2419 = NULL;
text_stream *TL_IS_2420 = NULL;
text_stream *TL_IS_2421 = NULL;
text_stream *TL_IS_2422 = NULL;
text_stream *TL_IS_2423 = NULL;
text_stream *TL_IS_2424 = NULL;
text_stream *TL_IS_2425 = NULL;
text_stream *TL_IS_2426 = NULL;
text_stream *TL_IS_2427 = NULL;
text_stream *TL_IS_2428 = NULL;
text_stream *TL_IS_2429 = NULL;
text_stream *TL_IS_2430 = NULL;
text_stream *TL_IS_2431 = NULL;
text_stream *TL_IS_2432 = NULL;
text_stream *TL_IS_2433 = NULL;
text_stream *TL_IS_2434 = NULL;
text_stream *TL_IS_2435 = NULL;
text_stream *TL_IS_2436 = NULL;
text_stream *TL_IS_2437 = NULL;
text_stream *TL_IS_2438 = NULL;
text_stream *TL_IS_2439 = NULL;
text_stream *TL_IS_2440 = NULL;
text_stream *TL_IS_2441 = NULL;
text_stream *TL_IS_2442 = NULL;
text_stream *TL_IS_2443 = NULL;
text_stream *TL_IS_2444 = NULL;
text_stream *TL_IS_2445 = NULL;
text_stream *TL_IS_2446 = NULL;
text_stream *TL_IS_2447 = NULL;
text_stream *TL_IS_2448 = NULL;
text_stream *TL_IS_2449 = NULL;
text_stream *TL_IS_2450 = NULL;
text_stream *TL_IS_2451 = NULL;
text_stream *TL_IS_2452 = NULL;
text_stream *TL_IS_2453 = NULL;
text_stream *TL_IS_2454 = NULL;
text_stream *TL_IS_2455 = NULL;
text_stream *TL_IS_2456 = NULL;
text_stream *TL_IS_2457 = NULL;
text_stream *TL_IS_2458 = NULL;
text_stream *TL_IS_2459 = NULL;
text_stream *TL_IS_2460 = NULL;
text_stream *TL_IS_2461 = NULL;
text_stream *TL_IS_2462 = NULL;
text_stream *TL_IS_2463 = NULL;
text_stream *TL_IS_2464 = NULL;
text_stream *TL_IS_2465 = NULL;
text_stream *TL_IS_2466 = NULL;
text_stream *TL_IS_2467 = NULL;
text_stream *TL_IS_2468 = NULL;
text_stream *TL_IS_2469 = NULL;
text_stream *TL_IS_2470 = NULL;
text_stream *TL_IS_2471 = NULL;
text_stream *TL_IS_2472 = NULL;
text_stream *TL_IS_2473 = NULL;
text_stream *TL_IS_2474 = NULL;
text_stream *TL_IS_2475 = NULL;
text_stream *TL_IS_2476 = NULL;
text_stream *TL_IS_2477 = NULL;
text_stream *TL_IS_2478 = NULL;
text_stream *TL_IS_2479 = NULL;
text_stream *TL_IS_2480 = NULL;
text_stream *TL_IS_2481 = NULL;
text_stream *TL_IS_2482 = NULL;
text_stream *TL_IS_2483 = NULL;
text_stream *TL_IS_2484 = NULL;
text_stream *TL_IS_2485 = NULL;
text_stream *TL_IS_2486 = NULL;
text_stream *TL_IS_2487 = NULL;
text_stream *TL_IS_2488 = NULL;
text_stream *TL_IS_2489 = NULL;
text_stream *TL_IS_2490 = NULL;
text_stream *TL_IS_2491 = NULL;
text_stream *TL_IS_2492 = NULL;
text_stream *TL_IS_2493 = NULL;
text_stream *TL_IS_2494 = NULL;
text_stream *TL_IS_2495 = NULL;
text_stream *TL_IS_2496 = NULL;
text_stream *TL_IS_2497 = NULL;
text_stream *TL_IS_2498 = NULL;
text_stream *TL_IS_2499 = NULL;
text_stream *TL_IS_2500 = NULL;
text_stream *TL_IS_2501 = NULL;
text_stream *TL_IS_2502 = NULL;
text_stream *TL_IS_2503 = NULL;
text_stream *TL_IS_2504 = NULL;
text_stream *TL_IS_2505 = NULL;
text_stream *TL_IS_2506 = NULL;
text_stream *TL_IS_2507 = NULL;
text_stream *TL_IS_2508 = NULL;
text_stream *TL_IS_2509 = NULL;
text_stream *TL_IS_2510 = NULL;
text_stream *TL_IS_2511 = NULL;
text_stream *TL_IS_2512 = NULL;
text_stream *TL_IS_2513 = NULL;
text_stream *TL_IS_2514 = NULL;
text_stream *TL_IS_2515 = NULL;
text_stream *TL_IS_2516 = NULL;
text_stream *TL_IS_2517 = NULL;
text_stream *TL_IS_2518 = NULL;
text_stream *TL_IS_2519 = NULL;
text_stream *TL_IS_2520 = NULL;
text_stream *TL_IS_2521 = NULL;
text_stream *TL_IS_2522 = NULL;
text_stream *TL_IS_2523 = NULL;
text_stream *TL_IS_2524 = NULL;
text_stream *TL_IS_2525 = NULL;
text_stream *TL_IS_2526 = NULL;
text_stream *TL_IS_2527 = NULL;
text_stream *TL_IS_2528 = NULL;
text_stream *TL_IS_2529 = NULL;
text_stream *TL_IS_2530 = NULL;
text_stream *TL_IS_2531 = NULL;
text_stream *TL_IS_2532 = NULL;
text_stream *TL_IS_2533 = NULL;
text_stream *TL_IS_2534 = NULL;
text_stream *TL_IS_2535 = NULL;
text_stream *TL_IS_2536 = NULL;
text_stream *TL_IS_2537 = NULL;
text_stream *TL_IS_2538 = NULL;
text_stream *TL_IS_2539 = NULL;
text_stream *TL_IS_2540 = NULL;
text_stream *TL_IS_2541 = NULL;
text_stream *TL_IS_2542 = NULL;
text_stream *TL_IS_2543 = NULL;
text_stream *TL_IS_2544 = NULL;
text_stream *TL_IS_2545 = NULL;
text_stream *TL_IS_2546 = NULL;
text_stream *TL_IS_2547 = NULL;
text_stream *TL_IS_2548 = NULL;
text_stream *TL_IS_2549 = NULL;
text_stream *TL_IS_2550 = NULL;
text_stream *TL_IS_2551 = NULL;
text_stream *TL_IS_2552 = NULL;
text_stream *TL_IS_2553 = NULL;
text_stream *TL_IS_2554 = NULL;
text_stream *TL_IS_2555 = NULL;
text_stream *TL_IS_2556 = NULL;
text_stream *TL_IS_2557 = NULL;
text_stream *TL_IS_2558 = NULL;
text_stream *TL_IS_2559 = NULL;
text_stream *TL_IS_2560 = NULL;
text_stream *TL_IS_2561 = NULL;
text_stream *TL_IS_2562 = NULL;
text_stream *TL_IS_2563 = NULL;
text_stream *TL_IS_2564 = NULL;
text_stream *TL_IS_2565 = NULL;
text_stream *TL_IS_2566 = NULL;
text_stream *TL_IS_2567 = NULL;
text_stream *TL_IS_2568 = NULL;
text_stream *TL_IS_2569 = NULL;
text_stream *TL_IS_2570 = NULL;
text_stream *TL_IS_2571 = NULL;
text_stream *TL_IS_2572 = NULL;
text_stream *TL_IS_2573 = NULL;
text_stream *TL_IS_2574 = NULL;
text_stream *TL_IS_2575 = NULL;
text_stream *TL_IS_2576 = NULL;
text_stream *TL_IS_2577 = NULL;
text_stream *TL_IS_2578 = NULL;
text_stream *TL_IS_2579 = NULL;
text_stream *TL_IS_2580 = NULL;
text_stream *TL_IS_2581 = NULL;
text_stream *TL_IS_2582 = NULL;
text_stream *TL_IS_2583 = NULL;
text_stream *TL_IS_2584 = NULL;
text_stream *TL_IS_2585 = NULL;
text_stream *TL_IS_2586 = NULL;
text_stream *TL_IS_2587 = NULL;
text_stream *TL_IS_2588 = NULL;
text_stream *TL_IS_2589 = NULL;
text_stream *TL_IS_2590 = NULL;
text_stream *TL_IS_2591 = NULL;
text_stream *TL_IS_2592 = NULL;
text_stream *TL_IS_2593 = NULL;
text_stream *TL_IS_2594 = NULL;
text_stream *TL_IS_2595 = NULL;
text_stream *TL_IS_2596 = NULL;
text_stream *TL_IS_2597 = NULL;
text_stream *TL_IS_2598 = NULL;
text_stream *TL_IS_2599 = NULL;
text_stream *TL_IS_2600 = NULL;
text_stream *TL_IS_2601 = NULL;
text_stream *TL_IS_2602 = NULL;
text_stream *TL_IS_2603 = NULL;
text_stream *TL_IS_2604 = NULL;
text_stream *TL_IS_2605 = NULL;
text_stream *TL_IS_2606 = NULL;
text_stream *TL_IS_2607 = NULL;
text_stream *TL_IS_2608 = NULL;
text_stream *TL_IS_2609 = NULL;
text_stream *TL_IS_2610 = NULL;
text_stream *TL_IS_2611 = NULL;
text_stream *TL_IS_2612 = NULL;
text_stream *TL_IS_2613 = NULL;
text_stream *TL_IS_2614 = NULL;
text_stream *TL_IS_2615 = NULL;
text_stream *TL_IS_2616 = NULL;
text_stream *TL_IS_2617 = NULL;
text_stream *TL_IS_2618 = NULL;
text_stream *TL_IS_2619 = NULL;
text_stream *TL_IS_2620 = NULL;
text_stream *TL_IS_2621 = NULL;
text_stream *TL_IS_2622 = NULL;
text_stream *TL_IS_2623 = NULL;
text_stream *TL_IS_2624 = NULL;
text_stream *TL_IS_2625 = NULL;
text_stream *TL_IS_2626 = NULL;
text_stream *TL_IS_2627 = NULL;
text_stream *TL_IS_2628 = NULL;
text_stream *TL_IS_2629 = NULL;
text_stream *TL_IS_2630 = NULL;
text_stream *TL_IS_2631 = NULL;
text_stream *TL_IS_2632 = NULL;
text_stream *TL_IS_2633 = NULL;
text_stream *TL_IS_2634 = NULL;
text_stream *TL_IS_2635 = NULL;
text_stream *TL_IS_2636 = NULL;
text_stream *TL_IS_2637 = NULL;
text_stream *TL_IS_2638 = NULL;
text_stream *TL_IS_2639 = NULL;
text_stream *TL_IS_2640 = NULL;
text_stream *TL_IS_2641 = NULL;
text_stream *TL_IS_2642 = NULL;
text_stream *TL_IS_2643 = NULL;
text_stream *TL_IS_2644 = NULL;
text_stream *TL_IS_2645 = NULL;
text_stream *TL_IS_2646 = NULL;
text_stream *TL_IS_2647 = NULL;
text_stream *TL_IS_2648 = NULL;
text_stream *TL_IS_2649 = NULL;
text_stream *TL_IS_2650 = NULL;
text_stream *TL_IS_2651 = NULL;
text_stream *TL_IS_2652 = NULL;
text_stream *TL_IS_2653 = NULL;
text_stream *TL_IS_2654 = NULL;
text_stream *TL_IS_2655 = NULL;
text_stream *TL_IS_2656 = NULL;
text_stream *TL_IS_2657 = NULL;
text_stream *TL_IS_2658 = NULL;
text_stream *TL_IS_2659 = NULL;
text_stream *TL_IS_2660 = NULL;
text_stream *TL_IS_2661 = NULL;
text_stream *TL_IS_2662 = NULL;
text_stream *TL_IS_2663 = NULL;
text_stream *TL_IS_2664 = NULL;
text_stream *TL_IS_2665 = NULL;
text_stream *TL_IS_2666 = NULL;
text_stream *TL_IS_2667 = NULL;
text_stream *TL_IS_2668 = NULL;
text_stream *TL_IS_2669 = NULL;
text_stream *TL_IS_2670 = NULL;
text_stream *TL_IS_2671 = NULL;
text_stream *TL_IS_2672 = NULL;
text_stream *TL_IS_2673 = NULL;
text_stream *TL_IS_2674 = NULL;
text_stream *TL_IS_2675 = NULL;
text_stream *TL_IS_2676 = NULL;
text_stream *TL_IS_2677 = NULL;
text_stream *TL_IS_2678 = NULL;
text_stream *TL_IS_2679 = NULL;
text_stream *TL_IS_2680 = NULL;
text_stream *TL_IS_2681 = NULL;
text_stream *TL_IS_2682 = NULL;
text_stream *TL_IS_2683 = NULL;
text_stream *TL_IS_2684 = NULL;
text_stream *TL_IS_2685 = NULL;
text_stream *TL_IS_2686 = NULL;
text_stream *TL_IS_2687 = NULL;
text_stream *TL_IS_2688 = NULL;
text_stream *TL_IS_2689 = NULL;
text_stream *TL_IS_2690 = NULL;
text_stream *TL_IS_2691 = NULL;
text_stream *TL_IS_2692 = NULL;
text_stream *TL_IS_2693 = NULL;
text_stream *TL_IS_2694 = NULL;
text_stream *TL_IS_2695 = NULL;
text_stream *TL_IS_2696 = NULL;
text_stream *TL_IS_2697 = NULL;
text_stream *TL_IS_2698 = NULL;
text_stream *TL_IS_2699 = NULL;
text_stream *TL_IS_2700 = NULL;
text_stream *TL_IS_2701 = NULL;
text_stream *TL_IS_2702 = NULL;
text_stream *TL_IS_2703 = NULL;
text_stream *TL_IS_2704 = NULL;
text_stream *TL_IS_2705 = NULL;
text_stream *TL_IS_2706 = NULL;
text_stream *TL_IS_2707 = NULL;
text_stream *TL_IS_2708 = NULL;
text_stream *TL_IS_2709 = NULL;
text_stream *TL_IS_2710 = NULL;
text_stream *TL_IS_2711 = NULL;
text_stream *TL_IS_2712 = NULL;
text_stream *TL_IS_2713 = NULL;
text_stream *TL_IS_2714 = NULL;
text_stream *TL_IS_2715 = NULL;
text_stream *TL_IS_2716 = NULL;
text_stream *TL_IS_2717 = NULL;
text_stream *TL_IS_2718 = NULL;
text_stream *TL_IS_2719 = NULL;
text_stream *TL_IS_2720 = NULL;
text_stream *TL_IS_2721 = NULL;
text_stream *TL_IS_2722 = NULL;
text_stream *TL_IS_2723 = NULL;
text_stream *TL_IS_2724 = NULL;
text_stream *TL_IS_2725 = NULL;
text_stream *TL_IS_2726 = NULL;
text_stream *TL_IS_2727 = NULL;
text_stream *TL_IS_2728 = NULL;
text_stream *TL_IS_2729 = NULL;
text_stream *TL_IS_2730 = NULL;
text_stream *TL_IS_2731 = NULL;
text_stream *TL_IS_2732 = NULL;
text_stream *TL_IS_2733 = NULL;
text_stream *TL_IS_2734 = NULL;
text_stream *TL_IS_2735 = NULL;
text_stream *TL_IS_2736 = NULL;
text_stream *TL_IS_2737 = NULL;
text_stream *TL_IS_2738 = NULL;
text_stream *TL_IS_2739 = NULL;
text_stream *TL_IS_2740 = NULL;
text_stream *TL_IS_2741 = NULL;
text_stream *TL_IS_2742 = NULL;
text_stream *TL_IS_2743 = NULL;
text_stream *TL_IS_2744 = NULL;
text_stream *TL_IS_2745 = NULL;
text_stream *TL_IS_2746 = NULL;
text_stream *TL_IS_2747 = NULL;
text_stream *TL_IS_2748 = NULL;
text_stream *TL_IS_2749 = NULL;
text_stream *TL_IS_2750 = NULL;
text_stream *TL_IS_2751 = NULL;
text_stream *TL_IS_2752 = NULL;
text_stream *TL_IS_2753 = NULL;
text_stream *TL_IS_2754 = NULL;
text_stream *TL_IS_2755 = NULL;
text_stream *TL_IS_2756 = NULL;
text_stream *TL_IS_2757 = NULL;
text_stream *TL_IS_2758 = NULL;
text_stream *TL_IS_2759 = NULL;
text_stream *TL_IS_2760 = NULL;
text_stream *TL_IS_2761 = NULL;
text_stream *TL_IS_2762 = NULL;
text_stream *TL_IS_2763 = NULL;
text_stream *TL_IS_2764 = NULL;
text_stream *TL_IS_2765 = NULL;
text_stream *TL_IS_2766 = NULL;
text_stream *TL_IS_2767 = NULL;
text_stream *TL_IS_2768 = NULL;
text_stream *TL_IS_2769 = NULL;
text_stream *TL_IS_2770 = NULL;
text_stream *TL_IS_2771 = NULL;
text_stream *TL_IS_2772 = NULL;
text_stream *TL_IS_2773 = NULL;
text_stream *TL_IS_2774 = NULL;
text_stream *TL_IS_2775 = NULL;
text_stream *TL_IS_2776 = NULL;
text_stream *TL_IS_2777 = NULL;
text_stream *TL_IS_2778 = NULL;
text_stream *TL_IS_2779 = NULL;
text_stream *TL_IS_2780 = NULL;
text_stream *TL_IS_2781 = NULL;
text_stream *TL_IS_2782 = NULL;
text_stream *TL_IS_2783 = NULL;
text_stream *TL_IS_2784 = NULL;
text_stream *TL_IS_2785 = NULL;
text_stream *TL_IS_2786 = NULL;
text_stream *TL_IS_2787 = NULL;
text_stream *TL_IS_2788 = NULL;
text_stream *TL_IS_2789 = NULL;
text_stream *TL_IS_2790 = NULL;
text_stream *TL_IS_2791 = NULL;
text_stream *TL_IS_2792 = NULL;
text_stream *TL_IS_2793 = NULL;
text_stream *TL_IS_2794 = NULL;
text_stream *TL_IS_2795 = NULL;
text_stream *TL_IS_2796 = NULL;
text_stream *TL_IS_2797 = NULL;
text_stream *TL_IS_2798 = NULL;
text_stream *TL_IS_2799 = NULL;
text_stream *TL_IS_2800 = NULL;
text_stream *TL_IS_2801 = NULL;
text_stream *TL_IS_2802 = NULL;
text_stream *TL_IS_2803 = NULL;
text_stream *TL_IS_2804 = NULL;
text_stream *TL_IS_2805 = NULL;
text_stream *TL_IS_2806 = NULL;
text_stream *TL_IS_2807 = NULL;
text_stream *TL_IS_2808 = NULL;
text_stream *TL_IS_2809 = NULL;
text_stream *TL_IS_2810 = NULL;
text_stream *TL_IS_2811 = NULL;
text_stream *TL_IS_2812 = NULL;
text_stream *TL_IS_2813 = NULL;
text_stream *TL_IS_2814 = NULL;
text_stream *TL_IS_2815 = NULL;
text_stream *TL_IS_2816 = NULL;
text_stream *TL_IS_2817 = NULL;
text_stream *TL_IS_2818 = NULL;
text_stream *TL_IS_2819 = NULL;
text_stream *TL_IS_2820 = NULL;
text_stream *TL_IS_2821 = NULL;
text_stream *TL_IS_2822 = NULL;
text_stream *TL_IS_2823 = NULL;
text_stream *TL_IS_2824 = NULL;
text_stream *TL_IS_2825 = NULL;
text_stream *TL_IS_2826 = NULL;
text_stream *TL_IS_2827 = NULL;
text_stream *TL_IS_2828 = NULL;
text_stream *TL_IS_2829 = NULL;
text_stream *TL_IS_2830 = NULL;
text_stream *TL_IS_2831 = NULL;
text_stream *TL_IS_2832 = NULL;
text_stream *TL_IS_2833 = NULL;
text_stream *TL_IS_2834 = NULL;
text_stream *TL_IS_2835 = NULL;
text_stream *TL_IS_2836 = NULL;
text_stream *TL_IS_2837 = NULL;
text_stream *TL_IS_2838 = NULL;
text_stream *TL_IS_2839 = NULL;
text_stream *TL_IS_2840 = NULL;
text_stream *TL_IS_2841 = NULL;
text_stream *TL_IS_2842 = NULL;
text_stream *TL_IS_2843 = NULL;
text_stream *TL_IS_2844 = NULL;
text_stream *TL_IS_2845 = NULL;
text_stream *TL_IS_2846 = NULL;
text_stream *TL_IS_2847 = NULL;
text_stream *TL_IS_2848 = NULL;
text_stream *TL_IS_2849 = NULL;
text_stream *TL_IS_2850 = NULL;
text_stream *TL_IS_2851 = NULL;
text_stream *TL_IS_2852 = NULL;
text_stream *TL_IS_2853 = NULL;
text_stream *TL_IS_2854 = NULL;
text_stream *TL_IS_2855 = NULL;
text_stream *TL_IS_2856 = NULL;
text_stream *TL_IS_2857 = NULL;
text_stream *TL_IS_2858 = NULL;
text_stream *TL_IS_2859 = NULL;
text_stream *TL_IS_2860 = NULL;
text_stream *TL_IS_2861 = NULL;
text_stream *TL_IS_2862 = NULL;
text_stream *TL_IS_2863 = NULL;
text_stream *TL_IS_2864 = NULL;
text_stream *TL_IS_2865 = NULL;
text_stream *TL_IS_2866 = NULL;
text_stream *TL_IS_2867 = NULL;
text_stream *TL_IS_2868 = NULL;
text_stream *TL_IS_2869 = NULL;
text_stream *TL_IS_2870 = NULL;
text_stream *TL_IS_2871 = NULL;
text_stream *TL_IS_2872 = NULL;
text_stream *TL_IS_2873 = NULL;
text_stream *TL_IS_2874 = NULL;
text_stream *TL_IS_2875 = NULL;
text_stream *TL_IS_2876 = NULL;
text_stream *TL_IS_2877 = NULL;
text_stream *TL_IS_2878 = NULL;
text_stream *TL_IS_2879 = NULL;
text_stream *TL_IS_2880 = NULL;
text_stream *TL_IS_2881 = NULL;
text_stream *TL_IS_2882 = NULL;
text_stream *TL_IS_2883 = NULL;
text_stream *TL_IS_2884 = NULL;
text_stream *TL_IS_2885 = NULL;
text_stream *TL_IS_2886 = NULL;
text_stream *TL_IS_2887 = NULL;
text_stream *TL_IS_2888 = NULL;
text_stream *TL_IS_2889 = NULL;
text_stream *TL_IS_2890 = NULL;
text_stream *TL_IS_2891 = NULL;
text_stream *TL_IS_2892 = NULL;
text_stream *TL_IS_2893 = NULL;
text_stream *TL_IS_2894 = NULL;
text_stream *TL_IS_2895 = NULL;
text_stream *TL_IS_2896 = NULL;
text_stream *TL_IS_2897 = NULL;
text_stream *TL_IS_2898 = NULL;
text_stream *TL_IS_2899 = NULL;
text_stream *TL_IS_2900 = NULL;
text_stream *TL_IS_2901 = NULL;
text_stream *TL_IS_2902 = NULL;
text_stream *TL_IS_2903 = NULL;
text_stream *TL_IS_2904 = NULL;
text_stream *TL_IS_2905 = NULL;
text_stream *TL_IS_2906 = NULL;
text_stream *TL_IS_2907 = NULL;
text_stream *TL_IS_2908 = NULL;
text_stream *TL_IS_2909 = NULL;
text_stream *TL_IS_2910 = NULL;
text_stream *TL_IS_2911 = NULL;
text_stream *TL_IS_2912 = NULL;
text_stream *TL_IS_2913 = NULL;
text_stream *TL_IS_2914 = NULL;
text_stream *TL_IS_2915 = NULL;
text_stream *TL_IS_2916 = NULL;
text_stream *TL_IS_2917 = NULL;
text_stream *TL_IS_2918 = NULL;
text_stream *TL_IS_2919 = NULL;
text_stream *TL_IS_2920 = NULL;
text_stream *TL_IS_2921 = NULL;
text_stream *TL_IS_2922 = NULL;
text_stream *TL_IS_2923 = NULL;
text_stream *TL_IS_2924 = NULL;
text_stream *TL_IS_2925 = NULL;
text_stream *TL_IS_2926 = NULL;
text_stream *TL_IS_2927 = NULL;
text_stream *TL_IS_2928 = NULL;
text_stream *TL_IS_2929 = NULL;
text_stream *TL_IS_2930 = NULL;
text_stream *TL_IS_2931 = NULL;
text_stream *TL_IS_2932 = NULL;
text_stream *TL_IS_2933 = NULL;
text_stream *TL_IS_2934 = NULL;
text_stream *TL_IS_2935 = NULL;
text_stream *TL_IS_2936 = NULL;
text_stream *TL_IS_2937 = NULL;
text_stream *TL_IS_2938 = NULL;
text_stream *TL_IS_2939 = NULL;
text_stream *TL_IS_2940 = NULL;
text_stream *TL_IS_2941 = NULL;
text_stream *TL_IS_2942 = NULL;
text_stream *TL_IS_2943 = NULL;
text_stream *TL_IS_2944 = NULL;
text_stream *TL_IS_2945 = NULL;
text_stream *TL_IS_2946 = NULL;
text_stream *TL_IS_2947 = NULL;
text_stream *TL_IS_2948 = NULL;
text_stream *TL_IS_2949 = NULL;
text_stream *TL_IS_2950 = NULL;
text_stream *TL_IS_2951 = NULL;
text_stream *TL_IS_2952 = NULL;
text_stream *TL_IS_2953 = NULL;
text_stream *TL_IS_2954 = NULL;
text_stream *TL_IS_2955 = NULL;
text_stream *TL_IS_2956 = NULL;
text_stream *TL_IS_2957 = NULL;
text_stream *TL_IS_2958 = NULL;
text_stream *TL_IS_2959 = NULL;
text_stream *TL_IS_2960 = NULL;
text_stream *TL_IS_2961 = NULL;
text_stream *TL_IS_2962 = NULL;
text_stream *TL_IS_2963 = NULL;
text_stream *TL_IS_2964 = NULL;
text_stream *TL_IS_2965 = NULL;
text_stream *TL_IS_2966 = NULL;
text_stream *TL_IS_2967 = NULL;
text_stream *TL_IS_2968 = NULL;
text_stream *TL_IS_2969 = NULL;
text_stream *TL_IS_2970 = NULL;
text_stream *TL_IS_2971 = NULL;
text_stream *TL_IS_2972 = NULL;
text_stream *TL_IS_2973 = NULL;
text_stream *TL_IS_2974 = NULL;
text_stream *TL_IS_2975 = NULL;
text_stream *TL_IS_2976 = NULL;
text_stream *TL_IS_2977 = NULL;
text_stream *TL_IS_2978 = NULL;
text_stream *TL_IS_2979 = NULL;
text_stream *TL_IS_2980 = NULL;
text_stream *TL_IS_2981 = NULL;
text_stream *TL_IS_2982 = NULL;
text_stream *TL_IS_2983 = NULL;
text_stream *TL_IS_2984 = NULL;
text_stream *TL_IS_2985 = NULL;
text_stream *TL_IS_2986 = NULL;
text_stream *TL_IS_2987 = NULL;
text_stream *TL_IS_2988 = NULL;
text_stream *TL_IS_2989 = NULL;
text_stream *TL_IS_2990 = NULL;
text_stream *TL_IS_2991 = NULL;
text_stream *TL_IS_2992 = NULL;
text_stream *TL_IS_2993 = NULL;
text_stream *TL_IS_2994 = NULL;
text_stream *TL_IS_2995 = NULL;
text_stream *TL_IS_2996 = NULL;
text_stream *TL_IS_2997 = NULL;
text_stream *TL_IS_2998 = NULL;
text_stream *TL_IS_2999 = NULL;
text_stream *TL_IS_3000 = NULL;
text_stream *TL_IS_3001 = NULL;
text_stream *TL_IS_3002 = NULL;
text_stream *TL_IS_3003 = NULL;
text_stream *TL_IS_3004 = NULL;
text_stream *TL_IS_3005 = NULL;
text_stream *TL_IS_3006 = NULL;
text_stream *TL_IS_3007 = NULL;
text_stream *TL_IS_3008 = NULL;
text_stream *TL_IS_3009 = NULL;
text_stream *TL_IS_3010 = NULL;
text_stream *TL_IS_3011 = NULL;
text_stream *TL_IS_3012 = NULL;
text_stream *TL_IS_3013 = NULL;
text_stream *TL_IS_3014 = NULL;
text_stream *TL_IS_3015 = NULL;
text_stream *TL_IS_3016 = NULL;
text_stream *TL_IS_3017 = NULL;
text_stream *TL_IS_3018 = NULL;
text_stream *TL_IS_3019 = NULL;
text_stream *TL_IS_3020 = NULL;
text_stream *TL_IS_3021 = NULL;
text_stream *TL_IS_3022 = NULL;
text_stream *TL_IS_3023 = NULL;
text_stream *TL_IS_3024 = NULL;
text_stream *TL_IS_3025 = NULL;
text_stream *TL_IS_3026 = NULL;
text_stream *TL_IS_3027 = NULL;
text_stream *TL_IS_3028 = NULL;
text_stream *TL_IS_3029 = NULL;
text_stream *TL_IS_3030 = NULL;
text_stream *TL_IS_3031 = NULL;
text_stream *TL_IS_3032 = NULL;
text_stream *TL_IS_3033 = NULL;
text_stream *TL_IS_3034 = NULL;
text_stream *TL_IS_3035 = NULL;
text_stream *TL_IS_3036 = NULL;
text_stream *TL_IS_3037 = NULL;
text_stream *TL_IS_3038 = NULL;
text_stream *TL_IS_3039 = NULL;
text_stream *TL_IS_3040 = NULL;
text_stream *TL_IS_3041 = NULL;
text_stream *TL_IS_3042 = NULL;
text_stream *TL_IS_3043 = NULL;
text_stream *TL_IS_3044 = NULL;
text_stream *TL_IS_3045 = NULL;
text_stream *TL_IS_3046 = NULL;
text_stream *TL_IS_3047 = NULL;
text_stream *TL_IS_3048 = NULL;
text_stream *TL_IS_3049 = NULL;
text_stream *TL_IS_3050 = NULL;
text_stream *TL_IS_3051 = NULL;
text_stream *TL_IS_3052 = NULL;
text_stream *TL_IS_3053 = NULL;
text_stream *TL_IS_3054 = NULL;
text_stream *TL_IS_3055 = NULL;
text_stream *TL_IS_3056 = NULL;
text_stream *TL_IS_3057 = NULL;
text_stream *TL_IS_3058 = NULL;
text_stream *TL_IS_3059 = NULL;
text_stream *TL_IS_3060 = NULL;
text_stream *TL_IS_3061 = NULL;
text_stream *TL_IS_3062 = NULL;
text_stream *TL_IS_3063 = NULL;
text_stream *TL_IS_3064 = NULL;
text_stream *TL_IS_3065 = NULL;
text_stream *TL_IS_3066 = NULL;
text_stream *TL_IS_3067 = NULL;
text_stream *TL_IS_3068 = NULL;
text_stream *TL_IS_3069 = NULL;
text_stream *TL_IS_3070 = NULL;
text_stream *TL_IS_3071 = NULL;
text_stream *TL_IS_3072 = NULL;
text_stream *TL_IS_3073 = NULL;
text_stream *TL_IS_3074 = NULL;
text_stream *TL_IS_3075 = NULL;
text_stream *TL_IS_3076 = NULL;
text_stream *TL_IS_3077 = NULL;
text_stream *TL_IS_3078 = NULL;
text_stream *TL_IS_3079 = NULL;
text_stream *TL_IS_3080 = NULL;
text_stream *TL_IS_3081 = NULL;
text_stream *TL_IS_3082 = NULL;
text_stream *TL_IS_3083 = NULL;
text_stream *TL_IS_3084 = NULL;
text_stream *TL_IS_3085 = NULL;
text_stream *TL_IS_3086 = NULL;
text_stream *TL_IS_3087 = NULL;
text_stream *TL_IS_3088 = NULL;
text_stream *TL_IS_3089 = NULL;
text_stream *TL_IS_3090 = NULL;
text_stream *TL_IS_3091 = NULL;
text_stream *TL_IS_3092 = NULL;
text_stream *TL_IS_3093 = NULL;
text_stream *TL_IS_3094 = NULL;
text_stream *TL_IS_3095 = NULL;
text_stream *TL_IS_3096 = NULL;
text_stream *TL_IS_3097 = NULL;
text_stream *TL_IS_3098 = NULL;
text_stream *TL_IS_3099 = NULL;
text_stream *TL_IS_3100 = NULL;
text_stream *TL_IS_3101 = NULL;
text_stream *TL_IS_3102 = NULL;
text_stream *TL_IS_3103 = NULL;
text_stream *TL_IS_3104 = NULL;
text_stream *TL_IS_3105 = NULL;
text_stream *TL_IS_3106 = NULL;
text_stream *TL_IS_3107 = NULL;
text_stream *TL_IS_3108 = NULL;
text_stream *TL_IS_3109 = NULL;
text_stream *TL_IS_3110 = NULL;
text_stream *TL_IS_3111 = NULL;
text_stream *TL_IS_3112 = NULL;
text_stream *TL_IS_3113 = NULL;
text_stream *TL_IS_3114 = NULL;
text_stream *TL_IS_3115 = NULL;
text_stream *TL_IS_3116 = NULL;
text_stream *TL_IS_3117 = NULL;
text_stream *TL_IS_3118 = NULL;
text_stream *TL_IS_3119 = NULL;
text_stream *TL_IS_3120 = NULL;
text_stream *TL_IS_3121 = NULL;
text_stream *TL_IS_3122 = NULL;
text_stream *TL_IS_3123 = NULL;
text_stream *TL_IS_3124 = NULL;
text_stream *TL_IS_3125 = NULL;
text_stream *TL_IS_3126 = NULL;
text_stream *TL_IS_3127 = NULL;
text_stream *TL_IS_3128 = NULL;
text_stream *TL_IS_3129 = NULL;
text_stream *TL_IS_3130 = NULL;
text_stream *TL_IS_3131 = NULL;
text_stream *TL_IS_3132 = NULL;
text_stream *TL_IS_3133 = NULL;
text_stream *TL_IS_3134 = NULL;
text_stream *TL_IS_3135 = NULL;
text_stream *TL_IS_3136 = NULL;
text_stream *TL_IS_3137 = NULL;
text_stream *TL_IS_3138 = NULL;
text_stream *TL_IS_3139 = NULL;
text_stream *TL_IS_3140 = NULL;
text_stream *TL_IS_3141 = NULL;
text_stream *TL_IS_3142 = NULL;
text_stream *TL_IS_3143 = NULL;
text_stream *TL_IS_3144 = NULL;
text_stream *TL_IS_3145 = NULL;
text_stream *TL_IS_3146 = NULL;
text_stream *TL_IS_3147 = NULL;
text_stream *TL_IS_3148 = NULL;
text_stream *TL_IS_3149 = NULL;
text_stream *TL_IS_3150 = NULL;
text_stream *TL_IS_3151 = NULL;
text_stream *TL_IS_3152 = NULL;
text_stream *TL_IS_3153 = NULL;
text_stream *TL_IS_3154 = NULL;
text_stream *TL_IS_3155 = NULL;
text_stream *TL_IS_3156 = NULL;
text_stream *TL_IS_3157 = NULL;
text_stream *TL_IS_3158 = NULL;
text_stream *TL_IS_3159 = NULL;
text_stream *TL_IS_3160 = NULL;
void register_tangled_text_literals(void);
#line 57 "inweb/foundation-module/Chapter 2/Streams.w"
#define WRITE(args...) Writers__printf(OUT, args)

#define PRINT(args...) Writers__printf(STDOUT, args)

#define WRITE_TO(stream, args...) Writers__printf(stream, args)

#define LOG(args...) Writers__printf(DL, args)

#define LOGIF(aspect, args...) { \
	if (Log__aspect_switched_on(aspect##_DA)) Writers__printf(DL, args); \
}

#line 52 "inweb/foundation-module/Chapter 1/Foundation Module.w"
text_stream *DL = NULL; /* Current destination of debugging text: kept |NULL| until opened */

#line 81 "inweb/foundation-module/Chapter 1/Foundation Module.w"

#line 91 "inweb/foundation-module/Chapter 1/Foundation Module.w"
void Foundation__start(int argc, char **argv) {
	CommandLine__set_locale(argc, argv);
	Platform__configure_terminal();
	Memory__start();
	
{
#line 111 "inweb/foundation-module/Chapter 1/Foundation Module.w"
	Writers__register_writer('f', &Filenames__writer);
	Writers__register_writer('p', &Pathnames__writer);
	Writers__register_writer('v', &VersionNumbers__writer);
	Writers__register_writer('S', &Streams__writer);

}
#line 95 "inweb/foundation-module/Chapter 1/Foundation Module.w"
;
	register_tangled_text_literals();
;
	Time__begin();
	Pathnames__start();
	MarkdownVariations__start();
	
{
#line 122 "inweb/foundation-module/Chapter 1/Foundation Module.w"
	Log__declare_aspect(DEBUGGING_LOG_INCLUSIONS_DA, U"debugging log inclusions", FALSE, FALSE);
	Log__declare_aspect(SHELL_USAGE_DA, U"shell usage", FALSE, FALSE);
	Log__declare_aspect(MEMORY_USAGE_DA, U"memory usage", FALSE, FALSE);
	Log__declare_aspect(TEXT_FILES_DA, U"text files", FALSE, FALSE);

}
#line 100 "inweb/foundation-module/Chapter 1/Foundation Module.w"
;
	
{
#line 133 "inweb/foundation-module/Chapter 1/Foundation Module.w"
	Writers__register_logger('a', &Tries__log_avinue);
	Writers__register_logger('S', &Streams__log);

}
#line 101 "inweb/foundation-module/Chapter 1/Foundation Module.w"
;
	
{
#line 153 "inweb/foundation-module/Chapter 1/Foundation Module.w"
	CommandLine__begin_group(FOUNDATION_CLSG, NULL);
	CommandLine__declare_switch(LOG_CLSW, U"log", 2,
		U"write the debugging log to include diagnostics on X");
	CommandLine__declare_switch(VERSION_CLSW, U"version", 1,
		U"print out version number");
	CommandLine__declare_boolean_switch(CRASH_CLSW, U"crash", 1,
		U"intentionally crash on internal errors, for backtracing", FALSE);
	CommandLine__declare_switch(HELP_CLSW, U"help", 1,
		U"print this help information");
	CommandLine__declare_boolean_switch(FIXTIME_CLSW, U"fixtime", 1,
		U"pretend the time is 11 a.m. on 28 March 2016 for testing", FALSE);
	CommandLine__declare_switch(AT_CLSW, U"at", 2,
		U"specify that this tool is installed at X");
	CommandLine__declare_switch(LOCALE_CLSW, U"locale", 2,
		U"set locales as 'L=E', L being shell or console, E platform, utf-8 or iso-latin1");
	CommandLine__end_group();

}
#line 102 "inweb/foundation-module/Chapter 1/Foundation Module.w"
;
}

#line 151 "inweb/foundation-module/Chapter 1/Foundation Module.w"

#line 176 "inweb/foundation-module/Chapter 1/Foundation Module.w"
void Foundation__end(void) {
	if (Log__aspect_switched_on(MEMORY_USAGE_DA)) Memory__log_statistics();
	Log__close();
	Memory__free();
}

#ifdef PLATFORM_POSIX
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 81 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__is_folder_separator(inchar32_t c) {
	return (c == FOLDER_SEPARATOR);
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 93 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#ifndef LOCALE_IS_ISO
#ifndef LOCALE_IS_UTF8
#define LOCALE_IS_UTF8 1
#endif
#endif

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 102 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
char *Platform__getenv(const char *name) {
	return getenv(name);
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#line 115 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__where_am_i(inchar32_t *p, size_t length) {
    char buffer[PATH_MAX + 1];
    
{
#ifdef PLATFORM_POSIX
#line 127 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	ssize_t link_len = readlink("/proc/self/exe", buffer, PATH_MAX);
    if (link_len < 0) 
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 128 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
; // unable to find
    buffer[link_len] = '\0';

#endif /* PLATFORM_POSIX */
}
#line 117 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;
	
{
#ifdef PLATFORM_POSIX
#line 136 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
    size_t convert_len = mbstowcs(p, buffer, length);
    if (convert_len == (size_t)-1) 
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 137 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
; // wouldn't fit

#endif /* PLATFORM_POSIX */
}
#line 118 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;
}

#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_UNIX
#ifdef PLATFORM_POSIX
#line 166 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__where_am_i(inchar32_t *p, size_t length) {
	
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 167 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;
}

#endif /* PLATFORM_UNIX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#line 173 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__where_am_i(inchar32_t *p, size_t length) {
	
{
#ifdef PLATFORM_POSIX
#line 180 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
	p[0] = '\0';
	return;

#endif /* PLATFORM_POSIX */
}
#line 174 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
;
}

#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifndef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 186 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__system(const char *cmd) {
	return system(cmd);
}

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 211 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

int Platform__system(const char *cmd) {
    char *argv[] = {"sh", "-c", (char *) cmd, NULL};
    pid_t pid;
    int status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
    if (status == 0) {
        if (waitpid(pid, &status, 0) != -1) return status;
    	internal_error("waitpid failed");
    } else {
        WRITE_TO(STDERR, "posix_spawn: %s\n", strerror(status));
        internal_error("posix_spawn failed");
    }
    return -1;
}

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 233 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__mkdir(char *transcoded_pathname) {
	errno = 0;
	int rv = mkdir(transcoded_pathname, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	if (rv == 0) return TRUE;
	if (errno == EEXIST) return TRUE;
	return FALSE;
}

void *Platform__opendir(char *dir_name) {
	DIR *dirp = opendir(dir_name);
	return (void *) dirp;
}

int Platform__readdir(void *D, char *dir_name, char *leafname) {
	char path_to[2*MAX_FILENAME_LENGTH+2];
	struct stat file_status;
	int rv;
	DIR *dirp = (DIR *) D;
	struct dirent *dp;
	do {
	  dp = readdir(dirp);
	  if (dp == NULL) return FALSE;
	  sprintf(path_to, "%s%c%s", dir_name, FOLDER_SEPARATOR, dp->d_name);
  	  errno = 0;
	  rv = stat(path_to, &file_status);
        } while (dp && (errno == ENOENT));
	if (rv != 0) return FALSE;
	if (S_ISDIR(file_status.st_mode)) sprintf(leafname, "%s/", dp->d_name);
	else strcpy(leafname, dp->d_name);
	return TRUE;
}

void Platform__closedir(void *D) {
	DIR *dirp = (DIR *) D;
	closedir(dirp);
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 273 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__rename_file(char *old_transcoded_pathname, char *new_transcoded_pathname) {
	if (rename(old_transcoded_pathname, new_transcoded_pathname) != 0)
		return FALSE;
	return TRUE;
}

int Platform__rename_directory(char *old_transcoded_pathname, char *new_transcoded_pathname) {
	if (rename(old_transcoded_pathname, new_transcoded_pathname) != 0)
		return FALSE;
	return TRUE;
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 288 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__copy_file(char *from_transcoded_pathname, char *to_transcoded_pathname) {
	char cp_command[10*MAX_FILENAME_LENGTH];
	sprintf(cp_command, "cp -f ");
	Platform__quote_text(cp_command + strlen(cp_command), from_transcoded_pathname, FALSE);
	sprintf(cp_command + strlen(cp_command), " ");
	Platform__quote_text(cp_command + strlen(cp_command), to_transcoded_pathname, FALSE);
	Platform__system(cp_command);
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 305 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
time_t Platform__never_time(void) {
	return (time_t) 0;
}

time_t Platform__timestamp(char *transcoded_filename) {
	struct stat filestat;
	if (stat(transcoded_filename, &filestat) != -1) return filestat.st_mtime;
	return Platform__never_time();
}

off_t Platform__size(char *transcoded_filename) {
	struct stat filestat;
	if (stat(transcoded_filename, &filestat) != -1) return filestat.st_size;
	return (off_t) 0;
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 329 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__rsync(char *transcoded_source, char *transcoded_dest) {
	char rsync_command[10*MAX_FILENAME_LENGTH];
	sprintf(rsync_command, "rsync -a --delete ");
	Platform__quote_text(rsync_command + strlen(rsync_command), transcoded_source, TRUE);
	sprintf(rsync_command + strlen(rsync_command), " ");
	Platform__quote_text(rsync_command + strlen(rsync_command), transcoded_dest, FALSE);
	Platform__system(rsync_command);
}

void Platform__quote_text(char *quoted, char *raw, int terminate) {
	quoted[0] = SHELL_QUOTE_CHARACTER;
	int qp = 1;
	for (int rp = 0; raw[rp]; rp++) {
		char c = raw[rp];
		if (c == SHELL_QUOTE_CHARACTER) quoted[qp++] = '\\';
		quoted[qp++] = c;
	}
	if (terminate) quoted[qp++] = FOLDER_SEPARATOR;
	quoted[qp++] = SHELL_QUOTE_CHARACTER;
	quoted[qp++] = 0;
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 354 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__sleep(int seconds) {
	sleep((unsigned int) seconds);
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 370 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__notification(text_stream *text, int happy) {
	char *sound_name = "Bell.aiff";
	if (happy == FALSE) sound_name = "Submarine.aiff";
	TEMPORARY_TEXT(TEMP)
	WRITE_TO(TEMP, "osascript -e 'display notification \"%S\" "
		"sound name \"%s\" with title \"intest Results\"'", text, sound_name);
	Shell__run(TEMP);
	DISCARD_TEXT(TEMP)
}

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifndef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 383 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__notification(text_stream *text, int happy) {
}

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 396 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
void Platform__configure_terminal(void) {
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#line 408 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__create_thread(foundation_thread *pt,
	const foundation_thread_attributes *pa, void *(*fn)(void *), void *arg) {
	return pthread_create(pt, pa, fn, arg);
}

int Platform__join_thread(foundation_thread pt, void** rv) {
	return pthread_join(pt, rv);
}

void Platform__init_thread(foundation_thread_attributes *pa, size_t size) {
	if (pthread_attr_init(pa) != 0) internal_error("thread initialisation failed");
	if (pthread_attr_setstacksize(pa, size) != 0) internal_error("thread stack sizing failed");
}

size_t Platform__get_thread_stack_size(foundation_thread_attributes *pa) {
	size_t mystacksize;
	pthread_attr_getstacksize(pa, &mystacksize);
	return mystacksize;
}

#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_LINUX
#ifdef PLATFORM_POSIX
#line 443 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__get_core_count(void) {
	int N = get_nprocs();
	if (N < 1) return 1;
	return N;
}

#endif /* PLATFORM_LINUX */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_MACOS
#ifdef PLATFORM_POSIX
#line 457 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__get_core_count(void) {
	int N;
	size_t N_size = sizeof(int);
	sysctlbyname("hw.logicalcpu", &N, &N_size, NULL, 0);
	if (N < 1) return 1;
	return N;
}

#endif /* PLATFORM_MACOS */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_ANDROID
#ifdef PLATFORM_POSIX
#line 469 "inweb/foundation-module/Chapter 1/POSIX Platforms.w"
int Platform__get_core_count(void) {
	return 1;
}

#endif /* PLATFORM_ANDROID */
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_POSIX
#endif /* PLATFORM_POSIX */
#ifdef PLATFORM_WINDOWS
#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 38 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int Platform__is_folder_separator(inchar32_t c) {
	return ((c == '\\') || (c == '/'));
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 70 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void Platform__where_am_i(inchar32_t *p, size_t length) {
  char path[_MAX_PATH];
	DWORD result = GetModuleFileName(NULL, path, _MAX_PATH);
	if ((result == 0) || (result >= length))
    p[0] = 0;
  else
  {
    for (int i = 0;; i++)
    {
      p[i] = (inchar32_t)path[i];
      if (p[i] == '\0')
        break;
    }
  }
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 178 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int Platform__mkdir(char *transcoded_pathname) {
	errno = 0;
	int rv = mkdir(transcoded_pathname);
	if (rv == 0) return TRUE;
	if (errno == EEXIST) return TRUE;
	return FALSE;
}

void *Platform__opendir(char *dir_name) {
	DIR *dirp = opendir(dir_name);
	return (void *) dirp;
}

int Platform__readdir(void *D, char *dir_name,
	char *leafname) {
	char path_to[2*MAX_FILENAME_LENGTH+2];
	struct _stat file_status;
	int rv;
	DIR *dirp = (DIR *) D;
	struct dirent *dp;
	if ((dp = readdir(dirp)) == NULL) return FALSE;
	sprintf(path_to, "%s%c%s", dir_name, FOLDER_SEPARATOR, dp->d_name);
	rv = _stat(path_to, &file_status);
	if (rv != 0) return FALSE;
	if (S_ISDIR(file_status.st_mode))
		sprintf(leafname, "%s%c", dp->d_name, FOLDER_SEPARATOR);
	else strcpy(leafname, dp->d_name);
	return TRUE;
}

void Platform__closedir(void *D) {
	DIR *dirp = (DIR *) D;
	closedir(dirp);
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 216 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int Platform__rename_file(char *old_transcoded_pathname, char *new_transcoded_pathname) {
	if (rename(old_transcoded_pathname, new_transcoded_pathname) != 0)
		return FALSE;
	return TRUE;
}

int Platform__rename_directory(char *old_transcoded_pathname, char *new_transcoded_pathname) {
	if (rename(old_transcoded_pathname, new_transcoded_pathname) != 0)
		return FALSE;
	return TRUE;
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 231 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void Platform__copy_file(char *from_transcoded_pathname, char *to_transcoded_pathname) {
	CopyFile(from_transcoded_pathname, to_transcoded_pathname, FALSE);
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 238 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void Platform__path_add(const char* base, const char* add, char* path) {
	char last;

	strcpy(path, base);
	last = path[strlen(path) - 1];
	if ((last != '/') && (last != '\\'))
		strcat(path, "\\");
	strcat(path, add);
}

void Platform__rsync(char *transcoded_source, char *transcoded_dest) {
	char srcPath[MAX_PATH], destPath[MAX_PATH];
	WIN32_FIND_DATA findData = { 0 };

	SHCreateDirectoryExA(0, transcoded_dest, NULL);

	Platform__path_add(transcoded_dest, "*", destPath);
	HANDLE findHandle = FindFirstFileA(destPath, &findData);
	if (findHandle != INVALID_HANDLE_VALUE) {
		do {
			if ((strcmp(findData.cFileName, ".") == 0) || (strcmp(findData.cFileName, "..") == 0))
				continue;

			Platform__path_add(transcoded_source, findData.cFileName, srcPath);

			int remove = 1;
			{
				DWORD srcAttrs = GetFileAttributesA(srcPath);
				if (srcAttrs != INVALID_FILE_ATTRIBUTES) {
					if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == (srcAttrs & FILE_ATTRIBUTE_DIRECTORY))
						remove = 0;
				}
			}
			if (remove) {
				Platform__path_add(transcoded_dest, findData.cFileName, destPath);
				if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
					SHFILEOPSTRUCTA oper = { 0 };
					oper.wFunc = FO_DELETE;
					oper.pFrom = destPath;
					oper.fFlags = FOF_NO_UI;
					SHFileOperationA(&oper);
				}
				else DeleteFileA(destPath);
			}
		}
		while (FindNextFileA(findHandle, &findData) != 0);
		FindClose(findHandle);
	}

	Platform__path_add(transcoded_source, "*", srcPath);
	findHandle = FindFirstFileA(srcPath, &findData);
	if (findHandle != INVALID_HANDLE_VALUE) {
		do {
			if ((strcmp(findData.cFileName, ".") == 0) || (strcmp(findData.cFileName, "..") == 0))
				continue;

			Platform__path_add(transcoded_source, findData.cFileName, srcPath);
			Platform__path_add(transcoded_dest, findData.cFileName, destPath);

			if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				CreateDirectoryA(destPath, 0);
				Platform__rsync(srcPath, destPath);
			} else {
				int needCopy = 1;
				{
					WIN32_FIND_DATA destFindData = { 0 };
					HANDLE destFindHandle = FindFirstFileA(destPath, &destFindData);
					if (destFindHandle != INVALID_HANDLE_VALUE) {
						if ((findData.nFileSizeLow == destFindData.nFileSizeLow) && (findData.nFileSizeHigh == destFindData.nFileSizeHigh)) {
							if (CompareFileTime(&(findData.ftLastWriteTime), &(destFindData.ftLastWriteTime)) == 0)
								needCopy = 0;
						}
						FindClose(destFindHandle);
					}
				}

				if (needCopy)
					CopyFileA(srcPath, destPath, 0);
			}
		}
		while (FindNextFileA(findHandle, &findData) != 0);
		FindClose(findHandle);
	}
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 327 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void Platform__sleep(int seconds) {
	Sleep((DWORD)(1000*seconds));
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 334 "inweb/foundation-module/Chapter 1/Windows Platform.w"
void Platform__notification(text_stream *text, int happy) {
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 345 "inweb/foundation-module/Chapter 1/Windows Platform.w"
#define WIN32CONS_RESET_MODE 1
#define WIN32CONS_RESET_OUTCP 2

int Win32_ResetConsole = 0;
DWORD Win32_ConsoleMode = 0;
UINT Win32_ConsoleOutCP = 0;

void Platform__Win32_ResetConsole(void) {
	if (Win32_ResetConsole & WIN32CONS_RESET_MODE) {
		HANDLE cons = GetStdHandle(STD_ERROR_HANDLE);
		if (cons) SetConsoleMode(cons, Win32_ConsoleMode);
	}
	if (Win32_ResetConsole & WIN32CONS_RESET_OUTCP)
		SetConsoleOutputCP(Win32_ConsoleOutCP);
}

void Platform__configure_terminal(void) {
	HANDLE cons = GetStdHandle(STD_ERROR_HANDLE);
	if (cons) {
		if (GetConsoleMode(cons, &Win32_ConsoleMode)) {
			if ((Win32_ConsoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == 0) {
				if (SetConsoleMode(cons, Win32_ConsoleMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) {
					Win32_ResetConsole |= WIN32CONS_RESET_MODE;
				}
			}
		}
	}

	Win32_ConsoleOutCP = GetConsoleOutputCP();
	UINT newCP = 0;
	int loc = Locales__get(CONSOLE_LOCALE);
	if (loc == FILE_ENCODING_ISO_STRF)
		newCP = 28591; /* ISO 8859-1 Latin */
	else if (loc == FILE_ENCODING_UTF8_STRF)
		newCP = CP_UTF8;
	if ((newCP != 0) && SetConsoleOutputCP(newCP))
		Win32_ResetConsole |= WIN32CONS_RESET_OUTCP;

	if (Win32_ResetConsole != 0) atexit(Platform__Win32_ResetConsole);
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 396 "inweb/foundation-module/Chapter 1/Windows Platform.w"
DWORD WINAPI Platform__Win32_Thread_Func(LPVOID param) {
	struct Win32_Thread_Start* start = (struct Win32_Thread_Start*)param;
	(start->fn)(start->arg);
	free(start);
	return 0;
}

int Platform__create_thread(foundation_thread *pt, const foundation_thread_attributes *pa,
	void *(*fn)(void *), void *arg) {
	struct Win32_Thread_Start* start = (struct Win32_Thread_Start*) malloc(sizeof (struct Win32_Thread_Start));
	start->fn = fn;
	start->arg = arg;
	HANDLE thread = CreateThread(0, 0, Platform__Win32_Thread_Func, start, 0, 0);
	if (thread == 0) {
		free(start);
		return 1;
	} else {
		*pt = thread;
		return 0;
	}
}

int Platform__join_thread(foundation_thread pt, void** rv) {
	return (WaitForSingleObject(pt, INFINITE) == WAIT_OBJECT_0) ? 0 : 1;
}

void Platform__init_thread(foundation_thread_attributes* pa, size_t size) {
}

size_t Platform__get_thread_stack_size(foundation_thread_attributes* pa) {
	return 1000000; /* 1Mb, the Windows default */
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 435 "inweb/foundation-module/Chapter 1/Windows Platform.w"
int Platform__get_core_count(void) {
	int count = 0;
	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	count = (int) sysInfo.dwNumberOfProcessors;

	/* Leave one core idle by default */
	if (count > 1)
		count--;

	return count;
}

#endif /* PLATFORM_WINDOWS */
#ifdef PLATFORM_WINDOWS
#line 456 "inweb/foundation-module/Chapter 1/Windows Platform.w"
time_t Platform__never_time(void) {
	return (time_t) 0;
}

time_t Platform__timestamp(char *transcoded_filename) {
	struct stat filestat;
	if (stat(transcoded_filename, &filestat) != -1) return filestat.st_mtime;
	return Platform__never_time();
}

off_t Platform__size(char *transcoded_filename) {
	struct stat filestat;
	if (stat(transcoded_filename, &filestat) != -1) return filestat.st_size;
	return (off_t) 0;
}

#endif /* PLATFORM_WINDOWS */
#line 10 "inweb/foundation-module/Chapter 2/Debugging Log.w"
text_stream debug_log_file_struct; /* The actual debugging log file */
text_stream *debug_log_file = &debug_log_file_struct; /* The actual debugging log file */

#line 49 "inweb/foundation-module/Chapter 2/Debugging Log.w"

#line 59 "inweb/foundation-module/Chapter 2/Debugging Log.w"

#line 61 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int das_created = FALSE;
debugging_aspect the_debugging_aspects[NO_DEFINED_DA_VALUES];

void Log__declare_aspect(int a, inchar32_t *name, int def, int alt) {
	if (das_created == FALSE) {
		das_created = TRUE;
		
{
#line 76 "inweb/foundation-module/Chapter 2/Debugging Log.w"
	for (int a=0; a<NO_DEFINED_DA_VALUES; a++) {
		debugging_aspect *da = &(the_debugging_aspects[a]);
		da->hyphenated_name = Str__new();
		da->unhyphenated_name = Str__new();
		da->negated_name = Str__new();
		da->on_or_off = FALSE;
		da->alternate = FALSE;
	}

}
#line 67 "inweb/foundation-module/Chapter 2/Debugging Log.w"
;
	}
	if ((a < 0) || (a >= NO_DEFINED_DA_VALUES)) internal_error("aspect out of range");

	debugging_aspect *da = &(the_debugging_aspects[a]);
	
{
#line 86 "inweb/foundation-module/Chapter 2/Debugging Log.w"
	WRITE_TO(da->negated_name, "no-");
	for (int i=0; name[i]; i++) {
		inchar32_t c = name[i];
		PUT_TO(da->unhyphenated_name, c);
		if (Characters__is_space_or_tab(c)) c = '-';
		PUT_TO(da->hyphenated_name, c);
		PUT_TO(da->negated_name, c);
	}
	da->on_or_off = def;
	da->alternate = alt;

}
#line 72 "inweb/foundation-module/Chapter 2/Debugging Log.w"
;
}

#line 109 "inweb/foundation-module/Chapter 2/Debugging Log.w"
filename *debug_log_filename = NULL;

filename *Log__get_debug_log_filename(void) {
	return debug_log_filename;
}

void Log__set_debug_log_filename(filename *F) {
	debug_log_filename = F;
}

int Log__open(void) {
	if ((debug_log_filename) && (DL == NULL)) {
		if (STREAM_OPEN_TO_FILE(debug_log_file, debug_log_filename, ISO_ENC) == FALSE)
			return FALSE;
		DL = debug_log_file;
		Streams__enable_debugging(DL);
		LOG("Debugging log of %s\n", PROGRAM_NAME);
		return TRUE;
	}
	return FALSE;
}

int Log__open_alternative(filename *F, text_stream *at) {
	if (STREAM_OPEN_TO_FILE(at, F, ISO_ENC) == FALSE)
		return FALSE;
	DL = at;
	Streams__enable_debugging(DL);
	LOG("Debugging log of %s\n", PROGRAM_NAME);
	return TRUE;
}

void Log__close(void) {
	if (DL) {
		Log__show_debugging_contents();
		STREAM_CLOSE(DL); DL = NULL;
	}
}

#line 153 "inweb/foundation-module/Chapter 2/Debugging Log.w"
char debug_log_phase[32];
int debug_log_subheading = 1;
void Log__new_phase(char *p, text_stream *q) {
	CStrings__truncated_strcpy(debug_log_phase, p, 32);
	LOG("\n\n-----------------------------------------------------\n");
	LOG("Phase %s ... %S", p, q);
	LOG("\n-----------------------------------------------------\n\n");
	STREAM_FLUSH(DL);
	debug_log_subheading = 1;
}

void Log__new_stage(text_stream *p) {
	LOG("\n\n==== Phase %s.%d ... %S ====\n\n", debug_log_phase, debug_log_subheading, p);
	debug_log_subheading++;
	STREAM_FLUSH(DL);
}

#line 178 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int Log__aspect_switched_on(int aspect) {
	int decision = the_debugging_aspects[aspect].on_or_off;
	if (aspect == DEBUGGING_LOG_INCLUSIONS_DA) decision = TRUE;
	if (decision) STREAM_FLUSH(DL);
	return decision;
}

void Log__set_aspect(int aspect, int state) {
	the_debugging_aspects[aspect].on_or_off = state;
}

#line 192 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void Log__set_all_aspects(int new_state) {
	if (DL) LOGIF(DEBUGGING_LOG_INCLUSIONS, "Set debugging aspect: everything -> %s\n",
		new_state?"TRUE":"FALSE");
	for (int a=0; a<NO_DEFINED_DA_VALUES; a++) {
		debugging_aspect *da = &(the_debugging_aspects[a]);
		da->on_or_off = new_state;
	}
}

#line 210 "inweb/foundation-module/Chapter 2/Debugging Log.w"
int Log__set_aspect_from_command_line(text_stream *name, int give_error) {
	int list_mode = FALSE;
	if (Str__eq_wide_string(name, U"everything")) { Log__set_all_aspects(TRUE); return TRUE; }
	if (Str__eq_wide_string(name, U"nothing")) { Log__set_all_aspects(FALSE); return TRUE; }
	if (Str__eq_wide_string(name, U"list")) list_mode = TRUE;

	for (int i=0; i<NO_DEFINED_DA_VALUES; i++) {
		debugging_aspect *da = &(the_debugging_aspects[i]);
		if (Str__eq(name, da->negated_name)) {
			da->on_or_off = FALSE; return TRUE;
		}
		if ((Str__eq(name, da->hyphenated_name)) ||
			(Str__eq(name, da->unhyphenated_name))) {
			da->on_or_off = TRUE; return TRUE;
		}
		if ((list_mode) && (Str__len(da->hyphenated_name) > 0)) {
			PRINT("--log %S  (%s)\n", da->hyphenated_name, (da->on_or_off)?"on":"off");
		}
	}
	if ((list_mode == FALSE) && (give_error))
		PRINT("No such debugging log aspect as '%S'.\n"
			"(Try running -log list for a list of the valid aspects.)\n", name);
	if (list_mode == TRUE) return TRUE;
	return FALSE;
}

#line 241 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void Log__tracing_on(int starred, text_stream *heading) {
	if (starred) {
		LOG("\n*** Entering sentence trace mode: %S ***\n", heading);
	} else {
		LOG("\n*** Leaving sentence trace mode: %S ***\n\n", heading);
	}
	for (int i=0; i<NO_DEFINED_DA_VALUES; i++) {
		debugging_aspect *da = &(the_debugging_aspects[i]);
		int j = da->on_or_off;
		da->on_or_off = da->alternate;
		da->alternate = j;
	}
}

#line 261 "inweb/foundation-module/Chapter 2/Debugging Log.w"
void Log__show_debugging_settings_with_state(int state) {
	int c = 0;
	for (int i=0; i<NO_DEFINED_DA_VALUES; i++) {
		debugging_aspect *da = &(the_debugging_aspects[i]);
		if (da->on_or_off == state) {
			c++;
			LOG("  %S", da->hyphenated_name);
			if (c % 6 == 0) LOG("\n");
		}
	}
	if (c == 0) { LOG("  (nothing)\n"); } else { LOG("\n"); }
}

void Log__show_debugging_contents(void) {
	if (Log__aspect_switched_on(DEBUGGING_LOG_INCLUSIONS_DA) == FALSE) return;
	LOG("\n\nThat concludes the debugging log from this run.\n"
		"Its contents were as follows -\n\n");
	LOG("Included:\n"); Log__show_debugging_settings_with_state(TRUE);
	LOG("Omitted:\n"); Log__show_debugging_settings_with_state(FALSE);
}

#line 70 "inweb/foundation-module/Chapter 2/Memory.w"

#line 76 "inweb/foundation-module/Chapter 2/Memory.w"
allocation_status_structure alloc_status[NO_DEFINED_CLASS_VALUES];

void Memory__start(void) {
	for (int i=0; i<NO_DEFINED_CLASS_VALUES; i++) {
		alloc_status[i].first_in_memory = NULL;
		alloc_status[i].last_in_memory = NULL;
		alloc_status[i].objects_allocated = 0;
		alloc_status[i].objects_count = 0;
		alloc_status[i].bytes_allocated = 0;
		alloc_status[i].no_allocated_together = 1;
		alloc_status[i].name_of_type = "unused";
	}
	Memory__name_fundamental_reasons();
}

#line 127 "inweb/foundation-module/Chapter 2/Memory.w"
int no_blocks_allocated = 0;
int total_objects_allocated = 0; /* a potentially larger number, used only for the debugging log */

#line 141 "inweb/foundation-module/Chapter 2/Memory.w"

#line 143 "inweb/foundation-module/Chapter 2/Memory.w"
memblock_header *first_memblock_header = NULL; /* head of list of memory blocks */
memblock_header *current_memblock_header = NULL; /* tail of list of memory blocks */

int used_in_current_memblock = 0; /* number of bytes so far used in the tail memory block */

CREATE_MUTEX(memory_single_allocation_mutex)
CREATE_MUTEX(memory_array_allocation_mutex)
CREATE_MUTEX(memory_statistics_mutex)

#line 156 "inweb/foundation-module/Chapter 2/Memory.w"
void Memory__allocate_another_block(void) {
	unsigned char *cp;
	memblock_header *mh;

	
{
#line 173 "inweb/foundation-module/Chapter 2/Memory.w"
	Memory__check_memory_integrity();
	cp = (unsigned char *) (Memory__paranoid_calloc(MEMORY_GRANULARITY, 1));
	if (cp == NULL) Errors__fatal("Run out of memory: malloc failed");
	for (int i=0; i<MEMORY_GRANULARITY; i++) cp[i] = 0;

}
#line 160 "inweb/foundation-module/Chapter 2/Memory.w"
;

	mh = (memblock_header *) cp;
	used_in_current_memblock = sizeof(memblock_header) + SAFETY_MARGIN;
	mh->the_memory = (void *) (cp + used_in_current_memblock);

	
{
#line 182 "inweb/foundation-module/Chapter 2/Memory.w"
	if (current_memblock_header == NULL) {
		mh->block_number = 0;
		first_memblock_header = mh;
	} else {
		mh->block_number = current_memblock_header->block_number + 1;
		current_memblock_header->next = mh;
	}
	current_memblock_header = mh;

}
#line 166 "inweb/foundation-module/Chapter 2/Memory.w"
;
}

#line 196 "inweb/foundation-module/Chapter 2/Memory.w"
void Memory__free(void) {
	CStrings__free_ssas();
	memblock_header *mh = first_memblock_header;
	while (mh != NULL) {
		memblock_header *next_mh = mh->next;
		void *p = (void *) mh;
		free(p);
		mh = next_mh;
	}
}

#line 223 "inweb/foundation-module/Chapter 2/Memory.w"

#line 229 "inweb/foundation-module/Chapter 2/Memory.w"
memory_frame *first_memory_frame = NULL; /* earliest memory frame ever allocated */
memory_frame *last_memory_frame = NULL;  /* most recent memory frame allocated */

#line 240 "inweb/foundation-module/Chapter 2/Memory.w"
int calls_to_cmi = 0;
void Memory__check_memory_integrity(void) {
	int c;
	memory_frame *mf;
	c = calls_to_cmi++;
	if (!((c<10) || (c == 100) || (c == 1000) || (c == 10000))) return;

	for (c = 0, mf = first_memory_frame; mf; c++, mf = mf->next_frame)
		if (mf->integrity_check != INTEGRITY_NUMBER)
			Errors__fatal("Memory manager failed integrity check");
}

void Memory__debug_memory_frames(int from, int to) {
	int c;
	memory_frame *mf;
	for (c = 0, mf = first_memory_frame; (mf) && (c <= to); c++, mf = mf->next_frame)
		if (c >= from) {
			char *desc = "corrupt";
			if (mf->integrity_check == INTEGRITY_NUMBER)
				desc = alloc_status[mf->mem_type].name_of_type;
		}
}

#line 269 "inweb/foundation-module/Chapter 2/Memory.w"
void *Memory__allocate(int mem_type, int extent) {
	unsigned char *cp;
	memory_frame *mf;
	int bytes_free_in_current_memblock, extent_without_overheads = extent;

	extent += sizeof(memory_frame); /* each allocation is preceded by a memory frame */
	extent += SAFETY_MARGIN; /* each allocation is followed by |SAFETY_MARGIN| null bytes */

	
{
#line 301 "inweb/foundation-module/Chapter 2/Memory.w"
	if (current_memblock_header == NULL) Memory__allocate_another_block();
	bytes_free_in_current_memblock = MEMORY_GRANULARITY - (used_in_current_memblock + extent);
	if (bytes_free_in_current_memblock < BLANK_END_SIZE) {
		Memory__allocate_another_block();
		if (extent+BLANK_END_SIZE >= MEMORY_GRANULARITY)
			Errors__fatal("Memory manager failed because granularity too low");
	}

}
#line 277 "inweb/foundation-module/Chapter 2/Memory.w"
;

	cp = ((unsigned char *) (current_memblock_header->the_memory)) + used_in_current_memblock;
	used_in_current_memblock += extent;

	mf = (memory_frame *) cp; /* the new memory frame, */
	cp = cp + sizeof(memory_frame); /* following which is the actual allocated data */

	mf->integrity_check = INTEGRITY_NUMBER;
	mf->allocation_id = alloc_status[mem_type].objects_allocated;
	mf->mem_type = mem_type;

	
{
#line 312 "inweb/foundation-module/Chapter 2/Memory.w"
	mf->next_frame = NULL;
	if (first_memory_frame == NULL) first_memory_frame = mf;
	else last_memory_frame->next_frame = mf;
	last_memory_frame = mf;

}
#line 289 "inweb/foundation-module/Chapter 2/Memory.w"
;
	
{
#line 320 "inweb/foundation-module/Chapter 2/Memory.w"
	if (alloc_status[mem_type].first_in_memory == NULL)
		alloc_status[mem_type].first_in_memory = (void *) cp;
	alloc_status[mem_type].last_in_memory = (void *) cp;
	alloc_status[mem_type].objects_allocated++;
	alloc_status[mem_type].bytes_allocated += extent_without_overheads;

}
#line 290 "inweb/foundation-module/Chapter 2/Memory.w"
;

	total_objects_allocated++;
	return (void *) cp;
}

#line 470 "inweb/foundation-module/Chapter 2/Memory.w"
void Memory__name_fundamental_reasons(void) {
	Memory__reason_name(STREAM_MREASON, "text stream storage");
	Memory__reason_name(FILENAME_STORAGE_MREASON, "filename/pathname storage");
	Memory__reason_name(STRING_STORAGE_MREASON, "string storage");
	Memory__reason_name(DICTIONARY_MREASON, "dictionary storage");
	Memory__reason_name(ARRAY_SORTING_MREASON, "sorting");
}

#line 481 "inweb/foundation-module/Chapter 2/Memory.w"
char *memory_needs[NO_DEFINED_MREASON_VALUES];

void Memory__reason_name(int r, char *reason) {
	if ((r < 0) || (r >= NO_DEFINED_MREASON_VALUES)) internal_error("MR out of range");
	memory_needs[r] = reason;
}

char *Memory__description_of_reason(int r) {
	if ((r < 0) || (r >= NO_DEFINED_MREASON_VALUES)) internal_error("MR out of range");
	return memory_needs[r];
}

#line 501 "inweb/foundation-module/Chapter 2/Memory.w"
int max_memory_at_once_for_each_need[NO_DEFINED_MREASON_VALUES],
	memory_claimed_for_each_need[NO_DEFINED_MREASON_VALUES],
	number_of_claims_for_each_need[NO_DEFINED_MREASON_VALUES];
int total_claimed_simply = 0;

#line 513 "inweb/foundation-module/Chapter 2/Memory.w"
void *Memory__calloc(int how_many, int size_in_bytes, int reason) {
	return Memory__alloc_inner(how_many, size_in_bytes, reason);
}
void *Memory__malloc(int size_in_bytes, int reason) {
	return Memory__alloc_inner(-1, size_in_bytes, reason);
}

#line 523 "inweb/foundation-module/Chapter 2/Memory.w"
void *Memory__alloc_inner(int N, int S, int R) {
	void *pointer;
	int bytes_needed;
	if ((R < 0) || (R >= NO_DEFINED_MREASON_VALUES)) internal_error("no such memory reason");
	if (total_claimed_simply == 0) 
{
#line 554 "inweb/foundation-module/Chapter 2/Memory.w"
	LOCK_MUTEX(memory_statistics_mutex);
	for (int i=0; i<NO_DEFINED_MREASON_VALUES; i++) {
		max_memory_at_once_for_each_need[i] = 0;
		memory_claimed_for_each_need[i] = 0;
		number_of_claims_for_each_need[i] = 0;
	}
	UNLOCK_MUTEX(memory_statistics_mutex);

}
#line 527 "inweb/foundation-module/Chapter 2/Memory.w"
;
	
{
#line 538 "inweb/foundation-module/Chapter 2/Memory.w"
	if (N > 0) {
		pointer = Memory__paranoid_calloc((size_t) N, (size_t) S);
		bytes_needed = N*S;
	} else {
		pointer = Memory__paranoid_calloc(1, (size_t) S);
		bytes_needed = S;
	}
	if (pointer == NULL) {
		Errors__fatal_with_C_string("Out of memory for %s", Memory__description_of_reason(R));
	}

}
#line 528 "inweb/foundation-module/Chapter 2/Memory.w"
;
	
{
#line 563 "inweb/foundation-module/Chapter 2/Memory.w"
	LOCK_MUTEX(memory_statistics_mutex);
	memory_claimed_for_each_need[R] += bytes_needed;
	total_claimed_simply += bytes_needed;
	number_of_claims_for_each_need[R]++;
	if (memory_claimed_for_each_need[R] > max_memory_at_once_for_each_need[R])
		max_memory_at_once_for_each_need[R] = memory_claimed_for_each_need[R];
	UNLOCK_MUTEX(memory_statistics_mutex);

}
#line 529 "inweb/foundation-module/Chapter 2/Memory.w"
;
	return pointer;
}

#line 574 "inweb/foundation-module/Chapter 2/Memory.w"
void Memory__I7_free(void *pointer, int R, int bytes_freed) {
	if ((R < 0) || (R >= NO_DEFINED_MREASON_VALUES)) internal_error("no such memory reason");
	if (pointer == NULL) internal_error("can't free NULL memory");
	LOCK_MUTEX(memory_statistics_mutex);
	memory_claimed_for_each_need[R] -= bytes_freed;
	UNLOCK_MUTEX(memory_statistics_mutex);
	free(pointer);
}

void Memory__I7_array_free(void *pointer, int R, int num_cells, size_t cell_size) {
	Memory__I7_free(pointer, R, num_cells*((int) cell_size));
}

#line 591 "inweb/foundation-module/Chapter 2/Memory.w"
void Memory__log_statistics(void) {
	int total_for_objects = MEMORY_GRANULARITY*no_blocks_allocated; /* usage in bytes */
	int total_for_SMAs = Memory__log_usage(0); /* usage in bytes */
	int sorted_usage[NO_DEFINED_CLASS_VALUES]; /* memory type numbers, in usage order */
	int total = (total_for_objects + total_for_SMAs)/1024; /* total memory usage in KB */

	
{
#line 624 "inweb/foundation-module/Chapter 2/Memory.w"
	for (int i=0; i<NO_DEFINED_CLASS_VALUES; i++) sorted_usage[i] = i;
	qsort(sorted_usage, (size_t) NO_DEFINED_CLASS_VALUES, sizeof(int), Memory__compare_usage);

}
#line 597 "inweb/foundation-module/Chapter 2/Memory.w"
;

	int total_for_objects_used = 0; /* out of the |total_for_objects|, the bytes used */
	int total_objects = 0;
	
{
#line 607 "inweb/foundation-module/Chapter 2/Memory.w"
	int i, j;
	for (j=0; j<NO_DEFINED_CLASS_VALUES; j++) {
		i = sorted_usage[j];
		if (alloc_status[i].objects_allocated != 0) {
			if (alloc_status[i].no_allocated_together == 1)
				total_objects += alloc_status[i].objects_allocated;
			else
				total_objects += alloc_status[i].objects_allocated*
									alloc_status[i].no_allocated_together;
			total_for_objects_used += alloc_status[i].bytes_allocated;
		}
	}

}
#line 601 "inweb/foundation-module/Chapter 2/Memory.w"
;
	int overhead_for_objects = total_for_objects - total_for_objects_used; /* bytes wasted */
	
{
#line 630 "inweb/foundation-module/Chapter 2/Memory.w"
	LOG("Total memory consumption was %dK = %d MB\n\n",
		total, (total+512)/1024);

	Memory__log_percentage(total_for_objects, total);
	LOG(" was used for %d objects, in %d frames in %d x %dK = %dK = %d MB:\n\n",
		total_objects, total_objects_allocated, no_blocks_allocated,
		MEMORY_GRANULARITY/1024,
		total_for_objects/1024, (total_for_objects+512)/1024/1024);
	for (int j=0; j<NO_DEFINED_CLASS_VALUES; j++) {
		int i = sorted_usage[j];
		if (alloc_status[i].objects_allocated != 0) {
			LOG("    ");
			Memory__log_percentage(alloc_status[i].bytes_allocated, total);
			LOG("  %s", alloc_status[i].name_of_type);
			for (int n=(int) strlen(alloc_status[i].name_of_type); n<41; n++) LOG(" ");
			if (alloc_status[i].no_allocated_together == 1) {
				LOG("%d ", alloc_status[i].objects_count);
				if (alloc_status[i].objects_count != alloc_status[i].objects_allocated)
					LOG("(+%d deleted) ",
						alloc_status[i].objects_allocated - alloc_status[i].objects_count);
				LOG("object");
				if (alloc_status[i].objects_allocated > 1) LOG("s");
			} else {
				if (alloc_status[i].objects_allocated > 1)
					LOG("%d x %d = %d ",
					alloc_status[i].objects_allocated, alloc_status[i].no_allocated_together,
					alloc_status[i].objects_allocated*alloc_status[i].no_allocated_together);
				else
					LOG("1 x %d ", alloc_status[i].no_allocated_together);
				LOG("objects");
			}
			LOG(", %d bytes\n", alloc_status[i].bytes_allocated);
		}
	}
	LOG("\n");
	Memory__log_percentage(1024*total-total_for_objects, total);
	LOG(" was used for memory not allocated for objects:\n\n");
	Memory__log_usage(total);
	LOG("\n"); Memory__log_percentage(overhead_for_objects, total);
	LOG(" was overhead - %d bytes = %dK = %d MB\n\n", overhead_for_objects,
		overhead_for_objects/1024, (overhead_for_objects+512)/1024/1024);

}
#line 603 "inweb/foundation-module/Chapter 2/Memory.w"
;
}

#line 673 "inweb/foundation-module/Chapter 2/Memory.w"
int Memory__log_usage(int total) {
	if (total_claimed_simply == 0) return 0;
	int i, t = 0;
	for (i=0; i<NO_DEFINED_MREASON_VALUES; i++) {
		t += max_memory_at_once_for_each_need[i];
		if ((total > 0) && (max_memory_at_once_for_each_need[i] > 0)) {
			LOG("    ");
			Memory__log_percentage(max_memory_at_once_for_each_need[i], total);
			LOG("  %s", Memory__description_of_reason(i));
			for (int n=(int) strlen(Memory__description_of_reason(i)); n<41; n++) LOG(" ");
			LOG("%d bytes in %d claim%s\n",
				max_memory_at_once_for_each_need[i],
				number_of_claims_for_each_need[i],
				(number_of_claims_for_each_need[i] == 1)?"":"s");
		}
	}
	return t;
}

#line 693 "inweb/foundation-module/Chapter 2/Memory.w"
int Memory__compare_usage(const void *ent1, const void *ent2) {
	int ix1 = *((const int *) ent1);
	int ix2 = *((const int *) ent2);
	return alloc_status[ix2].bytes_allocated - alloc_status[ix1].bytes_allocated;
}

#line 703 "inweb/foundation-module/Chapter 2/Memory.w"
void Memory__log_percentage(int bytes, int total) {
	float B = (float) bytes, T = (float) total;
	float P = (1000*B)/(1024*T);
	int N = (int) P;
	if (N == 0) LOG(" ----");
	else LOG("%2d.%01d%%", N/10, N%10);
}

#line 716 "inweb/foundation-module/Chapter 2/Memory.w"
void *Memory__paranoid_calloc(size_t N, size_t S) {
	void *P = calloc(N, S);
	return P;
}

#line 747 "inweb/foundation-module/Chapter 2/Memory.w"

general_pointer Memory__store_gp_null(void) {
	general_pointer gp;
	gp.pointer_to_data = NULL;
	gp.run_time_type_code = -1; /* guaranteed to differ from all |_CLASS| values */
	return gp;
}
int Memory__test_gp_null(general_pointer gp) {
	if (gp.run_time_type_code == -1) return TRUE;
	return FALSE;
}

#line 806 "inweb/foundation-module/Chapter 2/Memory.w"
MAKE_REFERENCE_ROUTINES(char, 1000)

#line 72 "inweb/foundation-module/Chapter 2/Foundation Classes.w"
DECLARE_CLASS(chapter_md)
DECLARE_CLASS(colouring_language_block)
DECLARE_CLASS(colouring_rule)
DECLARE_CLASS(command_line_switch)
DECLARE_CLASS(debugging_aspect)
DECLARE_CLASS(dictionary)
DECLARE_CLASS(ebook_chapter)
DECLARE_CLASS(ebook_datum)
DECLARE_CLASS(ebook_image)
DECLARE_CLASS(ebook_mark)
DECLARE_CLASS(ebook_page)
DECLARE_CLASS(ebook_volume)
DECLARE_CLASS(ebook)
DECLARE_CLASS(filename)
DECLARE_CLASS(hash_table_entry)
DECLARE_CLASS(heterogeneous_tree)
DECLARE_CLASS(HTML_file_state)
DECLARE_CLASS(IFM_example)
DECLARE_CLASS(JSON_pair_requirement)
DECLARE_CLASS(JSON_requirement)
DECLARE_CLASS(JSON_single_requirement)
DECLARE_CLASS(JSON_type)
DECLARE_CLASS(JSON_value)
DECLARE_CLASS(linked_list)
DECLARE_CLASS(markdown_feature)
DECLARE_CLASS(markdown_variation)
DECLARE_CLASS(md_doc_state)
DECLARE_CLASS(md_links_dictionary)
DECLARE_CLASS(method_set)
DECLARE_CLASS(method)
DECLARE_CLASS(module_search)
DECLARE_CLASS(module)
DECLARE_CLASS(pathname)
DECLARE_CLASS(preprocessor_macro)
DECLARE_CLASS(preprocessor_macro_parameter)
DECLARE_CLASS(preprocessor_variable)
DECLARE_CLASS(preprocessor_variable_set)
DECLARE_CLASS(programming_language)
DECLARE_CLASS(reserved_word)
DECLARE_CLASS(scan_directory)
DECLARE_CLASS(section_md)
DECLARE_CLASS(semantic_version_number_holder)
DECLARE_CLASS(semver_range)
DECLARE_CLASS(stopwatch_timer)
DECLARE_CLASS(string_storage_area)
DECLARE_CLASS(tree_node_type)
DECLARE_CLASS(tree_node)
DECLARE_CLASS(tree_type)
DECLARE_CLASS(web_bibliographic_datum)
DECLARE_CLASS(web_md)

DECLARE_CLASS_ALLOCATED_IN_ARRAYS(dict_entry, 100)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(HTML_tag, 1000)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(linked_list_item, 1000)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(markdown_item, 1000)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(match_avinue, 1000)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(match_trie, 1000)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(md_link_dictionary_entry, 100)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(md_emphasis_delimiter, 1000)
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(text_stream, 100)

#line 12 "inweb/foundation-module/Chapter 2/Locales.w"
char *Locales__name(int L) {
	switch (L) {
		case SHELL_LOCALE: return "shell";
		case CONSOLE_LOCALE: return "console";
	}
	return "";
}

int Locales__parse_locale(char *name) {
	for (int i=0; i<NO_DEFINED_LOCALE_VALUES; i++)
		if (strcmp(name, Locales__name(i)) == 0)
			return i;
	return -1;
}

#line 32 "inweb/foundation-module/Chapter 2/Locales.w"
int locales_unset = TRUE;
int locale_settings[NO_DEFINED_LOCALE_VALUES];

int Locales__get(int L) {
	if ((L < 0) || (L >= NO_DEFINED_LOCALE_VALUES)) Errors__fatal("locale out of range");
	if (locales_unset) return Locales__platform_locale();
	if (locale_settings[L] >= 0) return locale_settings[L];
	return Locales__platform_locale();
}

void Locales__set(int L, int E) {
	if ((L < 0) || (L >= NO_DEFINED_LOCALE_VALUES)) Errors__fatal("locale out of range");
	if (locales_unset) {
		for (int i=0; i<NO_DEFINED_LOCALE_VALUES; i++) locale_settings[i] = -1;
		locales_unset = FALSE;
	}
	locale_settings[L] = E;
}

#line 60 "inweb/foundation-module/Chapter 2/Locales.w"
int Locales__parse_encoding(char *name) {
	if (strcmp(name, "platform") == 0) return -1;
	if (strcmp(name, "iso-latin1") == 0) return FILE_ENCODING_ISO_STRF;
	if (strcmp(name, "utf-8") == 0) return FILE_ENCODING_UTF8_STRF;
	return 0;
}

#line 72 "inweb/foundation-module/Chapter 2/Locales.w"
void Locales__write_locales(OUTPUT_STREAM) {
	WRITE("Locales are: ");
	for (int i=0; i<NO_DEFINED_LOCALE_VALUES; i++) {
		if (i > 0) WRITE(", ");
		WRITE("%s = ", Locales__name(i));
		Locales__write_locale(OUT, Locales__get(i));
	}
	WRITE("\n");
}

void Locales__write_locale(OUTPUT_STREAM, int L) {
	switch (L) {
		case -1:
			WRITE("platform (= ");
			Locales__write_locale(OUT, Locales__platform_locale());
			WRITE(")"); break;
		case FILE_ENCODING_ISO_STRF: WRITE("iso-latin1"); break;
		case FILE_ENCODING_UTF8_STRF: WRITE("utf-8"); break;
		default: WRITE("?"); break;
	}
}

#line 98 "inweb/foundation-module/Chapter 2/Locales.w"
int Locales__platform_locale(void) {
	#ifdef LOCALE_IS_ISO
	return FILE_ENCODING_ISO_STRF;
	#endif
	#ifndef LOCALE_IS_ISO
		#ifdef LOCALE_IS_UTF8
		return FILE_ENCODING_UTF8_STRF;
		#endif
		#ifndef LOCALE_IS_UTF8
		Errors__fatal("built without either LOCALE_IS_ISO or LOCALE_IS_UTF8");
		return FILE_ENCODING_UTF8_STRF;
		#endif
	#endif
}

#line 118 "inweb/foundation-module/Chapter 2/Locales.w"
int Locales__set_locales(char *text) {
	if (text == NULL) return FALSE;
	for (int at=0; ((at >= 0) && (text[at])); ) {
		int c = -1;
		for (int i=at; text[i]; i++) if (text[i] == '=') { c = i; break; }
		if (c == -1) return FALSE;
		if (c-at >= 16) return FALSE;
		char L1[16], L2[16];
		for (int i=0; i<16; i++) { L1[i] = 0; L2[i] = 0; }
		for (int i=0; i<c-at; i++) L1[i] = (char) tolower((int) text[at+i]);
		int next_at = -1;
		for (int i=0; (text[c+1+i]) && (i<16); i++) {
			if (text[c+1+i] == ',') { next_at = c+1+i+1; break; }
			L2[i] = (char) tolower((int) text[c+1+i]);
		}
		int L = Locales__parse_locale(L1), E = Locales__parse_encoding(L2);
		if ((L < 0) || (L >= NO_DEFINED_LOCALE_VALUES)) return FALSE;
		if (E == 0) return FALSE;
		Locales__set(L, E);
		at = next_at;
	}
	return TRUE;
}

#line 245 "inweb/foundation-module/Chapter 2/Streams.w"

#line 260 "inweb/foundation-module/Chapter 2/Streams.w"
int total_file_writes = 0; /* number of text files opened for writing during the run */

#line 274 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__initialise(text_stream *stream, int from) {
	if (stream == NULL) internal_error("tried to initialise NULL stream");
	stream->stream_flags = from;
	stream->write_to_file = NULL;
	stream->write_to_memory = NULL;
	stream->chars_written = 0;
	stream->chars_capacity = 2147483647;
	stream->stream_continues = NULL;
	stream->as_HTML = NULL;
	stream->file_written = NULL;
}

#line 292 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__enable_XML_escapes(text_stream *stream) {
	if (stream) stream->stream_flags |= USES_XML_ESCAPES_STRF;
}

void Streams__disable_XML_escapes(text_stream *stream) {
	if ((stream) && (stream->stream_flags & USES_XML_ESCAPES_STRF))
		stream->stream_flags -= USES_XML_ESCAPES_STRF;
}

int I6_escapes_globally_enabled = FALSE;
void Streams__enable_I6_escapes(text_stream *stream) {
	if (stream) stream->stream_flags |= USES_I6_ESCAPES_STRF;
	I6_escapes_globally_enabled = TRUE;
}

void Streams__disable_I6_escapes(text_stream *stream) {
	if ((stream) && (stream->stream_flags & USES_I6_ESCAPES_STRF))
		stream->stream_flags -= USES_I6_ESCAPES_STRF;
	I6_escapes_globally_enabled = FALSE;
}

int Streams__I6_escapes_enabled(text_stream *stream) {
	return I6_escapes_globally_enabled;
}

void Streams__enable_debugging(text_stream *stream) {
	if (stream) stream->stream_flags |= USES_LOG_ESCAPES_STRF;
}

void Streams__disable_debugging(text_stream *stream) {
	if ((stream) && (stream->stream_flags & USES_LOG_ESCAPES_STRF))
		stream->stream_flags -= USES_LOG_ESCAPES_STRF;
}

void Streams__mark_as_read_only(text_stream *stream) {
	if (stream) stream->stream_flags |= READ_ONLY_STRF;
}

void Streams__declare_as_HTML(text_stream *stream, HTML_file_state *hs) {
	if (stream) stream->as_HTML = hs;
}

HTML_file_state *Streams__get_HTML_file_state(text_stream *stream) {
	return stream->as_HTML;
}

#line 341 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__log(OUTPUT_STREAM, void *vS) {
	text_stream *stream = (text_stream *) vS;
	if (stream == NULL) {
		WRITE("NULL");
	} else if (stream->write_to_file) {
		WRITE("F'%f'(%d)", stream->file_written, stream->chars_written);
	} else {
		WRITE("S(");
		while (stream) {
			WRITE("%d/%d", stream->chars_written, stream->chars_capacity);
			if (stream->stream_continues) WRITE("+");
			stream = stream->stream_continues;
		}
		WRITE(")");
	}
}

#line 363 "inweb/foundation-module/Chapter 2/Streams.w"
text_stream STDOUT_struct; int stdout_wrapper_initialised = FALSE;
text_stream *Streams__get_stdout(void) {
	if (stdout_wrapper_initialised == FALSE) {
		Streams__initialise(&STDOUT_struct, 0); STDOUT_struct.write_to_file = stdout;
		stdout_wrapper_initialised = TRUE;
		#ifdef STDOUT_LOCALE_TEST
		STDOUT_struct.stream_flags |= ECHO_BYTES_STRF;
		#endif
		if (Locales__get(CONSOLE_LOCALE) == FILE_ENCODING_ISO_STRF)
			STDOUT_struct.stream_flags |= FILE_ENCODING_ISO_STRF;
		if (Locales__get(CONSOLE_LOCALE) == FILE_ENCODING_UTF8_STRF)
			STDOUT_struct.stream_flags |= FILE_ENCODING_UTF8_STRF;
	}
	return &STDOUT_struct;
}

#line 382 "inweb/foundation-module/Chapter 2/Streams.w"
text_stream STDERR_struct; int stderr_wrapper_initialised = FALSE;
text_stream *Streams__get_stderr(void) {
	if (stderr_wrapper_initialised == FALSE) {
		Streams__initialise(&STDERR_struct, 0); STDERR_struct.write_to_file = stderr;
		stderr_wrapper_initialised = TRUE;
		if (Locales__get(CONSOLE_LOCALE) == FILE_ENCODING_ISO_STRF)
			STDERR_struct.stream_flags |= FILE_ENCODING_ISO_STRF;
		if (Locales__get(CONSOLE_LOCALE) == FILE_ENCODING_UTF8_STRF)
			STDERR_struct.stream_flags |= FILE_ENCODING_UTF8_STRF;
	}
	return &STDERR_struct;
}

#line 400 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_to_file(text_stream *stream, filename *name, int encoding) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	if (name == NULL) internal_error("stream_open_to_file on null filename");
	Streams__initialise(stream, FOR_FI_STRF);
	switch(encoding) {
		case UTF8_ENC: stream->stream_flags |= FILE_ENCODING_UTF8_STRF; break;
		case ISO_ENC: stream->stream_flags |= FILE_ENCODING_ISO_STRF; break;
		default: internal_error("stream has unknown text encoding");
	}
	stream->write_to_file = Filenames__fopen(name, "w");
	if (stream->write_to_file == NULL) return FALSE;
	stream->file_written = name;
	total_file_writes++;
	return TRUE;
}

#line 419 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_to_file_append(text_stream *stream, filename *name, int encoding) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	if (name == NULL) internal_error("stream_open_to_file on null filename");
	Streams__initialise(stream, FOR_FI_STRF);
	switch(encoding) {
		case UTF8_ENC: stream->stream_flags |= FILE_ENCODING_UTF8_STRF; break;
		case ISO_ENC: stream->stream_flags |= FILE_ENCODING_ISO_STRF; break;
		default: internal_error("stream has unknown text encoding");
	}
	stream->write_to_file = Filenames__fopen(name, "a");
	if (stream->write_to_file == NULL) return FALSE;
	total_file_writes++;
	return TRUE;
}

#line 440 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_to_memory(text_stream *stream, int capacity) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	capacity += SPACE_AT_END_OF_STREAM;
	Streams__initialise(stream, FOR_OM_STRF);
	stream->write_to_memory = Memory__calloc(capacity, sizeof(inchar32_t), STREAM_MREASON);
	if (stream->write_to_memory == NULL) return FALSE;
	(stream->write_to_memory)[0] = 0;
	stream->stream_flags |= MALLOCED_STRF;
	stream->chars_capacity = capacity;
	return TRUE;
}

#line 456 "inweb/foundation-module/Chapter 2/Streams.w"
text_stream Streams__new_buffer(int capacity, inchar32_t *at) {
	if (at == NULL) internal_error("tried to make stream wrapper for NULL string");
	if (capacity < SPACE_AT_END_OF_STREAM)
		internal_error("memory stream too small");
	text_stream stream;
	Streams__initialise(&stream, FOR_TT_STRF);
	stream.write_to_memory = at;
	(stream.write_to_memory)[0] = 0;
	stream.chars_capacity = capacity - SPACE_AT_END_OF_STREAM;
	return stream;
}

#line 474 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_from_wide_string(text_stream *stream, const inchar32_t *c_string, int capacity) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	
{
#line 522 "inweb/foundation-module/Chapter 2/Streams.w"
	if (capacity < 8) capacity = 8;
	capacity += 1+SPACE_AT_END_OF_STREAM;
	int rv = Streams__open_to_memory(stream, capacity);
	if (rv == FALSE) return FALSE;

}
#line 476 "inweb/foundation-module/Chapter 2/Streams.w"
;
	if (c_string) Streams__write_wide_string(stream, c_string);
	return TRUE;
}

void Streams__write_wide_string(text_stream *stream, const inchar32_t *c_string) {
	for (int i=0; c_string[i]; i++) Streams__putc(c_string[i], stream);
}

#line 489 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_from_ISO_string(text_stream *stream, const char *c_string) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	int capacity = (c_string)?((int) strlen(c_string)):0;
	
{
#line 522 "inweb/foundation-module/Chapter 2/Streams.w"
	if (capacity < 8) capacity = 8;
	capacity += 1+SPACE_AT_END_OF_STREAM;
	int rv = Streams__open_to_memory(stream, capacity);
	if (rv == FALSE) return FALSE;

}
#line 492 "inweb/foundation-module/Chapter 2/Streams.w"
;
	if (c_string) Streams__write_ISO_string(stream, c_string);
	return TRUE;
}

void Streams__write_ISO_string(text_stream *stream, const char *c_string) {
	for (int i=0; c_string[i]; i++) Streams__putci(c_string[i], stream);
}

#line 504 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_from_UTF8_string(text_stream *stream, const char *c_string) {
	if (stream == NULL) internal_error("tried to open NULL stream");
	int capacity = (c_string)?((int) strlen(c_string)):0;
	
{
#line 522 "inweb/foundation-module/Chapter 2/Streams.w"
	if (capacity < 8) capacity = 8;
	capacity += 1+SPACE_AT_END_OF_STREAM;
	int rv = Streams__open_to_memory(stream, capacity);
	if (rv == FALSE) return FALSE;

}
#line 507 "inweb/foundation-module/Chapter 2/Streams.w"
;
	if (c_string) Streams__write_UTF8_string(stream, c_string);
	return TRUE;
}

void Streams__write_UTF8_string(text_stream *stream, const char *c_string) {
	unicode_file_buffer ufb = TextFiles__create_ufb();
	int c;
	while ((c = TextFiles__utf8_fgetc(NULL, &c_string, &ufb)) != 0)
		Streams__putci(c, stream);
}

#line 531 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__write_as_wide_string(inchar32_t *C_string, text_stream *stream, int buffer_size) {
	if (buffer_size == 0) return;
	if (stream == NULL) { C_string[0] = 0; return; }
	if (stream->write_to_file) internal_error("stream_get_text on file stream");
	int i = 0;
	while (stream) {
		for (int j=0; j<stream->chars_written; j++) {
			if (i >= buffer_size-1) break;
			C_string[i++] = stream->write_to_memory[j];
		}
		stream = stream->stream_continues;
	}
	C_string[i] = 0;
}

#line 550 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__write_as_ISO_string(char *C_string, text_stream *stream, int buffer_size) {
	if (buffer_size == 0) return;
	if (stream == NULL) { C_string[0] = 0; return; }
	if (stream->write_to_file) internal_error("stream_get_text on file stream");
	int i = 0;
	while (stream) {
		for (int j=0; j<stream->chars_written; j++) {
			if (i >= buffer_size-1) break;
			inchar32_t c = stream->write_to_memory[j];
			if (c < 256) C_string[i++] = (char) c; else C_string[i++] = '?';
		}
		stream = stream->stream_continues;
	}
	C_string[i] = 0;
}

#line 567 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__write_as_UTF8_string(char *C_string, text_stream *stream, int buffer_size) {
	if (buffer_size == 0) return;
	if (stream == NULL) { C_string[0] = 0; return; }
	if (stream->write_to_file) internal_error("stream_get_text on file stream");
	unsigned char *to = (unsigned char *) C_string;
	int i = 0;
	while (stream) {
		for (int j=0; j<stream->chars_written; j++) {
			unsigned int c = (unsigned int) stream->write_to_memory[j];
			if (c >= 0x200000) { /* invalid Unicode */
				if (i >= buffer_size-1) break;
				to[i++] = '?';
			} else if (c >= 0x10000) {
				if (i >= buffer_size-4) break;
				to[i++] = 0xF0 + (unsigned char) (c >> 18);
				to[i++] = 0x80 + (unsigned char) ((c >> 12) & 0x3f);
				to[i++] = 0x80 + (unsigned char) ((c >> 6) & 0x3f);
				to[i++] = 0x80 + (unsigned char) (c & 0x3f);
			} else if (c >= 0x800) {
				if (i >= buffer_size-3) break;
				to[i++] = 0xE0 + (unsigned char) (c >> 12);
				to[i++] = 0x80 + (unsigned char) ((c >> 6) & 0x3f);
				to[i++] = 0x80 + (unsigned char) (c & 0x3f);
			} else if (c >= 0x80) {
				if (i >= buffer_size-2) break;
				to[i++] = 0xC0 + (unsigned char) (c >> 6);
				to[i++] = 0x80 + (unsigned char) (c & 0x3f);
			} else {
				if (i >= buffer_size-1) break;
				to[i++] = (unsigned char) c;
			}
		}
		stream = stream->stream_continues;
	}
	to[i] = 0;
}

#line 607 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__open_from_locale_string(text_stream *stream, const char *C_string) {
	if (Locales__get(SHELL_LOCALE) == FILE_ENCODING_UTF8_STRF)
		return Streams__open_from_UTF8_string(stream, C_string);
	if (Locales__get(SHELL_LOCALE) == FILE_ENCODING_ISO_STRF)
		return Streams__open_from_ISO_string(stream, C_string);
	Errors__fatal("unknown command line locale");
	return FALSE;
}

void Streams__write_as_locale_string(char *C_string, text_stream *stream, int buffer_size) {
	if (Locales__get(SHELL_LOCALE) == FILE_ENCODING_UTF8_STRF)
		Streams__write_as_UTF8_string(C_string, stream, buffer_size);
	else if (Locales__get(SHELL_LOCALE) == FILE_ENCODING_ISO_STRF)
		Streams__write_as_ISO_string(C_string, stream, buffer_size);
	else Errors__fatal("unknown command line locale");
}

void Streams__write_locale_string(text_stream *stream, char *C_string) {
	if (Locales__get(SHELL_LOCALE) == FILE_ENCODING_UTF8_STRF)
		Streams__write_UTF8_string(stream, C_string);
	else if (Locales__get(SHELL_LOCALE) == FILE_ENCODING_ISO_STRF)
		Streams__write_ISO_string(stream, C_string);
	else Errors__fatal("unknown command line locale");
}

#line 637 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__flush(text_stream *stream) {
	if (stream == NULL) return;
	if (stream->write_to_file) fflush(stream->write_to_file);
}

#line 645 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__close(text_stream *stream) {
	if (stream == NULL) internal_error("tried to close NULL stream");
	if (stream == &STDOUT_struct) internal_error("tried to close STDOUT stream");
	if (stream == &STDERR_struct) internal_error("tried to close STDERR stream");
	if (stream->chars_capacity == -1) internal_error("stream closed twice");
	if (stream->stream_continues) {
		Streams__close(stream->stream_continues);
		stream->stream_continues = NULL;
	}
	stream->chars_capacity = -1; /* mark as closed */
	if (stream->write_to_file) 
{
#line 666 "inweb/foundation-module/Chapter 2/Streams.w"
	if ((ferror(stream->write_to_file)) || (fclose(stream->write_to_file) == EOF))
		Errors__fatal("The host computer reported an error trying to write a text file");
	if (stream != DL)
		LOGIF(TEXT_FILES, "Text file '%f' (%s): %d characters written\n",
			stream->file_written,
			(stream->stream_flags & FILE_ENCODING_UTF8_STRF)?"UTF8":"ISO",
			stream->chars_written);
	stream->write_to_file = NULL;

}
#line 655 "inweb/foundation-module/Chapter 2/Streams.w"
;
	if (stream->write_to_memory) 
{
#line 685 "inweb/foundation-module/Chapter 2/Streams.w"
	if ((stream->stream_flags) & MALLOCED_STRF) {
		inchar32_t *mem = stream->write_to_memory;
		stream->write_to_memory = NULL;
		Memory__I7_free(mem, STREAM_MREASON, stream->chars_capacity*((int) sizeof(inchar32_t)));
		stream = NULL;
	}

}
#line 656 "inweb/foundation-module/Chapter 2/Streams.w"
;
}

#line 696 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__putc(inchar32_t c, text_stream *stream) {
	if (stream == NULL) return;
	text_stream *first_stream = stream;
	if (c != '\n') 
{
#line 770 "inweb/foundation-module/Chapter 2/Streams.w"
	if (first_stream->stream_flags & INDENT_PENDING_STRF) {
		first_stream->stream_flags -= INDENT_PENDING_STRF;
		int L = (first_stream->stream_flags & INDENTATION_MASK_STRF)/INDENTATION_BASE_STRF;
		for (int i=0; i<L; i++) {
			Streams__putc(' ', first_stream); Streams__putc(' ', first_stream);
			Streams__putc(' ', first_stream); Streams__putc(' ', first_stream);
		}
	}

}
#line 699 "inweb/foundation-module/Chapter 2/Streams.w"
;
	if (stream->stream_flags & READ_ONLY_STRF) internal_error("modifying read-only stream");
	if ((stream->stream_flags) & USES_XML_ESCAPES_STRF) {
		switch(c) {
			case NEWLINE_IN_STRING: Streams__literal(stream, "<br>"); return;
			case '&': Streams__literal(stream, "&amp;"); return;
			case '<': Streams__literal(stream, "&lt;"); return;
			case '>': Streams__literal(stream, "&gt;"); return;
		}
	}
	while (stream->stream_continues) stream = stream->stream_continues;
	
{
#line 797 "inweb/foundation-module/Chapter 2/Streams.w"
	if (stream->chars_written + SPACE_AT_END_OF_STREAM >= stream->chars_capacity) {
		if (stream->write_to_file) return; /* write nothing further */
		if (stream->write_to_memory) {
			int offset = (32 + 2*(stream->chars_capacity))*((int) sizeof(inchar32_t));
			int needed = offset + ((int) sizeof(text_stream)) + 32;
			void *further_allocation = Memory__malloc(needed, STREAM_MREASON);
			if (further_allocation == NULL) Errors__fatal("Out of memory");
			text_stream *continuation = (text_stream *) (further_allocation + offset);
			Streams__initialise(continuation, FOR_CO_STRF);
			continuation->write_to_memory = further_allocation;
			continuation->chars_capacity = 2*stream->chars_capacity;
			(continuation->write_to_memory)[0] = 0;
			stream->stream_continues = continuation;
			stream = continuation;
		}
	}

}
#line 710 "inweb/foundation-module/Chapter 2/Streams.w"
;
	if (stream->write_to_file) {
		if (stream->stream_flags & FILE_ENCODING_UTF8_STRF)
			
{
#line 753 "inweb/foundation-module/Chapter 2/Streams.w"
	if (c >= 0x200000) { /* invalid Unicode */
		fputc('?', stream->write_to_file);
	} else if (c >= 0x10000) {
		fputc(0xF0 + (c >> 18), stream->write_to_file);
		fputc(0x80 + ((c >> 12) & 0x3f), stream->write_to_file);
		fputc(0x80 + ((c >> 6) & 0x3f), stream->write_to_file);
		fputc(0x80 + (c & 0x3f), stream->write_to_file);
	} else if (c >= 0x800) {
		fputc(0xE0 + (c >> 12), stream->write_to_file);
		fputc(0x80 + ((c >> 6) & 0x3f), stream->write_to_file);
		fputc(0x80 + (c & 0x3f), stream->write_to_file);
	} else if (c >= 0x80) {
		fputc(0xC0 + (c >> 6), stream->write_to_file);
		fputc(0x80 + (c & 0x3f), stream->write_to_file);
	} else fputc((int) c, stream->write_to_file);

}
#line 713 "inweb/foundation-module/Chapter 2/Streams.w"

		else if (stream->stream_flags & FILE_ENCODING_ISO_STRF) {
		 	if (c >= 0x100) c = '?';
			fputc((int) c, stream->write_to_file);
		} else internal_error("stream has unknown text encoding");
		if (stream->stream_flags & ECHO_BYTES_STRF) {
			fputc(' ', stream->write_to_file);
			fputc('0'+(c/100), stream->write_to_file);
			fputc('0'+(c%100)/10, stream->write_to_file);
			fputc('0'+(c%10), stream->write_to_file);
			if (stream->stream_flags & FILE_ENCODING_UTF8_STRF)
				fputc('u', stream->write_to_file);
			if (stream->stream_flags & FILE_ENCODING_ISO_STRF)
				fputc('i', stream->write_to_file);
			fputc(' ', stream->write_to_file);
		}
	} else if (stream->write_to_memory) {
		if ((c >= 0x0300) && (c <= 0x036F) && (stream->chars_written > 0)) {
			unsigned int newc = (unsigned int) Characters__combine_accent(
				c, (stream->write_to_memory)[stream->chars_written - 1]);
			if (newc) {
				c = newc;
				stream->chars_written--;
			}
		}
		(stream->write_to_memory)[stream->chars_written] = c;
	}
	if (c == '\n') first_stream->stream_flags |= INDENT_PENDING_STRF;
	stream->chars_written++;
}

void Streams__putci(int c_int, text_stream *stream) {
	inchar32_t c;
	if (c_int >= 0) c = (inchar32_t) c_int; else c = (inchar32_t) (c_int + 256);
	Streams__putc(c, stream);
}

#line 817 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__literal(text_stream *stream, char *p) {
	if (stream == NULL) return;
	int i, x = ((stream->stream_flags) & USES_XML_ESCAPES_STRF);
	if (x) stream->stream_flags -= USES_XML_ESCAPES_STRF;
	for (i=0; p[i]; i++) Streams__putci(p[i], stream);
	if (x) stream->stream_flags += USES_XML_ESCAPES_STRF;
}

#line 831 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__indent(text_stream *stream) {
	if (stream == NULL) return;
	stream->stream_flags += INDENTATION_BASE_STRF;
}

void Streams__outdent(text_stream *stream) {
	if (stream == NULL) return;
	if ((stream->stream_flags & INDENTATION_MASK_STRF) == 0) {
		if (Errors__have_occurred() == FALSE) internal_error("stream indentation negative");
		return;
	}
	stream->stream_flags -= INDENTATION_BASE_STRF;
}

void Streams__set_indentation(text_stream *stream, int N) {
	if (stream == NULL) return;
	int B = stream->stream_flags & INDENTATION_MASK_STRF;
	stream->stream_flags -= B;
	stream->stream_flags += N*INDENTATION_BASE_STRF;
}

int Streams__get_indentation(text_stream *stream) {
	if (stream == NULL) return 0;
	return (stream->stream_flags & INDENTATION_MASK_STRF)/INDENTATION_BASE_STRF;
}

#line 864 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__get_position(text_stream *stream) {
	int t = 0;
	while (stream) {
		t += stream->chars_written;
		stream = stream->stream_continues;
	}
	return t;
}

#line 878 "inweb/foundation-module/Chapter 2/Streams.w"
int Streams__latest(text_stream *stream) {
	if (stream == NULL) return 0;
	if (stream->write_to_file) internal_error("stream_latest on file stream");
	while ((stream->stream_continues) && (stream->stream_continues->chars_written > 0))
		stream = stream->stream_continues;
	if (stream->write_to_memory) {
		if (stream->chars_written > 0)
			return (int) ((stream->write_to_memory)[stream->chars_written - 1]);
	}
	return 0;
}

#line 894 "inweb/foundation-module/Chapter 2/Streams.w"
inchar32_t Streams__get_char_at_index(text_stream *stream, int position) {
	if (stream == NULL) internal_error("examining null stream");
	if (stream->write_to_file) internal_error("examining file stream");
	while (position >= stream->chars_written) {
		position = position - stream->chars_written;
		stream = stream->stream_continues;
		if (stream == NULL) return 0;
	}
	if (stream->write_to_memory == NULL) return 0;
	return (stream->write_to_memory)[position];
}

void Streams__put_char_at_index(text_stream *stream, int position, inchar32_t C) {
	if (stream == NULL) internal_error("modifying null stream");
	if (stream->write_to_file) internal_error("modifying file stream");
	if (stream->stream_flags & READ_ONLY_STRF) internal_error("modifying read-only stream");
	while (position >= stream->chars_written) {
		position = position - stream->chars_written;
		stream = stream->stream_continues;
		if (stream == NULL) internal_error("overrun memory stream");
	}
	(stream->write_to_memory)[position] = C;
	if (C == 0) {
		stream->chars_written = position;
		if (stream->stream_continues) {
			Streams__close(stream->stream_continues);
			stream->stream_continues = NULL;
		}
	}
}

#line 932 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__set_position(text_stream *stream, int position) {
	if (stream == NULL) return;
	if (position < 0) position = 0; /* to simplify the implementation of backspacing */
	if (stream->write_to_file) internal_error("stream_set_position on file stream");
	if (stream->stream_flags & READ_ONLY_STRF) internal_error("modifying read-only stream");
	if (stream->write_to_memory) {
		while (position > stream->chars_written) {
			position = position - stream->chars_written;
			stream = stream->stream_continues;
			if (stream == NULL) internal_error("can't set position forwards");
		}
		stream->chars_written = position;
		(stream->write_to_memory)[stream->chars_written] = 0;
		if (stream->stream_continues) {
			Streams__close(stream->stream_continues);
			stream->stream_continues = NULL;
		}
	}
}

#line 956 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__copy(text_stream *to, text_stream *from) {
	if ((from == NULL) || (to == NULL)) return;
	if (from == to) internal_error("tried to copy a stream to itself");
	if (from->write_to_file) internal_error("stream_copy from file stream");
	if (from->write_to_memory) {
		for (int i=0; i<from->chars_written; i++) {
			inchar32_t c = (from->write_to_memory)[i];
			Streams__putc(c, to);
		}
		if (from->stream_continues) Streams__copy(to, from->stream_continues);
	}
}

#line 973 "inweb/foundation-module/Chapter 2/Streams.w"
void Streams__writer(OUTPUT_STREAM, char *format_string, void *vS) {
	text_stream *S = (text_stream *) vS;
	Streams__copy(OUT, S);
}

#line 37 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
int escapes_registered = FALSE;
int escapes_category[2][128]; /* one of the |*_ECAT| values above */
void *the_escapes[2][128]; /* the function to call to implement this */

#line 45 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
#ifdef WORDS_MODULE
	typedef void (*writer_function_W)(text_stream *, char *, wording);
	typedef void (*log_function_W)(text_stream *, wording);
#endif

#line 51 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void Writers__log_escape_usage(void) {
	for (int cat = 0; cat < 2; cat++) {
		char *alphanum = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		LOG("Vacant escapes: %s: ", (cat == 0)?"%":"$");
		for (int i=0; alphanum[i]; i++)
			if (escapes_category[cat][(int) alphanum[i]] == VACANT_ECAT)
				LOG("%c", alphanum[i]);
			else
				LOG(".");
		LOG("\n");
	}
}

#line 67 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void Writers__register_writer(int esc, void (*f)(text_stream *, char *, void *)) {
	Writers__register_writer_p(0, esc, (void *) f, POINTER_ECAT);
}
void Writers__register_logger(int esc, void (*f)(text_stream *, void *)) {
	Writers__register_writer_p(1, esc, (void *) f, POINTER_ECAT);
}
void Writers__register_writer_I(int esc, void (*f)(text_stream *, char *, int)) {
	Writers__register_writer_p(0, esc, (void *) f, INTSIZED_ECAT);
}
void Writers__register_logger_I(int esc, void (*f)(text_stream *, int)) {
	Writers__register_writer_p(1, esc, (void *) f, INTSIZED_ECAT);
}
#ifdef WORDS_MODULE
#define Writers__register_writer_W(esc, f) Writers__register_writer_p(0, esc, (void *) f, WORDING_ECAT);
#define Writers__register_logger_W(esc, f) Writers__register_writer_p(1, esc, (void *) f, WORDING_ECAT);
#endif

#line 87 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void Writers__register_writer_p(int set, int esc, void *f, int cat) {
	if (escapes_registered == FALSE) 
{
#line 108 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
	escapes_registered = TRUE;
	for (int e=0; e<2; e++)
		for (int i=0; i<128; i++) {
			the_escapes[e][i] = NULL; escapes_category[e][i] = VACANT_ECAT;
		}
	escapes_category[0]['c'] = DIRECT_ECAT;
	escapes_category[0]['d'] = DIRECT_ECAT;
	escapes_category[0]['g'] = DIRECT_ECAT;
	escapes_category[0]['i'] = DIRECT_ECAT;
	escapes_category[0]['s'] = DIRECT_ECAT;
	escapes_category[0]['w'] = DIRECT_ECAT;
	escapes_category[0]['x'] = DIRECT_ECAT;
	escapes_category[0]['%'] = DIRECT_ECAT;
	escapes_category[0]['$'] = DIRECT_ECAT;
	escapes_category[1]['%'] = DIRECT_ECAT;
	escapes_category[1]['$'] = DIRECT_ECAT;

}
#line 88 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
;
	if ((esc < 0) || (esc >= 128) ||
		((Characters__isalpha((inchar32_t) esc) == FALSE) &&
			(Characters__isdigit((inchar32_t) esc) == FALSE)))
		internal_error("nonalphabetic escape");
	if (escapes_category[set][esc] != VACANT_ECAT) {
		WRITE_TO(STDERR, "Clashing escape is %s%c\n", (set == 0)?"%":"$", esc);
		internal_error("clash of escapes");
	}
	escapes_category[set][esc] = cat;
	the_escapes[set][esc] = f;
}

#line 130 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
void Writers__printf(text_stream *stream, char *fmt, ...) {
	va_list ap; /* the variable argument list signified by the dots */
	char *p;
	if (stream == NULL) return;
	va_start(ap, fmt); /* macro to begin variable argument processing */
	for (p = fmt; *p; p++) {
		switch (*p) {
			case '%': {
				int set = 0; 
{
#line 163 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
	char format_string[8];
	int esc_number = ' ';
	int i = 0;
	format_string[i++] = *(p++);
	while (*p) {
		format_string[i++] = *p;
		if ((islower(*p)) || (isupper(*p)) || ((set == 1) && (isdigit(*p))) ||
			(*p == '%')) esc_number = (int) *p;
		p++;
		if ((esc_number != ' ') || (i==6)) break;
	}
	format_string[i] = 0; p--;
	if ((esc_number<0) || (esc_number > 255)) esc_number = 0;
	switch (escapes_category[set][esc_number]) {
		case POINTER_ECAT: {
			if (set == 0) {
				writer_function f = (writer_function) the_escapes[0][esc_number];
				void *q = va_arg(ap, void *);
				(*f)(stream, format_string+1, q);
			} else {
				log_function f = (log_function) the_escapes[1][esc_number];
				void *q = va_arg(ap, void *);
				(*f)(stream, q);
			}
			break;
		}
		case INTSIZED_ECAT: {
			if (set == 0) {
				writer_function_I f = (writer_function_I) the_escapes[0][esc_number];
				int N = va_arg(ap, int);
				(*f)(stream, format_string+1, N);
			} else {
				log_function_I f = (log_function_I) the_escapes[1][esc_number];
				int N = va_arg(ap, int);
				(*f)(stream, N);
			}
			break;
		}
		case WORDING_ECAT: {
			#ifdef WORDS_MODULE
			if (set == 0) {
				writer_function_W f = (writer_function_W) the_escapes[0][esc_number];
				wording W = va_arg(ap, wording);
				(*f)(stream, format_string+1, W);
			} else {
				log_function_W f = (log_function_W) the_escapes[1][esc_number];
				wording W = va_arg(ap, wording);
				(*f)(stream, W);
			}
			#endif
			break;
		}
		case DIRECT_ECAT: 
{
#line 237 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
	#pragma clang diagnostic push
	#pragma clang diagnostic ignored "-Wformat-nonliteral"
	switch (esc_number) {
		case 'c': { /* |char| is promoted to |int| in variable arguments */
			int ival = va_arg(ap, int);
			Streams__putci(ival, stream);
			break;
		}
		case 'd': case 'i': case 'x': {
			int ival = va_arg(ap, int);
			char temp[256];
			if (snprintf(temp, 255, format_string, ival) >= 255) strcpy(temp, "?");
			for (int j = 0; temp[j]; j++) Streams__putci(temp[j], stream);
			break;
		}
		case 'g': {
			double dval = va_arg(ap, double);
			char temp[256];
			if (snprintf(temp, 255, format_string, dval) >= 255) strcpy(temp, "?");
			for (int j = 0; temp[j]; j++) Streams__putci(temp[j], stream);
			break;
		}
		case 's':
			for (char *sval = va_arg(ap, char *); *sval; sval++) Streams__putci(*sval, stream);
			break;
		case 'w': {
			inchar32_t *W = (inchar32_t *) va_arg(ap, inchar32_t *);
			for (int j = 0; W[j]; j++) Streams__putc(W[j], stream);
			break;
		}
		case '%': Streams__putc('%', stream); break;
		case '$': Streams__putc('$', stream); break;
	}
	#pragma clang diagnostic pop

}
#line 215 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
; break;
		case VACANT_ECAT:
			WRITE_TO(STDERR, "*** Bad WRITE escape: <%s> ***\n", format_string);
			internal_error("Unknown string escape");
			break;
	}

}
#line 138 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
;
				break;
			}
			case '$': {
				int set = 1;
				if ((stream->stream_flags) & USES_LOG_ESCAPES_STRF)
					
{
#line 163 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
	char format_string[8];
	int esc_number = ' ';
	int i = 0;
	format_string[i++] = *(p++);
	while (*p) {
		format_string[i++] = *p;
		if ((islower(*p)) || (isupper(*p)) || ((set == 1) && (isdigit(*p))) ||
			(*p == '%')) esc_number = (int) *p;
		p++;
		if ((esc_number != ' ') || (i==6)) break;
	}
	format_string[i] = 0; p--;
	if ((esc_number<0) || (esc_number > 255)) esc_number = 0;
	switch (escapes_category[set][esc_number]) {
		case POINTER_ECAT: {
			if (set == 0) {
				writer_function f = (writer_function) the_escapes[0][esc_number];
				void *q = va_arg(ap, void *);
				(*f)(stream, format_string+1, q);
			} else {
				log_function f = (log_function) the_escapes[1][esc_number];
				void *q = va_arg(ap, void *);
				(*f)(stream, q);
			}
			break;
		}
		case INTSIZED_ECAT: {
			if (set == 0) {
				writer_function_I f = (writer_function_I) the_escapes[0][esc_number];
				int N = va_arg(ap, int);
				(*f)(stream, format_string+1, N);
			} else {
				log_function_I f = (log_function_I) the_escapes[1][esc_number];
				int N = va_arg(ap, int);
				(*f)(stream, N);
			}
			break;
		}
		case WORDING_ECAT: {
			#ifdef WORDS_MODULE
			if (set == 0) {
				writer_function_W f = (writer_function_W) the_escapes[0][esc_number];
				wording W = va_arg(ap, wording);
				(*f)(stream, format_string+1, W);
			} else {
				log_function_W f = (log_function_W) the_escapes[1][esc_number];
				wording W = va_arg(ap, wording);
				(*f)(stream, W);
			}
			#endif
			break;
		}
		case DIRECT_ECAT: 
{
#line 237 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
	#pragma clang diagnostic push
	#pragma clang diagnostic ignored "-Wformat-nonliteral"
	switch (esc_number) {
		case 'c': { /* |char| is promoted to |int| in variable arguments */
			int ival = va_arg(ap, int);
			Streams__putci(ival, stream);
			break;
		}
		case 'd': case 'i': case 'x': {
			int ival = va_arg(ap, int);
			char temp[256];
			if (snprintf(temp, 255, format_string, ival) >= 255) strcpy(temp, "?");
			for (int j = 0; temp[j]; j++) Streams__putci(temp[j], stream);
			break;
		}
		case 'g': {
			double dval = va_arg(ap, double);
			char temp[256];
			if (snprintf(temp, 255, format_string, dval) >= 255) strcpy(temp, "?");
			for (int j = 0; temp[j]; j++) Streams__putci(temp[j], stream);
			break;
		}
		case 's':
			for (char *sval = va_arg(ap, char *); *sval; sval++) Streams__putci(*sval, stream);
			break;
		case 'w': {
			inchar32_t *W = (inchar32_t *) va_arg(ap, inchar32_t *);
			for (int j = 0; W[j]; j++) Streams__putc(W[j], stream);
			break;
		}
		case '%': Streams__putc('%', stream); break;
		case '$': Streams__putc('$', stream); break;
	}
	#pragma clang diagnostic pop

}
#line 215 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"
; break;
		case VACANT_ECAT:
			WRITE_TO(STDERR, "*** Bad WRITE escape: <%s> ***\n", format_string);
			internal_error("Unknown string escape");
			break;
	}

}
#line 144 "inweb/foundation-module/Chapter 2/Writers and Loggers.w"

				else Streams__putc('$', stream);
				break;
			}
			case '"':
				if (stream->stream_flags & USES_I6_ESCAPES_STRF)
					Streams__putc('~', stream);
				else Streams__putci(*p, stream);
				break;
			case '\n':
				Streams__putci(*p, stream);
				break;
			default: Streams__putci(*p, stream); break;
		}
	}
	va_end(ap); /* macro to end variable argument processing */
}

#line 31 "inweb/foundation-module/Chapter 2/Methods.w"

method_set *Methods__new_set(void) {
	method_set *S = CREATE(method_set);
	S->first_method = NULL;
	return S;
}

#line 44 "inweb/foundation-module/Chapter 2/Methods.w"

#line 58 "inweb/foundation-module/Chapter 2/Methods.w"
INT_METHOD_TYPE(UNUSED_METHOD_ID_MTID, text_stream *example, int wont_be_used)

#line 75 "inweb/foundation-module/Chapter 2/Methods.w"

void Methods__add(method_set *S, int ID, void *function) {
	method *M = CREATE(method);
	M->method_id = ID;
	M->method_function = function;
	M->next_method = NULL;

	if (S->first_method == NULL) S->first_method = M;
	else {
		method *existing = S->first_method;
		while ((existing) && (existing->next_method)) existing = existing->next_method;
		existing->next_method = M;
	}
}

int Methods__provided(method_set *S, int ID) {
	if (S == NULL) return FALSE;
	for (method *M = S->first_method; M; M = M->next_method)
		if (M->method_id == ID)
			return TRUE;
	return FALSE;
}

#line 23 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"

#line 28 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"

#line 30 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
linked_list *LinkedLists__new(void) {
	linked_list *ll = CREATE(linked_list);
	LinkedLists__empty(ll);
	return ll;
}

void LinkedLists__empty(linked_list *ll) {
	ll->linked_list_length = 0;
	ll->early_items_used = 0;
	ll->first_list_item = NULL;
	ll->last_list_item = NULL;
}

#line 47 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void LinkedLists__add(linked_list *L, void *P, int to_end) {
	if (L == NULL) internal_error("null list");
	linked_list_item *item = NULL;
	if (L->early_items_used < NO_LL_EARLY_ITEMS)
		item = &(L->early_items[L->early_items_used++]);
	else
		item = CREATE(linked_list_item);
	item->item_contents = P;
	if (to_end) {
		item->next_list_item = NULL;
		if (L->last_list_item == NULL) {
			L->first_list_item = item;
			L->last_list_item = item;
		} else {
			L->last_list_item->next_list_item = item;
			L->last_list_item = item;
		}
	} else {
		item->next_list_item = L->first_list_item;
		L->first_list_item = item;
		if (L->last_list_item == NULL) L->last_list_item = item;
	}
	L->linked_list_length++;
}

#line 75 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void *LinkedLists__remove_from_front(linked_list *L) {
	if (L == NULL) internal_error("null list");
	linked_list_item *front = L->first_list_item;
	if (front == NULL) internal_error("empty list can't have item 0 removed");
	L->first_list_item = front->next_list_item;
	if (L->first_list_item == NULL) L->last_list_item = NULL;
	L->linked_list_length--;
	return front->item_contents;
}

#line 88 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void *LinkedLists__delete(int N, linked_list *L) {
	if (L == NULL) internal_error("null list");
	if ((N < 0) || (N >= L->linked_list_length)) internal_error("index not valid");
	if (N == 0) return LinkedLists__remove_from_front(L);

	for (linked_list_item *item = L->first_list_item; item; item = item->next_list_item) {
		N--;
		if (N == 0) {
			if (L->last_list_item == item->next_list_item) L->last_list_item = item;
			void *contents_deleted = item->next_list_item->item_contents;
			item->next_list_item = item->next_list_item->next_list_item;
			L->linked_list_length--;
			return contents_deleted;
		}
	}

	internal_error("index not found");
	return NULL;
}

#line 112 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
void LinkedLists__insert(linked_list *L, int N, void *P) {
	if (N <= 0) LinkedLists__add(L, P, FALSE);
	else {
		linked_list_item *prev = NULL;
		for (linked_list_item *I = L->first_list_item; I; I = I->next_list_item) {
			if (N-- == 0) break;
			prev = I;
		}
		if (prev == NULL) LinkedLists__add(L, P, FALSE);
		else {
			linked_list_item *item = NULL;
			if (L->early_items_used < NO_LL_EARLY_ITEMS)
				item = &(L->early_items[L->early_items_used++]);
			else
				item = CREATE(linked_list_item);
			item->item_contents = P;

			linked_list_item *subs = prev->next_list_item;
			prev->next_list_item = item;
			item->next_list_item = subs;
			L->linked_list_length++;
		}
	}
}

#line 140 "inweb/foundation-module/Chapter 2/Linked Lists and Stacks.w"
int LinkedLists__len(linked_list *L) {
	return L?(L->linked_list_length):0;
}
linked_list_item *LinkedLists__first(linked_list *L) {
	return L?(L->first_list_item):NULL;
}
void *LinkedLists__entry(int N, linked_list *L) {
	if ((N < 0) || (L == NULL) || (N >= L->linked_list_length)) return NULL;
	for (linked_list_item *I = L->first_list_item; I; I = I->next_list_item)
		if (N-- == 0)
			return I->item_contents;
	return NULL;
}
void LinkedLists__set_entry(int N, linked_list *L, void *P) {
	if ((N < 0) || (L == NULL) || (N >= L->linked_list_length)) return;
	for (linked_list_item *I = L->first_list_item; I; I = I->next_list_item)
		if (N-- == 0) {
			I->item_contents = P; return;
		}
}
linked_list_item *LinkedLists__last(linked_list *L) {
	return L?(L->last_list_item):NULL;
}
linked_list_item *LinkedLists__next(linked_list_item *I) {
	return I?(I->next_list_item):NULL;
}
void *LinkedLists__content(linked_list_item *I) {
	return I?(I->item_contents):NULL;
}

#line 20 "inweb/foundation-module/Chapter 2/Dictionaries.w"

#line 27 "inweb/foundation-module/Chapter 2/Dictionaries.w"

#line 33 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dictionary *Dictionaries__new(int S, int textual) {
	if (S < 2) internal_error("dictionary too small");
	dictionary *D = CREATE(dictionary);
	D->textual = textual;
	D->hash_table_size = S;
	D->no_entries = 0;
	D->hash_table = Memory__calloc(S, sizeof(dict_entry), DICTIONARY_MREASON);
	for (int i=0; i<S; i++) {
		D->hash_table[i].vacant = TRUE;
		D->hash_table[i].value = NULL;
		D->hash_table[i].next_in_entry = NULL;
	}
	return D;
}

#line 51 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void Dictionaries__log(OUTPUT_STREAM, dictionary *D) {
	WRITE("Dictionary:\n"); INDENT;
	for (int i=0; i<D->hash_table_size; i++) {
		WRITE("Slot %02d:", i);
		for (dict_entry *E = &(D->hash_table[i]); E; E = E->next_in_entry)
			if (E->vacant) WRITE(" vacant");
			else if (D->textual) WRITE(" %S='%S'", E->key, E->value);
			else WRITE(" %S=<binary>", E->key);
		WRITE("\n");
	}
	OUTDENT;
}

#line 71 "inweb/foundation-module/Chapter 2/Dictionaries.w"
int Dictionaries__hash(text_stream *K, int N) {
	unsigned int hash = 0;
	LOOP_THROUGH_TEXT(P, K)
		hash = 16339*hash + ((unsigned int) Str__get(P));
	return (int) (hash % ((unsigned int) N));
}

#line 85 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry *Dictionaries__find(dictionary *D, text_stream *K) {
	return Dictionaries__find_p(D, K, 0);
}
dict_entry *Dictionaries__create(dictionary *D, text_stream *K) {
	return Dictionaries__find_p(D, K, 1);
}
void Dictionaries__destroy(dictionary *D, text_stream *K) {
	Dictionaries__find_p(D, K, -1);
}

#line 100 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry *Dictionaries__find_literal(dictionary *D, inchar32_t *lit) {
	TEMPORARY_TEXT(K)
	WRITE_TO(K, "%w", lit);
	dict_entry *E = Dictionaries__find(D, K);
	DISCARD_TEXT(K)
	return E;
}
dict_entry *Dictionaries__create_literal(dictionary *D, inchar32_t *lit) {
	TEMPORARY_TEXT(K)
	WRITE_TO(K, "%w", lit);
	dict_entry *E = Dictionaries__create(D, K);
	DISCARD_TEXT(K)
	return E;
}
void Dictionaries__destroy_literal(dictionary *D, inchar32_t *lit) {
	TEMPORARY_TEXT(K)
	WRITE_TO(K, "%w", lit);
	Dictionaries__destroy(D, K);
	DISCARD_TEXT(K)
}

#line 125 "inweb/foundation-module/Chapter 2/Dictionaries.w"
dict_entry *Dictionaries__find_p(dictionary *D, text_stream *K, int change) {
	if (D == NULL) 
{
#line 134 "inweb/foundation-module/Chapter 2/Dictionaries.w"
	if (change == 0) return NULL;
	internal_error("tried to create or destroy in a null dictionary");

}
#line 126 "inweb/foundation-module/Chapter 2/Dictionaries.w"
;
	if (change == 1) 
{
#line 143 "inweb/foundation-module/Chapter 2/Dictionaries.w"
	if (D->no_entries > D->hash_table_size) {
		dictionary *D2 = Dictionaries__new(2*D->hash_table_size, D->textual);
		for (int i=0; i<D->hash_table_size; i++)
			for (dict_entry *E = &(D->hash_table[i]); E; E = E->next_in_entry)
				if (E->vacant == FALSE) {
					dict_entry *E2 = Dictionaries__find_p(D2, E->key, 1);
					E2->value = E->value;
				}
		Memory__I7_free(D->hash_table, DICTIONARY_MREASON,
			D->hash_table_size*((int) sizeof(dict_entry)));
		D->hash_table_size = D2->hash_table_size;
		D->hash_table = D2->hash_table;
	}

}
#line 127 "inweb/foundation-module/Chapter 2/Dictionaries.w"
;
	
{
#line 158 "inweb/foundation-module/Chapter 2/Dictionaries.w"
	dict_entry *last_E = NULL;
	for (dict_entry *E = &(D->hash_table[Dictionaries__hash(K, D->hash_table_size)]);
		E; E = E->next_in_entry) {
		last_E = E;
		if (E->vacant) {
			if (change == 1) { 
{
#line 183 "inweb/foundation-module/Chapter 2/Dictionaries.w"
	E->vacant = FALSE;
	if (D->textual) E->value = Str__new(); else E->value = NULL;
	E->key = Str__duplicate(K);
	D->no_entries++;

}
#line 163 "inweb/foundation-module/Chapter 2/Dictionaries.w"
; return E; }
		} else {
			if (Str__eq(K, E->key)) {
				if (change == -1) 
{
#line 193 "inweb/foundation-module/Chapter 2/Dictionaries.w"
	E->vacant = TRUE; D->no_entries--;
	if ((D->textual) && (E->value)) Str__dispose_of(E->value);
	E->value = NULL;

}
#line 166 "inweb/foundation-module/Chapter 2/Dictionaries.w"
;
				return E;
			}
		}
	}
	if (change == 1) {
		dict_entry *E = CREATE(dict_entry);
		
{
#line 183 "inweb/foundation-module/Chapter 2/Dictionaries.w"
	E->vacant = FALSE;
	if (D->textual) E->value = Str__new(); else E->value = NULL;
	E->key = Str__duplicate(K);
	D->no_entries++;

}
#line 173 "inweb/foundation-module/Chapter 2/Dictionaries.w"
;
		last_E->next_in_entry = E;
		return E;
	}
	return NULL;

}
#line 128 "inweb/foundation-module/Chapter 2/Dictionaries.w"
;
}

#line 202 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void *Dictionaries__value_for_entry(dict_entry *de) {
	if (de) return de->value;
	return NULL;
}

void *Dictionaries__read_value(dictionary *D, text_stream *key) {
	if (D == NULL) return NULL;
	if (D->textual) internal_error("textual dictionary accessed as pointy");
	dict_entry *E = Dictionaries__find(D, key);
	if (E == NULL) internal_error("read null dictionary entry");
	if (E->vacant) internal_error("read vacant dictionary entry");
	return E->value;
}
void *Dictionaries__read_value_literal(dictionary *D, inchar32_t *key) {
	if (D == NULL) return NULL;
	if (D->textual) internal_error("textual dictionary accessed as pointy");
	dict_entry *E = Dictionaries__find_literal(D, key);
	if (E == NULL) internal_error("read null dictionary entry");
	if (E->vacant) internal_error("read vacant dictionary entry");
	return E->value;
}

void Dictionaries__write_value(dictionary *D, text_stream *key, void *val) {
	if (D == NULL) internal_error("wrote to null dictionary");
	if (D->textual) internal_error("textual dictionary accessed as pointy");
	dict_entry *E = Dictionaries__find(D, key);
	if (E == NULL) internal_error("wrote null dictionary entry");
	if (E->vacant) internal_error("wrote vacant dictionary entry");
	E->value = val;
}
void Dictionaries__write_value_literal(dictionary *D, inchar32_t *key, void *val) {
	if (D == NULL) internal_error("wrote to null dictionary");
	if (D->textual) internal_error("textual dictionary accessed as pointy");
	dict_entry *E = Dictionaries__find_literal(D, key);
	if (E == NULL) internal_error("wrote null dictionary entry");
	if (E->vacant) internal_error("wrote vacant dictionary entry");
	E->value = val;
}

#line 245 "inweb/foundation-module/Chapter 2/Dictionaries.w"
text_stream *Dictionaries__create_text(dictionary *D, text_stream *key) {
	if (D == NULL) internal_error("wrote to null dictionary");
	if (D->textual == FALSE) internal_error("pointy dictionary accessed as textual");
	dict_entry *E = Dictionaries__create(D, key);
	return (text_stream *) E->value;
}
text_stream *Dictionaries__create_text_literal(dictionary *D, inchar32_t *lit) {
	if (D == NULL) internal_error("wrote to null dictionary");
	if (D->textual == FALSE) internal_error("pointy dictionary accessed as textual");
	dict_entry *E = Dictionaries__create_literal(D, lit);
	return (text_stream *) E->value;
}

#line 262 "inweb/foundation-module/Chapter 2/Dictionaries.w"
text_stream *Dictionaries__get_text(dictionary *D, text_stream *key) {
	if (D == NULL) return NULL;
	if (D->textual == FALSE) internal_error("pointy dictionary accessed as textual");
	dict_entry *E = Dictionaries__find(D, key);
	if (E == NULL) return NULL;
	return (text_stream *) E->value;
}

text_stream *Dictionaries__get_text_literal(dictionary *D, inchar32_t *lit) {
	if (D == NULL) return NULL;
	if (D->textual == FALSE) internal_error("pointy dictionary accessed as textual");
	dict_entry *E = Dictionaries__find_literal(D, lit);
	if (E == NULL) return NULL;
	return (text_stream *) E->value;
}

#line 283 "inweb/foundation-module/Chapter 2/Dictionaries.w"
void Dictionaries__dispose_of(dictionary *D) {
	if (D->textual)
		for (int i=0; i<D->hash_table_size; i++)
			for (dict_entry *E = &(D->hash_table[i]); E; E = E->next_in_entry)
				if (E->vacant == FALSE)
					Str__dispose_of(E->value);
	Memory__I7_free(D->hash_table, DICTIONARY_MREASON, D->hash_table_size*((int) sizeof(dict_entry)));
	D->hash_table = NULL;
}

#line 16 "inweb/foundation-module/Chapter 2/Trees.w"

#line 18 "inweb/foundation-module/Chapter 2/Trees.w"
heterogeneous_tree *Trees__new(tree_type *type) {
	heterogeneous_tree *T = CREATE(heterogeneous_tree);
	T->type = type;
	T->root = NULL;
	return T;
}

#line 35 "inweb/foundation-module/Chapter 2/Trees.w"

#line 40 "inweb/foundation-module/Chapter 2/Trees.w"
tree_node *Trees__new_node(heterogeneous_tree *T, tree_node_type *type, general_pointer wrapping) {
	if (T == NULL) internal_error("no tree");
	if (wrapping.run_time_type_code == -1)
		internal_error("no reference given");
	if (type->required_CLASS >= 0)
		if (wrapping.run_time_type_code != type->required_CLASS)
			internal_error("wrong reference type");

	tree_node *N = CREATE(tree_node);
	N->content = wrapping;
	N->owner = T;
	N->type = type;
	N->parent = NULL;
	N->child = NULL;
	N->next = NULL;
	return N;
}

#line 61 "inweb/foundation-module/Chapter 2/Trees.w"
tree_node *Trees__new_child(tree_node *of, tree_node_type *type, general_pointer wrapping) {
	tree_node *N = Trees__new_node(of->owner, type, wrapping);
	Trees__make_child(N, of);
	return N;
}

#line 79 "inweb/foundation-module/Chapter 2/Trees.w"

#line 81 "inweb/foundation-module/Chapter 2/Trees.w"
tree_type *Trees__new_type(text_stream *name, int (*verifier)(tree_node *)) {
	tree_type *T = CREATE(tree_type);
	T->name = Str__duplicate(name);
	T->verify_root = verifier;
	return T;
}

#line 98 "inweb/foundation-module/Chapter 2/Trees.w"

#line 100 "inweb/foundation-module/Chapter 2/Trees.w"
tree_node_type *Trees__new_node_type(text_stream *name, int req,
	int (*verifier)(tree_node *)) {
	tree_node_type *NT = CREATE(tree_node_type);
	NT->node_type_name = Str__duplicate(name);
	NT->required_CLASS = req;
	NT->verify_children = verifier;
	return NT;
}

#line 114 "inweb/foundation-module/Chapter 2/Trees.w"
void Trees__make_root(heterogeneous_tree *T, tree_node *N) {
	if (T == NULL) internal_error("no tree");
	if (N == NULL) internal_error("no node");
	N->owner = T;
	T->root = N;
	N->parent = NULL;
	N->next = NULL;
	if (T->type->verify_root)
		if ((*(T->type->verify_root))(N) == FALSE)
			internal_error("disallowed node as root");
}

void Trees__remove_root(heterogeneous_tree *T) {
	if (T == NULL) internal_error("no tree");
	T->root = NULL;
}

#line 134 "inweb/foundation-module/Chapter 2/Trees.w"
void Trees__make_child(tree_node *N, tree_node *of) {
	if (N == NULL) internal_error("no node");
	if (of == NULL) internal_error("no node");
	if (N == N->owner->root) Trees__remove_root(N->owner);
	N->owner = of->owner;
	N->parent = of;
	N->next = NULL;
	if (of->child == NULL)
		of->child = N;
	else
		for (tree_node *S = of->child; S; S = S->next)
			if (S->next == NULL) {
				S->next = N; break;
			}
	Trees__verify_children(of);
}

void Trees__make_eldest_child(tree_node *N, tree_node *of) {
	if (N == NULL) internal_error("no node");
	if (of == NULL) internal_error("no node");
	if (N == N->owner->root) Trees__remove_root(N->owner);
	N->owner = of->owner;
	N->parent = of;
	N->next = of->child;
	of->child = N;
	Trees__verify_children(of);
}

void Trees__make_sibling(tree_node *N, tree_node *of) {
	if (N == NULL) internal_error("no node");
	if (of == NULL) internal_error("no node");
	if (N == N->owner->root) Trees__remove_root(N->owner);
	if (of == of->owner->root)
		internal_error("nodes cannot be siblings of the root");
	N->owner = of->owner;
	N->parent = of->parent;
	N->next = of->next;
	of->next = N;
	if (of->parent)	Trees__verify_children(of->parent);
}

#line 179 "inweb/foundation-module/Chapter 2/Trees.w"
void Trees__remove(tree_node *N) {
	if (N == NULL) internal_error("no node");
	if (N == N->owner->root) { Trees__remove_root(N->owner); return; }
	tree_node *p = N->parent;
	if (N->parent->child == N)
		N->parent->child = N->next;
	else
		for (tree_node *S = N->parent->child; S; S = S->next)
			if (S->next == N)
				S->next = N->next;
	N->parent = NULL;
	N->next = NULL;
	if (p) Trees__verify_children(p);
}

int Trees__verify_children(tree_node *N) {
	if (N == NULL) internal_error("no node");
	if (N->type->verify_children)
		return (*(N->type->verify_children))(N);
	return TRUE;
}

#line 210 "inweb/foundation-module/Chapter 2/Trees.w"
void Trees__traverse_tree(heterogeneous_tree *T,
	int (*visitor)(tree_node *, void *, int L), void *state) {
	if (T == NULL) internal_error("no tree");
	Trees__traverse_from(T->root, visitor, state, 0);
}

void Trees__traverse_from(tree_node *N,
	int (*visitor)(tree_node *, void *, int L), void *state, int L) {
	if (N)
		if ((*visitor)(N, state, L))
			Trees__traverse(N->child, visitor, state, L+1);
}

void Trees__traverse(tree_node *N,
	int (*visitor)(tree_node *, void *, int L), void *state, int L) {
	for (tree_node *M = N; M; M = M->next)
		if ((*visitor)(M, state, L))
			Trees__traverse(M->child, visitor, state, L+1);
}

#line 233 "inweb/foundation-module/Chapter 2/Trees.w"
void Trees__prune_tree(heterogeneous_tree *T,
	int (*visitor)(tree_node *, void *), void *state) {
	if (T == NULL) internal_error("no tree");
	Trees__prune_from(T->root, visitor, state);
}

void Trees__prune_from(tree_node *N,
	int (*visitor)(tree_node *, void *), void *state) {
	if (N) {
		if ((*visitor)(N, state))
			Trees__remove(N);
		else
			Trees__prune(N->child, visitor, state);
	}
}

void Trees__prune(tree_node *N,
	int (*visitor)(tree_node *, void *), void *state) {
	for (tree_node *M = N, *next_M = N?(N->next):NULL; M; M = next_M, next_M = M?(M->next):NULL)
		if ((*visitor)(M, state))
			Trees__remove(M);
		else
			Trees__prune(M->child, visitor, state);
}

#line 10 "inweb/foundation-module/Chapter 3/Error Messages.w"
int (*errors_handler)(text_stream *, int) = NULL;
void (*internal_errors_handler)(void *, char *, char *, int) = NULL;

void Errors__set_handler(int (*f)(text_stream *, int)) {
	errors_handler = f;
}
void Errors__set_internal_handler(void (*f)(void *, char *, char *, int)) {
	internal_errors_handler = f;
}

int problem_count = 0;
int Errors__have_occurred(void) {
	if (problem_count > 0) return TRUE;
	return FALSE;
}

void Errors__issue(text_stream *message, int fatality) {
	STREAM_FLUSH(STDOUT);
	int rv = TRUE;
	if (errors_handler) rv = (*errors_handler)(message, fatality);
	if (rv) WRITE_TO(STDERR, "%S", message);
	STREAM_FLUSH(STDERR);
	if (fatality) Errors__die(); else problem_count++;
}

#line 43 "inweb/foundation-module/Chapter 3/Error Messages.w"
void Errors__fatal(char *message) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: %s\n", PROGRAM_NAME, message);
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_C_string(char *message, char *parameter) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: ", PROGRAM_NAME);
	WRITE_TO(ERM, message, parameter);
	WRITE_TO(ERM, "\n");
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_text(char *message, text_stream *parameter) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: ", PROGRAM_NAME);
	WRITE_TO(ERM, message, parameter);
	WRITE_TO(ERM, "\n");
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_file(char *message, filename *F) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: %s: %f\n", PROGRAM_NAME, message, F);
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

void Errors__fatal_with_path(char *message, pathname *P) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: fatal error: %s: %p\n", PROGRAM_NAME, message, P);
	Errors__issue(ERM, TRUE);
	DISCARD_TEXT(ERM)
}

#line 90 "inweb/foundation-module/Chapter 3/Error Messages.w"
_Noreturn
void Errors__internal_error_handler(void *p, char *message, char *f, int lc) {
	if (internal_errors_handler)
		(*internal_errors_handler)(p, message, f, lc);
	else
		Errors__fatal_with_C_string("internal error (%s)", message);
	exit(1); /* redundant but needed to remove compiler warning in clang */
}

#line 105 "inweb/foundation-module/Chapter 3/Error Messages.w"
int debugger_mode = FALSE;
void Errors__enter_debugger_mode(void) {
	debugger_mode = TRUE;
	printf("(Debugger mode enabled: will crash on fatal errors)\n");
}

void Errors__die(void) { /* as void as it gets */
	if (DL) STREAM_FLUSH(DL);
	if (debugger_mode) {
		WRITE_TO(STDERR, "(crashing intentionally to allow backtrace)\n");
		int to_deliberately_crash = 0;
		printf("%d", 1/to_deliberately_crash);
	}
	/* on a fatal exit, memory isn't freed, because that causes threading problems */
	exit(2);
}

#line 127 "inweb/foundation-module/Chapter 3/Error Messages.w"
void Errors__nowhere(char *message) {
	Errors__in_text_file(message, NULL);
}

void Errors__in_text_file(char *message, text_file_position *here) {
	if (here)
		Errors__at_position(message, here->text_file_filename, here->line_count);
	else
		Errors__at_position(message, NULL, 0);
}

void Errors__in_text_file_S(text_stream *message, text_file_position *here) {
	if (here)
		Errors__at_position_S(message, here->text_file_filename, here->line_count);
	else
		Errors__at_position_S(message, NULL, 0);
}

#line 148 "inweb/foundation-module/Chapter 3/Error Messages.w"
void Errors__at_position(char *message, filename *file, int line) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: ", PROGRAM_NAME);
	if (file) WRITE_TO(ERM, "%f, line %d: ", file, line);
	WRITE_TO(ERM, "%s\n", message);
	Errors__issue(ERM, FALSE);
	DISCARD_TEXT(ERM)
}

void Errors__at_position_S(text_stream *message, filename *file, int line) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: ", PROGRAM_NAME);
	if (file) WRITE_TO(ERM, "%f, line %d: ", file, line);
	WRITE_TO(ERM, "%S\n", message);
	Errors__issue(ERM, FALSE);
	DISCARD_TEXT(ERM)
}

#line 169 "inweb/foundation-module/Chapter 3/Error Messages.w"
void Errors__with_file(char *message, filename *F) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: %f: %s\n", PROGRAM_NAME, F, message);
	Errors__issue(ERM, FALSE);
	DISCARD_TEXT(ERM)
}

void Errors__with_text(char *message, text_stream *T) {
	TEMPORARY_TEXT(ERM)
	WRITE_TO(ERM, "%s: ", PROGRAM_NAME);
	WRITE_TO(ERM, message, T);
	WRITE_TO(ERM, "\n");
	Errors__issue(ERM, FALSE);
	DISCARD_TEXT(ERM)
}

#line 50 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"

#line 55 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
dictionary *cls_dictionary = NULL;

#line 63 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int current_switch_group = -1;
text_stream *switch_group_names[NO_DEFINED_CLSG_VALUES+1];
void CommandLine__begin_group(int id, text_stream *name) {
	if (current_switch_group == -1)
		for (int i=0; i<=NO_DEFINED_CLSG_VALUES; i++) switch_group_names[i] = NULL;
	current_switch_group = id;
	switch_group_names[id] = name;
}
void CommandLine__end_group(void) {
	current_switch_group = NO_CLSG;
}
command_line_switch *CommandLine__declare_switch(int id,
	inchar32_t *name_literal, int val, inchar32_t *help_literal) {
	return CommandLine__declare_switch_p(id,
		Str__new_from_wide_string(name_literal), val,
		Str__new_from_wide_string(help_literal));
}
command_line_switch *CommandLine__declare_switch_p(int id,
	text_stream *name, int val, text_stream *help_literal) {
	if (current_switch_group == -1) {
		current_switch_group = NO_CLSG;
		for (int i=0; i<=NO_DEFINED_CLSG_VALUES; i++) switch_group_names[i] = NULL;
	}
	if (cls_dictionary == NULL) cls_dictionary = Dictionaries__new(16, FALSE);
	command_line_switch *cls = CREATE(command_line_switch);
	cls->switch_name = name;
	
{
#line 107 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
	cls->switch_sort_name = Str__duplicate(name);
	if (Str__begins_with_wide_string(name, U"no-")) {
		Str__delete_n_characters(cls->switch_sort_name, 3);
		WRITE_TO(cls->switch_sort_name, "_");
	}

}
#line 89 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
;
	cls->switch_id = id;
	cls->valency = val;
	cls->help_text = help_literal;
	cls->form = ACTION_CLSF;
	cls->active_by_default = FALSE;
	cls->negates = NULL;
	cls->switch_group = current_switch_group;
	Dictionaries__create(cls_dictionary, cls->switch_name);
	Dictionaries__write_value(cls_dictionary, cls->switch_name, cls);
	return cls;
}

#line 117 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
command_line_switch *CommandLine__declare_boolean_switch(int id,
	inchar32_t *name_literal, int val, inchar32_t *help_literal, int active) {
	command_line_switch *cls =
		CommandLine__declare_switch(id, name_literal, val, help_literal);
	text_stream *neg = Str__new();
	WRITE_TO(neg, "no-%w", name_literal);
	text_stream *neg_help = Str__new();
	WRITE_TO(neg_help, "don't %w", help_literal);
	command_line_switch *negated =
		CommandLine__declare_switch_p(id, neg, val, neg_help);

	cls->form = BOOLEAN_ON_CLSF;
	negated->form = BOOLEAN_OFF_CLSF;
	negated->negates = cls;

	if (active) cls->active_by_default = TRUE; else negated->active_by_default = TRUE;
	return cls;
}

void CommandLine__declare_numerical_switch(int id,
	inchar32_t *name_literal, int val, inchar32_t *help_literal) {
	command_line_switch *cls =
		CommandLine__declare_switch(id, name_literal, val, help_literal);
	cls->form = NUMERICAL_CLSF;
}

void CommandLine__declare_textual_switch(int id,
	inchar32_t *name_literal, int val, inchar32_t *help_literal) {
	command_line_switch *cls =
		CommandLine__declare_switch(id, name_literal, val, help_literal);
	cls->form = TEXTUAL_CLSF;
}

#line 178 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"

int CommandLine__read(int argc, char **argv, void *state,
	void (*f)(int, int, text_stream *, void *), void (*g)(int, text_stream *, void *)) {
	clf_reader_state crs;
	crs.state = state; crs.f = f; crs.g = g;
	crs.subs = FALSE; crs.nrt = 0;
	CommandLine__read_array(&crs, argc, argv);
	CommandLine__read_file(&crs);
	return crs.subs;
}

void CommandLine__set_locale(int argc, char **argv) {
	for (int i=1; i<argc; i++) {
		char *p = argv[i];
		if ((strcmp(p, "-locale") == 0) && (i<argc-1))
			if (Locales__set_locales(argv[i+1]) == FALSE)
				Errors__fatal("unrecognised locale");
	}
}

void CommandLine__read_array(clf_reader_state *crs, int argc, char **argv) {
	for (int i=1; i<argc; i++) {
		int switched = FALSE;
		char *p = argv[i];
		while (p[0] == '-') { p++; switched = TRUE; } /* allow a doubled-dash as a single */
		TEMPORARY_TEXT(opt)
		Streams__write_locale_string(opt, p);
		TEMPORARY_TEXT(arg)
		if (i+1 < argc) Streams__write_locale_string(arg, argv[i+1]);
		if (switched) {
			int N = CommandLine__read_pair(crs, opt, arg);
			if (N == 0)
				Errors__fatal_with_text("unknown command line switch: -%S", opt);
			i += N - 1;
		} else {
			CommandLine__read_one(crs, opt);
		}
		DISCARD_TEXT(opt)
		DISCARD_TEXT(arg)
	}
}

#line 224 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
filename *command_line_file = NULL;
void CommandLine__also_read_file(filename *F) {
	command_line_file = F;
}

#line 235 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
linked_list *command_line_logs = NULL;
void CommandLine__record_log(text_stream *line) {
	if (command_line_logs == NULL)
		command_line_logs = NEW_LINKED_LIST(text_stream);
	ADD_TO_LINKED_LIST(line, text_stream, command_line_logs);
}

void CommandLine__play_back_log(void) {
	if (command_line_logs) {
		text_stream *line;
		LOOP_OVER_LINKED_LIST(line, text_stream, command_line_logs)
			LOG("%S\n", line);
	}
}

#line 259 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
void CommandLine__read_file(clf_reader_state *crs) {
	text_stream *logline = Str__new();
	WRITE_TO(logline, "Reading further switches from file: %f", command_line_file);
	CommandLine__record_log(logline);
	if (command_line_file)
		TextFiles__read(command_line_file, FALSE,
			NULL, FALSE, CommandLine__read_file_helper, NULL, (void *) crs);
	command_line_file = NULL;
	text_stream *lastline = Str__new();
	WRITE_TO(lastline, "Completed expert settings file");
	CommandLine__record_log(lastline);
}
void CommandLine__read_file_helper(text_stream *text, text_file_position *tfp, void *state) {
	clf_reader_state *crs = (clf_reader_state *) state;
	match_results mr = Regexp__create_mr();
	if ((Str__is_whitespace(text)) || (Regexp__match(&mr, text, U" *#%c*"))) {
		;
	} else {
		text_stream *logline = Str__new();
		WRITE_TO(logline, "line %d: %S", tfp->line_count, text);
		CommandLine__record_log(logline);
		if (Regexp__match(&mr, text, U" *-*(%C+) (%c+?) *")) {
			int N = CommandLine__read_pair(crs, mr.exp[0], mr.exp[1]);
			if (N == 0)
				Errors__fatal_with_text("unknown command line switch: -%S", mr.exp[0]);
			if (N == 1)
				Errors__fatal_with_text("command line switch does not take value: -%S", mr.exp[0]);
		} else if (Regexp__match(&mr, text, U" *-*(%C+) *")) {
			int N = CommandLine__read_pair(crs, mr.exp[0], NULL);
			if (N == 0)
				Errors__fatal_with_text("unknown command line switch: -%S", mr.exp[0]);
			if (N == 2)
				Errors__fatal_with_text("command line switch requires value: -%S", mr.exp[0]);
		} else {
			Errors__in_text_file("illegible line in expert settings file", tfp);
			WRITE_TO(STDERR, "'%S'\n", text);
		}
	}
	Regexp__dispose_of(&mr);
}

void CommandLine__read_one(clf_reader_state *crs, text_stream *opt) {
	(*(crs->g))(crs->nrt++, opt, crs->state);
	crs->subs = TRUE;
}

#line 308 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int CommandLine__read_pair(clf_reader_state *crs, text_stream *opt, text_stream *arg) {
	TEMPORARY_TEXT(opt_p)
	TEMPORARY_TEXT(opt_val)
	Str__copy(opt_p, opt);
	int N = BOGUS_CLSN;
	match_results mr = Regexp__create_mr();
	if ((Regexp__match(&mr, opt, U"(%c+)=(%d+)")) ||
		(Regexp__match(&mr, opt, U"(%c+)=(-%d+)"))) {
		N = Str__atoi(mr.exp[1], 0);
		Str__copy(opt_p, mr.exp[0]);
		Str__copy(opt_val, mr.exp[1]);
	} else if (Regexp__match(&mr, opt, U"(%c+)=(%c*)")) {
		Str__copy(opt_p, mr.exp[0]);
		Str__copy(opt_val, mr.exp[1]);
	}
	int rv = CommandLine__read_pair_p(opt_p, opt_val, N, arg, crs->state, crs->f, &(crs->subs));
	DISCARD_TEXT(opt_p)
	DISCARD_TEXT(opt_val)
	return rv;
}

#line 332 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int CommandLine__read_pair_p(text_stream *opt, text_stream *opt_val, int N,
	text_stream *arg, void *state,
	void (*f)(int, int, text_stream *, void *), int *substantive) {
	if (Dictionaries__find(cls_dictionary, opt) == NULL) return 0;
	command_line_switch *cls = Dictionaries__read_value(cls_dictionary, opt);
	if (cls == NULL) return 0;
	if ((N == BOGUS_CLSN) && (cls->form == NUMERICAL_CLSF)) {
		Errors__fatal_with_text("no value N given for -%S=N", opt);
		return cls->valency;
	}
	if ((N != BOGUS_CLSN) && (cls->form != NUMERICAL_CLSF)) {
		Errors__fatal_with_text("this is not a numerical setting: -%S", opt);
		return cls->valency;
	}
	if (cls->valency > 1) {
		if (Str__len(arg) == 0) {
			Errors__fatal_with_text("no argument X for -%S X", opt);
			return cls->valency;
		}
	}
	int innocuous = FALSE;
	
{
#line 362 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
	switch (cls->switch_id) {
		case CRASH_CLSW:
			if (cls->form == BOOLEAN_ON_CLSF) {
				Errors__enter_debugger_mode(); innocuous = TRUE;
			}
			break;
		case LOG_CLSW: 
{
#line 402 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
	if (Log__get_debug_log_filename() == NULL) {
		TEMPORARY_TEXT(itn)
		WRITE_TO(itn, "%s", PROGRAM_NAME);
		filename *F = Filenames__in(Pathnames__from_text(itn), TL_IS_1);
		DISCARD_TEXT(itn)
		Log__set_debug_log_filename(F);
	}
	Log__open();
	Log__set_aspect_from_command_line(arg, TRUE);

}
#line 368 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
; innocuous = TRUE; break;
		case VERSION_CLSW: {
			PRINT("inweb");
			char *svn = "7.2.1-beta+1B45";
			if (svn[0]) PRINT(" version %s", svn);
			char *vname = "Escape to Danger";
			if (vname[0]) PRINT(" '%s'", vname);
			char *d = "1 September 2023";
			if (d[0]) PRINT(" (%s)", d);
			PRINT("\n");
			innocuous = TRUE; break;
		}
		case HELP_CLSW: CommandLine__write_help(STDOUT); innocuous = TRUE; break;
		case FIXTIME_CLSW:
			if (cls->form == BOOLEAN_ON_CLSF) Time__fix();
			break;
		case AT_CLSW: Pathnames__set_installation_path(Pathnames__from_text(arg)); break;
		case LOCALE_CLSW: break; /* because it was done earlier */
		default:
			if (f) {
				int par = -1;
				switch (cls->form) {
					case BOOLEAN_ON_CLSF: par = TRUE; break;
					case BOOLEAN_OFF_CLSF: par = FALSE; break;
					case NUMERICAL_CLSF: par = N; break;
					case TEXTUAL_CLSF: arg = opt_val; break;
				}
				if (cls->valency == 1) (*f)(cls->switch_id, par, arg, state);
				else (*f)(cls->switch_id, par, arg, state);
			}
			break;
	}

}
#line 353 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
;
	if ((innocuous == FALSE) && (substantive)) *substantive = TRUE;
	return cls->valency;
}

#line 422 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
text_stream *cls_heading = NULL;

void CommandLine__declare_heading(inchar32_t *heading_text_literal) {
	cls_heading = Str__new_from_wide_string(heading_text_literal);
}

void CommandLine__write_help(OUTPUT_STREAM) {
	command_line_switch *cls;
	int max = 0, N = 0;
	LOOP_OVER(cls, command_line_switch) {
		int L = Str__len(cls->switch_name);
		if (L > max) max = L;
		N++;
	}
	command_line_switch **sorted_table =
		Memory__calloc(N, (int) sizeof(command_line_switch *), ARRAY_SORTING_MREASON);
	int i=0; LOOP_OVER(cls, command_line_switch) sorted_table[i++] = cls;
	qsort(sorted_table, (size_t) N, sizeof(command_line_switch *), CommandLine__compare_names);

	if (Str__len(cls_heading) > 0) WRITE("%S\n", cls_heading);
	int filter = NO_CLSG, new_para_needed = FALSE;
	
{
#line 454 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
	if (new_para_needed) {
		WRITE("\n");
		new_para_needed = FALSE;
	}
	for (int i=0; i<N; i++) {
		command_line_switch *cls = sorted_table[i];
		if (cls->switch_group != filter) continue;
		if ((cls->form == BOOLEAN_OFF_CLSF) || (cls->form == BOOLEAN_ON_CLSF)) {
			if (cls->active_by_default) continue;
		}
		text_stream *label = switch_group_names[filter];
		if (new_para_needed == FALSE) {
			if (Str__len(label) > 0) WRITE("%S:\n", label);
			new_para_needed = TRUE;
		}
		TEMPORARY_TEXT(line)
		if (Str__len(label) > 0) WRITE_TO(line, "  ");
		WRITE_TO(line, "-%S", cls->switch_name);
		if (cls->form == NUMERICAL_CLSF) WRITE_TO(line, "=N");
		if (cls->form == TEXTUAL_CLSF) WRITE_TO(line, "=X");
		if (cls->valency > 1) WRITE_TO(line, " X");
		while (Str__len(line) < max+7) WRITE_TO(line, " ");
		WRITE_TO(line, "%S", cls->help_text);
		if (cls->form == BOOLEAN_ON_CLSF)
			WRITE_TO(line, " (default is -no-%S)", cls->switch_name);
		if (cls->form == BOOLEAN_OFF_CLSF)
			WRITE_TO(line, " (default is -%S)", cls->negates->switch_name);
		WRITE("%S\n", line);
		DISCARD_TEXT(line)
	}

}
#line 443 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
;
	for (filter = NO_CLSG; filter<NO_DEFINED_CLSG_VALUES; filter++)
		if ((filter != NO_CLSG) && (filter != FOUNDATION_CLSG))
			
{
#line 454 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
	if (new_para_needed) {
		WRITE("\n");
		new_para_needed = FALSE;
	}
	for (int i=0; i<N; i++) {
		command_line_switch *cls = sorted_table[i];
		if (cls->switch_group != filter) continue;
		if ((cls->form == BOOLEAN_OFF_CLSF) || (cls->form == BOOLEAN_ON_CLSF)) {
			if (cls->active_by_default) continue;
		}
		text_stream *label = switch_group_names[filter];
		if (new_para_needed == FALSE) {
			if (Str__len(label) > 0) WRITE("%S:\n", label);
			new_para_needed = TRUE;
		}
		TEMPORARY_TEXT(line)
		if (Str__len(label) > 0) WRITE_TO(line, "  ");
		WRITE_TO(line, "-%S", cls->switch_name);
		if (cls->form == NUMERICAL_CLSF) WRITE_TO(line, "=N");
		if (cls->form == TEXTUAL_CLSF) WRITE_TO(line, "=X");
		if (cls->valency > 1) WRITE_TO(line, " X");
		while (Str__len(line) < max+7) WRITE_TO(line, " ");
		WRITE_TO(line, "%S", cls->help_text);
		if (cls->form == BOOLEAN_ON_CLSF)
			WRITE_TO(line, " (default is -no-%S)", cls->switch_name);
		if (cls->form == BOOLEAN_OFF_CLSF)
			WRITE_TO(line, " (default is -%S)", cls->negates->switch_name);
		WRITE("%S\n", line);
		DISCARD_TEXT(line)
	}

}
#line 446 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
;
	filter = FOUNDATION_CLSG;
	
{
#line 454 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
	if (new_para_needed) {
		WRITE("\n");
		new_para_needed = FALSE;
	}
	for (int i=0; i<N; i++) {
		command_line_switch *cls = sorted_table[i];
		if (cls->switch_group != filter) continue;
		if ((cls->form == BOOLEAN_OFF_CLSF) || (cls->form == BOOLEAN_ON_CLSF)) {
			if (cls->active_by_default) continue;
		}
		text_stream *label = switch_group_names[filter];
		if (new_para_needed == FALSE) {
			if (Str__len(label) > 0) WRITE("%S:\n", label);
			new_para_needed = TRUE;
		}
		TEMPORARY_TEXT(line)
		if (Str__len(label) > 0) WRITE_TO(line, "  ");
		WRITE_TO(line, "-%S", cls->switch_name);
		if (cls->form == NUMERICAL_CLSF) WRITE_TO(line, "=N");
		if (cls->form == TEXTUAL_CLSF) WRITE_TO(line, "=X");
		if (cls->valency > 1) WRITE_TO(line, " X");
		while (Str__len(line) < max+7) WRITE_TO(line, " ");
		WRITE_TO(line, "%S", cls->help_text);
		if (cls->form == BOOLEAN_ON_CLSF)
			WRITE_TO(line, " (default is -no-%S)", cls->switch_name);
		if (cls->form == BOOLEAN_OFF_CLSF)
			WRITE_TO(line, " (default is -%S)", cls->negates->switch_name);
		WRITE("%S\n", line);
		DISCARD_TEXT(line)
	}

}
#line 448 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
;

	Memory__I7_free(sorted_table, ARRAY_SORTING_MREASON, N*((int) sizeof(command_line_switch *)));
}

#line 486 "inweb/foundation-module/Chapter 3/Command Line Arguments.w"
int CommandLine__compare_names(const void *ent1, const void *ent2) {
	text_stream *tx1 = (*((const command_line_switch **) ent1))->switch_sort_name;
	text_stream *tx2 = (*((const command_line_switch **) ent2))->switch_sort_name;
	return Str__cmp_insensitive(tx1, tx2);
}

#line 44 "inweb/foundation-module/Chapter 3/Pathnames.w"

#line 50 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname *home_path = NULL;
void Pathnames__start(void) {
	char *home = (char *) (Platform__getenv("HOME"));
	if (home) {
		text_stream *H = Str__new_from_locale_string(home);
		home_path = Pathnames__from_text(H);
		home_path->known_to_exist = TRUE;
	}
}

#line 63 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname *installation_path = NULL;
void Pathnames__set_installation_path(pathname *P) {
	installation_path = P;
}
pathname *Pathnames__installation_path(const char *V, text_stream *def) {
	if (installation_path) return installation_path;
	inchar32_t where[4*MAX_FILENAME_LENGTH];
	where[0] = 0;
	Platform__where_am_i(where, 4*MAX_FILENAME_LENGTH);
	if (where[0]) {
		text_stream *v = Str__new_from_wide_string(where);
		filename *F = Filenames__from_text(v);
		pathname *P = Filenames__up(F);
		if ((P) && (Str__eq(P->intermediate, TL_IS_2)))
			P = P->pathname_of_parent;
		return P;
	}
	if (V) {
		char *val = Platform__getenv(V);
		if ((val) && (val[0])) {
			text_stream *v = Str__new_from_locale_string(val);
			return Pathnames__from_text(v);
		}
	}
	if (def) return Pathnames__from_text(def);
	return NULL;
}

#line 96 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname *Pathnames__down(pathname *P, text_stream *dir_name) {
	return Pathnames__primitive(dir_name, 0, Str__len(dir_name), P);
}

pathname *Pathnames__primitive(text_stream *str, int from, int to, pathname *par) {
	pathname *P = CREATE(pathname);
	P->pathname_of_parent = par;
	P->known_to_exist = FALSE;
	if (to-from <= 0) internal_error("empty intermediate pathname");
	P->intermediate = Str__new_with_capacity(to-from+1);
	if (str)
		for (int i = from; i < to; i++)
			PUT_TO(P->intermediate, Str__get(Str__at(str, i)));
	return P;
}

#line 120 "inweb/foundation-module/Chapter 3/Pathnames.w"
pathname *Pathnames__from_text(text_stream *path) {
	return Pathnames__from_text_relative(NULL, path);
}

pathname *Pathnames__from_text_relative(pathname *P, text_stream *path) {
	pathname *at = P;
	int i = 0, pos = 0;
	if ((Str__get(Str__start(path))) && (P == NULL)) i++;
	for (; i < Str__len(path); i++)
		if (Platform__is_folder_separator(Str__get(Str__at(path, i)))) {
			if (i > pos) at = Pathnames__primitive(path, pos, i, at);
			pos = i+1;
		}
	if (i > pos) at = Pathnames__primitive(path, pos, i, at);
	return at;
}

#line 141 "inweb/foundation-module/Chapter 3/Pathnames.w"
void Pathnames__writer(OUTPUT_STREAM, char *format_string, void *vP) {
	pathname *P = (pathname *) vP;
	inchar32_t divider = FOLDER_SEPARATOR;
	if (format_string[0] == '/') divider = '/';
	if (P) Pathnames__writer_r(OUT, P, divider); else WRITE(".");
}

void Pathnames__writer_r(OUTPUT_STREAM, pathname *P, inchar32_t divider) {
	if (P->pathname_of_parent) {
		Pathnames__writer_r(OUT, P->pathname_of_parent, divider);
		PUT(divider);
	}
	WRITE("%S", P->intermediate);
}

#line 178 "inweb/foundation-module/Chapter 3/Pathnames.w"
void Pathnames__to_text_relative(OUTPUT_STREAM, pathname *P, pathname *R) {
	TEMPORARY_TEXT(rt)
	TEMPORARY_TEXT(pt)
	WRITE_TO(rt, "%p", R);
	WRITE_TO(pt, "%p", P);
	int n = Str__len(pt);
	if ((Str__prefix_eq(rt, pt, n)) && (Platform__is_folder_separator(Str__get_at(rt, n)))) {
		Str__delete_n_characters(rt, n+1);
		WRITE("%S", rt);
	} else if (Str__eq(rt, pt) == FALSE)
		internal_error("pathname not relative to pathname");
	DISCARD_TEXT(rt)
	DISCARD_TEXT(pt)
}

pathname *Pathnames__up(pathname *P) {
	if (P == NULL) internal_error("can't go up from root directory");
	return P->pathname_of_parent;
}

text_stream *Pathnames__directory_name(pathname *P) {
	if (P == NULL) return NULL;
	return P->intermediate;
}

#line 209 "inweb/foundation-module/Chapter 3/Pathnames.w"
void Pathnames__relative_URL(OUTPUT_STREAM, pathname *from, pathname *to) {
	TEMPORARY_TEXT(url)
	int found = FALSE;
	for (pathname *P = to; P && (found == FALSE); P = Pathnames__up(P)) {
		TEMPORARY_TEXT(PT)
		WRITE_TO(PT, "%p", P);
		int q_up_count = 0;
		for (pathname *Q = from; Q && (found == FALSE); Q = Pathnames__up(Q)) {
			TEMPORARY_TEXT(QT)
			WRITE_TO(QT, "%p", Q);
			if (Str__eq(PT, QT)) {
				for (int i=0; i<q_up_count; i++) WRITE_TO(url, "../");
				TEMPORARY_TEXT(FPT)
				WRITE_TO(FPT, "%p", to);
				Str__substr(url, Str__at(FPT, Str__len(PT) + 1), Str__end(FPT));
				found = TRUE;
			}
			DISCARD_TEXT(QT)
			q_up_count++;
		}
		DISCARD_TEXT(PT)
	}
	if (found == FALSE) {
		for (pathname *Q = from; Q; Q = Pathnames__up(Q)) WRITE_TO(url, "../");
		WRITE_TO(url, "%p", to);
	}
	WRITE("%S", url);
	if ((Str__len(url) > 0) && (Str__get_last_char(url) != '/')) WRITE("/");
	DISCARD_TEXT(url)
}

#line 245 "inweb/foundation-module/Chapter 3/Pathnames.w"
int Pathnames__create_in_file_system(pathname *P) {
	if (P == NULL) return TRUE; /* the root of the file system always exists */
	if (P->known_to_exist) return TRUE;
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(pn)
	WRITE_TO(pn, "%p", P);
	Str__copy_to_locale_string(transcoded_pathname, pn, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(pn)
	P->known_to_exist = Platform__mkdir(transcoded_pathname);
	return P->known_to_exist;
}

#line 263 "inweb/foundation-module/Chapter 3/Pathnames.w"
void Pathnames__rsync(pathname *source, pathname *dest) {
	char transcoded_source[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(pn)
	WRITE_TO(pn, "%p", source);
	Str__copy_to_locale_string(transcoded_source, pn, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(pn)
	char transcoded_dest[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(pn2)
	WRITE_TO(pn2, "%p", dest);
	Str__copy_to_locale_string(transcoded_dest, pn2, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(pn2)
	Platform__rsync(transcoded_source, transcoded_dest);
}

#line 280 "inweb/foundation-module/Chapter 3/Pathnames.w"
int Pathnames__move_directory(pathname *from, pathname *to) {
	TEMPORARY_TEXT(from_path)
	TEMPORARY_TEXT(to_path)
	WRITE_TO(from_path, "%p", from);
	WRITE_TO(to_path, "%p", to);
	char from_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(from_name_written_out, from_path, 4*MAX_FILENAME_LENGTH);
	char to_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(to_name_written_out, to_path, 4*MAX_FILENAME_LENGTH);
	int rv = Platform__rename_directory(from_name_written_out, to_name_written_out);
	DISCARD_TEXT(from_path)
	DISCARD_TEXT(to_path)
	return rv;
}

#line 17 "inweb/foundation-module/Chapter 3/Filenames.w"

#line 22 "inweb/foundation-module/Chapter 3/Filenames.w"
filename *Filenames__in(pathname *P, text_stream *file_name) {
	return Filenames__primitive(file_name, 0, Str__len(file_name), P);
}

filename *Filenames__primitive(text_stream *S, int from, int to, pathname *P) {
	filename *F = CREATE(filename);
	F->pathname_of_location = P;
	if (to-from <= 0)
		internal_error("empty intermediate pathname");
	F->leafname = Str__new_with_capacity(to-from+1);
	string_position pos = Str__at(S, from);
	for (int i = from; i < to; i++, pos = Str__forward(pos))
		PUT_TO(F->leafname, Str__get(pos));
	return F;
}

#line 42 "inweb/foundation-module/Chapter 3/Filenames.w"
filename *Filenames__from_text(text_stream *path) {
	int i = 0, pos = -1;
	LOOP_THROUGH_TEXT(at, path) {
		if (Platform__is_folder_separator(Str__get(at))) pos = i;
		i++;
	}
	pathname *P = NULL;
	if (pos >= 0) {
		TEMPORARY_TEXT(PT)
		Str__substr(PT, Str__at(path, 0), Str__at(path, pos));
		P = Pathnames__from_text(PT);
		DISCARD_TEXT(PT)
	}
	return Filenames__primitive(path, pos+1, Str__len(path), P);
}

filename *Filenames__from_text_relative(pathname *from, text_stream *path) {
	filename *F = Filenames__from_text(path);
	if (from) {
		if (F->pathname_of_location == NULL) F->pathname_of_location = from;
		else {
			pathname *P = F->pathname_of_location;
			while ((P) && (P->pathname_of_parent)) P = P->pathname_of_parent;
			P->pathname_of_parent = from;
		}
	}
	return F;
}

#line 75 "inweb/foundation-module/Chapter 3/Filenames.w"
void Filenames__writer(OUTPUT_STREAM, char *format_string, void *vF) {
	filename *F = (filename *) vF;
	if (F == NULL) WRITE("<no file>");
	else {
		if (F->pathname_of_location) {
			Pathnames__writer(OUT, format_string, (void *) F->pathname_of_location);
			if (format_string[0] == '/') PUT('/');
			else PUT(FOLDER_SEPARATOR);
		}
		WRITE("%S", F->leafname);
	}
}

#line 91 "inweb/foundation-module/Chapter 3/Filenames.w"
void Filenames__to_text_relative(OUTPUT_STREAM, filename *F, pathname *P) {
	TEMPORARY_TEXT(ft)
	TEMPORARY_TEXT(pt)
	WRITE_TO(ft, "%f", F);
	WRITE_TO(pt, "%p", P);
	int n = Str__len(pt);
	if ((Str__prefix_eq(ft, pt, n)) && (Platform__is_folder_separator(Str__get_at(ft, n)))) {
		Str__delete_n_characters(ft, n+1);
		WRITE("%S", ft);
	} else {
		if (P == NULL) {
			WRITE("%S", ft);
		} else {
			WRITE("..%c", FOLDER_SEPARATOR);
			Filenames__to_text_relative(OUT, F, Pathnames__up(P));
		}
	}
	DISCARD_TEXT(ft)
	DISCARD_TEXT(pt)
}

#line 115 "inweb/foundation-module/Chapter 3/Filenames.w"
pathname *Filenames__up(filename *F) {
	if (F == NULL) return NULL;
	return F->pathname_of_location;
}

#line 123 "inweb/foundation-module/Chapter 3/Filenames.w"
filename *Filenames__without_path(filename *F) {
	return Filenames__in(NULL, F->leafname);
}

text_stream *Filenames__get_leafname(filename *F) {
	if (F == NULL) return NULL;
	return F->leafname;
}

void Filenames__write_unextended_leafname(OUTPUT_STREAM, filename *F) {
	LOOP_THROUGH_TEXT(pos, F->leafname) {
		inchar32_t c = Str__get(pos);
		if (c == '.') return;
		PUT(c);
	}
}

#line 148 "inweb/foundation-module/Chapter 3/Filenames.w"
void Filenames__write_extension(OUTPUT_STREAM, filename *F) {
	int on = FALSE;
	LOOP_THROUGH_TEXT(pos, F->leafname) {
		inchar32_t c = Str__get(pos);
		if (c == '.') on = TRUE;
		if (on) PUT(c);
	}
}

filename *Filenames__set_extension(filename *F, text_stream *extension) {
	TEMPORARY_TEXT(NEWLEAF)
	LOOP_THROUGH_TEXT(pos, F->leafname) {
		inchar32_t c = Str__get(pos);
		if (c == '.') break;
		PUT_TO(NEWLEAF, c);
	}
	if (Str__len(extension) > 0) {
		if (Str__get_first_char(extension) != '.') WRITE_TO(NEWLEAF, ".");
		WRITE_TO(NEWLEAF, "%S", extension);
	}
	filename *N = Filenames__in(F->pathname_of_location, NEWLEAF);
	DISCARD_TEXT(NEWLEAF)
	return N;
}

#line 190 "inweb/foundation-module/Chapter 3/Filenames.w"
int Filenames__guess_format(filename *F) {
	TEMPORARY_TEXT(EXT)
	Filenames__write_extension(EXT, F);
	TEMPORARY_TEXT(NORMALISED)
	LOOP_THROUGH_TEXT(pos, EXT) {
		inchar32_t c = Str__get(pos);
		if (c != ' ') PUT_TO(NORMALISED, Characters__tolower(c));
	}
	DISCARD_TEXT(EXT)

	int verdict = FORMAT_UNRECOGNISED;
	if (Str__eq_wide_string(NORMALISED, U".html")) verdict = FORMAT_PERHAPS_HTML;
	else if (Str__eq_wide_string(NORMALISED, U".htm")) verdict = FORMAT_PERHAPS_HTML;
	else if (Str__eq_wide_string(NORMALISED, U".jpg")) verdict = FORMAT_PERHAPS_JPEG;
	else if (Str__eq_wide_string(NORMALISED, U".jpeg")) verdict = FORMAT_PERHAPS_JPEG;
	else if (Str__eq_wide_string(NORMALISED, U".png")) verdict = FORMAT_PERHAPS_PNG;
	else if (Str__eq_wide_string(NORMALISED, U".ogg")) verdict = FORMAT_PERHAPS_OGG;
	else if (Str__eq_wide_string(NORMALISED, U".aiff")) verdict = FORMAT_PERHAPS_AIFF;
	else if (Str__eq_wide_string(NORMALISED, U".aif")) verdict = FORMAT_PERHAPS_AIFF;
	else if (Str__eq_wide_string(NORMALISED, U".midi")) verdict = FORMAT_PERHAPS_MIDI;
	else if (Str__eq_wide_string(NORMALISED, U".mid")) verdict = FORMAT_PERHAPS_MIDI;
	else if (Str__eq_wide_string(NORMALISED, U".mod")) verdict = FORMAT_PERHAPS_MOD;
	else if (Str__eq_wide_string(NORMALISED, U".svg")) verdict = FORMAT_PERHAPS_SVG;
	else if (Str__eq_wide_string(NORMALISED, U".gif")) verdict = FORMAT_PERHAPS_GIF;
	else if (Str__len(NORMALISED) > 0) {
		if ((Str__get(Str__at(NORMALISED, 0)) == '.') &&
			(Str__get(Str__at(NORMALISED, 1)) == 'z') &&
			(Characters__isdigit(Str__get(Str__at(NORMALISED, 2)))) &&
			(Str__len(NORMALISED) == 3))
			verdict = FORMAT_PERHAPS_ZCODE;
		else if (Str__get(Str__back(Str__end(NORMALISED))) == 'x')
			verdict = FORMAT_PERHAPS_GLULX;
	}
	DISCARD_TEXT(NORMALISED)
	return verdict;
}

#line 234 "inweb/foundation-module/Chapter 3/Filenames.w"
FILE *Filenames__fopen(filename *F, char *usage) {
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(FN)
	WRITE_TO(FN, "%f", F);
	Str__copy_to_locale_string(transcoded_pathname, FN, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(FN)
	return fopen(transcoded_pathname, usage);
}

FILE *Filenames__fopen_caseless(filename *F, char *usage) {
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(FN)
	WRITE_TO(FN, "%f", F);
	Str__copy_to_locale_string(transcoded_pathname, FN, 4*MAX_FILENAME_LENGTH);
	DISCARD_TEXT(FN)
	return CIFilingSystem__fopen(transcoded_pathname, usage);
}

#line 258 "inweb/foundation-module/Chapter 3/Filenames.w"
int Filenames__eq(filename *F1, filename *F2) {
	if (F1 == F2) return TRUE;
	TEMPORARY_TEXT(T1)
	TEMPORARY_TEXT(T2)
	WRITE_TO(T1, "%f", F1);
	WRITE_TO(T2, "%f", F2);
	int rv = Str__eq(T1, T2);
	DISCARD_TEXT(T1)
	DISCARD_TEXT(T2)
	return rv;
}

#line 273 "inweb/foundation-module/Chapter 3/Filenames.w"
time_t Filenames__timestamp(filename *F) {
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(FN)
	WRITE_TO(FN, "%f", F);
	Str__copy_to_locale_string(transcoded_pathname, FN, 4*MAX_FILENAME_LENGTH);
	time_t t = Platform__timestamp(transcoded_pathname);
	DISCARD_TEXT(FN)
	return t;
}

int Filenames__size(filename *F) {
	char transcoded_pathname[4*MAX_FILENAME_LENGTH];
	TEMPORARY_TEXT(FN)
	WRITE_TO(FN, "%f", F);
	Str__copy_to_locale_string(transcoded_pathname, FN, 4*MAX_FILENAME_LENGTH);
	int t = (int) Platform__size(transcoded_pathname);
	DISCARD_TEXT(FN)
	return t;
}

#line 298 "inweb/foundation-module/Chapter 3/Filenames.w"
int Filenames__rename(filename *F, text_stream *new_name) {
	text_stream *old_name = Filenames__get_leafname(F);
	if (Str__eq(old_name, new_name)) return TRUE;
	filename *G = Filenames__in(Filenames__up(F), new_name);
	TEMPORARY_TEXT(old_path)
	TEMPORARY_TEXT(new_path)
	WRITE_TO(old_path, "%f", F);
	WRITE_TO(new_path, "%f", G);
	char old_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(old_name_written_out, old_path, 4*MAX_FILENAME_LENGTH);
	char new_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(new_name_written_out, new_path, 4*MAX_FILENAME_LENGTH);
	int rv = Platform__rename_file(old_name_written_out, new_name_written_out);
	if (rv) {
		Str__clear(F->leafname);
		Str__copy(F->leafname, new_name);
	}
	DISCARD_TEXT(old_path)
	DISCARD_TEXT(new_path)
	return rv;
}

#line 323 "inweb/foundation-module/Chapter 3/Filenames.w"
void Filenames__copy_file(filename *from, filename *to) {
	TEMPORARY_TEXT(from_path)
	TEMPORARY_TEXT(to_path)
	WRITE_TO(from_path, "%f", from);
	WRITE_TO(to_path, "%f", to);
	char from_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(from_name_written_out, from_path, 4*MAX_FILENAME_LENGTH);
	char to_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(to_name_written_out, to_path, 4*MAX_FILENAME_LENGTH);
	Platform__copy_file(from_name_written_out, to_name_written_out);
	DISCARD_TEXT(from_path)
	DISCARD_TEXT(to_path)
}

#line 340 "inweb/foundation-module/Chapter 3/Filenames.w"
int Filenames__move_file(filename *from, filename *to) {
	TEMPORARY_TEXT(from_path)
	TEMPORARY_TEXT(to_path)
	WRITE_TO(from_path, "%f", from);
	WRITE_TO(to_path, "%f", to);
	char from_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(from_name_written_out, from_path, 4*MAX_FILENAME_LENGTH);
	char to_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(to_name_written_out, to_path, 4*MAX_FILENAME_LENGTH);
	int rv = Platform__rename_file(from_name_written_out, to_name_written_out);
	DISCARD_TEXT(from_path)
	DISCARD_TEXT(to_path)
	return rv;
}

#ifdef PLATFORM_POSIX
#line 50 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
FILE *CIFilingSystem__fopen(const char *path, const char *mode) {
	char *topdirpath = NULL, *ciextdirpath = NULL, *cistring = NULL, *ciextname = NULL;
	char *workstring = NULL, *workstring2 = NULL;
	DIR *topdir = NULL, *extdir = NULL; FILE *handle;
	size_t length;

	/* for efficiency's sake, though it's logically equivalent, we try... */
	handle = fopen(path, mode); if (handle) 
{
#line 137 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 137 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return handle;

}
#line 57 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;

	
{
#line 159 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	length = 0;
	if (path) length = (size_t) strlen(path);
	if (length < 1) { errno = ENOENT; return NULL; }

}
#line 59 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	
{
#line 121 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	workstring = calloc(length+1, sizeof(char));
	if (workstring == NULL) { errno = ENOMEM; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 122 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; }
	workstring2 = calloc(length+1, sizeof(char));
	if (workstring2 == NULL) { errno = ENOMEM; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 124 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; }
	topdirpath = calloc(length+1, sizeof(char));
	if (topdirpath == NULL) { errno = ENOMEM; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 126 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; }
	ciextdirpath = calloc(length+1, sizeof(char));
	if (ciextdirpath == NULL) { errno = ENOMEM; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 128 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; }
	cistring = calloc(length+1, sizeof(char));
	if (cistring == NULL) { errno = ENOMEM; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 130 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; }
	ciextname = calloc(length+1, sizeof(char));
	if (ciextname == NULL) { errno = ENOMEM; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 132 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; }

}
#line 60 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	
{
#line 175 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	char *p;
	size_t extdirindex = 0, extindex = 0, namelen = 0, dirlen = 0;

	p = CIFilingSystem__strrchr(path);
	if (p) {
		extindex = (size_t) (p - path);
		namelen = length - extindex - 1;
		strncpy(ciextname, path + extindex + 1, namelen);
	}
	ciextname[namelen] = 0;

	if (extindex > 0) strncpy(workstring, path, extindex);
	workstring[extindex] = 0;
	p = CIFilingSystem__strrchr(workstring);
	if (p) {
		extdirindex = (size_t) (p - workstring);
		strncpy(topdirpath, path, extdirindex);
	}
	topdirpath[extdirindex] = 0;

	dirlen = extindex - extdirindex;
	if (dirlen > 0) dirlen -= 1;
	strncpy(ciextdirpath, path + extdirindex + 1, dirlen);
	ciextdirpath[dirlen] = 0;

}
#line 61 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;

	topdir = opendir(topdirpath); /* whose pathname is assumed case-correct... */
	if (topdir == NULL) 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 64 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
; /* ...so that failure is fatal; |errno| is set by |opendir| */

	sprintf(workstring, "%s%c%s", topdirpath, FOLDER_SEPARATOR, ciextdirpath);
	extdir = opendir(workstring); /* try with supplied extension directory name */
	if (extdir == NULL) 
{
#line 83 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	int rc = CIFilingSystem__match_in_directory(topdir, ciextdirpath, workstring);
	switch (rc) {
		case 0:
			errno = ENOENT; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 86 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
		case 1:
			sprintf(cistring, "%s%c%s", topdirpath, FOLDER_SEPARATOR, workstring);
			extdir = opendir(cistring);
			if (extdir == NULL) {
				errno = ENOENT; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 91 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
			}
			break;
		default:
			errno = EBADF; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 95 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	}

}
#line 68 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"

	else strcpy(cistring, workstring);

	sprintf(workstring, "%s%c%s", cistring, FOLDER_SEPARATOR, ciextname);
	handle = fopen(workstring, mode); /* try with supplied name */
	if (handle) 
{
#line 137 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 137 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return handle;

}
#line 73 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;

	
{
#line 102 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	int rc = CIFilingSystem__match_in_directory(extdir, ciextname, workstring);

	switch (rc) {
		case 0:
			errno = ENOENT; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 106 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
		case 1:
			sprintf(workstring2, "%s%c%s", cistring, FOLDER_SEPARATOR, workstring);
			workstring2[length] = 0;
			handle = fopen(workstring2, mode);
			if (handle) 
{
#line 137 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 137 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return handle;

}
#line 111 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
			errno = ENOENT; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 112 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
		default:
			errno = EBADF; 
{
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	
{
#line 147 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
	if (workstring) free(workstring);
	if (workstring2) free(workstring2);
	if (topdirpath) free(topdirpath);
	if (ciextdirpath) free(ciextdirpath);
	if (cistring) free(cistring);
	if (ciextname) free(ciextname);
	if (topdir) closedir(topdir);
	if (extdir) closedir(extdir);

}
#line 143 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	return NULL;

}
#line 114 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
	}

}
#line 75 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
;
}

#endif /* PLATFORM_POSIX */
#line 205 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
char *CIFilingSystem__strrchr(const char *p) {
	const char *q = NULL;
	while (*p) {
		if (Platform__is_folder_separator((inchar32_t) (*p))) q = p;
		p++;
	}
	return (char *) q;
}

#line 225 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
int CIFilingSystem__match_in_directory(void *vd,
	char *name, char *last_match) {
	DIR *d = (DIR *) vd;
	struct dirent *dirp;
	int rc = 0;

	last_match[0] = 0;
	while ((dirp = readdir(d)) != NULL) {
		if (strcasecmp(name, dirp->d_name) == 0) {
			rc++;
			strcpy(last_match, dirp->d_name);
		}
	}
	return rc;
}

#ifndef PLATFORM_POSIX
#line 245 "inweb/foundation-module/Chapter 3/Case-Insensitive Filenames.w"
FILE *CIFilingSystem__fopen(const char *path, const char *mode) {
	return fopen(path, mode);
}

#endif /* PLATFORM_POSIX */
#line 14 "inweb/foundation-module/Chapter 3/Shell.w"
void Shell__quote_path(OUTPUT_STREAM, pathname *P) {
	TEMPORARY_TEXT(FN)
	WRITE_TO(FN, "%p", P);
	Shell__quote_text(OUT, FN);
	DISCARD_TEXT(FN)
}

void Shell__quote_file(OUTPUT_STREAM, filename *F) {
	TEMPORARY_TEXT(FN)
	WRITE_TO(FN, "%f", F);
	Shell__quote_text(OUT, FN);
	DISCARD_TEXT(FN)
}

void Shell__plain(OUTPUT_STREAM, char *raw) {
	WRITE("%s", raw);
}

void Shell__plain_text(OUTPUT_STREAM, text_stream *raw) {
	WRITE("%S", raw);
}

void Shell__quote_text(OUTPUT_STREAM, text_stream *raw) {
	PUT(SHELL_QUOTE_CHARACTER);
	LOOP_THROUGH_TEXT(pos, raw) {
		inchar32_t c = Str__get(pos);
		if (c == SHELL_QUOTE_CHARACTER) PUT('\\');
		PUT(c);
	}
	PUT(SHELL_QUOTE_CHARACTER);
	PUT(' ');
}

#line 50 "inweb/foundation-module/Chapter 3/Shell.w"
void Shell__apply(char *command, filename *F) {
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, command);
	Shell__plain(COMMAND, " ");
	Shell__quote_file(COMMAND, F);
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)
}
void Shell__apply_S(text_stream *command, filename *F) {
	TEMPORARY_TEXT(COMMAND)
	Shell__plain_text(COMMAND, command);
	Shell__plain(COMMAND, " ");
	Shell__quote_file(COMMAND, F);
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)
}

#line 70 "inweb/foundation-module/Chapter 3/Shell.w"
void Shell__rm(filename *F) {
	Shell__apply("rm", F);
}

void Shell__copy(filename *F, pathname *T, char *options) {
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, "cp ");
	Shell__plain(COMMAND, options);
	Shell__plain(COMMAND, " ");
	Shell__quote_file(COMMAND, F);
	Shell__quote_path(COMMAND, T);
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)
}

#line 89 "inweb/foundation-module/Chapter 3/Shell.w"
void Shell__redirect(OUTPUT_STREAM, filename *F) {
	Shell__plain(OUT, ">");
	Shell__quote_file(OUT, F);
	Shell__plain(OUT, "2>&1");
}

#line 105 "inweb/foundation-module/Chapter 3/Shell.w"
int shell_verbosity = FALSE;
void Shell__verbose(void) {
	shell_verbosity = TRUE;
}

int Shell__run(OUTPUT_STREAM) {
	if (shell_verbosity) PRINT("shell: %S\n", OUT);
	LOGIF(SHELL_USAGE, "shell: %S\n", OUT);
	char spool[SPOOL_LENGTH];
	Streams__write_as_locale_string(spool, OUT, SPOOL_LENGTH);
	if (debugger_mode) {
		WRITE_TO(STDOUT, "debugger mode suppressing shell command: %S\n", OUT);
		return 0;
	}
	int rv = Platform__system(spool);
	if (rv == -1) {
		WRITE_TO(STDERR, "shell: %S\n", OUT);
		internal_error("OS shell error");
	}
	if (rv == 127) {
		WRITE_TO(STDERR, "shell: %S\n", OUT);
		internal_error("Execution of the shell failed");
	}
	return rv;
}

#line 13 "inweb/foundation-module/Chapter 3/Directories.w"

#line 19 "inweb/foundation-module/Chapter 3/Directories.w"
scan_directory *Directories__open_from(text_stream *name) {
	scan_directory *D = CREATE(scan_directory);
	Str__copy_to_locale_string(D->directory_name_written_out, name, 4*MAX_FILENAME_LENGTH);
	D->directory_handle = Platform__opendir(D->directory_name_written_out);
	if (D->directory_handle == NULL) return NULL;
	return D;
}

scan_directory *Directories__open(pathname *P) {
	TEMPORARY_TEXT(pn)
	WRITE_TO(pn, "%p", P);
	scan_directory *D = Directories__open_from(pn);
	DISCARD_TEXT(pn)
	return D;
}

int Directories__next(scan_directory *D, text_stream *leafname) {
	char leafname_Cs[MAX_FILENAME_LENGTH];
	int rv = TRUE;
	while (rv) {
		rv = Platform__readdir(D->directory_handle, D->directory_name_written_out, leafname_Cs);
		if (leafname_Cs[0] != '.') break;
	}
	Str__clear(leafname);
	if (rv) Streams__write_locale_string(leafname, leafname_Cs);
	return rv;
}

void Directories__close(scan_directory *D) {
	Platform__closedir(D->directory_handle);
}

#line 55 "inweb/foundation-module/Chapter 3/Directories.w"
int Directories__exists(pathname *P) {
	scan_directory *TRY = Directories__open(P);
	if (TRY == NULL) return FALSE;
	Directories__close(TRY);
	return TRUE;
}

#line 74 "inweb/foundation-module/Chapter 3/Directories.w"
linked_list *Directories__listing(pathname *P) {
	int capacity = 4, used = 0;
	text_stream **listing_array = (text_stream **)
		(Memory__calloc(capacity, sizeof(text_stream *), ARRAY_SORTING_MREASON));
	scan_directory *D = Directories__open(P);
	if (D) {
		text_stream *entry = Str__new();
		while (Directories__next(D, entry)) {
			if (used == capacity) {
				int new_capacity = 4*capacity;
				text_stream **new_listing_array = (text_stream **)
					(Memory__calloc(new_capacity, sizeof(text_stream *), ARRAY_SORTING_MREASON));
				for (int i=0; i<used; i++) new_listing_array[i] = listing_array[i];
				listing_array = new_listing_array;
				capacity = new_capacity;
			}
			listing_array[used++] = entry;
			entry = Str__new();
		}
		Directories__close(D);
	}
	qsort(listing_array, (size_t) used, sizeof(text_stream *), Directories__compare_names);
	linked_list *L = NEW_LINKED_LIST(text_stream);
	for (int i=0; i<used; i++) ADD_TO_LINKED_LIST(listing_array[i], text_stream, L);
	Memory__I7_free(listing_array, ARRAY_SORTING_MREASON, capacity*((int) sizeof(text_stream *)));
	return L;
}

int Directories__compare_names(const void *ent1, const void *ent2) {
	text_stream *tx1 = *((text_stream **) ent1);
	text_stream *tx2 = *((text_stream **) ent2);
	return Str__cmp_insensitive(tx1, tx2);
}

#line 114 "inweb/foundation-module/Chapter 3/Directories.w"
int Directories__rename(pathname *P, text_stream *new_name) {
	text_stream *old_name = Pathnames__directory_name(P);
	if (Str__eq(old_name, new_name)) return TRUE;
	pathname *Q = Pathnames__down(Pathnames__up(P), new_name);
	TEMPORARY_TEXT(old_path)
	TEMPORARY_TEXT(new_path)
	WRITE_TO(old_path, "%p", P);
	WRITE_TO(new_path, "%p", Q);
	char old_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(old_name_written_out, old_path, 4*MAX_FILENAME_LENGTH);
	char new_name_written_out[4*MAX_FILENAME_LENGTH];
	Str__copy_to_locale_string(new_name_written_out, new_path, 4*MAX_FILENAME_LENGTH);
	int rv = Platform__rename_directory(old_name_written_out, new_name_written_out);
	if (rv) {
		Str__clear(P->intermediate);
		Str__copy(P->intermediate, new_name);
	}
	DISCARD_TEXT(old_path)
	DISCARD_TEXT(new_path)
	return rv;
}

#line 9 "inweb/foundation-module/Chapter 3/Time.w"
time_t right_now;
struct tm *the_present = NULL;
int fix_time_mode = FALSE;

void Time__begin(void) {
	time_t right_now = time(NULL);
	the_present = localtime(&right_now);
	fix_time_mode = FALSE;
}

#line 26 "inweb/foundation-module/Chapter 3/Time.w"
void Time__fix(void) {
	struct tm start;
	start.tm_sec = 0; start.tm_min = 0; start.tm_hour = 11;
	start.tm_mday = 28; start.tm_mon = 3; start.tm_year = 116; start.tm_isdst = -1;
	time_t pretend_time = mktime(&start);
	the_present = localtime(&pretend_time);
	fix_time_mode = TRUE;
}

int Time__fixed(void) {
	return fix_time_mode;
}

#line 79 "inweb/foundation-module/Chapter 3/Time.w"
void Time__easter(int year, int *d, int *m) {
	int c, y, k, i, n, j, l;
	y = year;
	c = y/100;
	n = y-19*(y/19);
	k = (c-17)/25;
	i = c-c/4-(c-k)/3+19*n+15;
	i = i-30*(i/30);
	i = i-(i/28)*(1-(i/28)*(29/(i+1))*((21-n)/11));
	j = y+y/4+i+2-c+c/4;
	j = j-7*(j/7);
	l = i-j;
	*m = 3+(l+40)/44;
	*d = l+28-31*(*m/4);
}

#line 102 "inweb/foundation-module/Chapter 3/Time.w"
int Time__feast(void) {
	int this_month = the_present->tm_mon + 1;
	int this_day = the_present->tm_mday;
	int this_year = the_present->tm_year + 1900;

	int m, d;
	Time__easter(this_year, &m, &d);

	if ((this_month == m) && (this_day >= d-2) && (this_day <= d+1))
		return EASTER_FEAST; /* that is, Good Friday to Easter Monday */
	if ((this_year == 2018) && (this_month == 3) && (this_day >= 30))
		return EASTER_FEAST; /* Easter Sunday falls on 1 April in 2018 */

	if ((this_month == 12) && (this_day >= 25))
		return CHRISTMAS_FEAST; /* that is, Christmas Day to New Year's Eve */

	return NON_FEAST;
}

#line 139 "inweb/foundation-module/Chapter 3/Time.w"

#line 145 "inweb/foundation-module/Chapter 3/Time.w"
stopwatch_timer *Time__start_stopwatch(stopwatch_timer *within, text_stream *name) {
	stopwatch_timer *st = CREATE(stopwatch_timer);
	st->event = Str__duplicate(name);
	st->start_time = clock();
	st->end_time = st->start_time;
	st->time_taken = 0;
	st->stages_chronological = NEW_LINKED_LIST(stopwatch_timer);
	st->stages_sorted = NULL;
	st->running = TRUE;
	if (within) {
		if (within->running == FALSE)
			internal_error("stopwatch started in event not under way");
		ADD_TO_LINKED_LIST(st, stopwatch_timer, within->stages_chronological);
	}
	return st;
}

#line 166 "inweb/foundation-module/Chapter 3/Time.w"
int Time__stop_stopwatch(stopwatch_timer *st) {
	if (st->running == FALSE) internal_error("already stopped");
	st->running = FALSE;
	st->end_time = clock();
	st->time_taken +=
		(((int) (st->end_time)) - ((int) (st->start_time))) / ((int) (CLOCKS_PER_SEC/100));
	int N = LinkedLists__len(st->stages_chronological);
	if (N > 0) 
{
#line 178 "inweb/foundation-module/Chapter 3/Time.w"
	st->stages_sorted = NEW_LINKED_LIST(stopwatch_timer);
	stopwatch_timer **as_array = (stopwatch_timer **)
		(Memory__calloc(N, sizeof(stopwatch_timer *), ARRAY_SORTING_MREASON));
	stopwatch_timer *sst; int i = 0;
	LOOP_OVER_LINKED_LIST(sst, stopwatch_timer, st->stages_chronological)
		as_array[i++] = sst;
	qsort(as_array, (size_t) N, sizeof(stopwatch_timer *), Time__compare_watches);
	for (i=0; i<N; i++)
		ADD_TO_LINKED_LIST(as_array[i], stopwatch_timer, st->stages_sorted);
	Memory__I7_array_free(as_array,
		ARRAY_SORTING_MREASON, N, sizeof(stopwatch_timer *));

}
#line 173 "inweb/foundation-module/Chapter 3/Time.w"
;
	return st->time_taken;
}

#line 193 "inweb/foundation-module/Chapter 3/Time.w"
int Time__compare_watches(const void *w1, const void *w2) {
	const stopwatch_timer **st1 = (const stopwatch_timer **) w1;
	const stopwatch_timer **st2 = (const stopwatch_timer **) w2;
	if ((*st1 == NULL) || (*st2 == NULL))
		internal_error("Disaster while sorting stopwatch timings");
	int t1 = (*st1)->time_taken, t2 = (*st2)->time_taken;
	if (t1 > t2) return -1;
	if (t1 < t2) return 1;
	return Str__cmp((*st1)->event, (*st2)->event);
}

#line 208 "inweb/foundation-module/Chapter 3/Time.w"
void Time__resume_stopwatch(stopwatch_timer *st) {
	if (st->running) internal_error("already running");
	st->running = TRUE;
	st->start_time = clock();
	st->end_time = st->start_time;
}

#line 220 "inweb/foundation-module/Chapter 3/Time.w"
void Time__log_timing(stopwatch_timer *st, int total) {
	if (st) {
		int N = 1000*st->time_taken/total;
		if (N > 0) {
			LOG("%3d.%d%% in %S\n", N/10, N%10, st->event);
			LOG_INDENT;
			int T = 0, no_details = 0;
			if (st->stages_sorted) {
				stopwatch_timer *sst;
				LOOP_OVER_LINKED_LIST(sst, stopwatch_timer, st->stages_sorted) {
					no_details++;
					T += sst->time_taken;
					Time__log_timing(sst, total);
				}
			}
			if (no_details > 0) {
				int M = N - 1000*T/total;
				if (M > 0) LOG("%3d.%d%% not specifically accounted for\n", M/10, M%10);
			}
			LOG_OUTDENT;
		}
	}
}

#line 8 "inweb/foundation-module/Chapter 4/Characters.w"
inchar32_t Characters__tolower(inchar32_t c) {
	return (inchar32_t) tolower((int) c);
}
inchar32_t Characters__toupper(inchar32_t c) {
	return (inchar32_t) toupper((int) c);
}
int Characters__isalpha(inchar32_t c) {
	return isalpha((int) c);
}
int Characters__isdigit(inchar32_t c) {
	return isdigit((int) c);
}
int Characters__isupper(inchar32_t c) {
	return isupper((int) c);
}
int Characters__islower(inchar32_t c) {
	return islower((int) c);
}
int Characters__isalnum(inchar32_t c) {
	return isalnum((int) c);
}
int Characters__iscntrl(inchar32_t c) {
	return (c < 32);
}
int Characters__vowel(inchar32_t c) {
	if ((c == 'a') || (c == 'e') || (c == 'i') || (c == 'o') || (c == 'u')) return TRUE;
	return FALSE;
}

#line 40 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__is_space_or_tab(inchar32_t c) {
	if ((c == ' ') || (c == '\t')) return TRUE;
	return FALSE;
}
int Characters__is_whitespace(inchar32_t c) {
	if ((c == ' ') || (c == '\t') || (c == '\n')) return TRUE;
	return FALSE;
}

#line 54 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__is_babel_whitespace(inchar32_t c) {
	if ((c == ' ') || (c == '\t') || (c == '\x0a')
		|| (c == '\x0d') || (c == NEWLINE_IN_STRING)) return TRUE;
	return FALSE;
}

#line 64 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__is_Unicode_whitespace(inchar32_t c) {
	if (c == 0x0009) return TRUE;
	if (c == 0x000A) return TRUE;
	if (c == 0x000C) return TRUE;
	if (c == 0x000D) return TRUE;
	if (c == 0x0020) return TRUE;
	if (c == 0x00A0) return TRUE; // NO-BREAK SPACE
	if (c == 0x1680) return TRUE; // OGHAM SPACE MARK
	if (c == 0x2000) return TRUE; // EN QUAD
	if (c == 0x2001) return TRUE; // EM QUAD
	if (c == 0x2002) return TRUE; // EN SPACE
	if (c == 0x2003) return TRUE; // EM SPACE
	if (c == 0x2004) return TRUE; // THREE-PER-EM SPACE
	if (c == 0x2005) return TRUE; // FOUR-PER-EM SPACE
	if (c == 0x2006) return TRUE; // SIX-PER-EM SPACE
	if (c == 0x2007) return TRUE; // FIGURE SPACE
	if (c == 0x2008) return TRUE; // PUNCTUATION SPACE
	if (c == 0x2009) return TRUE; // THIN SPACE
	if (c == 0x200A) return TRUE; // HAIR SPACE
	if (c == 0x202F) return TRUE; // NARROW NO-BREAK SPACE
	if (c == 0x205F) return TRUE; // MEDIUM MATHEMATICAL SPACE
	if (c == 0x3000) return TRUE; // IDEOGRAPHIC SPACE
	return FALSE;
}

#line 93 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__is_ASCII_punctuation(inchar32_t c) {
	if ((c >= 0x0021) && (c <= 0x002F)) return TRUE;
	if ((c >= 0x003A) && (c <= 0x0040)) return TRUE;
	if ((c >= 0x005B) && (c <= 0x0060)) return TRUE;
	if ((c >= 0x007B) && (c <= 0x007E)) return TRUE;
	return FALSE;
}

#line 106 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__is_Unicode_punctuation(inchar32_t c) {
	if (c < 0x80) return Characters__is_ASCII_punctuation(c);
	if (c == 0x00A1) return TRUE; // INVERTED EXCLAMATION MARK
	if (c == 0x00A7) return TRUE; // SECTION SIGN
	if (c == 0x00AB) return TRUE; // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
	if (c == 0x00B6) return TRUE; // PILCROW SIGN
	if (c == 0x00B7) return TRUE; // MIDDLE DOT
	if (c == 0x00BB) return TRUE; // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	if (c == 0x00BF) return TRUE; // INVERTED QUESTION MARK
	if (c < 0x0100) return FALSE;
	if (c == 0x037E) return TRUE; // GREEK QUESTION MARK
	if (c == 0x0387) return TRUE; // GREEK ANO TELEIA
	if (c == 0x055A) return TRUE; // ARMENIAN APOSTROPHE
	if (c == 0x055B) return TRUE; // ARMENIAN EMPHASIS MARK
	if (c == 0x055C) return TRUE; // ARMENIAN EXCLAMATION MARK
	if (c == 0x055D) return TRUE; // ARMENIAN COMMA
	if (c == 0x055E) return TRUE; // ARMENIAN QUESTION MARK
	if (c == 0x055F) return TRUE; // ARMENIAN ABBREVIATION MARK
	if (c == 0x0589) return TRUE; // ARMENIAN FULL STOP
	if (c == 0x058A) return TRUE; // ARMENIAN HYPHEN
	if (c == 0x05BE) return TRUE; // HEBREW PUNCTUATION MAQAF
	if (c == 0x05C0) return TRUE; // HEBREW PUNCTUATION PASEQ
	if (c == 0x05C3) return TRUE; // HEBREW PUNCTUATION SOF PASUQ
	if (c == 0x05C6) return TRUE; // HEBREW PUNCTUATION NUN HAFUKHA
	if (c == 0x05F3) return TRUE; // HEBREW PUNCTUATION GERESH
	if (c == 0x05F4) return TRUE; // HEBREW PUNCTUATION GERSHAYIM
	if (c == 0x0609) return TRUE; // ARABIC-INDIC PER MILLE SIGN
	if (c == 0x060A) return TRUE; // ARABIC-INDIC PER TEN THOUSAND SIGN
	if (c == 0x060C) return TRUE; // ARABIC COMMA
	if (c == 0x060D) return TRUE; // ARABIC DATE SEPARATOR
	if (c == 0x061B) return TRUE; // ARABIC SEMICOLON
	if (c == 0x061D) return TRUE; // ARABIC END OF TEXT MARK
	if (c == 0x061E) return TRUE; // ARABIC TRIPLE DOT PUNCTUATION MARK
	if (c == 0x061F) return TRUE; // ARABIC QUESTION MARK
	if (c == 0x066A) return TRUE; // ARABIC PERCENT SIGN
	if (c == 0x066B) return TRUE; // ARABIC DECIMAL SEPARATOR
	if (c == 0x066C) return TRUE; // ARABIC THOUSANDS SEPARATOR
	if (c == 0x066D) return TRUE; // ARABIC FIVE POINTED STAR
	if (c == 0x06D4) return TRUE; // ARABIC FULL STOP
	if (c == 0x0700) return TRUE; // SYRIAC END OF PARAGRAPH
	if (c == 0x0701) return TRUE; // SYRIAC SUPRALINEAR FULL STOP
	if (c == 0x0702) return TRUE; // SYRIAC SUBLINEAR FULL STOP
	if (c == 0x0703) return TRUE; // SYRIAC SUPRALINEAR COLON
	if (c == 0x0704) return TRUE; // SYRIAC SUBLINEAR COLON
	if (c == 0x0705) return TRUE; // SYRIAC HORIZONTAL COLON
	if (c == 0x0706) return TRUE; // SYRIAC COLON SKEWED LEFT
	if (c == 0x0707) return TRUE; // SYRIAC COLON SKEWED RIGHT
	if (c == 0x0708) return TRUE; // SYRIAC SUPRALINEAR COLON SKEWED LEFT
	if (c == 0x0709) return TRUE; // SYRIAC SUBLINEAR COLON SKEWED RIGHT
	if (c == 0x070A) return TRUE; // SYRIAC CONTRACTION
	if (c == 0x070B) return TRUE; // SYRIAC HARKLEAN OBELUS
	if (c == 0x070C) return TRUE; // SYRIAC HARKLEAN METOBELUS
	if (c == 0x070D) return TRUE; // SYRIAC HARKLEAN ASTERISCUS
	if (c == 0x07F7) return TRUE; // NKO SYMBOL GBAKURUNEN
	if (c == 0x07F8) return TRUE; // NKO COMMA
	if (c == 0x07F9) return TRUE; // NKO EXCLAMATION MARK
	if (c == 0x0830) return TRUE; // SAMARITAN PUNCTUATION NEQUDAA
	if (c == 0x0831) return TRUE; // SAMARITAN PUNCTUATION AFSAAQ
	if (c == 0x0832) return TRUE; // SAMARITAN PUNCTUATION ANGED
	if (c == 0x0833) return TRUE; // SAMARITAN PUNCTUATION BAU
	if (c == 0x0834) return TRUE; // SAMARITAN PUNCTUATION ATMAAU
	if (c == 0x0835) return TRUE; // SAMARITAN PUNCTUATION SHIYYAALAA
	if (c == 0x0836) return TRUE; // SAMARITAN ABBREVIATION MARK
	if (c == 0x0837) return TRUE; // SAMARITAN PUNCTUATION MELODIC QITSA
	if (c == 0x0838) return TRUE; // SAMARITAN PUNCTUATION ZIQAA
	if (c == 0x0839) return TRUE; // SAMARITAN PUNCTUATION QITSA
	if (c == 0x083A) return TRUE; // SAMARITAN PUNCTUATION ZAEF
	if (c == 0x083B) return TRUE; // SAMARITAN PUNCTUATION TURU
	if (c == 0x083C) return TRUE; // SAMARITAN PUNCTUATION ARKAANU
	if (c == 0x083D) return TRUE; // SAMARITAN PUNCTUATION SOF MASHFAAT
	if (c == 0x083E) return TRUE; // SAMARITAN PUNCTUATION ANNAAU
	if (c == 0x085E) return TRUE; // MANDAIC PUNCTUATION
	if (c == 0x0964) return TRUE; // DEVANAGARI DANDA
	if (c == 0x0965) return TRUE; // DEVANAGARI DOUBLE DANDA
	if (c == 0x0970) return TRUE; // DEVANAGARI ABBREVIATION SIGN
	if (c == 0x09FD) return TRUE; // BENGALI ABBREVIATION SIGN
	if (c == 0x0A76) return TRUE; // GURMUKHI ABBREVIATION SIGN
	if (c == 0x0AF0) return TRUE; // GUJARATI ABBREVIATION SIGN
	if (c == 0x0C77) return TRUE; // TELUGU SIGN SIDDHAM
	if (c == 0x0C84) return TRUE; // KANNADA SIGN SIDDHAM
	if (c == 0x0DF4) return TRUE; // SINHALA PUNCTUATION KUNDDALIYA
	if (c == 0x0E4F) return TRUE; // THAI CHARACTER FONGMAN
	if (c == 0x0E5A) return TRUE; // THAI CHARACTER ANGKHANKHU
	if (c == 0x0E5B) return TRUE; // THAI CHARACTER KHOMUT
	if (c == 0x0F04) return TRUE; // TIBETAN MARK INITIAL YIG MGO MDUN MA
	if (c == 0x0F05) return TRUE; // TIBETAN MARK CLOSING YIG MGO SGAB MA
	if (c == 0x0F06) return TRUE; // TIBETAN MARK CARET YIG MGO PHUR SHAD MA
	if (c == 0x0F07) return TRUE; // TIBETAN MARK YIG MGO TSHEG SHAD MA
	if (c == 0x0F08) return TRUE; // TIBETAN MARK SBRUL SHAD
	if (c == 0x0F09) return TRUE; // TIBETAN MARK BSKUR YIG MGO
	if (c == 0x0F0A) return TRUE; // TIBETAN MARK BKA- SHOG YIG MGO
	if (c == 0x0F0B) return TRUE; // TIBETAN MARK INTERSYLLABIC TSHEG
	if (c == 0x0F0C) return TRUE; // TIBETAN MARK DELIMITER TSHEG BSTAR
	if (c == 0x0F0D) return TRUE; // TIBETAN MARK SHAD
	if (c == 0x0F0E) return TRUE; // TIBETAN MARK NYIS SHAD
	if (c == 0x0F0F) return TRUE; // TIBETAN MARK TSHEG SHAD
	if (c == 0x0F10) return TRUE; // TIBETAN MARK NYIS TSHEG SHAD
	if (c == 0x0F11) return TRUE; // TIBETAN MARK RIN CHEN SPUNGS SHAD
	if (c == 0x0F12) return TRUE; // TIBETAN MARK RGYA GRAM SHAD
	if (c == 0x0F14) return TRUE; // TIBETAN MARK GTER TSHEG
	if (c == 0x0F3A) return TRUE; // TIBETAN MARK GUG RTAGS GYON
	if (c == 0x0F3B) return TRUE; // TIBETAN MARK GUG RTAGS GYAS
	if (c == 0x0F3C) return TRUE; // TIBETAN MARK ANG KHANG GYON
	if (c == 0x0F3D) return TRUE; // TIBETAN MARK ANG KHANG GYAS
	if (c == 0x0F85) return TRUE; // TIBETAN MARK PALUTA
	if (c == 0x0FD0) return TRUE; // TIBETAN MARK BSKA- SHOG GI MGO RGYAN
	if (c == 0x0FD1) return TRUE; // TIBETAN MARK MNYAM YIG GI MGO RGYAN
	if (c == 0x0FD2) return TRUE; // TIBETAN MARK NYIS TSHEG
	if (c == 0x0FD3) return TRUE; // TIBETAN MARK INITIAL BRDA RNYING YIG MGO MDUN MA
	if (c == 0x0FD4) return TRUE; // TIBETAN MARK CLOSING BRDA RNYING YIG MGO SGAB MA
	if (c == 0x0FD9) return TRUE; // TIBETAN MARK LEADING MCHAN RTAGS
	if (c == 0x0FDA) return TRUE; // TIBETAN MARK TRAILING MCHAN RTAGS
	if (c < 0x01000) return FALSE;
	if (c == 0x104A) return TRUE; // MYANMAR SIGN LITTLE SECTION
	if (c == 0x104B) return TRUE; // MYANMAR SIGN SECTION
	if (c == 0x104C) return TRUE; // MYANMAR SYMBOL LOCATIVE
	if (c == 0x104D) return TRUE; // MYANMAR SYMBOL COMPLETED
	if (c == 0x104E) return TRUE; // MYANMAR SYMBOL AFOREMENTIONED
	if (c == 0x104F) return TRUE; // MYANMAR SYMBOL GENITIVE
	if (c == 0x10FB) return TRUE; // GEORGIAN PARAGRAPH SEPARATOR
	if (c == 0x1360) return TRUE; // ETHIOPIC SECTION MARK
	if (c == 0x1361) return TRUE; // ETHIOPIC WORDSPACE
	if (c == 0x1362) return TRUE; // ETHIOPIC FULL STOP
	if (c == 0x1363) return TRUE; // ETHIOPIC COMMA
	if (c == 0x1364) return TRUE; // ETHIOPIC SEMICOLON
	if (c == 0x1365) return TRUE; // ETHIOPIC COLON
	if (c == 0x1366) return TRUE; // ETHIOPIC PREFACE COLON
	if (c == 0x1367) return TRUE; // ETHIOPIC QUESTION MARK
	if (c == 0x1368) return TRUE; // ETHIOPIC PARAGRAPH SEPARATOR
	if (c == 0x1400) return TRUE; // CANADIAN SYLLABICS HYPHEN
	if (c == 0x166E) return TRUE; // CANADIAN SYLLABICS FULL STOP
	if (c == 0x169B) return TRUE; // OGHAM FEATHER MARK
	if (c == 0x169C) return TRUE; // OGHAM REVERSED FEATHER MARK
	if (c == 0x16EB) return TRUE; // RUNIC SINGLE PUNCTUATION
	if (c == 0x16EC) return TRUE; // RUNIC MULTIPLE PUNCTUATION
	if (c == 0x16ED) return TRUE; // RUNIC CROSS PUNCTUATION
	if (c == 0x1735) return TRUE; // PHILIPPINE SINGLE PUNCTUATION
	if (c == 0x1736) return TRUE; // PHILIPPINE DOUBLE PUNCTUATION
	if (c == 0x17D4) return TRUE; // KHMER SIGN KHAN
	if (c == 0x17D5) return TRUE; // KHMER SIGN BARIYOOSAN
	if (c == 0x17D6) return TRUE; // KHMER SIGN CAMNUC PII KUUH
	if (c == 0x17D8) return TRUE; // KHMER SIGN BEYYAL
	if (c == 0x17D9) return TRUE; // KHMER SIGN PHNAEK MUAN
	if (c == 0x17DA) return TRUE; // KHMER SIGN KOOMUUT
	if (c == 0x1800) return TRUE; // MONGOLIAN BIRGA
	if (c == 0x1801) return TRUE; // MONGOLIAN ELLIPSIS
	if (c == 0x1802) return TRUE; // MONGOLIAN COMMA
	if (c == 0x1803) return TRUE; // MONGOLIAN FULL STOP
	if (c == 0x1804) return TRUE; // MONGOLIAN COLON
	if (c == 0x1805) return TRUE; // MONGOLIAN FOUR DOTS
	if (c == 0x1806) return TRUE; // MONGOLIAN TODO SOFT HYPHEN
	if (c == 0x1807) return TRUE; // MONGOLIAN SIBE SYLLABLE BOUNDARY MARKER
	if (c == 0x1808) return TRUE; // MONGOLIAN MANCHU COMMA
	if (c == 0x1809) return TRUE; // MONGOLIAN MANCHU FULL STOP
	if (c == 0x180A) return TRUE; // MONGOLIAN NIRUGU
	if (c == 0x1944) return TRUE; // LIMBU EXCLAMATION MARK
	if (c == 0x1945) return TRUE; // LIMBU QUESTION MARK
	if (c == 0x1A1E) return TRUE; // BUGINESE PALLAWA
	if (c == 0x1A1F) return TRUE; // BUGINESE END OF SECTION
	if (c == 0x1AA0) return TRUE; // TAI THAM SIGN WIANG
	if (c == 0x1AA1) return TRUE; // TAI THAM SIGN WIANGWAAK
	if (c == 0x1AA2) return TRUE; // TAI THAM SIGN SAWAN
	if (c == 0x1AA3) return TRUE; // TAI THAM SIGN KEOW
	if (c == 0x1AA4) return TRUE; // TAI THAM SIGN HOY
	if (c == 0x1AA5) return TRUE; // TAI THAM SIGN DOKMAI
	if (c == 0x1AA6) return TRUE; // TAI THAM SIGN REVERSED ROTATED RANA
	if (c == 0x1AA8) return TRUE; // TAI THAM SIGN KAAN
	if (c == 0x1AA9) return TRUE; // TAI THAM SIGN KAANKUU
	if (c == 0x1AAA) return TRUE; // TAI THAM SIGN SATKAAN
	if (c == 0x1AAB) return TRUE; // TAI THAM SIGN SATKAANKUU
	if (c == 0x1AAC) return TRUE; // TAI THAM SIGN HANG
	if (c == 0x1AAD) return TRUE; // TAI THAM SIGN CAANG
	if (c == 0x1B5A) return TRUE; // BALINESE PANTI
	if (c == 0x1B5B) return TRUE; // BALINESE PAMADA
	if (c == 0x1B5C) return TRUE; // BALINESE WINDU
	if (c == 0x1B5D) return TRUE; // BALINESE CARIK PAMUNGKAH
	if (c == 0x1B5E) return TRUE; // BALINESE CARIK SIKI
	if (c == 0x1B5F) return TRUE; // BALINESE CARIK PAREREN
	if (c == 0x1B60) return TRUE; // BALINESE PAMENENG
	if (c == 0x1B7D) return TRUE; // BALINESE PANTI LANTANG
	if (c == 0x1B7E) return TRUE; // BALINESE PAMADA LANTANG
	if (c == 0x1BFC) return TRUE; // BATAK SYMBOL BINDU NA METEK
	if (c == 0x1BFD) return TRUE; // BATAK SYMBOL BINDU PINARBORAS
	if (c == 0x1BFE) return TRUE; // BATAK SYMBOL BINDU JUDUL
	if (c == 0x1BFF) return TRUE; // BATAK SYMBOL BINDU PANGOLAT
	if (c == 0x1C3B) return TRUE; // LEPCHA PUNCTUATION TA-ROL
	if (c == 0x1C3C) return TRUE; // LEPCHA PUNCTUATION NYET THYOOM TA-ROL
	if (c == 0x1C3D) return TRUE; // LEPCHA PUNCTUATION CER-WA
	if (c == 0x1C3E) return TRUE; // LEPCHA PUNCTUATION TSHOOK CER-WA
	if (c == 0x1C3F) return TRUE; // LEPCHA PUNCTUATION TSHOOK
	if (c == 0x1C7E) return TRUE; // OL CHIKI PUNCTUATION MUCAAD
	if (c == 0x1C7F) return TRUE; // OL CHIKI PUNCTUATION DOUBLE MUCAAD
	if (c == 0x1CC0) return TRUE; // SUNDANESE PUNCTUATION BINDU SURYA
	if (c == 0x1CC1) return TRUE; // SUNDANESE PUNCTUATION BINDU PANGLONG
	if (c == 0x1CC2) return TRUE; // SUNDANESE PUNCTUATION BINDU PURNAMA
	if (c == 0x1CC3) return TRUE; // SUNDANESE PUNCTUATION BINDU CAKRA
	if (c == 0x1CC4) return TRUE; // SUNDANESE PUNCTUATION BINDU LEU SATANGA
	if (c == 0x1CC5) return TRUE; // SUNDANESE PUNCTUATION BINDU KA SATANGA
	if (c == 0x1CC6) return TRUE; // SUNDANESE PUNCTUATION BINDU DA SATANGA
	if (c == 0x1CC7) return TRUE; // SUNDANESE PUNCTUATION BINDU BA SATANGA
	if (c == 0x1CD3) return TRUE; // VEDIC SIGN NIHSHVASA
	if (c == 0x2010) return TRUE; // HYPHEN
	if (c == 0x2011) return TRUE; // NON-BREAKING HYPHEN
	if (c == 0x2012) return TRUE; // FIGURE DASH
	if (c == 0x2013) return TRUE; // EN DASH
	if (c == 0x2014) return TRUE; // EM DASH
	if (c == 0x2015) return TRUE; // HORIZONTAL BAR
	if (c == 0x2016) return TRUE; // DOUBLE VERTICAL LINE
	if (c == 0x2017) return TRUE; // DOUBLE LOW LINE
	if (c == 0x2018) return TRUE; // LEFT SINGLE QUOTATION MARK
	if (c == 0x2019) return TRUE; // RIGHT SINGLE QUOTATION MARK
	if (c == 0x201A) return TRUE; // SINGLE LOW-9 QUOTATION MARK
	if (c == 0x201B) return TRUE; // SINGLE HIGH-REVERSED-9 QUOTATION MARK
	if (c == 0x201C) return TRUE; // LEFT DOUBLE QUOTATION MARK
	if (c == 0x201D) return TRUE; // RIGHT DOUBLE QUOTATION MARK
	if (c == 0x201E) return TRUE; // DOUBLE LOW-9 QUOTATION MARK
	if (c == 0x201F) return TRUE; // DOUBLE HIGH-REVERSED-9 QUOTATION MARK
	if (c == 0x2020) return TRUE; // DAGGER
	if (c == 0x2021) return TRUE; // DOUBLE DAGGER
	if (c == 0x2022) return TRUE; // BULLET
	if (c == 0x2023) return TRUE; // TRIANGULAR BULLET
	if (c == 0x2024) return TRUE; // ONE DOT LEADER
	if (c == 0x2025) return TRUE; // TWO DOT LEADER
	if (c == 0x2026) return TRUE; // HORIZONTAL ELLIPSIS
	if (c == 0x2027) return TRUE; // HYPHENATION POINT
	if (c == 0x2030) return TRUE; // PER MILLE SIGN
	if (c == 0x2031) return TRUE; // PER TEN THOUSAND SIGN
	if (c == 0x2032) return TRUE; // PRIME
	if (c == 0x2033) return TRUE; // DOUBLE PRIME
	if (c == 0x2034) return TRUE; // TRIPLE PRIME
	if (c == 0x2035) return TRUE; // REVERSED PRIME
	if (c == 0x2036) return TRUE; // REVERSED DOUBLE PRIME
	if (c == 0x2037) return TRUE; // REVERSED TRIPLE PRIME
	if (c == 0x2038) return TRUE; // CARET
	if (c == 0x2039) return TRUE; // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
	if (c == 0x203A) return TRUE; // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
	if (c == 0x203B) return TRUE; // REFERENCE MARK
	if (c == 0x203C) return TRUE; // DOUBLE EXCLAMATION MARK
	if (c == 0x203D) return TRUE; // INTERROBANG
	if (c == 0x203E) return TRUE; // OVERLINE
	if (c == 0x203F) return TRUE; // UNDERTIE
	if (c == 0x2040) return TRUE; // CHARACTER TIE
	if (c == 0x2041) return TRUE; // CARET INSERTION POINT
	if (c == 0x2042) return TRUE; // ASTERISM
	if (c == 0x2043) return TRUE; // HYPHEN BULLET
	if (c == 0x2045) return TRUE; // LEFT SQUARE BRACKET WITH QUILL
	if (c == 0x2046) return TRUE; // RIGHT SQUARE BRACKET WITH QUILL
	if (c == 0x2047) return TRUE; // DOUBLE QUESTION MARK
	if (c == 0x2048) return TRUE; // QUESTION EXCLAMATION MARK
	if (c == 0x2049) return TRUE; // EXCLAMATION QUESTION MARK
	if (c == 0x204A) return TRUE; // TIRONIAN SIGN ET
	if (c == 0x204B) return TRUE; // REVERSED PILCROW SIGN
	if (c == 0x204C) return TRUE; // BLACK LEFTWARDS BULLET
	if (c == 0x204D) return TRUE; // BLACK RIGHTWARDS BULLET
	if (c == 0x204E) return TRUE; // LOW ASTERISK
	if (c == 0x204F) return TRUE; // REVERSED SEMICOLON
	if (c == 0x2050) return TRUE; // CLOSE UP
	if (c == 0x2051) return TRUE; // TWO ASTERISKS ALIGNED VERTICALLY
	if (c == 0x2053) return TRUE; // SWUNG DASH
	if (c == 0x2054) return TRUE; // INVERTED UNDERTIE
	if (c == 0x2055) return TRUE; // FLOWER PUNCTUATION MARK
	if (c == 0x2056) return TRUE; // THREE DOT PUNCTUATION
	if (c == 0x2057) return TRUE; // QUADRUPLE PRIME
	if (c == 0x2058) return TRUE; // FOUR DOT PUNCTUATION
	if (c == 0x2059) return TRUE; // FIVE DOT PUNCTUATION
	if (c == 0x205A) return TRUE; // TWO DOT PUNCTUATION
	if (c == 0x205B) return TRUE; // FOUR DOT MARK
	if (c == 0x205C) return TRUE; // DOTTED CROSS
	if (c == 0x205D) return TRUE; // TRICOLON
	if (c == 0x205E) return TRUE; // VERTICAL FOUR DOTS
	if (c == 0x207D) return TRUE; // SUPERSCRIPT LEFT PARENTHESIS
	if (c == 0x207E) return TRUE; // SUPERSCRIPT RIGHT PARENTHESIS
	if (c == 0x208D) return TRUE; // SUBSCRIPT LEFT PARENTHESIS
	if (c == 0x208E) return TRUE; // SUBSCRIPT RIGHT PARENTHESIS
	if (c == 0x2308) return TRUE; // LEFT CEILING
	if (c == 0x2309) return TRUE; // RIGHT CEILING
	if (c == 0x230A) return TRUE; // LEFT FLOOR
	if (c == 0x230B) return TRUE; // RIGHT FLOOR
	if (c == 0x2329) return TRUE; // LEFT-POINTING ANGLE BRACKET
	if (c == 0x232A) return TRUE; // RIGHT-POINTING ANGLE BRACKET
	if (c == 0x2768) return TRUE; // MEDIUM LEFT PARENTHESIS ORNAMENT
	if (c == 0x2769) return TRUE; // MEDIUM RIGHT PARENTHESIS ORNAMENT
	if (c == 0x276A) return TRUE; // MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
	if (c == 0x276B) return TRUE; // MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
	if (c == 0x276C) return TRUE; // MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
	if (c == 0x276D) return TRUE; // MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
	if (c == 0x276E) return TRUE; // HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
	if (c == 0x276F) return TRUE; // HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
	if (c == 0x2770) return TRUE; // HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
	if (c == 0x2771) return TRUE; // HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
	if (c == 0x2772) return TRUE; // LIGHT LEFT TORTOISE SHELL BRACKET ORNAMENT
	if (c == 0x2773) return TRUE; // LIGHT RIGHT TORTOISE SHELL BRACKET ORNAMENT
	if (c == 0x2774) return TRUE; // MEDIUM LEFT CURLY BRACKET ORNAMENT
	if (c == 0x2775) return TRUE; // MEDIUM RIGHT CURLY BRACKET ORNAMENT
	if (c == 0x27C5) return TRUE; // LEFT S-SHAPED BAG DELIMITER
	if (c == 0x27C6) return TRUE; // RIGHT S-SHAPED BAG DELIMITER
	if (c == 0x27E6) return TRUE; // MATHEMATICAL LEFT WHITE SQUARE BRACKET
	if (c == 0x27E7) return TRUE; // MATHEMATICAL RIGHT WHITE SQUARE BRACKET
	if (c == 0x27E8) return TRUE; // MATHEMATICAL LEFT ANGLE BRACKET
	if (c == 0x27E9) return TRUE; // MATHEMATICAL RIGHT ANGLE BRACKET
	if (c == 0x27EA) return TRUE; // MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
	if (c == 0x27EB) return TRUE; // MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET
	if (c == 0x27EC) return TRUE; // MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET
	if (c == 0x27ED) return TRUE; // MATHEMATICAL RIGHT WHITE TORTOISE SHELL BRACKET
	if (c == 0x27EE) return TRUE; // MATHEMATICAL LEFT FLATTENED PARENTHESIS
	if (c == 0x27EF) return TRUE; // MATHEMATICAL RIGHT FLATTENED PARENTHESIS
	if (c == 0x2983) return TRUE; // LEFT WHITE CURLY BRACKET
	if (c == 0x2984) return TRUE; // RIGHT WHITE CURLY BRACKET
	if (c == 0x2985) return TRUE; // LEFT WHITE PARENTHESIS
	if (c == 0x2986) return TRUE; // RIGHT WHITE PARENTHESIS
	if (c == 0x2987) return TRUE; // Z NOTATION LEFT IMAGE BRACKET
	if (c == 0x2988) return TRUE; // Z NOTATION RIGHT IMAGE BRACKET
	if (c == 0x2989) return TRUE; // Z NOTATION LEFT BINDING BRACKET
	if (c == 0x298A) return TRUE; // Z NOTATION RIGHT BINDING BRACKET
	if (c == 0x298B) return TRUE; // LEFT SQUARE BRACKET WITH UNDERBAR
	if (c == 0x298C) return TRUE; // RIGHT SQUARE BRACKET WITH UNDERBAR
	if (c == 0x298D) return TRUE; // LEFT SQUARE BRACKET WITH TICK IN TOP CORNER
	if (c == 0x298E) return TRUE; // RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
	if (c == 0x298F) return TRUE; // LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
	if (c == 0x2990) return TRUE; // RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER
	if (c == 0x2991) return TRUE; // LEFT ANGLE BRACKET WITH DOT
	if (c == 0x2992) return TRUE; // RIGHT ANGLE BRACKET WITH DOT
	if (c == 0x2993) return TRUE; // LEFT ARC LESS-THAN BRACKET
	if (c == 0x2994) return TRUE; // RIGHT ARC GREATER-THAN BRACKET
	if (c == 0x2995) return TRUE; // DOUBLE LEFT ARC GREATER-THAN BRACKET
	if (c == 0x2996) return TRUE; // DOUBLE RIGHT ARC LESS-THAN BRACKET
	if (c == 0x2997) return TRUE; // LEFT BLACK TORTOISE SHELL BRACKET
	if (c == 0x2998) return TRUE; // RIGHT BLACK TORTOISE SHELL BRACKET
	if (c == 0x29D8) return TRUE; // LEFT WIGGLY FENCE
	if (c == 0x29D9) return TRUE; // RIGHT WIGGLY FENCE
	if (c == 0x29DA) return TRUE; // LEFT DOUBLE WIGGLY FENCE
	if (c == 0x29DB) return TRUE; // RIGHT DOUBLE WIGGLY FENCE
	if (c == 0x29FC) return TRUE; // LEFT-POINTING CURVED ANGLE BRACKET
	if (c == 0x29FD) return TRUE; // RIGHT-POINTING CURVED ANGLE BRACKET
	if (c == 0x2CF9) return TRUE; // COPTIC OLD NUBIAN FULL STOP
	if (c == 0x2CFA) return TRUE; // COPTIC OLD NUBIAN DIRECT QUESTION MARK
	if (c == 0x2CFB) return TRUE; // COPTIC OLD NUBIAN INDIRECT QUESTION MARK
	if (c == 0x2CFC) return TRUE; // COPTIC OLD NUBIAN VERSE DIVIDER
	if (c == 0x2CFE) return TRUE; // COPTIC FULL STOP
	if (c == 0x2CFF) return TRUE; // COPTIC MORPHOLOGICAL DIVIDER
	if (c == 0x2D70) return TRUE; // TIFINAGH SEPARATOR MARK
	if (c == 0x2E00) return TRUE; // RIGHT ANGLE SUBSTITUTION MARKER
	if (c == 0x2E01) return TRUE; // RIGHT ANGLE DOTTED SUBSTITUTION MARKER
	if (c == 0x2E02) return TRUE; // LEFT SUBSTITUTION BRACKET
	if (c == 0x2E03) return TRUE; // RIGHT SUBSTITUTION BRACKET
	if (c == 0x2E04) return TRUE; // LEFT DOTTED SUBSTITUTION BRACKET
	if (c == 0x2E05) return TRUE; // RIGHT DOTTED SUBSTITUTION BRACKET
	if (c == 0x2E06) return TRUE; // RAISED INTERPOLATION MARKER
	if (c == 0x2E07) return TRUE; // RAISED DOTTED INTERPOLATION MARKER
	if (c == 0x2E08) return TRUE; // DOTTED TRANSPOSITION MARKER
	if (c == 0x2E09) return TRUE; // LEFT TRANSPOSITION BRACKET
	if (c == 0x2E0A) return TRUE; // RIGHT TRANSPOSITION BRACKET
	if (c == 0x2E0B) return TRUE; // RAISED SQUARE
	if (c == 0x2E0C) return TRUE; // LEFT RAISED OMISSION BRACKET
	if (c == 0x2E0D) return TRUE; // RIGHT RAISED OMISSION BRACKET
	if (c == 0x2E0E) return TRUE; // EDITORIAL CORONIS
	if (c == 0x2E0F) return TRUE; // PARAGRAPHOS
	if (c == 0x2E10) return TRUE; // FORKED PARAGRAPHOS
	if (c == 0x2E11) return TRUE; // REVERSED FORKED PARAGRAPHOS
	if (c == 0x2E12) return TRUE; // HYPODIASTOLE
	if (c == 0x2E13) return TRUE; // DOTTED OBELOS
	if (c == 0x2E14) return TRUE; // DOWNWARDS ANCORA
	if (c == 0x2E15) return TRUE; // UPWARDS ANCORA
	if (c == 0x2E16) return TRUE; // DOTTED RIGHT-POINTING ANGLE
	if (c == 0x2E17) return TRUE; // DOUBLE OBLIQUE HYPHEN
	if (c == 0x2E18) return TRUE; // INVERTED INTERROBANG
	if (c == 0x2E19) return TRUE; // PALM BRANCH
	if (c == 0x2E1A) return TRUE; // HYPHEN WITH DIAERESIS
	if (c == 0x2E1B) return TRUE; // TILDE WITH RING ABOVE
	if (c == 0x2E1C) return TRUE; // LEFT LOW PARAPHRASE BRACKET
	if (c == 0x2E1D) return TRUE; // RIGHT LOW PARAPHRASE BRACKET
	if (c == 0x2E1E) return TRUE; // TILDE WITH DOT ABOVE
	if (c == 0x2E1F) return TRUE; // TILDE WITH DOT BELOW
	if (c == 0x2E20) return TRUE; // LEFT VERTICAL BAR WITH QUILL
	if (c == 0x2E21) return TRUE; // RIGHT VERTICAL BAR WITH QUILL
	if (c == 0x2E22) return TRUE; // TOP LEFT HALF BRACKET
	if (c == 0x2E23) return TRUE; // TOP RIGHT HALF BRACKET
	if (c == 0x2E24) return TRUE; // BOTTOM LEFT HALF BRACKET
	if (c == 0x2E25) return TRUE; // BOTTOM RIGHT HALF BRACKET
	if (c == 0x2E26) return TRUE; // LEFT SIDEWAYS U BRACKET
	if (c == 0x2E27) return TRUE; // RIGHT SIDEWAYS U BRACKET
	if (c == 0x2E28) return TRUE; // LEFT DOUBLE PARENTHESIS
	if (c == 0x2E29) return TRUE; // RIGHT DOUBLE PARENTHESIS
	if (c == 0x2E2A) return TRUE; // TWO DOTS OVER ONE DOT PUNCTUATION
	if (c == 0x2E2B) return TRUE; // ONE DOT OVER TWO DOTS PUNCTUATION
	if (c == 0x2E2C) return TRUE; // SQUARED FOUR DOT PUNCTUATION
	if (c == 0x2E2D) return TRUE; // FIVE DOT MARK
	if (c == 0x2E2E) return TRUE; // REVERSED QUESTION MARK
	if (c == 0x2E30) return TRUE; // RING POINT
	if (c == 0x2E31) return TRUE; // WORD SEPARATOR MIDDLE DOT
	if (c == 0x2E32) return TRUE; // TURNED COMMA
	if (c == 0x2E33) return TRUE; // RAISED DOT
	if (c == 0x2E34) return TRUE; // RAISED COMMA
	if (c == 0x2E35) return TRUE; // TURNED SEMICOLON
	if (c == 0x2E36) return TRUE; // DAGGER WITH LEFT GUARD
	if (c == 0x2E37) return TRUE; // DAGGER WITH RIGHT GUARD
	if (c == 0x2E38) return TRUE; // TURNED DAGGER
	if (c == 0x2E39) return TRUE; // TOP HALF SECTION SIGN
	if (c == 0x2E3A) return TRUE; // TWO-EM DASH
	if (c == 0x2E3B) return TRUE; // THREE-EM DASH
	if (c == 0x2E3C) return TRUE; // STENOGRAPHIC FULL STOP
	if (c == 0x2E3D) return TRUE; // VERTICAL SIX DOTS
	if (c == 0x2E3E) return TRUE; // WIGGLY VERTICAL LINE
	if (c == 0x2E3F) return TRUE; // CAPITULUM
	if (c == 0x2E40) return TRUE; // DOUBLE HYPHEN
	if (c == 0x2E41) return TRUE; // REVERSED COMMA
	if (c == 0x2E42) return TRUE; // DOUBLE LOW-REVERSED-9 QUOTATION MARK
	if (c == 0x2E43) return TRUE; // DASH WITH LEFT UPTURN
	if (c == 0x2E44) return TRUE; // DOUBLE SUSPENSION MARK
	if (c == 0x2E45) return TRUE; // INVERTED LOW KAVYKA
	if (c == 0x2E46) return TRUE; // INVERTED LOW KAVYKA WITH KAVYKA ABOVE
	if (c == 0x2E47) return TRUE; // LOW KAVYKA
	if (c == 0x2E48) return TRUE; // LOW KAVYKA WITH DOT
	if (c == 0x2E49) return TRUE; // DOUBLE STACKED COMMA
	if (c == 0x2E4A) return TRUE; // DOTTED SOLIDUS
	if (c == 0x2E4B) return TRUE; // TRIPLE DAGGER
	if (c == 0x2E4C) return TRUE; // MEDIEVAL COMMA
	if (c == 0x2E4D) return TRUE; // PARAGRAPHUS MARK
	if (c == 0x2E4E) return TRUE; // PUNCTUS ELEVATUS MARK
	if (c == 0x2E4F) return TRUE; // CORNISH VERSE DIVIDER
	if (c == 0x2E52) return TRUE; // TIRONIAN SIGN CAPITAL ET
	if (c == 0x2E53) return TRUE; // MEDIEVAL EXCLAMATION MARK
	if (c == 0x2E54) return TRUE; // MEDIEVAL QUESTION MARK
	if (c == 0x2E55) return TRUE; // LEFT SQUARE BRACKET WITH STROKE
	if (c == 0x2E56) return TRUE; // RIGHT SQUARE BRACKET WITH STROKE
	if (c == 0x2E57) return TRUE; // LEFT SQUARE BRACKET WITH DOUBLE STROKE
	if (c == 0x2E58) return TRUE; // RIGHT SQUARE BRACKET WITH DOUBLE STROKE
	if (c == 0x2E59) return TRUE; // TOP HALF LEFT PARENTHESIS
	if (c == 0x2E5A) return TRUE; // TOP HALF RIGHT PARENTHESIS
	if (c == 0x2E5B) return TRUE; // BOTTOM HALF LEFT PARENTHESIS
	if (c == 0x2E5C) return TRUE; // BOTTOM HALF RIGHT PARENTHESIS
	if (c == 0x2E5D) return TRUE; // OBLIQUE HYPHEN
	if (c == 0x3001) return TRUE; // IDEOGRAPHIC COMMA
	if (c == 0x3002) return TRUE; // IDEOGRAPHIC FULL STOP
	if (c == 0x3003) return TRUE; // DITTO MARK
	if (c == 0x3008) return TRUE; // LEFT ANGLE BRACKET
	if (c == 0x3009) return TRUE; // RIGHT ANGLE BRACKET
	if (c == 0x300A) return TRUE; // LEFT DOUBLE ANGLE BRACKET
	if (c == 0x300B) return TRUE; // RIGHT DOUBLE ANGLE BRACKET
	if (c == 0x300C) return TRUE; // LEFT CORNER BRACKET
	if (c == 0x300D) return TRUE; // RIGHT CORNER BRACKET
	if (c == 0x300E) return TRUE; // LEFT WHITE CORNER BRACKET
	if (c == 0x300F) return TRUE; // RIGHT WHITE CORNER BRACKET
	if (c == 0x3010) return TRUE; // LEFT BLACK LENTICULAR BRACKET
	if (c == 0x3011) return TRUE; // RIGHT BLACK LENTICULAR BRACKET
	if (c == 0x3014) return TRUE; // LEFT TORTOISE SHELL BRACKET
	if (c == 0x3015) return TRUE; // RIGHT TORTOISE SHELL BRACKET
	if (c == 0x3016) return TRUE; // LEFT WHITE LENTICULAR BRACKET
	if (c == 0x3017) return TRUE; // RIGHT WHITE LENTICULAR BRACKET
	if (c == 0x3018) return TRUE; // LEFT WHITE TORTOISE SHELL BRACKET
	if (c == 0x3019) return TRUE; // RIGHT WHITE TORTOISE SHELL BRACKET
	if (c == 0x301A) return TRUE; // LEFT WHITE SQUARE BRACKET
	if (c == 0x301B) return TRUE; // RIGHT WHITE SQUARE BRACKET
	if (c == 0x301C) return TRUE; // WAVE DASH
	if (c == 0x301D) return TRUE; // REVERSED DOUBLE PRIME QUOTATION MARK
	if (c == 0x301E) return TRUE; // DOUBLE PRIME QUOTATION MARK
	if (c == 0x301F) return TRUE; // LOW DOUBLE PRIME QUOTATION MARK
	if (c == 0x3030) return TRUE; // WAVY DASH
	if (c == 0x303D) return TRUE; // PART ALTERNATION MARK
	if (c == 0x30A0) return TRUE; // KATAKANA-HIRAGANA DOUBLE HYPHEN
	if (c == 0x30FB) return TRUE; // KATAKANA MIDDLE DOT
	if (c == 0xA4FE) return TRUE; // LISU PUNCTUATION COMMA
	if (c == 0xA4FF) return TRUE; // LISU PUNCTUATION FULL STOP
	if (c == 0xA60D) return TRUE; // VAI COMMA
	if (c == 0xA60E) return TRUE; // VAI FULL STOP
	if (c == 0xA60F) return TRUE; // VAI QUESTION MARK
	if (c == 0xA673) return TRUE; // SLAVONIC ASTERISK
	if (c == 0xA67E) return TRUE; // CYRILLIC KAVYKA
	if (c == 0xA6F2) return TRUE; // BAMUM NJAEMLI
	if (c == 0xA6F3) return TRUE; // BAMUM FULL STOP
	if (c == 0xA6F4) return TRUE; // BAMUM COLON
	if (c == 0xA6F5) return TRUE; // BAMUM COMMA
	if (c == 0xA6F6) return TRUE; // BAMUM SEMICOLON
	if (c == 0xA6F7) return TRUE; // BAMUM QUESTION MARK
	if (c == 0xA874) return TRUE; // PHAGS-PA SINGLE HEAD MARK
	if (c == 0xA875) return TRUE; // PHAGS-PA DOUBLE HEAD MARK
	if (c == 0xA876) return TRUE; // PHAGS-PA MARK SHAD
	if (c == 0xA877) return TRUE; // PHAGS-PA MARK DOUBLE SHAD
	if (c == 0xA8CE) return TRUE; // SAURASHTRA DANDA
	if (c == 0xA8CF) return TRUE; // SAURASHTRA DOUBLE DANDA
	if (c == 0xA8F8) return TRUE; // DEVANAGARI SIGN PUSHPIKA
	if (c == 0xA8F9) return TRUE; // DEVANAGARI GAP FILLER
	if (c == 0xA8FA) return TRUE; // DEVANAGARI CARET
	if (c == 0xA8FC) return TRUE; // DEVANAGARI SIGN SIDDHAM
	if (c == 0xA92E) return TRUE; // KAYAH LI SIGN CWI
	if (c == 0xA92F) return TRUE; // KAYAH LI SIGN SHYA
	if (c == 0xA95F) return TRUE; // REJANG SECTION MARK
	if (c == 0xA9C1) return TRUE; // JAVANESE LEFT RERENGGAN
	if (c == 0xA9C2) return TRUE; // JAVANESE RIGHT RERENGGAN
	if (c == 0xA9C3) return TRUE; // JAVANESE PADA ANDAP
	if (c == 0xA9C4) return TRUE; // JAVANESE PADA MADYA
	if (c == 0xA9C5) return TRUE; // JAVANESE PADA LUHUR
	if (c == 0xA9C6) return TRUE; // JAVANESE PADA WINDU
	if (c == 0xA9C7) return TRUE; // JAVANESE PADA PANGKAT
	if (c == 0xA9C8) return TRUE; // JAVANESE PADA LINGSA
	if (c == 0xA9C9) return TRUE; // JAVANESE PADA LUNGSI
	if (c == 0xA9CA) return TRUE; // JAVANESE PADA ADEG
	if (c == 0xA9CB) return TRUE; // JAVANESE PADA ADEG ADEG
	if (c == 0xA9CC) return TRUE; // JAVANESE PADA PISELEH
	if (c == 0xA9CD) return TRUE; // JAVANESE TURNED PADA PISELEH
	if (c == 0xA9DE) return TRUE; // JAVANESE PADA TIRTA TUMETES
	if (c == 0xA9DF) return TRUE; // JAVANESE PADA ISEN-ISEN
	if (c == 0xAA5C) return TRUE; // CHAM PUNCTUATION SPIRAL
	if (c == 0xAA5D) return TRUE; // CHAM PUNCTUATION DANDA
	if (c == 0xAA5E) return TRUE; // CHAM PUNCTUATION DOUBLE DANDA
	if (c == 0xAA5F) return TRUE; // CHAM PUNCTUATION TRIPLE DANDA
	if (c == 0xAADE) return TRUE; // TAI VIET SYMBOL HO HOI
	if (c == 0xAADF) return TRUE; // TAI VIET SYMBOL KOI KOI
	if (c == 0xAAF0) return TRUE; // MEETEI MAYEK CHEIKHAN
	if (c == 0xAAF1) return TRUE; // MEETEI MAYEK AHANG KHUDAM
	if (c == 0xABEB) return TRUE; // MEETEI MAYEK CHEIKHEI
	if (c == 0xFD3E) return TRUE; // ORNATE LEFT PARENTHESIS
	if (c == 0xFD3F) return TRUE; // ORNATE RIGHT PARENTHESIS
	if (c == 0xFE10) return TRUE; // PRESENTATION FORM FOR VERTICAL COMMA
	if (c == 0xFE11) return TRUE; // PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC COMMA
	if (c == 0xFE12) return TRUE; // PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC FULL STOP
	if (c == 0xFE13) return TRUE; // PRESENTATION FORM FOR VERTICAL COLON
	if (c == 0xFE14) return TRUE; // PRESENTATION FORM FOR VERTICAL SEMICOLON
	if (c == 0xFE15) return TRUE; // PRESENTATION FORM FOR VERTICAL EXCLAMATION MARK
	if (c == 0xFE16) return TRUE; // PRESENTATION FORM FOR VERTICAL QUESTION MARK
	if (c == 0xFE17) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT WHITE LENTICULAR BRACKET
	if (c == 0xFE18) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRAKCET
	if (c == 0xFE19) return TRUE; // PRESENTATION FORM FOR VERTICAL HORIZONTAL ELLIPSIS
	if (c == 0xFE30) return TRUE; // PRESENTATION FORM FOR VERTICAL TWO DOT LEADER
	if (c == 0xFE31) return TRUE; // PRESENTATION FORM FOR VERTICAL EM DASH
	if (c == 0xFE32) return TRUE; // PRESENTATION FORM FOR VERTICAL EN DASH
	if (c == 0xFE33) return TRUE; // PRESENTATION FORM FOR VERTICAL LOW LINE
	if (c == 0xFE34) return TRUE; // PRESENTATION FORM FOR VERTICAL WAVY LOW LINE
	if (c == 0xFE35) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
	if (c == 0xFE36) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
	if (c == 0xFE37) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
	if (c == 0xFE38) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
	if (c == 0xFE39) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET
	if (c == 0xFE3A) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET
	if (c == 0xFE3B) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET
	if (c == 0xFE3C) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET
	if (c == 0xFE3D) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET
	if (c == 0xFE3E) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET
	if (c == 0xFE3F) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET
	if (c == 0xFE40) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
	if (c == 0xFE41) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
	if (c == 0xFE42) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET
	if (c == 0xFE43) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET
	if (c == 0xFE44) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET
	if (c == 0xFE45) return TRUE; // SESAME DOT
	if (c == 0xFE46) return TRUE; // WHITE SESAME DOT
	if (c == 0xFE47) return TRUE; // PRESENTATION FORM FOR VERTICAL LEFT SQUARE BRACKET
	if (c == 0xFE48) return TRUE; // PRESENTATION FORM FOR VERTICAL RIGHT SQUARE BRACKET
	if (c == 0xFE49) return TRUE; // DASHED OVERLINE
	if (c == 0xFE4A) return TRUE; // CENTRELINE OVERLINE
	if (c == 0xFE4B) return TRUE; // WAVY OVERLINE
	if (c == 0xFE4C) return TRUE; // DOUBLE WAVY OVERLINE
	if (c == 0xFE4D) return TRUE; // DASHED LOW LINE
	if (c == 0xFE4E) return TRUE; // CENTRELINE LOW LINE
	if (c == 0xFE4F) return TRUE; // WAVY LOW LINE
	if (c == 0xFE50) return TRUE; // SMALL COMMA
	if (c == 0xFE51) return TRUE; // SMALL IDEOGRAPHIC COMMA
	if (c == 0xFE52) return TRUE; // SMALL FULL STOP
	if (c == 0xFE54) return TRUE; // SMALL SEMICOLON
	if (c == 0xFE55) return TRUE; // SMALL COLON
	if (c == 0xFE56) return TRUE; // SMALL QUESTION MARK
	if (c == 0xFE57) return TRUE; // SMALL EXCLAMATION MARK
	if (c == 0xFE58) return TRUE; // SMALL EM DASH
	if (c == 0xFE59) return TRUE; // SMALL LEFT PARENTHESIS
	if (c == 0xFE5A) return TRUE; // SMALL RIGHT PARENTHESIS
	if (c == 0xFE5B) return TRUE; // SMALL LEFT CURLY BRACKET
	if (c == 0xFE5C) return TRUE; // SMALL RIGHT CURLY BRACKET
	if (c == 0xFE5D) return TRUE; // SMALL LEFT TORTOISE SHELL BRACKET
	if (c == 0xFE5E) return TRUE; // SMALL RIGHT TORTOISE SHELL BRACKET
	if (c == 0xFE5F) return TRUE; // SMALL NUMBER SIGN
	if (c == 0xFE60) return TRUE; // SMALL AMPERSAND
	if (c == 0xFE61) return TRUE; // SMALL ASTERISK
	if (c == 0xFE63) return TRUE; // SMALL HYPHEN-MINUS
	if (c == 0xFE68) return TRUE; // SMALL REVERSE SOLIDUS
	if (c == 0xFE6A) return TRUE; // SMALL PERCENT SIGN
	if (c == 0xFE6B) return TRUE; // SMALL COMMERCIAL AT
	if (c == 0xFF01) return TRUE; // FULLWIDTH EXCLAMATION MARK
	if (c == 0xFF02) return TRUE; // FULLWIDTH QUOTATION MARK
	if (c == 0xFF03) return TRUE; // FULLWIDTH NUMBER SIGN
	if (c == 0xFF05) return TRUE; // FULLWIDTH PERCENT SIGN
	if (c == 0xFF06) return TRUE; // FULLWIDTH AMPERSAND
	if (c == 0xFF07) return TRUE; // FULLWIDTH APOSTROPHE
	if (c == 0xFF08) return TRUE; // FULLWIDTH LEFT PARENTHESIS
	if (c == 0xFF09) return TRUE; // FULLWIDTH RIGHT PARENTHESIS
	if (c == 0xFF0A) return TRUE; // FULLWIDTH ASTERISK
	if (c == 0xFF0C) return TRUE; // FULLWIDTH COMMA
	if (c == 0xFF0D) return TRUE; // FULLWIDTH HYPHEN-MINUS
	if (c == 0xFF0E) return TRUE; // FULLWIDTH FULL STOP
	if (c == 0xFF0F) return TRUE; // FULLWIDTH SOLIDUS
	if (c == 0xFF1A) return TRUE; // FULLWIDTH COLON
	if (c == 0xFF1B) return TRUE; // FULLWIDTH SEMICOLON
	if (c == 0xFF1F) return TRUE; // FULLWIDTH QUESTION MARK
	if (c == 0xFF20) return TRUE; // FULLWIDTH COMMERCIAL AT
	if (c == 0xFF3B) return TRUE; // FULLWIDTH LEFT SQUARE BRACKET
	if (c == 0xFF3C) return TRUE; // FULLWIDTH REVERSE SOLIDUS
	if (c == 0xFF3D) return TRUE; // FULLWIDTH RIGHT SQUARE BRACKET
	if (c == 0xFF3F) return TRUE; // FULLWIDTH LOW LINE
	if (c == 0xFF5B) return TRUE; // FULLWIDTH LEFT CURLY BRACKET
	if (c == 0xFF5D) return TRUE; // FULLWIDTH RIGHT CURLY BRACKET
	if (c == 0xFF5F) return TRUE; // FULLWIDTH LEFT WHITE PARENTHESIS
	if (c == 0xFF60) return TRUE; // FULLWIDTH RIGHT WHITE PARENTHESIS
	if (c == 0xFF61) return TRUE; // HALFWIDTH IDEOGRAPHIC FULL STOP
	if (c == 0xFF62) return TRUE; // HALFWIDTH LEFT CORNER BRACKET
	if (c == 0xFF63) return TRUE; // HALFWIDTH RIGHT CORNER BRACKET
	if (c == 0xFF64) return TRUE; // HALFWIDTH IDEOGRAPHIC COMMA
	if (c == 0xFF65) return TRUE; // HALFWIDTH KATAKANA MIDDLE DOT
	if (c == 0x10100) return TRUE; // AEGEAN WORD SEPARATOR LINE
	if (c == 0x10101) return TRUE; // AEGEAN WORD SEPARATOR DOT
	if (c == 0x10102) return TRUE; // AEGEAN CHECK MARK
	if (c == 0x1039F) return TRUE; // UGARITIC WORD DIVIDER
	if (c == 0x103D0) return TRUE; // OLD PERSIAN WORD DIVIDER
	if (c == 0x1056F) return TRUE; // CAUCASIAN ALBANIAN CITATION MARK
	if (c == 0x10857) return TRUE; // IMPERIAL ARAMAIC SECTION SIGN
	if (c == 0x1091F) return TRUE; // PHOENICIAN WORD SEPARATOR
	if (c == 0x1093F) return TRUE; // LYDIAN TRIANGULAR MARK
	if (c == 0x10A50) return TRUE; // KHAROSHTHI PUNCTUATION DOT
	if (c == 0x10A51) return TRUE; // KHAROSHTHI PUNCTUATION SMALL CIRCLE
	if (c == 0x10A52) return TRUE; // KHAROSHTHI PUNCTUATION CIRCLE
	if (c == 0x10A53) return TRUE; // KHAROSHTHI PUNCTUATION CRESCENT BAR
	if (c == 0x10A54) return TRUE; // KHAROSHTHI PUNCTUATION MANGALAM
	if (c == 0x10A55) return TRUE; // KHAROSHTHI PUNCTUATION LOTUS
	if (c == 0x10A56) return TRUE; // KHAROSHTHI PUNCTUATION DANDA
	if (c == 0x10A57) return TRUE; // KHAROSHTHI PUNCTUATION DOUBLE DANDA
	if (c == 0x10A58) return TRUE; // KHAROSHTHI PUNCTUATION LINES
	if (c == 0x10A7F) return TRUE; // OLD SOUTH ARABIAN NUMERIC INDICATOR
	if (c == 0x10AF0) return TRUE; // MANICHAEAN PUNCTUATION STAR
	if (c == 0x10AF1) return TRUE; // MANICHAEAN PUNCTUATION FLEURON
	if (c == 0x10AF2) return TRUE; // MANICHAEAN PUNCTUATION DOUBLE DOT WITHIN DOT
	if (c == 0x10AF3) return TRUE; // MANICHAEAN PUNCTUATION DOT WITHIN DOT
	if (c == 0x10AF4) return TRUE; // MANICHAEAN PUNCTUATION DOT
	if (c == 0x10AF5) return TRUE; // MANICHAEAN PUNCTUATION TWO DOTS
	if (c == 0x10AF6) return TRUE; // MANICHAEAN PUNCTUATION LINE FILLER
	if (c == 0x10B39) return TRUE; // AVESTAN ABBREVIATION MARK
	if (c == 0x10B3A) return TRUE; // TINY TWO DOTS OVER ONE DOT PUNCTUATION
	if (c == 0x10B3B) return TRUE; // SMALL TWO DOTS OVER ONE DOT PUNCTUATION
	if (c == 0x10B3C) return TRUE; // LARGE TWO DOTS OVER ONE DOT PUNCTUATION
	if (c == 0x10B3D) return TRUE; // LARGE ONE DOT OVER TWO DOTS PUNCTUATION
	if (c == 0x10B3E) return TRUE; // LARGE TWO RINGS OVER ONE RING PUNCTUATION
	if (c == 0x10B3F) return TRUE; // LARGE ONE RING OVER TWO RINGS PUNCTUATION
	if (c == 0x10B99) return TRUE; // PSALTER PAHLAVI SECTION MARK
	if (c == 0x10B9A) return TRUE; // PSALTER PAHLAVI TURNED SECTION MARK
	if (c == 0x10B9B) return TRUE; // PSALTER PAHLAVI FOUR DOTS WITH CROSS
	if (c == 0x10B9C) return TRUE; // PSALTER PAHLAVI FOUR DOTS WITH DOT
	if (c == 0x10EAD) return TRUE; // YEZIDI HYPHENATION MARK
	if (c == 0x10F55) return TRUE; // SOGDIAN PUNCTUATION TWO VERTICAL BARS
	if (c == 0x10F56) return TRUE; // SOGDIAN PUNCTUATION TWO VERTICAL BARS WITH DOTS
	if (c == 0x10F57) return TRUE; // SOGDIAN PUNCTUATION CIRCLE WITH DOT
	if (c == 0x10F58) return TRUE; // SOGDIAN PUNCTUATION TWO CIRCLES WITH DOTS
	if (c == 0x10F59) return TRUE; // SOGDIAN PUNCTUATION HALF CIRCLE WITH DOT
	if (c == 0x10F86) return TRUE; // OLD UYGHUR PUNCTUATION BAR
	if (c == 0x10F87) return TRUE; // OLD UYGHUR PUNCTUATION TWO BARS
	if (c == 0x10F88) return TRUE; // OLD UYGHUR PUNCTUATION TWO DOTS
	if (c == 0x10F89) return TRUE; // OLD UYGHUR PUNCTUATION FOUR DOTS
	if (c == 0x11047) return TRUE; // BRAHMI DANDA
	if (c == 0x11048) return TRUE; // BRAHMI DOUBLE DANDA
	if (c == 0x11049) return TRUE; // BRAHMI PUNCTUATION DOT
	if (c == 0x1104A) return TRUE; // BRAHMI PUNCTUATION DOUBLE DOT
	if (c == 0x1104B) return TRUE; // BRAHMI PUNCTUATION LINE
	if (c == 0x1104C) return TRUE; // BRAHMI PUNCTUATION CRESCENT BAR
	if (c == 0x1104D) return TRUE; // BRAHMI PUNCTUATION LOTUS
	if (c == 0x110BB) return TRUE; // KAITHI ABBREVIATION SIGN
	if (c == 0x110BC) return TRUE; // KAITHI ENUMERATION SIGN
	if (c == 0x110BE) return TRUE; // KAITHI SECTION MARK
	if (c == 0x110BF) return TRUE; // KAITHI DOUBLE SECTION MARK
	if (c == 0x110C0) return TRUE; // KAITHI DANDA
	if (c == 0x110C1) return TRUE; // KAITHI DOUBLE DANDA
	if (c == 0x11140) return TRUE; // CHAKMA SECTION MARK
	if (c == 0x11141) return TRUE; // CHAKMA DANDA
	if (c == 0x11142) return TRUE; // CHAKMA DOUBLE DANDA
	if (c == 0x11143) return TRUE; // CHAKMA QUESTION MARK
	if (c == 0x11174) return TRUE; // MAHAJANI ABBREVIATION SIGN
	if (c == 0x11175) return TRUE; // MAHAJANI SECTION MARK
	if (c == 0x111C5) return TRUE; // SHARADA DANDA
	if (c == 0x111C6) return TRUE; // SHARADA DOUBLE DANDA
	if (c == 0x111C7) return TRUE; // SHARADA ABBREVIATION SIGN
	if (c == 0x111C8) return TRUE; // SHARADA SEPARATOR
	if (c == 0x111CD) return TRUE; // SHARADA SUTRA MARK
	if (c == 0x111DB) return TRUE; // SHARADA SIGN SIDDHAM
	if (c == 0x111DD) return TRUE; // SHARADA CONTINUATION SIGN
	if (c == 0x111DE) return TRUE; // SHARADA SECTION MARK-1
	if (c == 0x111DF) return TRUE; // SHARADA SECTION MARK-2
	if (c == 0x11238) return TRUE; // KHOJKI DANDA
	if (c == 0x11239) return TRUE; // KHOJKI DOUBLE DANDA
	if (c == 0x1123A) return TRUE; // KHOJKI WORD SEPARATOR
	if (c == 0x1123B) return TRUE; // KHOJKI SECTION MARK
	if (c == 0x1123C) return TRUE; // KHOJKI DOUBLE SECTION MARK
	if (c == 0x1123D) return TRUE; // KHOJKI ABBREVIATION SIGN
	if (c == 0x112A9) return TRUE; // MULTANI SECTION MARK
	if (c == 0x1144B) return TRUE; // NEWA DANDA
	if (c == 0x1144C) return TRUE; // NEWA DOUBLE DANDA
	if (c == 0x1144D) return TRUE; // NEWA COMMA
	if (c == 0x1144E) return TRUE; // NEWA GAP FILLER
	if (c == 0x1144F) return TRUE; // NEWA ABBREVIATION SIGN
	if (c == 0x1145A) return TRUE; // NEWA DOUBLE COMMA
	if (c == 0x1145B) return TRUE; // NEWA PLACEHOLDER MARK
	if (c == 0x1145D) return TRUE; // NEWA INSERTION SIGN
	if (c == 0x114C6) return TRUE; // TIRHUTA ABBREVIATION SIGN
	if (c == 0x115C1) return TRUE; // SIDDHAM SIGN SIDDHAM
	if (c == 0x115C2) return TRUE; // SIDDHAM DANDA
	if (c == 0x115C3) return TRUE; // SIDDHAM DOUBLE DANDA
	if (c == 0x115C4) return TRUE; // SIDDHAM SEPARATOR DOT
	if (c == 0x115C5) return TRUE; // SIDDHAM SEPARATOR BAR
	if (c == 0x115C6) return TRUE; // SIDDHAM REPETITION MARK-1
	if (c == 0x115C7) return TRUE; // SIDDHAM REPETITION MARK-2
	if (c == 0x115C8) return TRUE; // SIDDHAM REPETITION MARK-3
	if (c == 0x115C9) return TRUE; // SIDDHAM END OF TEXT MARK
	if (c == 0x115CA) return TRUE; // SIDDHAM SECTION MARK WITH TRIDENT AND U-SHAPED ORNAMENTS
	if (c == 0x115CB) return TRUE; // SIDDHAM SECTION MARK WITH TRIDENT AND DOTTED CRESCENTS
	if (c == 0x115CC) return TRUE; // SIDDHAM SECTION MARK WITH RAYS AND DOTTED CRESCENTS
	if (c == 0x115CD) return TRUE; // SIDDHAM SECTION MARK WITH RAYS AND DOTTED DOUBLE CRESCENTS
	if (c == 0x115CE) return TRUE; // SIDDHAM SECTION MARK WITH RAYS AND DOTTED TRIPLE CRESCENTS
	if (c == 0x115CF) return TRUE; // SIDDHAM SECTION MARK DOUBLE RING
	if (c == 0x115D0) return TRUE; // SIDDHAM SECTION MARK DOUBLE RING WITH RAYS
	if (c == 0x115D1) return TRUE; // SIDDHAM SECTION MARK WITH DOUBLE CRESCENTS
	if (c == 0x115D2) return TRUE; // SIDDHAM SECTION MARK WITH TRIPLE CRESCENTS
	if (c == 0x115D3) return TRUE; // SIDDHAM SECTION MARK WITH QUADRUPLE CRESCENTS
	if (c == 0x115D4) return TRUE; // SIDDHAM SECTION MARK WITH SEPTUPLE CRESCENTS
	if (c == 0x115D5) return TRUE; // SIDDHAM SECTION MARK WITH CIRCLES AND RAYS
	if (c == 0x115D6) return TRUE; // SIDDHAM SECTION MARK WITH CIRCLES AND TWO ENCLOSURES
	if (c == 0x115D7) return TRUE; // SIDDHAM SECTION MARK WITH CIRCLES AND FOUR ENCLOSURES
	if (c == 0x11641) return TRUE; // MODI DANDA
	if (c == 0x11642) return TRUE; // MODI DOUBLE DANDA
	if (c == 0x11643) return TRUE; // MODI ABBREVIATION SIGN
	if (c == 0x11660) return TRUE; // MONGOLIAN BIRGA WITH ORNAMENT
	if (c == 0x11661) return TRUE; // MONGOLIAN ROTATED BIRGA
	if (c == 0x11662) return TRUE; // MONGOLIAN DOUBLE BIRGA WITH ORNAMENT
	if (c == 0x11663) return TRUE; // MONGOLIAN TRIPLE BIRGA WITH ORNAMENT
	if (c == 0x11664) return TRUE; // MONGOLIAN BIRGA WITH DOUBLE ORNAMENT
	if (c == 0x11665) return TRUE; // MONGOLIAN ROTATED BIRGA WITH ORNAMENT
	if (c == 0x11666) return TRUE; // MONGOLIAN ROTATED BIRGA WITH DOUBLE ORNAMENT
	if (c == 0x11667) return TRUE; // MONGOLIAN INVERTED BIRGA
	if (c == 0x11668) return TRUE; // MONGOLIAN INVERTED BIRGA WITH DOUBLE ORNAMENT
	if (c == 0x11669) return TRUE; // MONGOLIAN SWIRL BIRGA
	if (c == 0x1166A) return TRUE; // MONGOLIAN SWIRL BIRGA WITH ORNAMENT
	if (c == 0x1166B) return TRUE; // MONGOLIAN SWIRL BIRGA WITH DOUBLE ORNAMENT
	if (c == 0x1166C) return TRUE; // MONGOLIAN TURNED SWIRL BIRGA WITH DOUBLE ORNAMENT
	if (c == 0x116B9) return TRUE; // TAKRI ABBREVIATION SIGN
	if (c == 0x1173C) return TRUE; // AHOM SIGN SMALL SECTION
	if (c == 0x1173D) return TRUE; // AHOM SIGN SECTION
	if (c == 0x1173E) return TRUE; // AHOM SIGN RULAI
	if (c == 0x1183B) return TRUE; // DOGRA ABBREVIATION SIGN
	if (c == 0x11944) return TRUE; // DIVES AKURU DOUBLE DANDA
	if (c == 0x11945) return TRUE; // DIVES AKURU GAP FILLER
	if (c == 0x11946) return TRUE; // DIVES AKURU END OF TEXT MARK
	if (c == 0x119E2) return TRUE; // NANDINAGARI SIGN SIDDHAM
	if (c == 0x11A3F) return TRUE; // ZANABAZAR SQUARE INITIAL HEAD MARK
	if (c == 0x11A40) return TRUE; // ZANABAZAR SQUARE CLOSING HEAD MARK
	if (c == 0x11A41) return TRUE; // ZANABAZAR SQUARE MARK TSHEG
	if (c == 0x11A42) return TRUE; // ZANABAZAR SQUARE MARK SHAD
	if (c == 0x11A43) return TRUE; // ZANABAZAR SQUARE MARK DOUBLE SHAD
	if (c == 0x11A44) return TRUE; // ZANABAZAR SQUARE MARK LONG TSHEG
	if (c == 0x11A45) return TRUE; // ZANABAZAR SQUARE INITIAL DOUBLE-LINED HEAD MARK
	if (c == 0x11A46) return TRUE; // ZANABAZAR SQUARE CLOSING DOUBLE-LINED HEAD MARK
	if (c == 0x11A9A) return TRUE; // SOYOMBO MARK TSHEG
	if (c == 0x11A9B) return TRUE; // SOYOMBO MARK SHAD
	if (c == 0x11A9C) return TRUE; // SOYOMBO MARK DOUBLE SHAD
	if (c == 0x11A9E) return TRUE; // SOYOMBO HEAD MARK WITH MOON AND SUN AND TRIPLE FLAME
	if (c == 0x11A9F) return TRUE; // SOYOMBO HEAD MARK WITH MOON AND SUN AND FLAME
	if (c == 0x11AA0) return TRUE; // SOYOMBO HEAD MARK WITH MOON AND SUN
	if (c == 0x11AA1) return TRUE; // SOYOMBO TERMINAL MARK-1
	if (c == 0x11AA2) return TRUE; // SOYOMBO TERMINAL MARK-2
	if (c == 0x11B00) return TRUE; // DEVANAGARI HEAD MARK
	if (c == 0x11B01) return TRUE; // DEVANAGARI HEAD MARK WITH HEADSTROKE
	if (c == 0x11B02) return TRUE; // DEVANAGARI SIGN BHALE
	if (c == 0x11B03) return TRUE; // DEVANAGARI SIGN BHALE WITH HOOK
	if (c == 0x11B04) return TRUE; // DEVANAGARI SIGN EXTENDED BHALE
	if (c == 0x11B05) return TRUE; // DEVANAGARI SIGN EXTENDED BHALE WITH HOOK
	if (c == 0x11B06) return TRUE; // DEVANAGARI SIGN WESTERN FIVE-LIKE BHALE
	if (c == 0x11B07) return TRUE; // DEVANAGARI SIGN WESTERN NINE-LIKE BHALE
	if (c == 0x11B08) return TRUE; // DEVANAGARI SIGN REVERSED NINE-LIKE BHALE
	if (c == 0x11B09) return TRUE; // DEVANAGARI SIGN MINDU
	if (c == 0x11C41) return TRUE; // BHAIKSUKI DANDA
	if (c == 0x11C42) return TRUE; // BHAIKSUKI DOUBLE DANDA
	if (c == 0x11C43) return TRUE; // BHAIKSUKI WORD SEPARATOR
	if (c == 0x11C44) return TRUE; // BHAIKSUKI GAP FILLER-1
	if (c == 0x11C45) return TRUE; // BHAIKSUKI GAP FILLER-2
	if (c == 0x11C70) return TRUE; // MARCHEN HEAD MARK
	if (c == 0x11C71) return TRUE; // MARCHEN MARK SHAD
	if (c == 0x11EF7) return TRUE; // MAKASAR PASSIMBANG
	if (c == 0x11EF8) return TRUE; // MAKASAR END OF SECTION
	if (c == 0x11F43) return TRUE; // KAWI DANDA
	if (c == 0x11F44) return TRUE; // KAWI DOUBLE DANDA
	if (c == 0x11F45) return TRUE; // KAWI PUNCTUATION SECTION MARKER
	if (c == 0x11F46) return TRUE; // KAWI PUNCTUATION ALTERNATE SECTION MARKER
	if (c == 0x11F47) return TRUE; // KAWI PUNCTUATION FLOWER
	if (c == 0x11F48) return TRUE; // KAWI PUNCTUATION SPACE FILLER
	if (c == 0x11F49) return TRUE; // KAWI PUNCTUATION DOT
	if (c == 0x11F4A) return TRUE; // KAWI PUNCTUATION DOUBLE DOT
	if (c == 0x11F4B) return TRUE; // KAWI PUNCTUATION TRIPLE DOT
	if (c == 0x11F4C) return TRUE; // KAWI PUNCTUATION CIRCLE
	if (c == 0x11F4D) return TRUE; // KAWI PUNCTUATION FILLED CIRCLE
	if (c == 0x11F4E) return TRUE; // KAWI PUNCTUATION SPIRAL
	if (c == 0x11F4F) return TRUE; // KAWI PUNCTUATION CLOSING SPIRAL
	if (c == 0x11FFF) return TRUE; // TAMIL PUNCTUATION END OF TEXT
	if (c == 0x12470) return TRUE; // CUNEIFORM PUNCTUATION SIGN OLD ASSYRIAN WORD DIVIDER
	if (c == 0x12471) return TRUE; // CUNEIFORM PUNCTUATION SIGN VERTICAL COLON
	if (c == 0x12472) return TRUE; // CUNEIFORM PUNCTUATION SIGN DIAGONAL COLON
	if (c == 0x12473) return TRUE; // CUNEIFORM PUNCTUATION SIGN DIAGONAL TRICOLON
	if (c == 0x12474) return TRUE; // CUNEIFORM PUNCTUATION SIGN DIAGONAL QUADCOLON
	if (c == 0x12FF1) return TRUE; // CYPRO-MINOAN SIGN CM301
	if (c == 0x12FF2) return TRUE; // CYPRO-MINOAN SIGN CM302
	if (c == 0x16A6E) return TRUE; // MRO DANDA
	if (c == 0x16A6F) return TRUE; // MRO DOUBLE DANDA
	if (c == 0x16AF5) return TRUE; // BASSA VAH FULL STOP
	if (c == 0x16B37) return TRUE; // PAHAWH HMONG SIGN VOS THOM
	if (c == 0x16B38) return TRUE; // PAHAWH HMONG SIGN VOS TSHAB CEEB
	if (c == 0x16B39) return TRUE; // PAHAWH HMONG SIGN CIM CHEEM
	if (c == 0x16B3A) return TRUE; // PAHAWH HMONG SIGN VOS THIAB
	if (c == 0x16B3B) return TRUE; // PAHAWH HMONG SIGN VOS FEEM
	if (c == 0x16B44) return TRUE; // PAHAWH HMONG SIGN XAUS
	if (c == 0x16E97) return TRUE; // MEDEFAIDRIN COMMA
	if (c == 0x16E98) return TRUE; // MEDEFAIDRIN FULL STOP
	if (c == 0x16E99) return TRUE; // MEDEFAIDRIN SYMBOL AIVA
	if (c == 0x16E9A) return TRUE; // MEDEFAIDRIN EXCLAMATION OH
	if (c == 0x16FE2) return TRUE; // OLD CHINESE HOOK MARK
	if (c == 0x1BC9F) return TRUE; // DUPLOYAN PUNCTUATION CHINOOK FULL STOP
	if (c == 0x1DA87) return TRUE; // SIGNWRITING COMMA
	if (c == 0x1DA88) return TRUE; // SIGNWRITING FULL STOP
	if (c == 0x1DA89) return TRUE; // SIGNWRITING SEMICOLON
	if (c == 0x1DA8A) return TRUE; // SIGNWRITING COLON
	if (c == 0x1DA8B) return TRUE; // SIGNWRITING PARENTHESIS
	if (c == 0x1E95E) return TRUE; // ADLAM INITIAL EXCLAMATION MARK
	if (c == 0x1E95F) return TRUE; // ADLAM INITIAL QUESTION MARK
	return FALSE;
}

#line 937 "inweb/foundation-module/Chapter 4/Characters.w"
void Characters__full_Unicode_fold(inchar32_t c, inchar32_t *F) {
	F[1] = 0; F[2] = 0; F[3] = 0;
	if (c < 0x0100) {
		if ((c >= 0x0041) && (c <= 0x005A)) { F[0] = 0x0061 + (c - 0x0041); return; } /* LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z */
		if (c == 0x00B5) { F[0] = 0x03BC; return; } /* MICRO SIGN */
		if ((c >= 0x00C0) && (c <= 0x00D6)) { F[0] = 0x00E0 + (c - 0x00C0); return; } /* LATIN CAPITAL LETTER A WITH GRAVE to LATIN CAPITAL LETTER O WITH DIAERESIS */
		if ((c >= 0x00D8) && (c <= 0x00DE)) { F[0] = 0x00F8 + (c - 0x00D8); return; } /* LATIN CAPITAL LETTER O WITH STROKE to LATIN CAPITAL LETTER THORN */
		if (c == 0x00DF) { F[0] = 0x0073; F[1] = 0x0073; return; } /* LATIN SMALL LETTER SHARP S */
	} else if ((c >= 0x0100) && (c < 0x0200)) {
		if (c == 0x0100) { F[0] = 0x0101; return; } /* LATIN CAPITAL LETTER A WITH MACRON */
		if (c == 0x0102) { F[0] = 0x0103; return; } /* LATIN CAPITAL LETTER A WITH BREVE */
		if (c == 0x0104) { F[0] = 0x0105; return; } /* LATIN CAPITAL LETTER A WITH OGONEK */
		if (c == 0x0106) { F[0] = 0x0107; return; } /* LATIN CAPITAL LETTER C WITH ACUTE */
		if (c == 0x0108) { F[0] = 0x0109; return; } /* LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
		if (c == 0x010A) { F[0] = 0x010B; return; } /* LATIN CAPITAL LETTER C WITH DOT ABOVE */
		if (c == 0x010C) { F[0] = 0x010D; return; } /* LATIN CAPITAL LETTER C WITH CARON */
		if (c == 0x010E) { F[0] = 0x010F; return; } /* LATIN CAPITAL LETTER D WITH CARON */
		if (c == 0x0110) { F[0] = 0x0111; return; } /* LATIN CAPITAL LETTER D WITH STROKE */
		if (c == 0x0112) { F[0] = 0x0113; return; } /* LATIN CAPITAL LETTER E WITH MACRON */
		if (c == 0x0114) { F[0] = 0x0115; return; } /* LATIN CAPITAL LETTER E WITH BREVE */
		if (c == 0x0116) { F[0] = 0x0117; return; } /* LATIN CAPITAL LETTER E WITH DOT ABOVE */
		if (c == 0x0118) { F[0] = 0x0119; return; } /* LATIN CAPITAL LETTER E WITH OGONEK */
		if (c == 0x011A) { F[0] = 0x011B; return; } /* LATIN CAPITAL LETTER E WITH CARON */
		if (c == 0x011C) { F[0] = 0x011D; return; } /* LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
		if (c == 0x011E) { F[0] = 0x011F; return; } /* LATIN CAPITAL LETTER G WITH BREVE */
		if (c == 0x0120) { F[0] = 0x0121; return; } /* LATIN CAPITAL LETTER G WITH DOT ABOVE */
		if (c == 0x0122) { F[0] = 0x0123; return; } /* LATIN CAPITAL LETTER G WITH CEDILLA */
		if (c == 0x0124) { F[0] = 0x0125; return; } /* LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
		if (c == 0x0126) { F[0] = 0x0127; return; } /* LATIN CAPITAL LETTER H WITH STROKE */
		if (c == 0x0128) { F[0] = 0x0129; return; } /* LATIN CAPITAL LETTER I WITH TILDE */
		if (c == 0x012A) { F[0] = 0x012B; return; } /* LATIN CAPITAL LETTER I WITH MACRON */
		if (c == 0x012C) { F[0] = 0x012D; return; } /* LATIN CAPITAL LETTER I WITH BREVE */
		if (c == 0x012E) { F[0] = 0x012F; return; } /* LATIN CAPITAL LETTER I WITH OGONEK */
		if (c == 0x0130) { F[0] = 0x0069; F[1] = 0x0307; return; } /* LATIN CAPITAL LETTER I WITH DOT ABOVE */
		if (c == 0x0132) { F[0] = 0x0133; return; } /* LATIN CAPITAL LIGATURE IJ */
		if (c == 0x0134) { F[0] = 0x0135; return; } /* LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
		if (c == 0x0136) { F[0] = 0x0137; return; } /* LATIN CAPITAL LETTER K WITH CEDILLA */
		if (c == 0x0139) { F[0] = 0x013A; return; } /* LATIN CAPITAL LETTER L WITH ACUTE */
		if (c == 0x013B) { F[0] = 0x013C; return; } /* LATIN CAPITAL LETTER L WITH CEDILLA */
		if (c == 0x013D) { F[0] = 0x013E; return; } /* LATIN CAPITAL LETTER L WITH CARON */
		if (c == 0x013F) { F[0] = 0x0140; return; } /* LATIN CAPITAL LETTER L WITH MIDDLE DOT */
		if (c == 0x0141) { F[0] = 0x0142; return; } /* LATIN CAPITAL LETTER L WITH STROKE */
		if (c == 0x0143) { F[0] = 0x0144; return; } /* LATIN CAPITAL LETTER N WITH ACUTE */
		if (c == 0x0145) { F[0] = 0x0146; return; } /* LATIN CAPITAL LETTER N WITH CEDILLA */
		if (c == 0x0147) { F[0] = 0x0148; return; } /* LATIN CAPITAL LETTER N WITH CARON */
		if (c == 0x0149) { F[0] = 0x02BC; F[1] = 0x006E; return; } /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */
		if (c == 0x014A) { F[0] = 0x014B; return; } /* LATIN CAPITAL LETTER ENG */
		if (c == 0x014C) { F[0] = 0x014D; return; } /* LATIN CAPITAL LETTER O WITH MACRON */
		if (c == 0x014E) { F[0] = 0x014F; return; } /* LATIN CAPITAL LETTER O WITH BREVE */
		if (c == 0x0150) { F[0] = 0x0151; return; } /* LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
		if (c == 0x0152) { F[0] = 0x0153; return; } /* LATIN CAPITAL LIGATURE OE */
		if (c == 0x0154) { F[0] = 0x0155; return; } /* LATIN CAPITAL LETTER R WITH ACUTE */
		if (c == 0x0156) { F[0] = 0x0157; return; } /* LATIN CAPITAL LETTER R WITH CEDILLA */
		if (c == 0x0158) { F[0] = 0x0159; return; } /* LATIN CAPITAL LETTER R WITH CARON */
		if (c == 0x015A) { F[0] = 0x015B; return; } /* LATIN CAPITAL LETTER S WITH ACUTE */
		if (c == 0x015C) { F[0] = 0x015D; return; } /* LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
		if (c == 0x015E) { F[0] = 0x015F; return; } /* LATIN CAPITAL LETTER S WITH CEDILLA */
		if (c == 0x0160) { F[0] = 0x0161; return; } /* LATIN CAPITAL LETTER S WITH CARON */
		if (c == 0x0162) { F[0] = 0x0163; return; } /* LATIN CAPITAL LETTER T WITH CEDILLA */
		if (c == 0x0164) { F[0] = 0x0165; return; } /* LATIN CAPITAL LETTER T WITH CARON */
		if (c == 0x0166) { F[0] = 0x0167; return; } /* LATIN CAPITAL LETTER T WITH STROKE */
		if (c == 0x0168) { F[0] = 0x0169; return; } /* LATIN CAPITAL LETTER U WITH TILDE */
		if (c == 0x016A) { F[0] = 0x016B; return; } /* LATIN CAPITAL LETTER U WITH MACRON */
		if (c == 0x016C) { F[0] = 0x016D; return; } /* LATIN CAPITAL LETTER U WITH BREVE */
		if (c == 0x016E) { F[0] = 0x016F; return; } /* LATIN CAPITAL LETTER U WITH RING ABOVE */
		if (c == 0x0170) { F[0] = 0x0171; return; } /* LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
		if (c == 0x0172) { F[0] = 0x0173; return; } /* LATIN CAPITAL LETTER U WITH OGONEK */
		if (c == 0x0174) { F[0] = 0x0175; return; } /* LATIN CAPITAL LETTER W WITH CIRCUMFLEX */
		if (c == 0x0176) { F[0] = 0x0177; return; } /* LATIN CAPITAL LETTER Y WITH CIRCUMFLEX */
		if (c == 0x0178) { F[0] = 0x00FF; return; } /* LATIN CAPITAL LETTER Y WITH DIAERESIS */
		if (c == 0x0179) { F[0] = 0x017A; return; } /* LATIN CAPITAL LETTER Z WITH ACUTE */
		if (c == 0x017B) { F[0] = 0x017C; return; } /* LATIN CAPITAL LETTER Z WITH DOT ABOVE */
		if (c == 0x017D) { F[0] = 0x017E; return; } /* LATIN CAPITAL LETTER Z WITH CARON */
		if (c == 0x017F) { F[0] = 0x0073; return; } /* LATIN SMALL LETTER LONG S */
		if (c == 0x0181) { F[0] = 0x0253; return; } /* LATIN CAPITAL LETTER B WITH HOOK */
		if (c == 0x0182) { F[0] = 0x0183; return; } /* LATIN CAPITAL LETTER B WITH TOPBAR */
		if (c == 0x0184) { F[0] = 0x0185; return; } /* LATIN CAPITAL LETTER TONE SIX */
		if (c == 0x0186) { F[0] = 0x0254; return; } /* LATIN CAPITAL LETTER OPEN O */
		if (c == 0x0187) { F[0] = 0x0188; return; } /* LATIN CAPITAL LETTER C WITH HOOK */
		if (c == 0x0189) { F[0] = 0x0256; return; } /* LATIN CAPITAL LETTER AFRICAN D */
		if (c == 0x018A) { F[0] = 0x0257; return; } /* LATIN CAPITAL LETTER D WITH HOOK */
		if (c == 0x018B) { F[0] = 0x018C; return; } /* LATIN CAPITAL LETTER D WITH TOPBAR */
		if (c == 0x018E) { F[0] = 0x01DD; return; } /* LATIN CAPITAL LETTER REVERSED E */
		if (c == 0x018F) { F[0] = 0x0259; return; } /* LATIN CAPITAL LETTER SCHWA */
		if (c == 0x0190) { F[0] = 0x025B; return; } /* LATIN CAPITAL LETTER OPEN E */
		if (c == 0x0191) { F[0] = 0x0192; return; } /* LATIN CAPITAL LETTER F WITH HOOK */
		if (c == 0x0193) { F[0] = 0x0260; return; } /* LATIN CAPITAL LETTER G WITH HOOK */
		if (c == 0x0194) { F[0] = 0x0263; return; } /* LATIN CAPITAL LETTER GAMMA */
		if (c == 0x0196) { F[0] = 0x0269; return; } /* LATIN CAPITAL LETTER IOTA */
		if (c == 0x0197) { F[0] = 0x0268; return; } /* LATIN CAPITAL LETTER I WITH STROKE */
		if (c == 0x0198) { F[0] = 0x0199; return; } /* LATIN CAPITAL LETTER K WITH HOOK */
		if (c == 0x019C) { F[0] = 0x026F; return; } /* LATIN CAPITAL LETTER TURNED M */
		if (c == 0x019D) { F[0] = 0x0272; return; } /* LATIN CAPITAL LETTER N WITH LEFT HOOK */
		if (c == 0x019F) { F[0] = 0x0275; return; } /* LATIN CAPITAL LETTER O WITH MIDDLE TILDE */
		if (c == 0x01A0) { F[0] = 0x01A1; return; } /* LATIN CAPITAL LETTER O WITH HORN */
		if (c == 0x01A2) { F[0] = 0x01A3; return; } /* LATIN CAPITAL LETTER OI */
		if (c == 0x01A4) { F[0] = 0x01A5; return; } /* LATIN CAPITAL LETTER P WITH HOOK */
		if (c == 0x01A6) { F[0] = 0x0280; return; } /* LATIN LETTER YR */
		if (c == 0x01A7) { F[0] = 0x01A8; return; } /* LATIN CAPITAL LETTER TONE TWO */
		if (c == 0x01A9) { F[0] = 0x0283; return; } /* LATIN CAPITAL LETTER ESH */
		if (c == 0x01AC) { F[0] = 0x01AD; return; } /* LATIN CAPITAL LETTER T WITH HOOK */
		if (c == 0x01AE) { F[0] = 0x0288; return; } /* LATIN CAPITAL LETTER T WITH RETROFLEX HOOK */
		if (c == 0x01AF) { F[0] = 0x01B0; return; } /* LATIN CAPITAL LETTER U WITH HORN */
		if (c == 0x01B1) { F[0] = 0x028A; return; } /* LATIN CAPITAL LETTER UPSILON */
		if (c == 0x01B2) { F[0] = 0x028B; return; } /* LATIN CAPITAL LETTER V WITH HOOK */
		if (c == 0x01B3) { F[0] = 0x01B4; return; } /* LATIN CAPITAL LETTER Y WITH HOOK */
		if (c == 0x01B5) { F[0] = 0x01B6; return; } /* LATIN CAPITAL LETTER Z WITH STROKE */
		if (c == 0x01B7) { F[0] = 0x0292; return; } /* LATIN CAPITAL LETTER EZH */
		if (c == 0x01B8) { F[0] = 0x01B9; return; } /* LATIN CAPITAL LETTER EZH REVERSED */
		if (c == 0x01BC) { F[0] = 0x01BD; return; } /* LATIN CAPITAL LETTER TONE FIVE */
		if (c == 0x01C4) { F[0] = 0x01C6; return; } /* LATIN CAPITAL LETTER DZ WITH CARON */
		if (c == 0x01C5) { F[0] = 0x01C6; return; } /* LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON */
		if (c == 0x01C7) { F[0] = 0x01C9; return; } /* LATIN CAPITAL LETTER LJ */
		if (c == 0x01C8) { F[0] = 0x01C9; return; } /* LATIN CAPITAL LETTER L WITH SMALL LETTER J */
		if (c == 0x01CA) { F[0] = 0x01CC; return; } /* LATIN CAPITAL LETTER NJ */
		if (c == 0x01CB) { F[0] = 0x01CC; return; } /* LATIN CAPITAL LETTER N WITH SMALL LETTER J */
		if (c == 0x01CD) { F[0] = 0x01CE; return; } /* LATIN CAPITAL LETTER A WITH CARON */
		if (c == 0x01CF) { F[0] = 0x01D0; return; } /* LATIN CAPITAL LETTER I WITH CARON */
		if (c == 0x01D1) { F[0] = 0x01D2; return; } /* LATIN CAPITAL LETTER O WITH CARON */
		if (c == 0x01D3) { F[0] = 0x01D4; return; } /* LATIN CAPITAL LETTER U WITH CARON */
		if (c == 0x01D5) { F[0] = 0x01D6; return; } /* LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON */
		if (c == 0x01D7) { F[0] = 0x01D8; return; } /* LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE */
		if (c == 0x01D9) { F[0] = 0x01DA; return; } /* LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON */
		if (c == 0x01DB) { F[0] = 0x01DC; return; } /* LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE */
		if (c == 0x01DE) { F[0] = 0x01DF; return; } /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */
		if (c == 0x01E0) { F[0] = 0x01E1; return; } /* LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON */
		if (c == 0x01E2) { F[0] = 0x01E3; return; } /* LATIN CAPITAL LETTER AE WITH MACRON */
		if (c == 0x01E4) { F[0] = 0x01E5; return; } /* LATIN CAPITAL LETTER G WITH STROKE */
		if (c == 0x01E6) { F[0] = 0x01E7; return; } /* LATIN CAPITAL LETTER G WITH CARON */
		if (c == 0x01E8) { F[0] = 0x01E9; return; } /* LATIN CAPITAL LETTER K WITH CARON */
		if (c == 0x01EA) { F[0] = 0x01EB; return; } /* LATIN CAPITAL LETTER O WITH OGONEK */
		if (c == 0x01EC) { F[0] = 0x01ED; return; } /* LATIN CAPITAL LETTER O WITH OGONEK AND MACRON */
		if (c == 0x01EE) { F[0] = 0x01EF; return; } /* LATIN CAPITAL LETTER EZH WITH CARON */
		if (c == 0x01F0) { F[0] = 0x006A; F[1] = 0x030C; return; } /* LATIN SMALL LETTER J WITH CARON */
		if (c == 0x01F1) { F[0] = 0x01F3; return; } /* LATIN CAPITAL LETTER DZ */
		if (c == 0x01F2) { F[0] = 0x01F3; return; } /* LATIN CAPITAL LETTER D WITH SMALL LETTER Z */
		if (c == 0x01F4) { F[0] = 0x01F5; return; } /* LATIN CAPITAL LETTER G WITH ACUTE */
		if (c == 0x01F6) { F[0] = 0x0195; return; } /* LATIN CAPITAL LETTER HWAIR */
		if (c == 0x01F7) { F[0] = 0x01BF; return; } /* LATIN CAPITAL LETTER WYNN */
		if (c == 0x01F8) { F[0] = 0x01F9; return; } /* LATIN CAPITAL LETTER N WITH GRAVE */
		if (c == 0x01FA) { F[0] = 0x01FB; return; } /* LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE */
		if (c == 0x01FC) { F[0] = 0x01FD; return; } /* LATIN CAPITAL LETTER AE WITH ACUTE */
		if (c == 0x01FE) { F[0] = 0x01FF; return; } /* LATIN CAPITAL LETTER O WITH STROKE AND ACUTE */
	} else if ((c >= 0x0200) && (c < 0x0300)) {
		if (c == 0x0200) { F[0] = 0x0201; return; } /* LATIN CAPITAL LETTER A WITH DOUBLE GRAVE */
		if (c == 0x0202) { F[0] = 0x0203; return; } /* LATIN CAPITAL LETTER A WITH INVERTED BREVE */
		if (c == 0x0204) { F[0] = 0x0205; return; } /* LATIN CAPITAL LETTER E WITH DOUBLE GRAVE */
		if (c == 0x0206) { F[0] = 0x0207; return; } /* LATIN CAPITAL LETTER E WITH INVERTED BREVE */
		if (c == 0x0208) { F[0] = 0x0209; return; } /* LATIN CAPITAL LETTER I WITH DOUBLE GRAVE */
		if (c == 0x020A) { F[0] = 0x020B; return; } /* LATIN CAPITAL LETTER I WITH INVERTED BREVE */
		if (c == 0x020C) { F[0] = 0x020D; return; } /* LATIN CAPITAL LETTER O WITH DOUBLE GRAVE */
		if (c == 0x020E) { F[0] = 0x020F; return; } /* LATIN CAPITAL LETTER O WITH INVERTED BREVE */
		if (c == 0x0210) { F[0] = 0x0211; return; } /* LATIN CAPITAL LETTER R WITH DOUBLE GRAVE */
		if (c == 0x0212) { F[0] = 0x0213; return; } /* LATIN CAPITAL LETTER R WITH INVERTED BREVE */
		if (c == 0x0214) { F[0] = 0x0215; return; } /* LATIN CAPITAL LETTER U WITH DOUBLE GRAVE */
		if (c == 0x0216) { F[0] = 0x0217; return; } /* LATIN CAPITAL LETTER U WITH INVERTED BREVE */
		if (c == 0x0218) { F[0] = 0x0219; return; } /* LATIN CAPITAL LETTER S WITH COMMA BELOW */
		if (c == 0x021A) { F[0] = 0x021B; return; } /* LATIN CAPITAL LETTER T WITH COMMA BELOW */
		if (c == 0x021C) { F[0] = 0x021D; return; } /* LATIN CAPITAL LETTER YOGH */
		if (c == 0x021E) { F[0] = 0x021F; return; } /* LATIN CAPITAL LETTER H WITH CARON */
		if (c == 0x0220) { F[0] = 0x019E; return; } /* LATIN CAPITAL LETTER N WITH LONG RIGHT LEG */
		if (c == 0x0222) { F[0] = 0x0223; return; } /* LATIN CAPITAL LETTER OU */
		if (c == 0x0224) { F[0] = 0x0225; return; } /* LATIN CAPITAL LETTER Z WITH HOOK */
		if (c == 0x0226) { F[0] = 0x0227; return; } /* LATIN CAPITAL LETTER A WITH DOT ABOVE */
		if (c == 0x0228) { F[0] = 0x0229; return; } /* LATIN CAPITAL LETTER E WITH CEDILLA */
		if (c == 0x022A) { F[0] = 0x022B; return; } /* LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON */
		if (c == 0x022C) { F[0] = 0x022D; return; } /* LATIN CAPITAL LETTER O WITH TILDE AND MACRON */
		if (c == 0x022E) { F[0] = 0x022F; return; } /* LATIN CAPITAL LETTER O WITH DOT ABOVE */
		if (c == 0x0230) { F[0] = 0x0231; return; } /* LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON */
		if (c == 0x0232) { F[0] = 0x0233; return; } /* LATIN CAPITAL LETTER Y WITH MACRON */
		if (c == 0x023A) { F[0] = 0x2C65; return; } /* LATIN CAPITAL LETTER A WITH STROKE */
		if (c == 0x023B) { F[0] = 0x023C; return; } /* LATIN CAPITAL LETTER C WITH STROKE */
		if (c == 0x023D) { F[0] = 0x019A; return; } /* LATIN CAPITAL LETTER L WITH BAR */
		if (c == 0x023E) { F[0] = 0x2C66; return; } /* LATIN CAPITAL LETTER T WITH DIAGONAL STROKE */
		if (c == 0x0241) { F[0] = 0x0242; return; } /* LATIN CAPITAL LETTER GLOTTAL STOP */
		if (c == 0x0243) { F[0] = 0x0180; return; } /* LATIN CAPITAL LETTER B WITH STROKE */
		if (c == 0x0244) { F[0] = 0x0289; return; } /* LATIN CAPITAL LETTER U BAR */
		if (c == 0x0245) { F[0] = 0x028C; return; } /* LATIN CAPITAL LETTER TURNED V */
		if (c == 0x0246) { F[0] = 0x0247; return; } /* LATIN CAPITAL LETTER E WITH STROKE */
		if (c == 0x0248) { F[0] = 0x0249; return; } /* LATIN CAPITAL LETTER J WITH STROKE */
		if (c == 0x024A) { F[0] = 0x024B; return; } /* LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL */
		if (c == 0x024C) { F[0] = 0x024D; return; } /* LATIN CAPITAL LETTER R WITH STROKE */
		if (c == 0x024E) { F[0] = 0x024F; return; } /* LATIN CAPITAL LETTER Y WITH STROKE */
	} else if ((c >= 0x0300) && (c < 0x0400)) {
		if (c == 0x0345) { F[0] = 0x03B9; return; } /* COMBINING GREEK YPOGEGRAMMENI */
		if (c == 0x0370) { F[0] = 0x0371; return; } /* GREEK CAPITAL LETTER HETA */
		if (c == 0x0372) { F[0] = 0x0373; return; } /* GREEK CAPITAL LETTER ARCHAIC SAMPI */
		if (c == 0x0376) { F[0] = 0x0377; return; } /* GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA */
		if (c == 0x037F) { F[0] = 0x03F3; return; } /* GREEK CAPITAL LETTER YOT */
		if (c == 0x0386) { F[0] = 0x03AC; return; } /* GREEK CAPITAL LETTER ALPHA WITH TONOS */
		if ((c >= 0x0388) && (c <= 0x038A)) { F[0] = 0x03AD + (c - 0x0388); return; } /* GREEK CAPITAL LETTER EPSILON WITH TONOS to GREEK CAPITAL LETTER IOTA WITH TONOS */
		if (c == 0x038C) { F[0] = 0x03CC; return; } /* GREEK CAPITAL LETTER OMICRON WITH TONOS */
		if (c == 0x038E) { F[0] = 0x03CD; return; } /* GREEK CAPITAL LETTER UPSILON WITH TONOS */
		if (c == 0x038F) { F[0] = 0x03CE; return; } /* GREEK CAPITAL LETTER OMEGA WITH TONOS */
		if (c == 0x0390) { F[0] = 0x03B9; F[1] = 0x0308; F[2] = 0x0301; return; } /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
		if ((c >= 0x0391) && (c <= 0x03A1)) { F[0] = 0x03B1 + (c - 0x0391); return; } /* GREEK CAPITAL LETTER ALPHA to GREEK CAPITAL LETTER RHO */
		if ((c >= 0x03A3) && (c <= 0x03AB)) { F[0] = 0x03C3 + (c - 0x03A3); return; } /* GREEK CAPITAL LETTER SIGMA to GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
		if (c == 0x03B0) { F[0] = 0x03C5; F[1] = 0x0308; F[2] = 0x0301; return; } /* GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
		if (c == 0x03C2) { F[0] = 0x03C3; return; } /* GREEK SMALL LETTER FINAL SIGMA */
		if (c == 0x03CF) { F[0] = 0x03D7; return; } /* GREEK CAPITAL KAI SYMBOL */
		if (c == 0x03D0) { F[0] = 0x03B2; return; } /* GREEK BETA SYMBOL */
		if (c == 0x03D1) { F[0] = 0x03B8; return; } /* GREEK THETA SYMBOL */
		if (c == 0x03D5) { F[0] = 0x03C6; return; } /* GREEK PHI SYMBOL */
		if (c == 0x03D6) { F[0] = 0x03C0; return; } /* GREEK PI SYMBOL */
		if (c == 0x03D8) { F[0] = 0x03D9; return; } /* GREEK LETTER ARCHAIC KOPPA */
		if (c == 0x03DA) { F[0] = 0x03DB; return; } /* GREEK LETTER STIGMA */
		if (c == 0x03DC) { F[0] = 0x03DD; return; } /* GREEK LETTER DIGAMMA */
		if (c == 0x03DE) { F[0] = 0x03DF; return; } /* GREEK LETTER KOPPA */
		if (c == 0x03E0) { F[0] = 0x03E1; return; } /* GREEK LETTER SAMPI */
		if (c == 0x03E2) { F[0] = 0x03E3; return; } /* COPTIC CAPITAL LETTER SHEI */
		if (c == 0x03E4) { F[0] = 0x03E5; return; } /* COPTIC CAPITAL LETTER FEI */
		if (c == 0x03E6) { F[0] = 0x03E7; return; } /* COPTIC CAPITAL LETTER KHEI */
		if (c == 0x03E8) { F[0] = 0x03E9; return; } /* COPTIC CAPITAL LETTER HORI */
		if (c == 0x03EA) { F[0] = 0x03EB; return; } /* COPTIC CAPITAL LETTER GANGIA */
		if (c == 0x03EC) { F[0] = 0x03ED; return; } /* COPTIC CAPITAL LETTER SHIMA */
		if (c == 0x03EE) { F[0] = 0x03EF; return; } /* COPTIC CAPITAL LETTER DEI */
		if (c == 0x03F0) { F[0] = 0x03BA; return; } /* GREEK KAPPA SYMBOL */
		if (c == 0x03F1) { F[0] = 0x03C1; return; } /* GREEK RHO SYMBOL */
		if (c == 0x03F4) { F[0] = 0x03B8; return; } /* GREEK CAPITAL THETA SYMBOL */
		if (c == 0x03F5) { F[0] = 0x03B5; return; } /* GREEK LUNATE EPSILON SYMBOL */
		if (c == 0x03F7) { F[0] = 0x03F8; return; } /* GREEK CAPITAL LETTER SHO */
		if (c == 0x03F9) { F[0] = 0x03F2; return; } /* GREEK CAPITAL LUNATE SIGMA SYMBOL */
		if (c == 0x03FA) { F[0] = 0x03FB; return; } /* GREEK CAPITAL LETTER SAN */
		if ((c >= 0x03FD) && (c <= 0x03FF)) { F[0] = 0x037B + (c - 0x03FD); return; } /* GREEK CAPITAL REVERSED LUNATE SIGMA SYMBOL to GREEK CAPITAL REVERSED DOTTED LUNATE SIGMA SYMBOL */
	} else if ((c >= 0x0400) && (c < 0x0500)) {
		if ((c >= 0x0400) && (c <= 0x040F)) { F[0] = 0x0450 + (c - 0x0400); return; } /* CYRILLIC CAPITAL LETTER IE WITH GRAVE to CYRILLIC CAPITAL LETTER DZHE */
		if ((c >= 0x0410) && (c <= 0x042F)) { F[0] = 0x0430 + (c - 0x0410); return; } /* CYRILLIC CAPITAL LETTER A to CYRILLIC CAPITAL LETTER YA */
		if (c == 0x0460) { F[0] = 0x0461; return; } /* CYRILLIC CAPITAL LETTER OMEGA */
		if (c == 0x0462) { F[0] = 0x0463; return; } /* CYRILLIC CAPITAL LETTER YAT */
		if (c == 0x0464) { F[0] = 0x0465; return; } /* CYRILLIC CAPITAL LETTER IOTIFIED E */
		if (c == 0x0466) { F[0] = 0x0467; return; } /* CYRILLIC CAPITAL LETTER LITTLE YUS */
		if (c == 0x0468) { F[0] = 0x0469; return; } /* CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS */
		if (c == 0x046A) { F[0] = 0x046B; return; } /* CYRILLIC CAPITAL LETTER BIG YUS */
		if (c == 0x046C) { F[0] = 0x046D; return; } /* CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS */
		if (c == 0x046E) { F[0] = 0x046F; return; } /* CYRILLIC CAPITAL LETTER KSI */
		if (c == 0x0470) { F[0] = 0x0471; return; } /* CYRILLIC CAPITAL LETTER PSI */
		if (c == 0x0472) { F[0] = 0x0473; return; } /* CYRILLIC CAPITAL LETTER FITA */
		if (c == 0x0474) { F[0] = 0x0475; return; } /* CYRILLIC CAPITAL LETTER IZHITSA */
		if (c == 0x0476) { F[0] = 0x0477; return; } /* CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT */
		if (c == 0x0478) { F[0] = 0x0479; return; } /* CYRILLIC CAPITAL LETTER UK */
		if (c == 0x047A) { F[0] = 0x047B; return; } /* CYRILLIC CAPITAL LETTER ROUND OMEGA */
		if (c == 0x047C) { F[0] = 0x047D; return; } /* CYRILLIC CAPITAL LETTER OMEGA WITH TITLO */
		if (c == 0x047E) { F[0] = 0x047F; return; } /* CYRILLIC CAPITAL LETTER OT */
		if (c == 0x0480) { F[0] = 0x0481; return; } /* CYRILLIC CAPITAL LETTER KOPPA */
		if (c == 0x048A) { F[0] = 0x048B; return; } /* CYRILLIC CAPITAL LETTER SHORT I WITH TAIL */
		if (c == 0x048C) { F[0] = 0x048D; return; } /* CYRILLIC CAPITAL LETTER SEMISOFT SIGN */
		if (c == 0x048E) { F[0] = 0x048F; return; } /* CYRILLIC CAPITAL LETTER ER WITH TICK */
		if (c == 0x0490) { F[0] = 0x0491; return; } /* CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
		if (c == 0x0492) { F[0] = 0x0493; return; } /* CYRILLIC CAPITAL LETTER GHE WITH STROKE */
		if (c == 0x0494) { F[0] = 0x0495; return; } /* CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK */
		if (c == 0x0496) { F[0] = 0x0497; return; } /* CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER */
		if (c == 0x0498) { F[0] = 0x0499; return; } /* CYRILLIC CAPITAL LETTER ZE WITH DESCENDER */
		if (c == 0x049A) { F[0] = 0x049B; return; } /* CYRILLIC CAPITAL LETTER KA WITH DESCENDER */
		if (c == 0x049C) { F[0] = 0x049D; return; } /* CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE */
		if (c == 0x049E) { F[0] = 0x049F; return; } /* CYRILLIC CAPITAL LETTER KA WITH STROKE */
		if (c == 0x04A0) { F[0] = 0x04A1; return; } /* CYRILLIC CAPITAL LETTER BASHKIR KA */
		if (c == 0x04A2) { F[0] = 0x04A3; return; } /* CYRILLIC CAPITAL LETTER EN WITH DESCENDER */
		if (c == 0x04A4) { F[0] = 0x04A5; return; } /* CYRILLIC CAPITAL LIGATURE EN GHE */
		if (c == 0x04A6) { F[0] = 0x04A7; return; } /* CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK */
		if (c == 0x04A8) { F[0] = 0x04A9; return; } /* CYRILLIC CAPITAL LETTER ABKHASIAN HA */
		if (c == 0x04AA) { F[0] = 0x04AB; return; } /* CYRILLIC CAPITAL LETTER ES WITH DESCENDER */
		if (c == 0x04AC) { F[0] = 0x04AD; return; } /* CYRILLIC CAPITAL LETTER TE WITH DESCENDER */
		if (c == 0x04AE) { F[0] = 0x04AF; return; } /* CYRILLIC CAPITAL LETTER STRAIGHT U */
		if (c == 0x04B0) { F[0] = 0x04B1; return; } /* CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE */
		if (c == 0x04B2) { F[0] = 0x04B3; return; } /* CYRILLIC CAPITAL LETTER HA WITH DESCENDER */
		if (c == 0x04B4) { F[0] = 0x04B5; return; } /* CYRILLIC CAPITAL LIGATURE TE TSE */
		if (c == 0x04B6) { F[0] = 0x04B7; return; } /* CYRILLIC CAPITAL LETTER CHE WITH DESCENDER */
		if (c == 0x04B8) { F[0] = 0x04B9; return; } /* CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE */
		if (c == 0x04BA) { F[0] = 0x04BB; return; } /* CYRILLIC CAPITAL LETTER SHHA */
		if (c == 0x04BC) { F[0] = 0x04BD; return; } /* CYRILLIC CAPITAL LETTER ABKHASIAN CHE */
		if (c == 0x04BE) { F[0] = 0x04BF; return; } /* CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER */
		if (c == 0x04C0) { F[0] = 0x04CF; return; } /* CYRILLIC LETTER PALOCHKA */
		if (c == 0x04C1) { F[0] = 0x04C2; return; } /* CYRILLIC CAPITAL LETTER ZHE WITH BREVE */
		if (c == 0x04C3) { F[0] = 0x04C4; return; } /* CYRILLIC CAPITAL LETTER KA WITH HOOK */
		if (c == 0x04C5) { F[0] = 0x04C6; return; } /* CYRILLIC CAPITAL LETTER EL WITH TAIL */
		if (c == 0x04C7) { F[0] = 0x04C8; return; } /* CYRILLIC CAPITAL LETTER EN WITH HOOK */
		if (c == 0x04C9) { F[0] = 0x04CA; return; } /* CYRILLIC CAPITAL LETTER EN WITH TAIL */
		if (c == 0x04CB) { F[0] = 0x04CC; return; } /* CYRILLIC CAPITAL LETTER KHAKASSIAN CHE */
		if (c == 0x04CD) { F[0] = 0x04CE; return; } /* CYRILLIC CAPITAL LETTER EM WITH TAIL */
		if (c == 0x04D0) { F[0] = 0x04D1; return; } /* CYRILLIC CAPITAL LETTER A WITH BREVE */
		if (c == 0x04D2) { F[0] = 0x04D3; return; } /* CYRILLIC CAPITAL LETTER A WITH DIAERESIS */
		if (c == 0x04D4) { F[0] = 0x04D5; return; } /* CYRILLIC CAPITAL LIGATURE A IE */
		if (c == 0x04D6) { F[0] = 0x04D7; return; } /* CYRILLIC CAPITAL LETTER IE WITH BREVE */
		if (c == 0x04D8) { F[0] = 0x04D9; return; } /* CYRILLIC CAPITAL LETTER SCHWA */
		if (c == 0x04DA) { F[0] = 0x04DB; return; } /* CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS */
		if (c == 0x04DC) { F[0] = 0x04DD; return; } /* CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS */
		if (c == 0x04DE) { F[0] = 0x04DF; return; } /* CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS */
		if (c == 0x04E0) { F[0] = 0x04E1; return; } /* CYRILLIC CAPITAL LETTER ABKHASIAN DZE */
		if (c == 0x04E2) { F[0] = 0x04E3; return; } /* CYRILLIC CAPITAL LETTER I WITH MACRON */
		if (c == 0x04E4) { F[0] = 0x04E5; return; } /* CYRILLIC CAPITAL LETTER I WITH DIAERESIS */
		if (c == 0x04E6) { F[0] = 0x04E7; return; } /* CYRILLIC CAPITAL LETTER O WITH DIAERESIS */
		if (c == 0x04E8) { F[0] = 0x04E9; return; } /* CYRILLIC CAPITAL LETTER BARRED O */
		if (c == 0x04EA) { F[0] = 0x04EB; return; } /* CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS */
		if (c == 0x04EC) { F[0] = 0x04ED; return; } /* CYRILLIC CAPITAL LETTER E WITH DIAERESIS */
		if (c == 0x04EE) { F[0] = 0x04EF; return; } /* CYRILLIC CAPITAL LETTER U WITH MACRON */
		if (c == 0x04F0) { F[0] = 0x04F1; return; } /* CYRILLIC CAPITAL LETTER U WITH DIAERESIS */
		if (c == 0x04F2) { F[0] = 0x04F3; return; } /* CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE */
		if (c == 0x04F4) { F[0] = 0x04F5; return; } /* CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS */
		if (c == 0x04F6) { F[0] = 0x04F7; return; } /* CYRILLIC CAPITAL LETTER GHE WITH DESCENDER */
		if (c == 0x04F8) { F[0] = 0x04F9; return; } /* CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS */
		if (c == 0x04FA) { F[0] = 0x04FB; return; } /* CYRILLIC CAPITAL LETTER GHE WITH STROKE AND HOOK */
		if (c == 0x04FC) { F[0] = 0x04FD; return; } /* CYRILLIC CAPITAL LETTER HA WITH HOOK */
		if (c == 0x04FE) { F[0] = 0x04FF; return; } /* CYRILLIC CAPITAL LETTER HA WITH STROKE */
	} else if ((c >= 0x0500) && (c < 0x0600)) {
		if (c == 0x0500) { F[0] = 0x0501; return; } /* CYRILLIC CAPITAL LETTER KOMI DE */
		if (c == 0x0502) { F[0] = 0x0503; return; } /* CYRILLIC CAPITAL LETTER KOMI DJE */
		if (c == 0x0504) { F[0] = 0x0505; return; } /* CYRILLIC CAPITAL LETTER KOMI ZJE */
		if (c == 0x0506) { F[0] = 0x0507; return; } /* CYRILLIC CAPITAL LETTER KOMI DZJE */
		if (c == 0x0508) { F[0] = 0x0509; return; } /* CYRILLIC CAPITAL LETTER KOMI LJE */
		if (c == 0x050A) { F[0] = 0x050B; return; } /* CYRILLIC CAPITAL LETTER KOMI NJE */
		if (c == 0x050C) { F[0] = 0x050D; return; } /* CYRILLIC CAPITAL LETTER KOMI SJE */
		if (c == 0x050E) { F[0] = 0x050F; return; } /* CYRILLIC CAPITAL LETTER KOMI TJE */
		if (c == 0x0510) { F[0] = 0x0511; return; } /* CYRILLIC CAPITAL LETTER REVERSED ZE */
		if (c == 0x0512) { F[0] = 0x0513; return; } /* CYRILLIC CAPITAL LETTER EL WITH HOOK */
		if (c == 0x0514) { F[0] = 0x0515; return; } /* CYRILLIC CAPITAL LETTER LHA */
		if (c == 0x0516) { F[0] = 0x0517; return; } /* CYRILLIC CAPITAL LETTER RHA */
		if (c == 0x0518) { F[0] = 0x0519; return; } /* CYRILLIC CAPITAL LETTER YAE */
		if (c == 0x051A) { F[0] = 0x051B; return; } /* CYRILLIC CAPITAL LETTER QA */
		if (c == 0x051C) { F[0] = 0x051D; return; } /* CYRILLIC CAPITAL LETTER WE */
		if (c == 0x051E) { F[0] = 0x051F; return; } /* CYRILLIC CAPITAL LETTER ALEUT KA */
		if (c == 0x0520) { F[0] = 0x0521; return; } /* CYRILLIC CAPITAL LETTER EL WITH MIDDLE HOOK */
		if (c == 0x0522) { F[0] = 0x0523; return; } /* CYRILLIC CAPITAL LETTER EN WITH MIDDLE HOOK */
		if (c == 0x0524) { F[0] = 0x0525; return; } /* CYRILLIC CAPITAL LETTER PE WITH DESCENDER */
		if (c == 0x0526) { F[0] = 0x0527; return; } /* CYRILLIC CAPITAL LETTER SHHA WITH DESCENDER */
		if (c == 0x0528) { F[0] = 0x0529; return; } /* CYRILLIC CAPITAL LETTER EN WITH LEFT HOOK */
		if (c == 0x052A) { F[0] = 0x052B; return; } /* CYRILLIC CAPITAL LETTER DZZHE */
		if (c == 0x052C) { F[0] = 0x052D; return; } /* CYRILLIC CAPITAL LETTER DCHE */
		if (c == 0x052E) { F[0] = 0x052F; return; } /* CYRILLIC CAPITAL LETTER EL WITH DESCENDER */
		if ((c >= 0x0531) && (c <= 0x0556)) { F[0] = 0x0561 + (c - 0x0531); return; } /* ARMENIAN CAPITAL LETTER AYB to ARMENIAN CAPITAL LETTER FEH */
		if (c == 0x0587) { F[0] = 0x0565; F[1] = 0x0582; return; } /* ARMENIAN SMALL LIGATURE ECH YIWN */
	} else if ((c >= 0x1000) && (c < 0x2000)) {
		if ((c >= 0x10A0) && (c <= 0x10C5)) { F[0] = 0x2D00 + (c - 0x10A0); return; } /* GEORGIAN CAPITAL LETTER AN to GEORGIAN CAPITAL LETTER HOE */
		if (c == 0x10C7) { F[0] = 0x2D27; return; } /* GEORGIAN CAPITAL LETTER YN */
		if (c == 0x10CD) { F[0] = 0x2D2D; return; } /* GEORGIAN CAPITAL LETTER AEN */
		if ((c >= 0x13F8) && (c <= 0x13FD)) { F[0] = 0x13F0 + (c - 0x13F8); return; } /* CHEROKEE SMALL LETTER YE to CHEROKEE SMALL LETTER MV */
		if (c == 0x1C80) { F[0] = 0x0432; return; } /* CYRILLIC SMALL LETTER ROUNDED VE */
		if (c == 0x1C81) { F[0] = 0x0434; return; } /* CYRILLIC SMALL LETTER LONG-LEGGED DE */
		if (c == 0x1C82) { F[0] = 0x043E; return; } /* CYRILLIC SMALL LETTER NARROW O */
		if (c == 0x1C83) { F[0] = 0x0441; return; } /* CYRILLIC SMALL LETTER WIDE ES */
		if (c == 0x1C84) { F[0] = 0x0442; return; } /* CYRILLIC SMALL LETTER TALL TE */
		if (c == 0x1C85) { F[0] = 0x0442; return; } /* CYRILLIC SMALL LETTER THREE-LEGGED TE */
		if (c == 0x1C86) { F[0] = 0x044A; return; } /* CYRILLIC SMALL LETTER TALL HARD SIGN */
		if (c == 0x1C87) { F[0] = 0x0463; return; } /* CYRILLIC SMALL LETTER TALL YAT */
		if (c == 0x1C88) { F[0] = 0xA64B; return; } /* CYRILLIC SMALL LETTER UNBLENDED UK */
		if ((c >= 0x1C90) && (c <= 0x1CBA)) { F[0] = 0x10D0 + (c - 0x1C90); return; } /* GEORGIAN MTAVRULI CAPITAL LETTER AN to GEORGIAN MTAVRULI CAPITAL LETTER AIN */
		if ((c >= 0x1CBD) && (c <= 0x1CBF)) { F[0] = 0x10FD + (c - 0x1CBD); return; } /* GEORGIAN MTAVRULI CAPITAL LETTER AEN to GEORGIAN MTAVRULI CAPITAL LETTER LABIAL SIGN */
		if (c == 0x1E00) { F[0] = 0x1E01; return; } /* LATIN CAPITAL LETTER A WITH RING BELOW */
		if (c == 0x1E02) { F[0] = 0x1E03; return; } /* LATIN CAPITAL LETTER B WITH DOT ABOVE */
		if (c == 0x1E04) { F[0] = 0x1E05; return; } /* LATIN CAPITAL LETTER B WITH DOT BELOW */
		if (c == 0x1E06) { F[0] = 0x1E07; return; } /* LATIN CAPITAL LETTER B WITH LINE BELOW */
		if (c == 0x1E08) { F[0] = 0x1E09; return; } /* LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE */
		if (c == 0x1E0A) { F[0] = 0x1E0B; return; } /* LATIN CAPITAL LETTER D WITH DOT ABOVE */
		if (c == 0x1E0C) { F[0] = 0x1E0D; return; } /* LATIN CAPITAL LETTER D WITH DOT BELOW */
		if (c == 0x1E0E) { F[0] = 0x1E0F; return; } /* LATIN CAPITAL LETTER D WITH LINE BELOW */
		if (c == 0x1E10) { F[0] = 0x1E11; return; } /* LATIN CAPITAL LETTER D WITH CEDILLA */
		if (c == 0x1E12) { F[0] = 0x1E13; return; } /* LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW */
		if (c == 0x1E14) { F[0] = 0x1E15; return; } /* LATIN CAPITAL LETTER E WITH MACRON AND GRAVE */
		if (c == 0x1E16) { F[0] = 0x1E17; return; } /* LATIN CAPITAL LETTER E WITH MACRON AND ACUTE */
		if (c == 0x1E18) { F[0] = 0x1E19; return; } /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW */
		if (c == 0x1E1A) { F[0] = 0x1E1B; return; } /* LATIN CAPITAL LETTER E WITH TILDE BELOW */
		if (c == 0x1E1C) { F[0] = 0x1E1D; return; } /* LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE */
		if (c == 0x1E1E) { F[0] = 0x1E1F; return; } /* LATIN CAPITAL LETTER F WITH DOT ABOVE */
		if (c == 0x1E20) { F[0] = 0x1E21; return; } /* LATIN CAPITAL LETTER G WITH MACRON */
		if (c == 0x1E22) { F[0] = 0x1E23; return; } /* LATIN CAPITAL LETTER H WITH DOT ABOVE */
		if (c == 0x1E24) { F[0] = 0x1E25; return; } /* LATIN CAPITAL LETTER H WITH DOT BELOW */
		if (c == 0x1E26) { F[0] = 0x1E27; return; } /* LATIN CAPITAL LETTER H WITH DIAERESIS */
		if (c == 0x1E28) { F[0] = 0x1E29; return; } /* LATIN CAPITAL LETTER H WITH CEDILLA */
		if (c == 0x1E2A) { F[0] = 0x1E2B; return; } /* LATIN CAPITAL LETTER H WITH BREVE BELOW */
		if (c == 0x1E2C) { F[0] = 0x1E2D; return; } /* LATIN CAPITAL LETTER I WITH TILDE BELOW */
		if (c == 0x1E2E) { F[0] = 0x1E2F; return; } /* LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE */
		if (c == 0x1E30) { F[0] = 0x1E31; return; } /* LATIN CAPITAL LETTER K WITH ACUTE */
		if (c == 0x1E32) { F[0] = 0x1E33; return; } /* LATIN CAPITAL LETTER K WITH DOT BELOW */
		if (c == 0x1E34) { F[0] = 0x1E35; return; } /* LATIN CAPITAL LETTER K WITH LINE BELOW */
		if (c == 0x1E36) { F[0] = 0x1E37; return; } /* LATIN CAPITAL LETTER L WITH DOT BELOW */
		if (c == 0x1E38) { F[0] = 0x1E39; return; } /* LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON */
		if (c == 0x1E3A) { F[0] = 0x1E3B; return; } /* LATIN CAPITAL LETTER L WITH LINE BELOW */
		if (c == 0x1E3C) { F[0] = 0x1E3D; return; } /* LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW */
		if (c == 0x1E3E) { F[0] = 0x1E3F; return; } /* LATIN CAPITAL LETTER M WITH ACUTE */
		if (c == 0x1E40) { F[0] = 0x1E41; return; } /* LATIN CAPITAL LETTER M WITH DOT ABOVE */
		if (c == 0x1E42) { F[0] = 0x1E43; return; } /* LATIN CAPITAL LETTER M WITH DOT BELOW */
		if (c == 0x1E44) { F[0] = 0x1E45; return; } /* LATIN CAPITAL LETTER N WITH DOT ABOVE */
		if (c == 0x1E46) { F[0] = 0x1E47; return; } /* LATIN CAPITAL LETTER N WITH DOT BELOW */
		if (c == 0x1E48) { F[0] = 0x1E49; return; } /* LATIN CAPITAL LETTER N WITH LINE BELOW */
		if (c == 0x1E4A) { F[0] = 0x1E4B; return; } /* LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW */
		if (c == 0x1E4C) { F[0] = 0x1E4D; return; } /* LATIN CAPITAL LETTER O WITH TILDE AND ACUTE */
		if (c == 0x1E4E) { F[0] = 0x1E4F; return; } /* LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS */
		if (c == 0x1E50) { F[0] = 0x1E51; return; } /* LATIN CAPITAL LETTER O WITH MACRON AND GRAVE */
		if (c == 0x1E52) { F[0] = 0x1E53; return; } /* LATIN CAPITAL LETTER O WITH MACRON AND ACUTE */
		if (c == 0x1E54) { F[0] = 0x1E55; return; } /* LATIN CAPITAL LETTER P WITH ACUTE */
		if (c == 0x1E56) { F[0] = 0x1E57; return; } /* LATIN CAPITAL LETTER P WITH DOT ABOVE */
		if (c == 0x1E58) { F[0] = 0x1E59; return; } /* LATIN CAPITAL LETTER R WITH DOT ABOVE */
		if (c == 0x1E5A) { F[0] = 0x1E5B; return; } /* LATIN CAPITAL LETTER R WITH DOT BELOW */
		if (c == 0x1E5C) { F[0] = 0x1E5D; return; } /* LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON */
		if (c == 0x1E5E) { F[0] = 0x1E5F; return; } /* LATIN CAPITAL LETTER R WITH LINE BELOW */
		if (c == 0x1E60) { F[0] = 0x1E61; return; } /* LATIN CAPITAL LETTER S WITH DOT ABOVE */
		if (c == 0x1E62) { F[0] = 0x1E63; return; } /* LATIN CAPITAL LETTER S WITH DOT BELOW */
		if (c == 0x1E64) { F[0] = 0x1E65; return; } /* LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE */
		if (c == 0x1E66) { F[0] = 0x1E67; return; } /* LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE */
		if (c == 0x1E68) { F[0] = 0x1E69; return; } /* LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE */
		if (c == 0x1E6A) { F[0] = 0x1E6B; return; } /* LATIN CAPITAL LETTER T WITH DOT ABOVE */
		if (c == 0x1E6C) { F[0] = 0x1E6D; return; } /* LATIN CAPITAL LETTER T WITH DOT BELOW */
		if (c == 0x1E6E) { F[0] = 0x1E6F; return; } /* LATIN CAPITAL LETTER T WITH LINE BELOW */
		if (c == 0x1E70) { F[0] = 0x1E71; return; } /* LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW */
		if (c == 0x1E72) { F[0] = 0x1E73; return; } /* LATIN CAPITAL LETTER U WITH DIAERESIS BELOW */
		if (c == 0x1E74) { F[0] = 0x1E75; return; } /* LATIN CAPITAL LETTER U WITH TILDE BELOW */
		if (c == 0x1E76) { F[0] = 0x1E77; return; } /* LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW */
		if (c == 0x1E78) { F[0] = 0x1E79; return; } /* LATIN CAPITAL LETTER U WITH TILDE AND ACUTE */
		if (c == 0x1E7A) { F[0] = 0x1E7B; return; } /* LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS */
		if (c == 0x1E7C) { F[0] = 0x1E7D; return; } /* LATIN CAPITAL LETTER V WITH TILDE */
		if (c == 0x1E7E) { F[0] = 0x1E7F; return; } /* LATIN CAPITAL LETTER V WITH DOT BELOW */
		if (c == 0x1E80) { F[0] = 0x1E81; return; } /* LATIN CAPITAL LETTER W WITH GRAVE */
		if (c == 0x1E82) { F[0] = 0x1E83; return; } /* LATIN CAPITAL LETTER W WITH ACUTE */
		if (c == 0x1E84) { F[0] = 0x1E85; return; } /* LATIN CAPITAL LETTER W WITH DIAERESIS */
		if (c == 0x1E86) { F[0] = 0x1E87; return; } /* LATIN CAPITAL LETTER W WITH DOT ABOVE */
		if (c == 0x1E88) { F[0] = 0x1E89; return; } /* LATIN CAPITAL LETTER W WITH DOT BELOW */
		if (c == 0x1E8A) { F[0] = 0x1E8B; return; } /* LATIN CAPITAL LETTER X WITH DOT ABOVE */
		if (c == 0x1E8C) { F[0] = 0x1E8D; return; } /* LATIN CAPITAL LETTER X WITH DIAERESIS */
		if (c == 0x1E8E) { F[0] = 0x1E8F; return; } /* LATIN CAPITAL LETTER Y WITH DOT ABOVE */
		if (c == 0x1E90) { F[0] = 0x1E91; return; } /* LATIN CAPITAL LETTER Z WITH CIRCUMFLEX */
		if (c == 0x1E92) { F[0] = 0x1E93; return; } /* LATIN CAPITAL LETTER Z WITH DOT BELOW */
		if (c == 0x1E94) { F[0] = 0x1E95; return; } /* LATIN CAPITAL LETTER Z WITH LINE BELOW */
		if (c == 0x1E96) { F[0] = 0x0068; F[1] = 0x0331; return; } /* LATIN SMALL LETTER H WITH LINE BELOW */
		if (c == 0x1E97) { F[0] = 0x0074; F[1] = 0x0308; return; } /* LATIN SMALL LETTER T WITH DIAERESIS */
		if (c == 0x1E98) { F[0] = 0x0077; F[1] = 0x030A; return; } /* LATIN SMALL LETTER W WITH RING ABOVE */
		if (c == 0x1E99) { F[0] = 0x0079; F[1] = 0x030A; return; } /* LATIN SMALL LETTER Y WITH RING ABOVE */
		if (c == 0x1E9A) { F[0] = 0x0061; F[1] = 0x02BE; return; } /* LATIN SMALL LETTER A WITH RIGHT HALF RING */
		if (c == 0x1E9B) { F[0] = 0x1E61; return; } /* LATIN SMALL LETTER LONG S WITH DOT ABOVE */
		if (c == 0x1E9E) { F[0] = 0x0073; F[1] = 0x0073; return; } /* LATIN CAPITAL LETTER SHARP S */
		if (c == 0x1EA0) { F[0] = 0x1EA1; return; } /* LATIN CAPITAL LETTER A WITH DOT BELOW */
		if (c == 0x1EA2) { F[0] = 0x1EA3; return; } /* LATIN CAPITAL LETTER A WITH HOOK ABOVE */
		if (c == 0x1EA4) { F[0] = 0x1EA5; return; } /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE */
		if (c == 0x1EA6) { F[0] = 0x1EA7; return; } /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE */
		if (c == 0x1EA8) { F[0] = 0x1EA9; return; } /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
		if (c == 0x1EAA) { F[0] = 0x1EAB; return; } /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE */
		if (c == 0x1EAC) { F[0] = 0x1EAD; return; } /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
		if (c == 0x1EAE) { F[0] = 0x1EAF; return; } /* LATIN CAPITAL LETTER A WITH BREVE AND ACUTE */
		if (c == 0x1EB0) { F[0] = 0x1EB1; return; } /* LATIN CAPITAL LETTER A WITH BREVE AND GRAVE */
		if (c == 0x1EB2) { F[0] = 0x1EB3; return; } /* LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE */
		if (c == 0x1EB4) { F[0] = 0x1EB5; return; } /* LATIN CAPITAL LETTER A WITH BREVE AND TILDE */
		if (c == 0x1EB6) { F[0] = 0x1EB7; return; } /* LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW */
		if (c == 0x1EB8) { F[0] = 0x1EB9; return; } /* LATIN CAPITAL LETTER E WITH DOT BELOW */
		if (c == 0x1EBA) { F[0] = 0x1EBB; return; } /* LATIN CAPITAL LETTER E WITH HOOK ABOVE */
		if (c == 0x1EBC) { F[0] = 0x1EBD; return; } /* LATIN CAPITAL LETTER E WITH TILDE */
		if (c == 0x1EBE) { F[0] = 0x1EBF; return; } /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE */
		if (c == 0x1EC0) { F[0] = 0x1EC1; return; } /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE */
		if (c == 0x1EC2) { F[0] = 0x1EC3; return; } /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
		if (c == 0x1EC4) { F[0] = 0x1EC5; return; } /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE */
		if (c == 0x1EC6) { F[0] = 0x1EC7; return; } /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
		if (c == 0x1EC8) { F[0] = 0x1EC9; return; } /* LATIN CAPITAL LETTER I WITH HOOK ABOVE */
		if (c == 0x1ECA) { F[0] = 0x1ECB; return; } /* LATIN CAPITAL LETTER I WITH DOT BELOW */
		if (c == 0x1ECC) { F[0] = 0x1ECD; return; } /* LATIN CAPITAL LETTER O WITH DOT BELOW */
		if (c == 0x1ECE) { F[0] = 0x1ECF; return; } /* LATIN CAPITAL LETTER O WITH HOOK ABOVE */
		if (c == 0x1ED0) { F[0] = 0x1ED1; return; } /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE */
		if (c == 0x1ED2) { F[0] = 0x1ED3; return; } /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE */
		if (c == 0x1ED4) { F[0] = 0x1ED5; return; } /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
		if (c == 0x1ED6) { F[0] = 0x1ED7; return; } /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE */
		if (c == 0x1ED8) { F[0] = 0x1ED9; return; } /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
		if (c == 0x1EDA) { F[0] = 0x1EDB; return; } /* LATIN CAPITAL LETTER O WITH HORN AND ACUTE */
		if (c == 0x1EDC) { F[0] = 0x1EDD; return; } /* LATIN CAPITAL LETTER O WITH HORN AND GRAVE */
		if (c == 0x1EDE) { F[0] = 0x1EDF; return; } /* LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE */
		if (c == 0x1EE0) { F[0] = 0x1EE1; return; } /* LATIN CAPITAL LETTER O WITH HORN AND TILDE */
		if (c == 0x1EE2) { F[0] = 0x1EE3; return; } /* LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW */
		if (c == 0x1EE4) { F[0] = 0x1EE5; return; } /* LATIN CAPITAL LETTER U WITH DOT BELOW */
		if (c == 0x1EE6) { F[0] = 0x1EE7; return; } /* LATIN CAPITAL LETTER U WITH HOOK ABOVE */
		if (c == 0x1EE8) { F[0] = 0x1EE9; return; } /* LATIN CAPITAL LETTER U WITH HORN AND ACUTE */
		if (c == 0x1EEA) { F[0] = 0x1EEB; return; } /* LATIN CAPITAL LETTER U WITH HORN AND GRAVE */
		if (c == 0x1EEC) { F[0] = 0x1EED; return; } /* LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE */
		if (c == 0x1EEE) { F[0] = 0x1EEF; return; } /* LATIN CAPITAL LETTER U WITH HORN AND TILDE */
		if (c == 0x1EF0) { F[0] = 0x1EF1; return; } /* LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW */
		if (c == 0x1EF2) { F[0] = 0x1EF3; return; } /* LATIN CAPITAL LETTER Y WITH GRAVE */
		if (c == 0x1EF4) { F[0] = 0x1EF5; return; } /* LATIN CAPITAL LETTER Y WITH DOT BELOW */
		if (c == 0x1EF6) { F[0] = 0x1EF7; return; } /* LATIN CAPITAL LETTER Y WITH HOOK ABOVE */
		if (c == 0x1EF8) { F[0] = 0x1EF9; return; } /* LATIN CAPITAL LETTER Y WITH TILDE */
		if (c == 0x1EFA) { F[0] = 0x1EFB; return; } /* LATIN CAPITAL LETTER MIDDLE-WELSH LL */
		if (c == 0x1EFC) { F[0] = 0x1EFD; return; } /* LATIN CAPITAL LETTER MIDDLE-WELSH V */
		if (c == 0x1EFE) { F[0] = 0x1EFF; return; } /* LATIN CAPITAL LETTER Y WITH LOOP */
		if ((c >= 0x1F08) && (c <= 0x1F0F)) { F[0] = 0x1F00 + (c - 0x1F08); return; } /* GREEK CAPITAL LETTER ALPHA WITH PSILI to GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI */
		if ((c >= 0x1F18) && (c <= 0x1F1D)) { F[0] = 0x1F10 + (c - 0x1F18); return; } /* GREEK CAPITAL LETTER EPSILON WITH PSILI to GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA */
		if ((c >= 0x1F28) && (c <= 0x1F2F)) { F[0] = 0x1F20 + (c - 0x1F28); return; } /* GREEK CAPITAL LETTER ETA WITH PSILI to GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI */
		if ((c >= 0x1F38) && (c <= 0x1F3F)) { F[0] = 0x1F30 + (c - 0x1F38); return; } /* GREEK CAPITAL LETTER IOTA WITH PSILI to GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI */
		if ((c >= 0x1F48) && (c <= 0x1F4D)) { F[0] = 0x1F40 + (c - 0x1F48); return; } /* GREEK CAPITAL LETTER OMICRON WITH PSILI to GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA */
		if (c == 0x1F50) { F[0] = 0x03C5; F[1] = 0x0313; return; } /* GREEK SMALL LETTER UPSILON WITH PSILI */
		if (c == 0x1F52) { F[0] = 0x03C5; F[1] = 0x0313; F[2] = 0x0300; return; } /* GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA */
		if (c == 0x1F54) { F[0] = 0x03C5; F[1] = 0x0313; F[2] = 0x0301; return; } /* GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA */
		if (c == 0x1F56) { F[0] = 0x03C5; F[1] = 0x0313; F[2] = 0x0342; return; } /* GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI */
		if (c == 0x1F59) { F[0] = 0x1F51; return; } /* GREEK CAPITAL LETTER UPSILON WITH DASIA */
		if (c == 0x1F5B) { F[0] = 0x1F53; return; } /* GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA */
		if (c == 0x1F5D) { F[0] = 0x1F55; return; } /* GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA */
		if (c == 0x1F5F) { F[0] = 0x1F57; return; } /* GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI */
		if ((c >= 0x1F68) && (c <= 0x1F6F)) { F[0] = 0x1F60 + (c - 0x1F68); return; } /* GREEK CAPITAL LETTER OMEGA WITH PSILI to GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI */
		if (c == 0x1F80) { F[0] = 0x1F00; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI */
		if (c == 0x1F81) { F[0] = 0x1F01; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI */
		if (c == 0x1F82) { F[0] = 0x1F02; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI */
		if (c == 0x1F83) { F[0] = 0x1F03; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI */
		if (c == 0x1F84) { F[0] = 0x1F04; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI */
		if (c == 0x1F85) { F[0] = 0x1F05; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI */
		if (c == 0x1F86) { F[0] = 0x1F06; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1F87) { F[0] = 0x1F07; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1F88) { F[0] = 0x1F00; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI */
		if (c == 0x1F89) { F[0] = 0x1F01; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI */
		if (c == 0x1F8A) { F[0] = 0x1F02; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI */
		if (c == 0x1F8B) { F[0] = 0x1F03; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI */
		if (c == 0x1F8C) { F[0] = 0x1F04; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI */
		if (c == 0x1F8D) { F[0] = 0x1F05; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI */
		if (c == 0x1F8E) { F[0] = 0x1F06; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI */
		if (c == 0x1F8F) { F[0] = 0x1F07; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI */
		if (c == 0x1F90) { F[0] = 0x1F20; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI */
		if (c == 0x1F91) { F[0] = 0x1F21; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI */
		if (c == 0x1F92) { F[0] = 0x1F22; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI */
		if (c == 0x1F93) { F[0] = 0x1F23; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI */
		if (c == 0x1F94) { F[0] = 0x1F24; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI */
		if (c == 0x1F95) { F[0] = 0x1F25; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI */
		if (c == 0x1F96) { F[0] = 0x1F26; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1F97) { F[0] = 0x1F27; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1F98) { F[0] = 0x1F20; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI */
		if (c == 0x1F99) { F[0] = 0x1F21; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI */
		if (c == 0x1F9A) { F[0] = 0x1F22; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI */
		if (c == 0x1F9B) { F[0] = 0x1F23; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI */
		if (c == 0x1F9C) { F[0] = 0x1F24; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI */
		if (c == 0x1F9D) { F[0] = 0x1F25; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI */
		if (c == 0x1F9E) { F[0] = 0x1F26; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI */
		if (c == 0x1F9F) { F[0] = 0x1F27; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI */
		if (c == 0x1FA0) { F[0] = 0x1F60; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI */
		if (c == 0x1FA1) { F[0] = 0x1F61; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI */
		if (c == 0x1FA2) { F[0] = 0x1F62; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI */
		if (c == 0x1FA3) { F[0] = 0x1F63; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI */
		if (c == 0x1FA4) { F[0] = 0x1F64; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI */
		if (c == 0x1FA5) { F[0] = 0x1F65; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI */
		if (c == 0x1FA6) { F[0] = 0x1F66; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1FA7) { F[0] = 0x1F67; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1FA8) { F[0] = 0x1F60; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI */
		if (c == 0x1FA9) { F[0] = 0x1F61; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI */
		if (c == 0x1FAA) { F[0] = 0x1F62; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI */
		if (c == 0x1FAB) { F[0] = 0x1F63; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI */
		if (c == 0x1FAC) { F[0] = 0x1F64; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI */
		if (c == 0x1FAD) { F[0] = 0x1F65; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI */
		if (c == 0x1FAE) { F[0] = 0x1F66; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI */
		if (c == 0x1FAF) { F[0] = 0x1F67; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI */
		if (c == 0x1FB2) { F[0] = 0x1F70; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI */
		if (c == 0x1FB3) { F[0] = 0x03B1; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH YPOGEGRAMMENI */
		if (c == 0x1FB4) { F[0] = 0x03AC; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI */
		if (c == 0x1FB6) { F[0] = 0x03B1; F[1] = 0x0342; return; } /* GREEK SMALL LETTER ALPHA WITH PERISPOMENI */
		if (c == 0x1FB7) { F[0] = 0x03B1; F[1] = 0x0342; F[2] = 0x03B9; return; } /* GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1FB8) { F[0] = 0x1FB0; return; } /* GREEK CAPITAL LETTER ALPHA WITH VRACHY */
		if (c == 0x1FB9) { F[0] = 0x1FB1; return; } /* GREEK CAPITAL LETTER ALPHA WITH MACRON */
		if (c == 0x1FBA) { F[0] = 0x1F70; return; } /* GREEK CAPITAL LETTER ALPHA WITH VARIA */
		if (c == 0x1FBB) { F[0] = 0x1F71; return; } /* GREEK CAPITAL LETTER ALPHA WITH OXIA */
		if (c == 0x1FBC) { F[0] = 0x03B1; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI */
		if (c == 0x1FBE) { F[0] = 0x03B9; return; } /* GREEK PROSGEGRAMMENI */
		if (c == 0x1FC2) { F[0] = 0x1F74; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI */
		if (c == 0x1FC3) { F[0] = 0x03B7; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH YPOGEGRAMMENI */
		if (c == 0x1FC4) { F[0] = 0x03AE; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI */
		if (c == 0x1FC6) { F[0] = 0x03B7; F[1] = 0x0342; return; } /* GREEK SMALL LETTER ETA WITH PERISPOMENI */
		if (c == 0x1FC7) { F[0] = 0x03B7; F[1] = 0x0342; F[2] = 0x03B9; return; } /* GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI */
		if ((c >= 0x1FC8) && (c <= 0x1FCB)) { F[0] = 0x1F72 + (c - 0x1FC8); return; } /* GREEK CAPITAL LETTER EPSILON WITH VARIA to GREEK CAPITAL LETTER ETA WITH OXIA */
		if (c == 0x1FCC) { F[0] = 0x03B7; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI */
		if (c == 0x1FD2) { F[0] = 0x03B9; F[1] = 0x0308; F[2] = 0x0300; return; } /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA */
		if (c == 0x1FD3) { F[0] = 0x03B9; F[1] = 0x0308; F[2] = 0x0301; return; } /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA */
		if (c == 0x1FD6) { F[0] = 0x03B9; F[1] = 0x0342; return; } /* GREEK SMALL LETTER IOTA WITH PERISPOMENI */
		if (c == 0x1FD7) { F[0] = 0x03B9; F[1] = 0x0308; F[2] = 0x0342; return; } /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI */
		if (c == 0x1FD8) { F[0] = 0x1FD0; return; } /* GREEK CAPITAL LETTER IOTA WITH VRACHY */
		if (c == 0x1FD9) { F[0] = 0x1FD1; return; } /* GREEK CAPITAL LETTER IOTA WITH MACRON */
		if (c == 0x1FDA) { F[0] = 0x1F76; return; } /* GREEK CAPITAL LETTER IOTA WITH VARIA */
		if (c == 0x1FDB) { F[0] = 0x1F77; return; } /* GREEK CAPITAL LETTER IOTA WITH OXIA */
		if (c == 0x1FE2) { F[0] = 0x03C5; F[1] = 0x0308; F[2] = 0x0300; return; } /* GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA */
		if (c == 0x1FE3) { F[0] = 0x03C5; F[1] = 0x0308; F[2] = 0x0301; return; } /* GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA */
		if (c == 0x1FE4) { F[0] = 0x03C1; F[1] = 0x0313; return; } /* GREEK SMALL LETTER RHO WITH PSILI */
		if (c == 0x1FE6) { F[0] = 0x03C5; F[1] = 0x0342; return; } /* GREEK SMALL LETTER UPSILON WITH PERISPOMENI */
		if (c == 0x1FE7) { F[0] = 0x03C5; F[1] = 0x0308; F[2] = 0x0342; return; } /* GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI */
		if (c == 0x1FE8) { F[0] = 0x1FE0; return; } /* GREEK CAPITAL LETTER UPSILON WITH VRACHY */
		if (c == 0x1FE9) { F[0] = 0x1FE1; return; } /* GREEK CAPITAL LETTER UPSILON WITH MACRON */
		if (c == 0x1FEA) { F[0] = 0x1F7A; return; } /* GREEK CAPITAL LETTER UPSILON WITH VARIA */
		if (c == 0x1FEB) { F[0] = 0x1F7B; return; } /* GREEK CAPITAL LETTER UPSILON WITH OXIA */
		if (c == 0x1FEC) { F[0] = 0x1FE5; return; } /* GREEK CAPITAL LETTER RHO WITH DASIA */
		if (c == 0x1FF2) { F[0] = 0x1F7C; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI */
		if (c == 0x1FF3) { F[0] = 0x03C9; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH YPOGEGRAMMENI */
		if (c == 0x1FF4) { F[0] = 0x03CE; F[1] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI */
		if (c == 0x1FF6) { F[0] = 0x03C9; F[1] = 0x0342; return; } /* GREEK SMALL LETTER OMEGA WITH PERISPOMENI */
		if (c == 0x1FF7) { F[0] = 0x03C9; F[1] = 0x0342; F[2] = 0x03B9; return; } /* GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI */
		if (c == 0x1FF8) { F[0] = 0x1F78; return; } /* GREEK CAPITAL LETTER OMICRON WITH VARIA */
		if (c == 0x1FF9) { F[0] = 0x1F79; return; } /* GREEK CAPITAL LETTER OMICRON WITH OXIA */
		if (c == 0x1FFA) { F[0] = 0x1F7C; return; } /* GREEK CAPITAL LETTER OMEGA WITH VARIA */
		if (c == 0x1FFB) { F[0] = 0x1F7D; return; } /* GREEK CAPITAL LETTER OMEGA WITH OXIA */
		if (c == 0x1FFC) { F[0] = 0x03C9; F[1] = 0x03B9; return; } /* GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI */
	} else if ((c >= 0x2000) && (c < 0x3000)) {
		if (c == 0x2126) { F[0] = 0x03C9; return; } /* OHM SIGN */
		if (c == 0x212A) { F[0] = 0x006B; return; } /* KELVIN SIGN */
		if (c == 0x212B) { F[0] = 0x00E5; return; } /* ANGSTROM SIGN */
		if (c == 0x2132) { F[0] = 0x214E; return; } /* TURNED CAPITAL F */
		if ((c >= 0x2160) && (c <= 0x216F)) { F[0] = 0x2170 + (c - 0x2160); return; } /* ROMAN NUMERAL ONE to ROMAN NUMERAL ONE THOUSAND */
		if (c == 0x2183) { F[0] = 0x2184; return; } /* ROMAN NUMERAL REVERSED ONE HUNDRED */
		if ((c >= 0x24B6) && (c <= 0x24CF)) { F[0] = 0x24D0 + (c - 0x24B6); return; } /* CIRCLED LATIN CAPITAL LETTER A to CIRCLED LATIN CAPITAL LETTER Z */
		if ((c >= 0x2C00) && (c <= 0x2C2F)) { F[0] = 0x2C30 + (c - 0x2C00); return; } /* GLAGOLITIC CAPITAL LETTER AZU to GLAGOLITIC CAPITAL LETTER CAUDATE CHRIVI */
		if (c == 0x2C60) { F[0] = 0x2C61; return; } /* LATIN CAPITAL LETTER L WITH DOUBLE BAR */
		if (c == 0x2C62) { F[0] = 0x026B; return; } /* LATIN CAPITAL LETTER L WITH MIDDLE TILDE */
		if (c == 0x2C63) { F[0] = 0x1D7D; return; } /* LATIN CAPITAL LETTER P WITH STROKE */
		if (c == 0x2C64) { F[0] = 0x027D; return; } /* LATIN CAPITAL LETTER R WITH TAIL */
		if (c == 0x2C67) { F[0] = 0x2C68; return; } /* LATIN CAPITAL LETTER H WITH DESCENDER */
		if (c == 0x2C69) { F[0] = 0x2C6A; return; } /* LATIN CAPITAL LETTER K WITH DESCENDER */
		if (c == 0x2C6B) { F[0] = 0x2C6C; return; } /* LATIN CAPITAL LETTER Z WITH DESCENDER */
		if (c == 0x2C6D) { F[0] = 0x0251; return; } /* LATIN CAPITAL LETTER ALPHA */
		if (c == 0x2C6E) { F[0] = 0x0271; return; } /* LATIN CAPITAL LETTER M WITH HOOK */
		if (c == 0x2C6F) { F[0] = 0x0250; return; } /* LATIN CAPITAL LETTER TURNED A */
		if (c == 0x2C70) { F[0] = 0x0252; return; } /* LATIN CAPITAL LETTER TURNED ALPHA */
		if (c == 0x2C72) { F[0] = 0x2C73; return; } /* LATIN CAPITAL LETTER W WITH HOOK */
		if (c == 0x2C75) { F[0] = 0x2C76; return; } /* LATIN CAPITAL LETTER HALF H */
		if (c == 0x2C7E) { F[0] = 0x023F; return; } /* LATIN CAPITAL LETTER S WITH SWASH TAIL */
		if (c == 0x2C7F) { F[0] = 0x0240; return; } /* LATIN CAPITAL LETTER Z WITH SWASH TAIL */
		if (c == 0x2C80) { F[0] = 0x2C81; return; } /* COPTIC CAPITAL LETTER ALFA */
		if (c == 0x2C82) { F[0] = 0x2C83; return; } /* COPTIC CAPITAL LETTER VIDA */
		if (c == 0x2C84) { F[0] = 0x2C85; return; } /* COPTIC CAPITAL LETTER GAMMA */
		if (c == 0x2C86) { F[0] = 0x2C87; return; } /* COPTIC CAPITAL LETTER DALDA */
		if (c == 0x2C88) { F[0] = 0x2C89; return; } /* COPTIC CAPITAL LETTER EIE */
		if (c == 0x2C8A) { F[0] = 0x2C8B; return; } /* COPTIC CAPITAL LETTER SOU */
		if (c == 0x2C8C) { F[0] = 0x2C8D; return; } /* COPTIC CAPITAL LETTER ZATA */
		if (c == 0x2C8E) { F[0] = 0x2C8F; return; } /* COPTIC CAPITAL LETTER HATE */
		if (c == 0x2C90) { F[0] = 0x2C91; return; } /* COPTIC CAPITAL LETTER THETHE */
		if (c == 0x2C92) { F[0] = 0x2C93; return; } /* COPTIC CAPITAL LETTER IAUDA */
		if (c == 0x2C94) { F[0] = 0x2C95; return; } /* COPTIC CAPITAL LETTER KAPA */
		if (c == 0x2C96) { F[0] = 0x2C97; return; } /* COPTIC CAPITAL LETTER LAULA */
		if (c == 0x2C98) { F[0] = 0x2C99; return; } /* COPTIC CAPITAL LETTER MI */
		if (c == 0x2C9A) { F[0] = 0x2C9B; return; } /* COPTIC CAPITAL LETTER NI */
		if (c == 0x2C9C) { F[0] = 0x2C9D; return; } /* COPTIC CAPITAL LETTER KSI */
		if (c == 0x2C9E) { F[0] = 0x2C9F; return; } /* COPTIC CAPITAL LETTER O */
		if (c == 0x2CA0) { F[0] = 0x2CA1; return; } /* COPTIC CAPITAL LETTER PI */
		if (c == 0x2CA2) { F[0] = 0x2CA3; return; } /* COPTIC CAPITAL LETTER RO */
		if (c == 0x2CA4) { F[0] = 0x2CA5; return; } /* COPTIC CAPITAL LETTER SIMA */
		if (c == 0x2CA6) { F[0] = 0x2CA7; return; } /* COPTIC CAPITAL LETTER TAU */
		if (c == 0x2CA8) { F[0] = 0x2CA9; return; } /* COPTIC CAPITAL LETTER UA */
		if (c == 0x2CAA) { F[0] = 0x2CAB; return; } /* COPTIC CAPITAL LETTER FI */
		if (c == 0x2CAC) { F[0] = 0x2CAD; return; } /* COPTIC CAPITAL LETTER KHI */
		if (c == 0x2CAE) { F[0] = 0x2CAF; return; } /* COPTIC CAPITAL LETTER PSI */
		if (c == 0x2CB0) { F[0] = 0x2CB1; return; } /* COPTIC CAPITAL LETTER OOU */
		if (c == 0x2CB2) { F[0] = 0x2CB3; return; } /* COPTIC CAPITAL LETTER DIALECT-P ALEF */
		if (c == 0x2CB4) { F[0] = 0x2CB5; return; } /* COPTIC CAPITAL LETTER OLD COPTIC AIN */
		if (c == 0x2CB6) { F[0] = 0x2CB7; return; } /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC EIE */
		if (c == 0x2CB8) { F[0] = 0x2CB9; return; } /* COPTIC CAPITAL LETTER DIALECT-P KAPA */
		if (c == 0x2CBA) { F[0] = 0x2CBB; return; } /* COPTIC CAPITAL LETTER DIALECT-P NI */
		if (c == 0x2CBC) { F[0] = 0x2CBD; return; } /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC NI */
		if (c == 0x2CBE) { F[0] = 0x2CBF; return; } /* COPTIC CAPITAL LETTER OLD COPTIC OOU */
		if (c == 0x2CC0) { F[0] = 0x2CC1; return; } /* COPTIC CAPITAL LETTER SAMPI */
		if (c == 0x2CC2) { F[0] = 0x2CC3; return; } /* COPTIC CAPITAL LETTER CROSSED SHEI */
		if (c == 0x2CC4) { F[0] = 0x2CC5; return; } /* COPTIC CAPITAL LETTER OLD COPTIC SHEI */
		if (c == 0x2CC6) { F[0] = 0x2CC7; return; } /* COPTIC CAPITAL LETTER OLD COPTIC ESH */
		if (c == 0x2CC8) { F[0] = 0x2CC9; return; } /* COPTIC CAPITAL LETTER AKHMIMIC KHEI */
		if (c == 0x2CCA) { F[0] = 0x2CCB; return; } /* COPTIC CAPITAL LETTER DIALECT-P HORI */
		if (c == 0x2CCC) { F[0] = 0x2CCD; return; } /* COPTIC CAPITAL LETTER OLD COPTIC HORI */
		if (c == 0x2CCE) { F[0] = 0x2CCF; return; } /* COPTIC CAPITAL LETTER OLD COPTIC HA */
		if (c == 0x2CD0) { F[0] = 0x2CD1; return; } /* COPTIC CAPITAL LETTER L-SHAPED HA */
		if (c == 0x2CD2) { F[0] = 0x2CD3; return; } /* COPTIC CAPITAL LETTER OLD COPTIC HEI */
		if (c == 0x2CD4) { F[0] = 0x2CD5; return; } /* COPTIC CAPITAL LETTER OLD COPTIC HAT */
		if (c == 0x2CD6) { F[0] = 0x2CD7; return; } /* COPTIC CAPITAL LETTER OLD COPTIC GANGIA */
		if (c == 0x2CD8) { F[0] = 0x2CD9; return; } /* COPTIC CAPITAL LETTER OLD COPTIC DJA */
		if (c == 0x2CDA) { F[0] = 0x2CDB; return; } /* COPTIC CAPITAL LETTER OLD COPTIC SHIMA */
		if (c == 0x2CDC) { F[0] = 0x2CDD; return; } /* COPTIC CAPITAL LETTER OLD NUBIAN SHIMA */
		if (c == 0x2CDE) { F[0] = 0x2CDF; return; } /* COPTIC CAPITAL LETTER OLD NUBIAN NGI */
		if (c == 0x2CE0) { F[0] = 0x2CE1; return; } /* COPTIC CAPITAL LETTER OLD NUBIAN NYI */
		if (c == 0x2CE2) { F[0] = 0x2CE3; return; } /* COPTIC CAPITAL LETTER OLD NUBIAN WAU */
		if (c == 0x2CEB) { F[0] = 0x2CEC; return; } /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC SHEI */
		if (c == 0x2CED) { F[0] = 0x2CEE; return; } /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC GANGIA */
		if (c == 0x2CF2) { F[0] = 0x2CF3; return; } /* COPTIC CAPITAL LETTER BOHAIRIC KHEI */
	} else if (c >= 0x3000) {
		if (c == 0xA640) { F[0] = 0xA641; return; } /* CYRILLIC CAPITAL LETTER ZEMLYA */
		if (c == 0xA642) { F[0] = 0xA643; return; } /* CYRILLIC CAPITAL LETTER DZELO */
		if (c == 0xA644) { F[0] = 0xA645; return; } /* CYRILLIC CAPITAL LETTER REVERSED DZE */
		if (c == 0xA646) { F[0] = 0xA647; return; } /* CYRILLIC CAPITAL LETTER IOTA */
		if (c == 0xA648) { F[0] = 0xA649; return; } /* CYRILLIC CAPITAL LETTER DJERV */
		if (c == 0xA64A) { F[0] = 0xA64B; return; } /* CYRILLIC CAPITAL LETTER MONOGRAPH UK */
		if (c == 0xA64C) { F[0] = 0xA64D; return; } /* CYRILLIC CAPITAL LETTER BROAD OMEGA */
		if (c == 0xA64E) { F[0] = 0xA64F; return; } /* CYRILLIC CAPITAL LETTER NEUTRAL YER */
		if (c == 0xA650) { F[0] = 0xA651; return; } /* CYRILLIC CAPITAL LETTER YERU WITH BACK YER */
		if (c == 0xA652) { F[0] = 0xA653; return; } /* CYRILLIC CAPITAL LETTER IOTIFIED YAT */
		if (c == 0xA654) { F[0] = 0xA655; return; } /* CYRILLIC CAPITAL LETTER REVERSED YU */
		if (c == 0xA656) { F[0] = 0xA657; return; } /* CYRILLIC CAPITAL LETTER IOTIFIED A */
		if (c == 0xA658) { F[0] = 0xA659; return; } /* CYRILLIC CAPITAL LETTER CLOSED LITTLE YUS */
		if (c == 0xA65A) { F[0] = 0xA65B; return; } /* CYRILLIC CAPITAL LETTER BLENDED YUS */
		if (c == 0xA65C) { F[0] = 0xA65D; return; } /* CYRILLIC CAPITAL LETTER IOTIFIED CLOSED LITTLE YUS */
		if (c == 0xA65E) { F[0] = 0xA65F; return; } /* CYRILLIC CAPITAL LETTER YN */
		if (c == 0xA660) { F[0] = 0xA661; return; } /* CYRILLIC CAPITAL LETTER REVERSED TSE */
		if (c == 0xA662) { F[0] = 0xA663; return; } /* CYRILLIC CAPITAL LETTER SOFT DE */
		if (c == 0xA664) { F[0] = 0xA665; return; } /* CYRILLIC CAPITAL LETTER SOFT EL */
		if (c == 0xA666) { F[0] = 0xA667; return; } /* CYRILLIC CAPITAL LETTER SOFT EM */
		if (c == 0xA668) { F[0] = 0xA669; return; } /* CYRILLIC CAPITAL LETTER MONOCULAR O */
		if (c == 0xA66A) { F[0] = 0xA66B; return; } /* CYRILLIC CAPITAL LETTER BINOCULAR O */
		if (c == 0xA66C) { F[0] = 0xA66D; return; } /* CYRILLIC CAPITAL LETTER DOUBLE MONOCULAR O */
		if (c == 0xA680) { F[0] = 0xA681; return; } /* CYRILLIC CAPITAL LETTER DWE */
		if (c == 0xA682) { F[0] = 0xA683; return; } /* CYRILLIC CAPITAL LETTER DZWE */
		if (c == 0xA684) { F[0] = 0xA685; return; } /* CYRILLIC CAPITAL LETTER ZHWE */
		if (c == 0xA686) { F[0] = 0xA687; return; } /* CYRILLIC CAPITAL LETTER CCHE */
		if (c == 0xA688) { F[0] = 0xA689; return; } /* CYRILLIC CAPITAL LETTER DZZE */
		if (c == 0xA68A) { F[0] = 0xA68B; return; } /* CYRILLIC CAPITAL LETTER TE WITH MIDDLE HOOK */
		if (c == 0xA68C) { F[0] = 0xA68D; return; } /* CYRILLIC CAPITAL LETTER TWE */
		if (c == 0xA68E) { F[0] = 0xA68F; return; } /* CYRILLIC CAPITAL LETTER TSWE */
		if (c == 0xA690) { F[0] = 0xA691; return; } /* CYRILLIC CAPITAL LETTER TSSE */
		if (c == 0xA692) { F[0] = 0xA693; return; } /* CYRILLIC CAPITAL LETTER TCHE */
		if (c == 0xA694) { F[0] = 0xA695; return; } /* CYRILLIC CAPITAL LETTER HWE */
		if (c == 0xA696) { F[0] = 0xA697; return; } /* CYRILLIC CAPITAL LETTER SHWE */
		if (c == 0xA698) { F[0] = 0xA699; return; } /* CYRILLIC CAPITAL LETTER DOUBLE O */
		if (c == 0xA69A) { F[0] = 0xA69B; return; } /* CYRILLIC CAPITAL LETTER CROSSED O */
		if (c == 0xA722) { F[0] = 0xA723; return; } /* LATIN CAPITAL LETTER EGYPTOLOGICAL ALEF */
		if (c == 0xA724) { F[0] = 0xA725; return; } /* LATIN CAPITAL LETTER EGYPTOLOGICAL AIN */
		if (c == 0xA726) { F[0] = 0xA727; return; } /* LATIN CAPITAL LETTER HENG */
		if (c == 0xA728) { F[0] = 0xA729; return; } /* LATIN CAPITAL LETTER TZ */
		if (c == 0xA72A) { F[0] = 0xA72B; return; } /* LATIN CAPITAL LETTER TRESILLO */
		if (c == 0xA72C) { F[0] = 0xA72D; return; } /* LATIN CAPITAL LETTER CUATRILLO */
		if (c == 0xA72E) { F[0] = 0xA72F; return; } /* LATIN CAPITAL LETTER CUATRILLO WITH COMMA */
		if (c == 0xA732) { F[0] = 0xA733; return; } /* LATIN CAPITAL LETTER AA */
		if (c == 0xA734) { F[0] = 0xA735; return; } /* LATIN CAPITAL LETTER AO */
		if (c == 0xA736) { F[0] = 0xA737; return; } /* LATIN CAPITAL LETTER AU */
		if (c == 0xA738) { F[0] = 0xA739; return; } /* LATIN CAPITAL LETTER AV */
		if (c == 0xA73A) { F[0] = 0xA73B; return; } /* LATIN CAPITAL LETTER AV WITH HORIZONTAL BAR */
		if (c == 0xA73C) { F[0] = 0xA73D; return; } /* LATIN CAPITAL LETTER AY */
		if (c == 0xA73E) { F[0] = 0xA73F; return; } /* LATIN CAPITAL LETTER REVERSED C WITH DOT */
		if (c == 0xA740) { F[0] = 0xA741; return; } /* LATIN CAPITAL LETTER K WITH STROKE */
		if (c == 0xA742) { F[0] = 0xA743; return; } /* LATIN CAPITAL LETTER K WITH DIAGONAL STROKE */
		if (c == 0xA744) { F[0] = 0xA745; return; } /* LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE */
		if (c == 0xA746) { F[0] = 0xA747; return; } /* LATIN CAPITAL LETTER BROKEN L */
		if (c == 0xA748) { F[0] = 0xA749; return; } /* LATIN CAPITAL LETTER L WITH HIGH STROKE */
		if (c == 0xA74A) { F[0] = 0xA74B; return; } /* LATIN CAPITAL LETTER O WITH LONG STROKE OVERLAY */
		if (c == 0xA74C) { F[0] = 0xA74D; return; } /* LATIN CAPITAL LETTER O WITH LOOP */
		if (c == 0xA74E) { F[0] = 0xA74F; return; } /* LATIN CAPITAL LETTER OO */
		if (c == 0xA750) { F[0] = 0xA751; return; } /* LATIN CAPITAL LETTER P WITH STROKE THROUGH DESCENDER */
		if (c == 0xA752) { F[0] = 0xA753; return; } /* LATIN CAPITAL LETTER P WITH FLOURISH */
		if (c == 0xA754) { F[0] = 0xA755; return; } /* LATIN CAPITAL LETTER P WITH SQUIRREL TAIL */
		if (c == 0xA756) { F[0] = 0xA757; return; } /* LATIN CAPITAL LETTER Q WITH STROKE THROUGH DESCENDER */
		if (c == 0xA758) { F[0] = 0xA759; return; } /* LATIN CAPITAL LETTER Q WITH DIAGONAL STROKE */
		if (c == 0xA75A) { F[0] = 0xA75B; return; } /* LATIN CAPITAL LETTER R ROTUNDA */
		if (c == 0xA75C) { F[0] = 0xA75D; return; } /* LATIN CAPITAL LETTER RUM ROTUNDA */
		if (c == 0xA75E) { F[0] = 0xA75F; return; } /* LATIN CAPITAL LETTER V WITH DIAGONAL STROKE */
		if (c == 0xA760) { F[0] = 0xA761; return; } /* LATIN CAPITAL LETTER VY */
		if (c == 0xA762) { F[0] = 0xA763; return; } /* LATIN CAPITAL LETTER VISIGOTHIC Z */
		if (c == 0xA764) { F[0] = 0xA765; return; } /* LATIN CAPITAL LETTER THORN WITH STROKE */
		if (c == 0xA766) { F[0] = 0xA767; return; } /* LATIN CAPITAL LETTER THORN WITH STROKE THROUGH DESCENDER */
		if (c == 0xA768) { F[0] = 0xA769; return; } /* LATIN CAPITAL LETTER VEND */
		if (c == 0xA76A) { F[0] = 0xA76B; return; } /* LATIN CAPITAL LETTER ET */
		if (c == 0xA76C) { F[0] = 0xA76D; return; } /* LATIN CAPITAL LETTER IS */
		if (c == 0xA76E) { F[0] = 0xA76F; return; } /* LATIN CAPITAL LETTER CON */
		if (c == 0xA779) { F[0] = 0xA77A; return; } /* LATIN CAPITAL LETTER INSULAR D */
		if (c == 0xA77B) { F[0] = 0xA77C; return; } /* LATIN CAPITAL LETTER INSULAR F */
		if (c == 0xA77D) { F[0] = 0x1D79; return; } /* LATIN CAPITAL LETTER INSULAR G */
		if (c == 0xA77E) { F[0] = 0xA77F; return; } /* LATIN CAPITAL LETTER TURNED INSULAR G */
		if (c == 0xA780) { F[0] = 0xA781; return; } /* LATIN CAPITAL LETTER TURNED L */
		if (c == 0xA782) { F[0] = 0xA783; return; } /* LATIN CAPITAL LETTER INSULAR R */
		if (c == 0xA784) { F[0] = 0xA785; return; } /* LATIN CAPITAL LETTER INSULAR S */
		if (c == 0xA786) { F[0] = 0xA787; return; } /* LATIN CAPITAL LETTER INSULAR T */
		if (c == 0xA78B) { F[0] = 0xA78C; return; } /* LATIN CAPITAL LETTER SALTILLO */
		if (c == 0xA78D) { F[0] = 0x0265; return; } /* LATIN CAPITAL LETTER TURNED H */
		if (c == 0xA790) { F[0] = 0xA791; return; } /* LATIN CAPITAL LETTER N WITH DESCENDER */
		if (c == 0xA792) { F[0] = 0xA793; return; } /* LATIN CAPITAL LETTER C WITH BAR */
		if (c == 0xA796) { F[0] = 0xA797; return; } /* LATIN CAPITAL LETTER B WITH FLOURISH */
		if (c == 0xA798) { F[0] = 0xA799; return; } /* LATIN CAPITAL LETTER F WITH STROKE */
		if (c == 0xA79A) { F[0] = 0xA79B; return; } /* LATIN CAPITAL LETTER VOLAPUK AE */
		if (c == 0xA79C) { F[0] = 0xA79D; return; } /* LATIN CAPITAL LETTER VOLAPUK OE */
		if (c == 0xA79E) { F[0] = 0xA79F; return; } /* LATIN CAPITAL LETTER VOLAPUK UE */
		if (c == 0xA7A0) { F[0] = 0xA7A1; return; } /* LATIN CAPITAL LETTER G WITH OBLIQUE STROKE */
		if (c == 0xA7A2) { F[0] = 0xA7A3; return; } /* LATIN CAPITAL LETTER K WITH OBLIQUE STROKE */
		if (c == 0xA7A4) { F[0] = 0xA7A5; return; } /* LATIN CAPITAL LETTER N WITH OBLIQUE STROKE */
		if (c == 0xA7A6) { F[0] = 0xA7A7; return; } /* LATIN CAPITAL LETTER R WITH OBLIQUE STROKE */
		if (c == 0xA7A8) { F[0] = 0xA7A9; return; } /* LATIN CAPITAL LETTER S WITH OBLIQUE STROKE */
		if (c == 0xA7AA) { F[0] = 0x0266; return; } /* LATIN CAPITAL LETTER H WITH HOOK */
		if (c == 0xA7AB) { F[0] = 0x025C; return; } /* LATIN CAPITAL LETTER REVERSED OPEN E */
		if (c == 0xA7AC) { F[0] = 0x0261; return; } /* LATIN CAPITAL LETTER SCRIPT G */
		if (c == 0xA7AD) { F[0] = 0x026C; return; } /* LATIN CAPITAL LETTER L WITH BELT */
		if (c == 0xA7AE) { F[0] = 0x026A; return; } /* LATIN CAPITAL LETTER SMALL CAPITAL I */
		if (c == 0xA7B0) { F[0] = 0x029E; return; } /* LATIN CAPITAL LETTER TURNED K */
		if (c == 0xA7B1) { F[0] = 0x0287; return; } /* LATIN CAPITAL LETTER TURNED T */
		if (c == 0xA7B2) { F[0] = 0x029D; return; } /* LATIN CAPITAL LETTER J WITH CROSSED-TAIL */
		if (c == 0xA7B3) { F[0] = 0xAB53; return; } /* LATIN CAPITAL LETTER CHI */
		if (c == 0xA7B4) { F[0] = 0xA7B5; return; } /* LATIN CAPITAL LETTER BETA */
		if (c == 0xA7B6) { F[0] = 0xA7B7; return; } /* LATIN CAPITAL LETTER OMEGA */
		if (c == 0xA7B8) { F[0] = 0xA7B9; return; } /* LATIN CAPITAL LETTER U WITH STROKE */
		if (c == 0xA7BA) { F[0] = 0xA7BB; return; } /* LATIN CAPITAL LETTER GLOTTAL A */
		if (c == 0xA7BC) { F[0] = 0xA7BD; return; } /* LATIN CAPITAL LETTER GLOTTAL I */
		if (c == 0xA7BE) { F[0] = 0xA7BF; return; } /* LATIN CAPITAL LETTER GLOTTAL U */
		if (c == 0xA7C0) { F[0] = 0xA7C1; return; } /* LATIN CAPITAL LETTER OLD POLISH O */
		if (c == 0xA7C2) { F[0] = 0xA7C3; return; } /* LATIN CAPITAL LETTER ANGLICANA W */
		if (c == 0xA7C4) { F[0] = 0xA794; return; } /* LATIN CAPITAL LETTER C WITH PALATAL HOOK */
		if (c == 0xA7C5) { F[0] = 0x0282; return; } /* LATIN CAPITAL LETTER S WITH HOOK */
		if (c == 0xA7C6) { F[0] = 0x1D8E; return; } /* LATIN CAPITAL LETTER Z WITH PALATAL HOOK */
		if (c == 0xA7C7) { F[0] = 0xA7C8; return; } /* LATIN CAPITAL LETTER D WITH SHORT STROKE OVERLAY */
		if (c == 0xA7C9) { F[0] = 0xA7CA; return; } /* LATIN CAPITAL LETTER S WITH SHORT STROKE OVERLAY */
		if (c == 0xA7D0) { F[0] = 0xA7D1; return; } /* LATIN CAPITAL LETTER CLOSED INSULAR G */
		if (c == 0xA7D6) { F[0] = 0xA7D7; return; } /* LATIN CAPITAL LETTER MIDDLE SCOTS S */
		if (c == 0xA7D8) { F[0] = 0xA7D9; return; } /* LATIN CAPITAL LETTER SIGMOID S */
		if (c == 0xA7F5) { F[0] = 0xA7F6; return; } /* LATIN CAPITAL LETTER REVERSED HALF H */
		if ((c >= 0xAB70) && (c <= 0xABBF)) { F[0] = 0x13A0 + (c - 0xAB70); return; } /* CHEROKEE SMALL LETTER A to CHEROKEE SMALL LETTER YA */
		if (c == 0xFB00) { F[0] = 0x0066; F[1] = 0x0066; return; } /* LATIN SMALL LIGATURE FF */
		if (c == 0xFB01) { F[0] = 0x0066; F[1] = 0x0069; return; } /* LATIN SMALL LIGATURE FI */
		if (c == 0xFB02) { F[0] = 0x0066; F[1] = 0x006C; return; } /* LATIN SMALL LIGATURE FL */
		if (c == 0xFB03) { F[0] = 0x0066; F[1] = 0x0066; F[2] = 0x0069; return; } /* LATIN SMALL LIGATURE FFI */
		if (c == 0xFB04) { F[0] = 0x0066; F[1] = 0x0066; F[2] = 0x006C; return; } /* LATIN SMALL LIGATURE FFL */
		if (c == 0xFB05) { F[0] = 0x0073; F[1] = 0x0074; return; } /* LATIN SMALL LIGATURE LONG S T */
		if (c == 0xFB06) { F[0] = 0x0073; F[1] = 0x0074; return; } /* LATIN SMALL LIGATURE ST */
		if (c == 0xFB13) { F[0] = 0x0574; F[1] = 0x0576; return; } /* ARMENIAN SMALL LIGATURE MEN NOW */
		if (c == 0xFB14) { F[0] = 0x0574; F[1] = 0x0565; return; } /* ARMENIAN SMALL LIGATURE MEN ECH */
		if (c == 0xFB15) { F[0] = 0x0574; F[1] = 0x056B; return; } /* ARMENIAN SMALL LIGATURE MEN INI */
		if (c == 0xFB16) { F[0] = 0x057E; F[1] = 0x0576; return; } /* ARMENIAN SMALL LIGATURE VEW NOW */
		if (c == 0xFB17) { F[0] = 0x0574; F[1] = 0x056D; return; } /* ARMENIAN SMALL LIGATURE MEN XEH */
		if ((c >= 0xFF21) && (c <= 0xFF3A)) { F[0] = 0xFF41 + (c - 0xFF21); return; } /* FULLWIDTH LATIN CAPITAL LETTER A to FULLWIDTH LATIN CAPITAL LETTER Z */
		if ((c >= 0x10400) && (c <= 0x10427)) { F[0] = 0x10428 + (c - 0x10400); return; } /* DESERET CAPITAL LETTER LONG I to DESERET CAPITAL LETTER EW */
		if ((c >= 0x104B0) && (c <= 0x104D3)) { F[0] = 0x104D8 + (c - 0x104B0); return; } /* OSAGE CAPITAL LETTER A to OSAGE CAPITAL LETTER ZHA */
		if ((c >= 0x10570) && (c <= 0x1057A)) { F[0] = 0x10597 + (c - 0x10570); return; } /* VITHKUQI CAPITAL LETTER A to VITHKUQI CAPITAL LETTER GA */
		if ((c >= 0x1057C) && (c <= 0x1058A)) { F[0] = 0x105A3 + (c - 0x1057C); return; } /* VITHKUQI CAPITAL LETTER HA to VITHKUQI CAPITAL LETTER RE */
		if ((c >= 0x1058C) && (c <= 0x10592)) { F[0] = 0x105B3 + (c - 0x1058C); return; } /* VITHKUQI CAPITAL LETTER SE to VITHKUQI CAPITAL LETTER XE */
		if (c == 0x10594) { F[0] = 0x105BB; return; } /* VITHKUQI CAPITAL LETTER Y */
		if (c == 0x10595) { F[0] = 0x105BC; return; } /* VITHKUQI CAPITAL LETTER ZE */
		if ((c >= 0x10C80) && (c <= 0x10CB2)) { F[0] = 0x10CC0 + (c - 0x10C80); return; } /* OLD HUNGARIAN CAPITAL LETTER A to OLD HUNGARIAN CAPITAL LETTER US */
		if ((c >= 0x118A0) && (c <= 0x118BF)) { F[0] = 0x118C0 + (c - 0x118A0); return; } /* WARANG CITI CAPITAL LETTER NGAA to WARANG CITI CAPITAL LETTER VIYO */
		if ((c >= 0x16E40) && (c <= 0x16E5F)) { F[0] = 0x16E60 + (c - 0x16E40); return; } /* MEDEFAIDRIN CAPITAL LETTER M to MEDEFAIDRIN CAPITAL LETTER Y */
		if ((c >= 0x1E900) && (c <= 0x1E921)) { F[0] = 0x1E922 + (c - 0x1E900); return; } /* ADLAM CAPITAL LETTER ALIF to ADLAM CAPITAL LETTER SHA */
	}
	F[0] = c; return;
}

#line 1754 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__is_ASCII_letter(inchar32_t c) {
	if ((c >= 'a') && (c <= 'z')) return TRUE;
	if ((c >= 'A') && (c <= 'Z')) return TRUE;
	return FALSE;
}

int Characters__is_ASCII_digit(inchar32_t c) {
	if ((c >= '0') && (c <= '9')) return TRUE;
	return FALSE;
}

int Characters__is_control_character(inchar32_t c) {
	if ((c >= 0x0001) && (c <= 0x001f)) return TRUE;
	if (c == 0x007f) return TRUE;
	return FALSE;
}

#line 1778 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__combine_accent(inchar32_t accent, inchar32_t letter) {
	switch(accent) {
		case 0x0300: /* Unicode combining grave */
			switch(letter) {
				case 'a': return 0xE0; case 'e': return 0xE8; case 'i': return 0xEC;
				case 'o': return 0xF2; case 'u': return 0xF9;
				case 'A': return 0xC0; case 'E': return 0xC8; case 'I': return 0xCC;
				case 'O': return 0xD2; case 'U': return 0xD9;
			}
			break;
		case 0x0301: /* Unicode combining acute */
			switch(letter) {
				case 'a': return 0xE1; case 'e': return 0xE9; case 'i': return 0xED;
				case 'o': return 0xF3; case 'u': return 0xFA; case 'y': return 0xFF;
				case 'A': return 0xC1; case 'E': return 0xC9; case 'I': return 0xCD;
				case 'O': return 0xD3; case 'U': return 0xDA;
			}
			break;
		case 0x0302: /* Unicode combining circumflex */
			switch(letter) {
				case 'a': return 0xE2; case 'e': return 0xEA; case 'i': return 0xEE;
				case 'o': return 0xF4; case 'u': return 0xFB;
				case 'A': return 0xC2; case 'E': return 0xCA; case 'I': return 0xCE;
				case 'O': return 0xD4; case 'U': return 0xDB;
			}
			break;
		case 0x0303: /* Unicode combining tilde */
			switch(letter) {
				case 'a': return 0xE3; case 'n': return 0xF1; case 'o': return 0xF5;
				case 'A': return 0xC3; case 'N': return 0xD1; case 'O': return 0xD5;
			}
			break;
		case 0x0308: /* Unicode combining diaeresis */
			switch(letter) {
				case 'a': return 0xE4; case 'e': return 0xEB; case 'u': return 0xFC;
				case 'o': return 0xF6; case 'i': return 0xEF;
				case 'A': return 0xC4; case 'E': return 0xCB; case 'U': return 0xDC;
				case 'O': return 0xD6; case 'I': return 0xCF;
			}
			break;
		case 0x0327: /* Unicode combining cedilla */
			switch(letter) {
				case 'c': return 0xE7; case 'C': return 0xC7;
			}
			break;
	}
	return 0;
}

#line 1832 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__make_filename_safe(int charcode) {
	charcode = Characters__remove_accent(charcode);
	if (charcode >= 128) charcode = '-';
	return charcode;
}

inchar32_t Characters__make_wchar_t_filename_safe(inchar32_t charcode) {
	charcode = Characters__remove_wchar_t_accent(charcode);
	if (charcode >= 128) charcode = '-';
	return charcode;
}

#line 1847 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__remove_accent(int charcode) {
	switch (charcode) {
		case 0xC0: case 0xC1: case 0xC2: case 0xC3:
		case 0xC4: case 0xC5: charcode = 'A'; break;
		case 0xE0: case 0xE1: case 0xE2: case 0xE3:
		case 0xE4: case 0xE5: charcode = 'a'; break;
		case 0xC8: case 0xC9: case 0xCA: case 0xCB: charcode = 'E'; break;
		case 0xE8: case 0xE9: case 0xEA: case 0xEB: charcode = 'e'; break;
		case 0xCC: case 0xCD: case 0xCE: case 0xCF: charcode = 'I'; break;
		case 0xEC: case 0xED: case 0xEE: case 0xEF: charcode = 'i'; break;
		case 0xD2: case 0xD3: case 0xD4: case 0xD5:
		case 0xD6: case 0xD8: charcode = 'O'; break;
		case 0xF2: case 0xF3: case 0xF4: case 0xF5:
		case 0xF6: case 0xF8: charcode = 'o'; break;
		case 0xD9: case 0xDA: case 0xDB: case 0xDC: charcode = 'U'; break;
		case 0xF9: case 0xFA: case 0xFB: case 0xFC: charcode = 'u'; break;
		case 0xDD: charcode = 'Y'; break;
		case 0xFD: charcode = 'y'; break;
		case 0xD1: charcode = 'N'; break;
		case 0xF1: charcode = 'n'; break;
		case 0xC7: charcode = 'C'; break;
		case 0xE7: charcode = 'c'; break;
		case 0xDF: charcode = 's'; break;
	}
	return charcode;
}

inchar32_t Characters__remove_wchar_t_accent(inchar32_t charcode) {
	return (inchar32_t) Characters__remove_accent((int) charcode);
}

#line 1881 "inweb/foundation-module/Chapter 4/Characters.w"
int Characters__isalphabetic(int letter) {
	return Characters__isalpha((inchar32_t) Characters__remove_accent(letter));
}


#line 21 "inweb/foundation-module/Chapter 4/C Strings.w"

#line 25 "inweb/foundation-module/Chapter 4/C Strings.w"
int CStrings__strlen_unbounded(const char *p) {
	return (int) strlen(p);
}

#line 35 "inweb/foundation-module/Chapter 4/C Strings.w"
int CStrings__check_len(int n) {
	if ((n > MAX_STRING_LENGTH) || (n < 0)) Errors__fatal("String overflow\n");
	return n;
}

#line 44 "inweb/foundation-module/Chapter 4/C Strings.w"
int CStrings__len(char *str) {
	for (int i=0; i<=MAX_STRING_LENGTH; i++)
		if (str[i] == 0) return i;
	str[MAX_STRING_LENGTH] = 0;
	return MAX_STRING_LENGTH;
}

#line 55 "inweb/foundation-module/Chapter 4/C Strings.w"
void CStrings__copy(char *to, char *from) {
	CStrings__check_len(CStrings__len(from));
	int i;
	for (i=0; ((from[i]) && (i < MAX_STRING_LENGTH)); i++) to[i] = from[i];
	to[i] = 0;
}

#line 65 "inweb/foundation-module/Chapter 4/C Strings.w"
int CStrings__eq(char *A, char *B) {
	return (CStrings__cmp(A, B) == 0)?TRUE:FALSE;
}

int CStrings__ne(char *A, char *B) {
	return (CStrings__cmp(A, B) == 0)?FALSE:TRUE;
}

#line 76 "inweb/foundation-module/Chapter 4/C Strings.w"
int CStrings__cmp(char *A, char *B) {
	if ((A == NULL) || (A[0] == 0)) {
		if ((B == NULL) || (B[0] == 0)) return 0;
		return -1;
	}
	if ((B == NULL) || (B[0] == 0)) return 1;
	return strcmp(A, B);
}

#line 89 "inweb/foundation-module/Chapter 4/C Strings.w"
void CStrings__transcode_ISO_string_to_UTF8(char *p, char *dest) {
	int i, j;
	for (i=0, j=0; p[i]; i++) {
		int charcode = (int) (((unsigned char *)p)[i]);
		if (charcode >= 128) {
			dest[j++] = (char) (0xC0 + (charcode >> 6));
			dest[j++] = (char) (0x80 + (charcode & 0x3f));
		} else {
			dest[j++] = p[i];
		}
	}
	dest[j] = 0;
}

#line 110 "inweb/foundation-module/Chapter 4/C Strings.w"
void CStrings__truncated_strcpy(char *to, char *from, int max) {
	int i;
	for (i=0; ((from[i]) && (i<max-1)); i++) to[i] = from[i];
	to[i] = 0;
}

#line 128 "inweb/foundation-module/Chapter 4/C Strings.w"

#line 130 "inweb/foundation-module/Chapter 4/C Strings.w"
char *CStrings__park_string(char *from) {
	string_storage_area *ssa = CREATE(string_storage_area);
	ssa->capacity = (int) CStrings__strlen_unbounded(from) + 1;
	ssa->storage_at = Memory__malloc(ssa->capacity, STRING_STORAGE_MREASON);
	strcpy(ssa->storage_at, from);
	return ssa->storage_at;
}

#line 141 "inweb/foundation-module/Chapter 4/C Strings.w"
void CStrings__free_ssas(void) {
	string_storage_area *ssa;
	LOOP_OVER(ssa, string_storage_area)
		Memory__I7_free(ssa->storage_at, STRING_STORAGE_MREASON, ssa->capacity);
}



#line 11 "inweb/foundation-module/Chapter 4/Wide Strings.w"
int Wide__len(const inchar32_t *p) {
	int l = 0;
	while (p[l] != 0) l++;
	return l;
}

#line 20 "inweb/foundation-module/Chapter 4/Wide Strings.w"
int Wide__cmp(inchar32_t *A, inchar32_t *B) {
	int i = 0;
	while ((A[i] != 0) && (B[i] != 0))
	{
		if (A[i] > B[i]) return 1;
		else if (A[i] < B[i]) return -1;
		i++;
	}
	return 0;
}

#line 32 "inweb/foundation-module/Chapter 4/Wide Strings.w"
int Wide__atoi(inchar32_t *p) {
	return 0;/*(int) wcstol(p, NULL, 10)*/
}

#line 37 "inweb/foundation-module/Chapter 4/Wide Strings.w"
void Wide__copy(inchar32_t *to, inchar32_t *from) {
	int i = 0;
	while (1)
	{
		to[i] = from[i];
		if (to[i] == 0) break;
		i++;
	}
}

#line 38 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream *Str__new(void) {
	return Str__new_with_capacity(32);
}

text_stream *Str__new_with_capacity(int c) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_to_memory(S, c)) return S;
	return NULL;
}

void Str__dispose_of(text_stream *text) {
	if (text) STREAM_CLOSE(text);
}

#line 57 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream *Str__duplicate(text_stream *E) {
	if (E == NULL) return Str__new();
	text_stream *S = CREATE(text_stream);
	if (Streams__open_to_memory(S, Str__len(E)+4)) {
		Streams__copy(S, E);
		return S;
	}
	return NULL;
}

#line 73 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream *Str__new_from_wide_string(const inchar32_t *C_string) {
	text_stream *S = CREATE(text_stream);
	int C_len = (C_string)?Wide__len(C_string):0;
	if (Streams__open_from_wide_string(S, C_string, C_len)) return S;
	return NULL;
}

text_stream *Str__new_from_ISO_string(const char *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_ISO_string(S, C_string)) return S;
	return NULL;
}

text_stream *Str__new_from_UTF8_string(const char *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_UTF8_string(S, C_string)) return S;
	return NULL;
}

text_stream *Str__new_from_locale_string(const char *C_string) {
	text_stream *S = CREATE(text_stream);
	if (Streams__open_from_locale_string(S, C_string)) return S;
	return NULL;
}

#line 101 "inweb/foundation-module/Chapter 4/String Manipulation.w"
text_stream *Str__from_wide_string(text_stream *S, inchar32_t *c_string) {
	int c_len = (c_string)?Wide__len(c_string):0;
	if (Streams__open_from_wide_string(S, c_string, c_len) == FALSE) return NULL;
	return S;
}

text_stream *Str__from_locale_string(text_stream *S, char *c_string) {
	if (Streams__open_from_locale_string(S, c_string) == FALSE) return NULL;
	return S;
}

#line 115 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__copy_to_ISO_string(char *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_ISO_string(C_string, S, buffer_size);
}

void Str__copy_to_UTF8_string(char *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_UTF8_string(C_string, S, buffer_size);
}

void Str__copy_to_wide_string(inchar32_t *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_wide_string(C_string, S, buffer_size);
}

void Str__copy_to_locale_string(char *C_string, text_stream *S, int buffer_size) {
	Streams__write_as_locale_string(C_string, S, buffer_size);
}

#line 134 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__atoi(text_stream *S, int index) {
	char buffer[32];
	int i = 0;
	for (string_position P = Str__at(S, index);
		((i < 31) && (P.index < Str__len(S))); P = Str__forward(P))
		buffer[i++] = (char) Str__get(P);
	buffer[i] = 0;
	return atoi(buffer);
}

#line 148 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__len(text_stream *S) {
	return Streams__get_position(S);
}

#line 165 "inweb/foundation-module/Chapter 4/String Manipulation.w"

#line 169 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position Str__start(text_stream *S) {
	string_position P; P.S = S; P.index = 0; return P;
}

string_position Str__at(text_stream *S, int i) {
	if (i < 0) i = 0;
	if (i > Str__len(S)) i = Str__len(S);
	string_position P; P.S = S; P.index = i; return P;
}

string_position Str__end(text_stream *S) {
	string_position P; P.S = S; P.index = Str__len(S); return P;
}

#line 186 "inweb/foundation-module/Chapter 4/String Manipulation.w"
string_position Str__back(string_position P) {
	if (P.index > 0) P.index--; return P;
}

string_position Str__forward(string_position P) {
	P.index++; return P;
}

string_position Str__plus(string_position P, int increment) {
	P.index += increment; return P;
}

int Str__width_between(string_position P1, string_position P2) {
	if (P1.S != P2.S) internal_error("positions are in different strings");
	return P2.index - P1.index;
}

int Str__in_range(string_position P) {
	if (P.index < Str__len(P.S)) return TRUE;
	return FALSE;
}

int Str__index(string_position P) {
	return P.index;
}

#line 224 "inweb/foundation-module/Chapter 4/String Manipulation.w"
inchar32_t Str__get(string_position P) {
	if ((P.S == NULL) || (P.index < 0)) return 0;
	return Streams__get_char_at_index(P.S, P.index);
}

inchar32_t Str__get_at(text_stream *S, int index) {
	if ((S == NULL) || (index < 0)) return 0;
	return Streams__get_char_at_index(S, index);
}

inchar32_t Str__get_first_char(text_stream *S) {
	return Str__get(Str__at(S, 0));
}

inchar32_t Str__get_last_char(text_stream *S) {
	int L = Str__len(S);
	if (L == 0) return 0;
	return Str__get(Str__at(S, L-1));
}

#line 245 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__put(string_position P, inchar32_t C) {
	if (P.index < 0) internal_error("wrote before start of string");
	if (P.S == NULL) internal_error("wrote to null stream");
	int ext = Str__len(P.S);
	if (P.index > ext) internal_error("wrote beyond end of string");
	if (P.index == ext) {
		if (C) PUT_TO(P.S, C);
		return;
	}
	Streams__put_char_at_index(P.S, P.index, C);
}

void Str__put_at(text_stream *S, int index, inchar32_t C) {
	Str__put(Str__at(S, index), C);
}

#line 264 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__clear(text_stream *S) {
	Str__truncate(S, 0);
}

void Str__truncate(text_stream *S, int len) {
	if (len < 0) len = 0;
	if (len < Str__len(S)) Str__put(Str__at(S, len), 0);
}

#line 276 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__remove_indentation(text_stream *S, int spaces_per_tab) {
	int spaces_in = 0, tab_stops_of_indentation = 0;
	while (Characters__is_space_or_tab(Str__get_first_char(S))) {
		if (Str__get_first_char(S) == '\t') {
			spaces_in = 0;
			tab_stops_of_indentation++;
		} else {
			spaces_in++;
			if (spaces_in == spaces_per_tab) {
				tab_stops_of_indentation++;
				spaces_in = 0;
			}
		}
		Str__delete_first_character(S);
	}
	if (spaces_in > 0) {
		TEMPORARY_TEXT(respaced)
		while (spaces_in > 0) { PUT_TO(respaced, ' '); spaces_in--; }
		WRITE_TO(respaced, "%S", S);
		Str__clear(S);
		Str__copy(S, respaced);
		DISCARD_TEXT(respaced)
	}
	return tab_stops_of_indentation;
}

void Str__rectify_indentation(text_stream *S, int spaces_per_tab) {
	TEMPORARY_TEXT(tail)
	WRITE_TO(tail, "%S", S);
	int N = Str__remove_indentation(tail, spaces_per_tab);
	Str__clear(S);
	for (int i=0; i<N; i++) for (int j=0; j<spaces_per_tab; j++) PUT_TO(S, ' ');
	WRITE_TO(S, "%S", tail);
	DISCARD_TEXT(tail)
}

#line 315 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__concatenate(text_stream *S1, text_stream *S2) {
	Streams__copy(S1, S2);
}

void Str__copy(text_stream *S1, text_stream *S2) {
	if (S1 == S2) return;
	Str__clear(S1);
	Streams__copy(S1, S2);
}

void Str__copy_tail(text_stream *S1, text_stream *S2, int from) {
	Str__clear(S1);
	int L = Str__len(S2);
	if (from < L)
		for (string_position P = Str__at(S2, from); P.index < L; P = Str__forward(P))
			PUT_TO(S1, Str__get(P));
}

#line 336 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__copy_ISO_string(text_stream *S, char *C_string) {
	Str__clear(S);
	Streams__write_ISO_string(S, C_string);
}

void Str__copy_UTF8_string(text_stream *S, char *C_string) {
	Str__clear(S);
	Streams__write_UTF8_string(S, C_string);
}

void Str__copy_wide_string(text_stream *S, inchar32_t *C_string) {
	Str__clear(S);
	Streams__write_wide_string(S, C_string);
}

#line 355 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__eq(text_stream *S1, text_stream *S2) {
	if (Str__cmp(S1, S2) == 0) return TRUE;
	return FALSE;
}

int Str__eq_insensitive(text_stream *S1, text_stream *S2) {
	if ((Str__len(S1) == Str__len(S2)) && (Str__cmp_insensitive(S1, S2) == 0)) return TRUE;
	return FALSE;
}

int Str__ne(text_stream *S1, text_stream *S2) {
	if (Str__cmp(S1, S2) != 0) return TRUE;
	return FALSE;
}

int Str__ne_insensitive(text_stream *S1, text_stream *S2) {
	if ((Str__len(S1) != Str__len(S2)) || (Str__cmp_insensitive(S1, S2) != 0)) return TRUE;
	return FALSE;
}

#line 392 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__cmp(text_stream *S1, text_stream *S2) {
	int L1 = Str__len(S1), L2 = Str__len(S2), M = L1;
	if (L2 < M) M = L2;
	for (int i=0; i<M; i++) {
		int d = (int) Str__get_at(S1, i) - (int) Str__get_at(S2, i);
		if (d != 0) return d;
	}
	return L1 - L2;
}

int Str__cmp_insensitive(text_stream *S1, text_stream *S2) {
	for (string_position P = Str__start(S1), Q = Str__start(S2);
		(P.index < Str__len(S1)) && (Q.index < Str__len(S2));
		P = Str__forward(P), Q = Str__forward(Q)) {
		int d = tolower((int) Str__get(P)) - tolower((int) Str__get(Q));
		if (d != 0) return d;
	}
	return Str__len(S1) - Str__len(S2);
}

#line 423 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__prefix_eq(text_stream *S1, text_stream *S2, int N) {
	int L1 = Str__len(S1), L2 = Str__len(S2);
	if ((N > L1) || (N > L2)) return FALSE;
	for (int i=0; i<N; i++)
		if (Str__get_at(S1, i) != Str__get_at(S2, i))
			return FALSE;
	return TRUE;
}

int Str__suffix_eq(text_stream *S1, text_stream *S2, int N) {
	int L1 = Str__len(S1), L2 = Str__len(S2);
	if ((N > L1) || (N > L2)) return FALSE;
	for (int i=1; i<=N; i++)
		if (Str__get_at(S1, L1-i) != Str__get_at(S2, L2-i))
			return FALSE;
	return TRUE;
}

int Str__begins_with(text_stream *S1, text_stream *S2) {
	return Str__prefix_eq(S1, S2, Str__len(S2));
}

int Str__ends_with(text_stream *S1, text_stream *S2) {
	return Str__suffix_eq(S1, S2, Str__len(S2));
}

int Str__begins_with_wide_string(text_stream *S, inchar32_t *prefix) {
	if ((prefix == NULL) || (*prefix == 0)) return TRUE;
	if (S == NULL) return FALSE;
	for (int i = 0; prefix[i]; i++)
		if (Str__get_at(S, i) != prefix[i])
			return FALSE;
	return TRUE;
}

int Str__ends_with_wide_string(text_stream *S, inchar32_t *suffix) {
	if ((suffix == NULL) || (*suffix == 0)) return TRUE;
	if (S == NULL) return FALSE;
	for (int i = 0, at = Str__len(S) - Wide__len(suffix); suffix[i]; i++)
		if (Str__get_at(S, at+i) != suffix[i])
			return FALSE;
	return TRUE;
}

#line 468 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__eq_wide_string(text_stream *S1, inchar32_t *S2) {
	if (S2 == NULL) return (Str__len(S1) == 0)?TRUE:FALSE;
	if (Str__len(S1) == Wide__len(S2)) {
		int i=0;
		LOOP_THROUGH_TEXT(P, S1)
			if (Str__get(P) != S2[i++])
				return FALSE;
		return TRUE;
	}
	return FALSE;
}
int Str__eq_narrow_string(text_stream *S1, char *S2) {
	if (S2 == NULL) return (Str__len(S1) == 0)?TRUE:FALSE;
	if (Str__len(S1) == (int) strlen(S2)) {
		int i=0;
		LOOP_THROUGH_TEXT(P, S1)
			if (Str__get(P) != (inchar32_t) S2[i++])
				return FALSE;
		return TRUE;
	}
	return FALSE;
}
int Str__ne_wide_string(text_stream *S1, inchar32_t *S2) {
	return (Str__eq_wide_string(S1, S2)?FALSE:TRUE);
}

#line 497 "inweb/foundation-module/Chapter 4/String Manipulation.w"
int Str__is_whitespace(text_stream *S) {
	LOOP_THROUGH_TEXT(pos, S)
		if (Characters__is_space_or_tab(Str__get(pos)) == FALSE)
			return FALSE;
	return TRUE;
}

#line 507 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__trim_white_space(text_stream *S) {
	int len = Str__len(S), i = 0, j = 0;
	string_position F = Str__start(S);
	LOOP_THROUGH_TEXT(P, S) {
		if (!(Characters__is_space_or_tab(Str__get(P)))) { F = P; break; }
		i++;
	}
	LOOP_BACKWARDS_THROUGH_TEXT(Q, S) {
		if (!(Characters__is_space_or_tab(Str__get(Q)))) break;
		j++;
	}
	if (i+j > Str__len(S)) Str__truncate(S, 0);
	else {
		len = len - j;
		Str__truncate(S, len);
		if (i > 0) {
			string_position P = Str__start(S);
			inchar32_t c = 0;
			do {
				c = Str__get(F);
				Str__put(P, c);
				P = Str__forward(P); F = Str__forward(F);
			} while (c != 0);
			len = len - i;
			Str__truncate(S, len);
		}
	}
}

int Str__trim_white_space_at_end(text_stream *S) {
	int shortened = FALSE;
	for (int j = Str__len(S)-1; j >= 0; j--) {
		if (Characters__is_space_or_tab(Str__get_at(S, j))) {
			Str__truncate(S, j);
			shortened = TRUE;
		} else break;
	}
	return shortened;
}

int Str__trim_all_white_space_at_end(text_stream *S) {
	int shortened = FALSE;
	for (int j = Str__len(S)-1; j >= 0; j--) {
		if (Characters__is_babel_whitespace(Str__get_at(S, j))) {
			Str__truncate(S, j);
			shortened = TRUE;
		} else break;
	}
	return shortened;
}

#line 561 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__delete_first_character(text_stream *S) {
	Str__delete_nth_character(S, 0);
}

void Str__delete_last_character(text_stream *S) {
	if (Str__len(S) > 0)
		Str__truncate(S, Str__len(S) - 1);
}

void Str__delete_nth_character(text_stream *S, int n) {
	for (string_position P = Str__at(S, n); P.index < Str__len(P.S); P = Str__forward(P))
		Str__put(P, Str__get(Str__forward(P)));
}

void Str__delete_n_characters(text_stream *S, int n) {
	int L = Str__len(S) - n;
	if (L <= 0) Str__clear(S);
	else {
		for (int i=0; i<L; i++)
			Str__put(Str__at(S, i), Str__get(Str__at(S, i+n)));
		Str__truncate(S, L);
	}
}

#line 588 "inweb/foundation-module/Chapter 4/String Manipulation.w"
void Str__substr(OUTPUT_STREAM, string_position from, string_position to) {
	if (from.S != to.S) internal_error("substr on two different strings");
	for (int i = from.index; i < to.index; i++)
		PUT(Str__get_at(from.S, i));
}

int Str__includes_character(text_stream *S, inchar32_t c) {
	if (S)
		LOOP_THROUGH_TEXT(pos, S)
			if (Str__get(pos) == c)
				return TRUE;
	return FALSE;
}

int Str__includes_wide_string_at(text_stream *S, inchar32_t *prefix, int j) {
	if ((prefix == NULL) || (*prefix == 0)) return TRUE;
	if (S == NULL) return FALSE;
	for (int i = 0; prefix[i]; i++)
		if (Str__get_at(S, i+j) != prefix[i])
			return FALSE;
	return TRUE;
}

int Str__includes_wide_string_at_insensitive(text_stream *S, inchar32_t *prefix, int j) {
	if ((prefix == NULL) || (*prefix == 0)) return TRUE;
	if (S == NULL) return FALSE;
	for (int i = 0; prefix[i]; i++)
		if (Characters__tolower(Str__get_at(S, i+j)) != Characters__tolower(prefix[i]))
			return FALSE;
	return TRUE;
}

int Str__includes(text_stream *S, text_stream *T) {
	int LS = Str__len(S);
	int LT = Str__len(T);
	for (int i=0; i<=LS-LT; i++) {
		int failed = FALSE;
		for (int j=0; j<LT; j++)
			if (Str__get_at(S, i+j) != Str__get_at(T, j)) {
				failed = TRUE;
				break;
			}
		if (failed == FALSE) return TRUE;
	}
	return FALSE;
}

int Str__includes_insensitive(text_stream *S, text_stream *T) {
	int LS = Str__len(S);
	int LT = Str__len(T);
	for (int i=0; i<=LS-LT; i++) {
		int failed = FALSE;
		for (int j=0; j<LT; j++)
			if (Characters__tolower(Str__get_at(S, i+j)) !=
				Characters__tolower(Str__get_at(T, j))) {
				failed = TRUE;
				break;
			}
		if (failed == FALSE) return TRUE;
	}
	return FALSE;
}

int Str__includes_at(text_stream *line, int i, text_stream *pattern) {
	if (Str__len(pattern) == 0) return FALSE;
	if (i < 0) return FALSE;
	if (i + Str__len(pattern) > Str__len(line)) return FALSE;
	LOOP_THROUGH_TEXT(pos, pattern)
		if (Str__get(pos) != Str__get_at(line, i++))
			return FALSE;
	return TRUE;
}

#line 672 "inweb/foundation-module/Chapter 4/String Manipulation.w"
dictionary *string_literals_dictionary = NULL;

text_stream *Str__literal(inchar32_t *wide_C_string) {
	text_stream *answer = NULL;
	CREATE_MUTEX(mutex);
	LOCK_MUTEX(mutex);
	
{
#line 684 "inweb/foundation-module/Chapter 4/String Manipulation.w"
	if (string_literals_dictionary == NULL)
		string_literals_dictionary = Dictionaries__new(100, TRUE);
	answer = Dictionaries__get_text_literal(string_literals_dictionary, wide_C_string);
	if (answer == NULL) {
		Dictionaries__create_literal(string_literals_dictionary, wide_C_string);
		answer = Dictionaries__get_text_literal(string_literals_dictionary, wide_C_string);
		WRITE_TO(answer, "%w", wide_C_string);
		Streams__mark_as_read_only(answer);
	}

}
#line 678 "inweb/foundation-module/Chapter 4/String Manipulation.w"
;
	UNLOCK_MUTEX(mutex);
	return answer;
}

#line 23 "inweb/foundation-module/Chapter 4/Tab Stops.w"

tabbed_string_iterator TabbedStr__new(text_stream *line, int tab_spacing) {
	tabbed_string_iterator mdw;
	mdw.line = line;
	mdw.read_index = 0;
	mdw.line_position = 0;
	mdw.tab_spacing = tab_spacing;
	return mdw;
}

#line 37 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int TabbedStr__get_index(tabbed_string_iterator *mdw) {
	return mdw->read_index;
}

int TabbedStr__get_position(tabbed_string_iterator *mdw) {
	return mdw->line_position;
}

#line 50 "inweb/foundation-module/Chapter 4/Tab Stops.w"
inchar32_t TabbedStr__get_character(tabbed_string_iterator *mdw) {
	inchar32_t c = Str__get_at(mdw->line, mdw->read_index);
	if (c == '\t') return ' ';
	return c;
}

#line 60 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int TabbedStr__at_whole_character(tabbed_string_iterator *mdw) {
	inchar32_t c = Str__get_at(mdw->line, mdw->read_index);
	if (c != '\t') return TRUE;
	if (mdw->line_position % mdw->tab_spacing == 0) return TRUE;
	return FALSE;
}

#line 70 "inweb/foundation-module/Chapter 4/Tab Stops.w"
void TabbedStr__advance(tabbed_string_iterator *mdw) {
	mdw->line_position++;
	if (TabbedStr__at_whole_character(mdw)) mdw->read_index++;
}

void TabbedStr__advance_by(tabbed_string_iterator *mdw, int N) {
	if (N < 0) internal_error("There's no going back");
	for (int i=0; i<N; i++) TabbedStr__advance(mdw);
}

#line 84 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int TabbedStr__seek(tabbed_string_iterator *mdw, int pos) {
	mdw->read_index = 0;
	mdw->line_position = 0;
	while (mdw->read_index < Str__len(mdw->line)) {
		if (mdw->line_position == pos) return TRUE;
		TabbedStr__advance(mdw);
	}
	return FALSE;
}

#line 97 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int TabbedStr__eat_space(tabbed_string_iterator *mdw) {
	if (mdw == NULL) internal_error("no mdw");
	if (TabbedStr__get_character(mdw) == ' ') {
		TabbedStr__advance(mdw);
		return TRUE;
	}
	return FALSE;
}

int TabbedStr__eat_spaces(int N, tabbed_string_iterator *mdw) {
	tabbed_string_iterator copy = *mdw;
	for (int i=1; i<=N; i++)
		if (TabbedStr__eat_space(mdw) == FALSE) {
			*mdw = copy;
			return FALSE;
		}
	return TRUE;
}

#line 120 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int TabbedStr__spaces_available(tabbed_string_iterator *mdw) {
	tabbed_string_iterator copy = *mdw;
	int total = 0;
	while (TabbedStr__eat_space(&copy)) total++;
	return total;
}

#line 130 "inweb/foundation-module/Chapter 4/Tab Stops.w"
int TabbedStr__blank_from_here(tabbed_string_iterator *mdw) {
	for (int i=mdw->read_index; i<Str__len(mdw->line); i++) {
		inchar32_t c = Str__get_at(mdw->line, i);
		if ((c != ' ') && (c != '\t')) return FALSE;
	}
	return TRUE;
}

#line 20 "inweb/foundation-module/Chapter 4/Text Files.w"
int TextFiles__exists(filename *F) {
	TEMPORARY_TEXT(pn)
	WRITE_TO(pn, "%f", F);
	scan_directory *D = Directories__open_from(pn);
	DISCARD_TEXT(pn)
	if (D) {
		Directories__close(D);
		return FALSE;
	}
	FILE *HANDLE = Filenames__fopen(F, "rb");
	if (HANDLE == NULL) return FALSE;
	fclose(HANDLE);
	return TRUE;
}

#line 48 "inweb/foundation-module/Chapter 4/Text Files.w"

#line 52 "inweb/foundation-module/Chapter 4/Text Files.w"
int TextFiles__get_line_count(text_file_position *tfp) {
	if (tfp == NULL) return 0;
	return tfp->line_count;
}

#line 60 "inweb/foundation-module/Chapter 4/Text Files.w"
text_file_position TextFiles__nowhere(void) {
	text_file_position tfp;
	tfp.text_file_filename = NULL;
	tfp.line_count = 0;
	tfp.line_position = 0;
	tfp.skip_terminator = FALSE;
	tfp.actively_scanning = FALSE;
	return tfp;
}

text_file_position TextFiles__at(filename *F, int line) {
	text_file_position tfp = TextFiles__nowhere();
	tfp.text_file_filename = F;
	tfp.line_count = line;
	return tfp;
}

#line 84 "inweb/foundation-module/Chapter 4/Text Files.w"
int TextFiles__read(filename *F, int escape_oddities, char *message, int serious,
	void (iterator)(text_stream *, text_file_position *, void *),
	text_file_position *start_at, void *state) {
	text_file_position tfp;
	if (escape_oddities) tfp.ufb = TextFiles__create_filtered_ufb(UNICODE_UFBHM);
	else tfp.ufb = TextFiles__create_ufb();
	
{
#line 98 "inweb/foundation-module/Chapter 4/Text Files.w"
	tfp.handle_when_open = Filenames__fopen(F, "rb");
	if (tfp.handle_when_open == NULL) {
		if (message == NULL) return 0;
		if (serious) Errors__fatal_with_file(message, F);
		else { Errors__with_file(message, F); return 0; }
	}

}
#line 90 "inweb/foundation-module/Chapter 4/Text Files.w"
;
	
{
#line 111 "inweb/foundation-module/Chapter 4/Text Files.w"
	if (start_at == NULL) {
		tfp.line_count = 1;
		tfp.line_position = 0;
		tfp.skip_terminator = 'X';
	} else {
		tfp = *start_at;
		if (fseek(tfp.handle_when_open, (long int) (tfp.line_position), SEEK_SET)) {
			if (serious) Errors__fatal_with_file("unable to seek position in file", F);
			Errors__with_file("unable to seek position in file", F);
			return 0;
		}
	}
	tfp.actively_scanning = TRUE;
	tfp.text_file_filename = F;

}
#line 91 "inweb/foundation-module/Chapter 4/Text Files.w"
;
	
{
#line 130 "inweb/foundation-module/Chapter 4/Text Files.w"
	TEMPORARY_TEXT(line)
	int i = 0, c = ' ';
	while ((c != EOF) && (tfp.actively_scanning)) {
		c = TextFiles__utf8_fgetc(tfp.handle_when_open, NULL, &tfp.ufb);
		if ((c == EOF) || (c == '\x0a') || (c == '\x0d')) {
			Str__put_at(line, i, 0);
			if ((i > 0) || (c != tfp.skip_terminator)) {
				
{
#line 154 "inweb/foundation-module/Chapter 4/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 137 "inweb/foundation-module/Chapter 4/Text Files.w"
;
				if (c == '\x0a') tfp.skip_terminator = '\x0d';
				if (c == '\x0d') tfp.skip_terminator = '\x0a';
			} else tfp.skip_terminator = 'X';
			
{
#line 168 "inweb/foundation-module/Chapter 4/Text Files.w"
	tfp.line_position = (int) (ftell(tfp.handle_when_open));
	if (tfp.line_position == -1) {
		if (serious)
			Errors__fatal_with_file("unable to determine position in file", F);
		else
			Errors__with_file("unable to determine position in file", F);
	}

}
#line 141 "inweb/foundation-module/Chapter 4/Text Files.w"
;
			i = 0;
		} else {
			Str__put_at(line, i++, (inchar32_t) c);
		}
	}
	if ((i > 0) && (tfp.actively_scanning))
		
{
#line 154 "inweb/foundation-module/Chapter 4/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 148 "inweb/foundation-module/Chapter 4/Text Files.w"
;
	DISCARD_TEXT(line)

}
#line 92 "inweb/foundation-module/Chapter 4/Text Files.w"
;
	fclose(tfp.handle_when_open);
	return tfp.line_count;
}

#line 177 "inweb/foundation-module/Chapter 4/Text Files.w"
void TextFiles__read_line(OUTPUT_STREAM, int escape_oddities, text_file_position *tfp) {
	Str__clear(OUT);
	int i = 0, c = ' ';
	while ((c != EOF) && (tfp->actively_scanning)) {
		c = TextFiles__utf8_fgetc(tfp->handle_when_open, NULL, &tfp->ufb);
		if ((c == EOF) || (c == '\x0a') || (c == '\x0d')) {
			Str__put_at(OUT, i, 0);
			if ((i > 0) || (c != tfp->skip_terminator)) {
				if (c == '\x0a') tfp->skip_terminator = '\x0d';
				if (c == '\x0d') tfp->skip_terminator = '\x0a';
			} else tfp->skip_terminator = 'X';
			tfp->line_position = (int) (ftell(tfp->handle_when_open));
			i = 0;
			tfp->line_count++; return;
		}
		Str__put_at(OUT, i++, (inchar32_t) c);
	}
	if ((i > 0) && (tfp->actively_scanning)) tfp->line_count++;
}

#line 201 "inweb/foundation-module/Chapter 4/Text Files.w"
void TextFiles__lose_interest(text_file_position *tfp) {
	tfp->actively_scanning = FALSE;
}

#line 231 "inweb/foundation-module/Chapter 4/Text Files.w"

#line 238 "inweb/foundation-module/Chapter 4/Text Files.w"

unicode_file_buffer TextFiles__create_ufb(void) {
	unicode_file_buffer ufb;
	ufb.ufb_counter = -1;
	ufb.handling_mode = NONE_UFBHM;
	return ufb;
}

unicode_file_buffer TextFiles__create_filtered_ufb(int mode) {
	unicode_file_buffer ufb = TextFiles__create_ufb();
	ufb.handling_mode = mode;
	return ufb;
}

int TextFiles__utf8_fgetc(FILE *from, const char **or_from, unicode_file_buffer *ufb) {
	int c = EOF, conts, mode = (ufb)?ufb->handling_mode:NONE_UFBHM;
	if ((ufb) && (ufb->ufb_counter >= 0)) {
		if (ufb->unicode_feed_buffer[ufb->ufb_counter] == 0) ufb->ufb_counter = -1;
		else return ufb->unicode_feed_buffer[ufb->ufb_counter++];
	}
	if (from) c = fgetc(from); else if (or_from) c = ((unsigned char) *((*or_from)++));
	if (c == EOF) return c; /* ruling out EOF leaves a genuine byte from the file */
	if (c<0x80) return c; /* in all other cases, a UTF-8 continuation sequence begins */

	
{
#line 286 "inweb/foundation-module/Chapter 4/Text Files.w"
    if (c<0xC0) return '?'; /* malformed UTF-8 */
	if (c<0xE0) { c = c & 0x1f; conts = 1; }
	else if (c<0xF0) { c = c & 0xf; conts = 2; }
	else if (c<0xF8) { c = c & 0x7; conts = 3; }
	else if (c<0xFC) { c = c & 0x3; conts = 4; }
	else { c = c & 0x1; conts = 5; }
	while (conts > 0) {
		int d = EOF;
		if (from) d = fgetc(from); else if (or_from) d = ((unsigned char) *((*or_from)++));
		if (d == EOF) return '?'; /* malformed UTF-8 */
		c = c << 6;
		c = c + (d & 0x3F);
		conts--;
	}

}
#line 262 "inweb/foundation-module/Chapter 4/Text Files.w"
;
	if (c == 0xFEFF) return c; /* the Unicode BOM non-character */

    if (mode != NONE_UFBHM) 
{
#line 329 "inweb/foundation-module/Chapter 4/Text Files.w"
	if (c == 0x85) return '\x0d'; /* NEL, or "next line" */
	if (c == 0xa0) return ' '; /* non-breaking space */
	if (c == 0xd7) return 'x'; /* convert multiplication sign to lower case "x" */
	if ((c >= 0x2000) && (c <= 0x200a)) return ' '; /* space variants */
	if ((c >= 0x2010) && (c <= 0x2014)) return '-'; /* rules and dashes */
	if ((c >= 0x2018) && (c <= 0x2019)) return '\''; /* smart single quotes */
	if ((c >= 0x201c) && (c <= 0x201d)) return '"'; /* smart double quotes */
	if ((c >= 0x2028) && (c <= 0x2029)) return '\x0d'; /* fancy newlines */

}
#line 265 "inweb/foundation-module/Chapter 4/Text Files.w"
;

	if (mode == ZSCII_UFBHM) {
	    
{
#line 311 "inweb/foundation-module/Chapter 4/Text Files.w"
	if ((c == 0xa1) || (c == 0xa3) || (c == 0xbf)) return c; /* pound sign, inverted ! and ? */
	if ((c >= 0xc0) && (c <= 0xff)) { /* accented West European letters, but... */
		if ((c != 0xd0) && (c != 0xf0) && /* not Icelandic eths */
		    (c != 0xde) && (c != 0xfe) && /* nor Icelandic thorns */
			(c != 0xf7)) /* nor division signs */
			return c;
	}

}
#line 268 "inweb/foundation-module/Chapter 4/Text Files.w"
;
		if (ufb) {
			sprintf(ufb->unicode_feed_buffer, "[unicode %d]", c);
			ufb->ufb_counter = 1;
			return '[';
		}
		return '?';
	}
	return c;
}

#line 344 "inweb/foundation-module/Chapter 4/Text Files.w"
int TextFiles__write_file_contents(OUTPUT_STREAM, filename *F) {
	return TextFiles__read(F, FALSE, NULL, FALSE,
		&TextFiles__write_file_contents_helper, NULL, OUT);
}

void TextFiles__write_file_contents_helper(text_stream *text, text_file_position *tfp,
	void *state) {
	text_stream *OUT = (text_stream *) state;
	WRITE("%S\n", text);
}

#line 28 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__preprocess(filename *prototype, filename *F, text_stream *header,
	linked_list *special_macros, general_pointer specifics, inchar32_t comment_char,
	int encoding) {
	struct text_stream processed_file;
	if (STREAM_OPEN_TO_FILE(&processed_file, F, encoding) == FALSE)
		Errors__fatal_with_file("unable to write tangled file", F);
	text_stream *OUT = &processed_file;
	WRITE("%S", header);

	preprocessor_state PPS;
	
{
#line 79 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	PPS.dest = Str__new();
	PPS.suppress_newline = FALSE;
	PPS.last_line_was_blank = TRUE;
	PPS.defining = NULL;
	PPS.repeat_sp = 0;
	PPS.shadow_sp = 0;
	PPS.global_variables = Preprocessor__new_variable_set(NULL);
	PPS.stack_frame = PPS.global_variables;
	PPS.known_macros = Preprocessor__list_of_reserved_macros(special_macros);
	PPS.specifics = specifics;
	PPS.comment_character = comment_char;

}
#line 38 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	TextFiles__read(prototype, FALSE, "can't open prototype file",
		TRUE, Preprocessor__scan_line, NULL, &PPS);
	for (int i=0; i<Str__len(PPS.dest); i++) {
		inchar32_t c = Str__get_at(PPS.dest, i);
		if (c == PROTECTED_OPEN_BRACE_PPCHAR) PUT('{');
		else if (c == PROTECTED_CLOSE_BRACE_PPCHAR) PUT('}');
		else if (c != PROTECTED_BLANK_PPCHAR) PUT(c);
	}
	STREAM_CLOSE(OUT);
}

#line 70 "inweb/foundation-module/Chapter 4/Preprocessor.w"

#line 77 "inweb/foundation-module/Chapter 4/Preprocessor.w"

#line 95 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__set_loop_var_name(preprocessor_loop *loop, text_stream *name) {
	loop->loop_var_name = Str__duplicate(name);
}
void Preprocessor__add_loop_iteration(preprocessor_loop *loop, text_stream *value) {
	ADD_TO_LINKED_LIST(Str__duplicate(value), text_stream, loop->iterations);
}

#line 110 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__scan_line(text_stream *line, text_file_position *tfp, void *X) {
	preprocessor_state *PPS = (preprocessor_state *) X;
	
{
#line 123 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	LOOP_THROUGH_TEXT(pos, line) {
		inchar32_t c = Str__get(pos);
		if (c == PPS->comment_character) return;
		if (Characters__is_whitespace(c) == FALSE) break;
	}

}
#line 112 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	
{
#line 130 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	for (int i = 0; i < Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		if (c == '\\') {
			inchar32_t d = Str__get_at(line, i+1);
			switch (d) {
				case '{':
					Str__put_at(line, i, PROTECTED_OPEN_BRACE_PPCHAR);
					Str__put_at(line, i+1, PROTECTED_BLANK_PPCHAR);
					break;
				case '}':
					Str__put_at(line, i, PROTECTED_CLOSE_BRACE_PPCHAR);
					Str__put_at(line, i+1, PROTECTED_BLANK_PPCHAR);
					break;
				case '\\':
					Str__put_at(line, i+1, PROTECTED_BLANK_PPCHAR);
					break;
				case ' ': case '\t': case '\n': case '\r': case 0: break;
				default:
					Errors__in_text_file("backslash '\\' must be followed by '{', '}' or '\\'", tfp);
					break;
			}
		}
	}

}
#line 113 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	
{
#line 155 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U" *{define: *(%C+) *} *")) 
{
#line 163 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (PPS->defining)
		Errors__in_text_file("nested definitions are not allowed", tfp);
	text_stream *name = mr.exp[0];
	text_stream *parameter_specification = Str__new();
	PPS->defining = Preprocessor__new_macro(PPS->known_macros, name,
		parameter_specification, Preprocessor__default_expander, tfp);
	Regexp__dispose_of(&mr);
	return;

}
#line 156 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	if (Regexp__match(&mr, line, U" *{define: *(%C+) (%c*)} *")) 
{
#line 173 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (PPS->defining)
		Errors__in_text_file("nested definitions are not allowed", tfp);
	text_stream *name = mr.exp[0];
	text_stream *parameter_specification = mr.exp[1];
	PPS->defining = Preprocessor__new_macro(PPS->known_macros, name,
		parameter_specification, Preprocessor__default_expander, tfp);
	Regexp__dispose_of(&mr);
	return;

}
#line 157 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	if (Regexp__match(&mr, line, U" *{end-define} *")) 
{
#line 188 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (PPS->defining == NULL)
		Errors__in_text_file("{end-define} without {define: ...}", tfp);
	PPS->defining = NULL;
	Regexp__dispose_of(&mr);
	return;

}
#line 158 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	if (PPS->defining) 
{
#line 183 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	Preprocessor__add_line_to_macro(PPS->defining, line, tfp);
	Regexp__dispose_of(&mr);
	return;

}
#line 159 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	Regexp__dispose_of(&mr);

}
#line 114 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	Preprocessor__expand(line, tfp, PPS);
	
{
#line 195 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (PPS->suppress_newline == FALSE) {
		text_stream *OUT = PPS->dest;
		if (Str__len(line) == 0) {
			if (PPS->last_line_was_blank == FALSE) WRITE("\n");
			PPS->last_line_was_blank = TRUE;
		} else {
			PPS->last_line_was_blank = FALSE;
			WRITE("\n");
		}
	}
	PPS->suppress_newline = FALSE;

}
#line 116 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
}

#line 218 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__expand(text_stream *text, text_file_position *tfp, preprocessor_state *PPS) {
	TEMPORARY_TEXT(before_matter)
	TEMPORARY_TEXT(braced_matter)
	TEMPORARY_TEXT(after_matter)
	int bl = 0, after_times = FALSE;
	for (int i = 0; i < Str__len(text); i++) {
		inchar32_t c = Str__get_at(text, i);
		if (after_times) PUT_TO(after_matter, c);
		else if (c == '{') {
			bl++;
			if (bl > 1) PUT_TO(braced_matter, c);
		} else if (c == '}') {
			bl--;
			if (bl == 0) after_times = TRUE;
			else PUT_TO(braced_matter, c);
		} else {
			if (bl < 0) Errors__in_text_file("too many '}'s", tfp);
			if (bl == 0) PUT_TO(before_matter, c);
			else PUT_TO(braced_matter, c);
		}
	}
	if (bl > 0) Errors__in_text_file("too many '{'s", tfp);
	if (after_times) {
		
{
#line 255 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (Preprocessor__acceptable_variable_name(braced_matter)) {
		
{
#line 316 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	Preprocessor__expand(before_matter, tfp, PPS);
	if (PPS->repeat_sp > 0) {
		WRITE_TO(PPS->dest, "{%S}", braced_matter);
	} else {
		
{
#line 361 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	preprocessor_variable *var =
		Preprocessor__find_variable(braced_matter, PPS->stack_frame);
	if (var) {
		WRITE_TO(PPS->dest, "%S", Preprocessor__read_variable(var));
	} else {
		TEMPORARY_TEXT(erm)
		WRITE_TO(erm, "unknown variable '%S'", braced_matter);
		Errors__in_text_file_S(erm, tfp);
		DISCARD_TEXT(erm)
	}

}
#line 320 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	}
	Preprocessor__expand(after_matter, tfp, PPS);

}
#line 256 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	} else {
		text_stream *identifier = braced_matter;
		text_stream *parameter_settings = NULL;
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, identifier, U"(%C+) (%c*)")) {
			identifier = mr.exp[0];
			parameter_settings = mr.exp[1];
		}
		
{
#line 283 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	preprocessor_macro *loop_mm;
	LOOP_OVER_LINKED_LIST(loop_mm, preprocessor_macro, PPS->known_macros)
		if (Str__len(loop_mm->loop_name) > 0) {
			if (Str__eq(identifier, loop_mm->loop_name)) {
				if (Str__is_whitespace(after_matter)) {
					if ((loop_mm->span == FALSE) && (loop_mm->begins_loop))
						identifier = loop_mm->identifier;
				} else {
					if ((loop_mm->span) && (loop_mm->begins_loop))
						identifier = loop_mm->identifier;
				}
			}
			TEMPORARY_TEXT(end_name)
			WRITE_TO(end_name, "end-%S", loop_mm->loop_name);
			if (Str__eq(identifier, end_name)) {
				if ((PPS->repeat_sp > 0) &&
					(PPS->repeat_data[PPS->repeat_sp-1].repeat_is_block)) {
					if ((loop_mm->span == FALSE) && (loop_mm->ends_loop))
						identifier = loop_mm->identifier;
				} else {
					if ((loop_mm->span) && (loop_mm->ends_loop))
						identifier = loop_mm->identifier;
				}
			}
			DISCARD_TEXT(end_name)
		}

}
#line 265 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;

		preprocessor_macro *mm = Preprocessor__find_macro(PPS->known_macros, identifier);
		if (mm == NULL) {
			TEMPORARY_TEXT(erm)
			WRITE_TO(erm, "unknown macro '%S'", identifier);
			Errors__in_text_file_S(erm, tfp);
			DISCARD_TEXT(erm)
		} else {
			
{
#line 332 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (mm->suppress_whitespace_when_expanding) {
		while (Characters__is_whitespace(Str__get_last_char(before_matter)))
			Str__delete_last_character(before_matter);
		while (Characters__is_whitespace(Str__get_first_char(after_matter)))
			Str__delete_first_character(after_matter);
	}
	Preprocessor__expand(before_matter, tfp, PPS);
	int divert_if_repeating = TRUE;
	if ((mm) && (mm->begins_loop)) {
		PPS->shadow_sp++;
	}
	if ((mm) && (mm->ends_loop)) {
		PPS->shadow_sp--;
		if (PPS->shadow_sp == 0) divert_if_repeating = FALSE;
	}

	if ((divert_if_repeating) && (PPS->repeat_sp > 0)) {
		WRITE_TO(PPS->dest, "{%S}", braced_matter);
	} else {
		
{
#line 376 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	text_stream *parameter_values[MAX_PP_MACRO_PARAMETERS];
	for (int i=0; i<MAX_PP_MACRO_PARAMETERS; i++) parameter_values[i] = NULL;
	
{
#line 391 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	match_results mr = Regexp__create_mr();
	while (Regexp__match(&mr, parameter_settings, U" *(%C+): *(%c*)")) {
		text_stream *setting = mr.exp[0];
		text_stream *value = mr.exp[1];
		text_stream *remainder = NULL;
		match_results mr3 = Regexp__create_mr();
		if (Regexp__match(&mr3, value, U"(%c+?) *(%C+:[^/]%c*)")) {
			value = mr3.exp[0];
			remainder = mr3.exp[1];
		}
		int found = FALSE;
		for (int i=0; i<mm->no_parameters; i++)
			if (Str__eq(setting, mm->parameters[i]->name)) {
				found = TRUE;
				parameter_values[i] = Str__new();
				text_stream *saved = PPS->dest;
				PPS->dest = parameter_values[i];
				Preprocessor__expand(value, tfp, PPS);
				PPS->dest = saved;
			}
		if (found == FALSE) {
			TEMPORARY_TEXT(erm)
			WRITE_TO(erm, "unknown parameter '%S:'", setting);
			Errors__in_text_file_S(erm, tfp);
			DISCARD_TEXT(erm)
		}
		Str__clear(parameter_settings);
		Str__copy(parameter_settings, remainder);
		Regexp__dispose_of(&mr3);
	}
	Regexp__dispose_of(&mr);
	if (Str__is_whitespace(parameter_settings) == FALSE)
		Errors__in_text_file("parameter list is malformed", tfp);

}
#line 378 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	
{
#line 426 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	for (int i=0; i<mm->no_parameters; i++)
		if (parameter_values[i] == NULL)
			if (mm->parameters[i]->optional == FALSE) {
				TEMPORARY_TEXT(erm)
				WRITE_TO(erm, "compulsory parameter '%S:' not given", mm->parameters[i]->name);
				Errors__in_text_file_S(erm, tfp);
				DISCARD_TEXT(erm)
			}

}
#line 379 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;

	preprocessor_loop *loop = NULL;
	if (mm->begins_loop) 
{
#line 440 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	if (PPS->repeat_sp >= MAX_PREPROCESSOR_LOOP_DEPTH) {
		Errors__in_text_file("repetition too deep", tfp);
	} else {
		loop = &(PPS->repeat_data[PPS->repeat_sp++]);
		PPS->shadow_sp = 1;
		Preprocessor__set_loop_var_name(loop, TL_IS_3);
		loop->iterations = NEW_LINKED_LIST(text_stream);
		loop->repeat_is_block = TRUE;
		if (mm->span) loop->repeat_is_block = FALSE;
		loop->repeat_saved_dest = PPS->dest;
		PPS->dest = Str__new();
	}

}
#line 382 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;

	(*(mm->expander))(mm, PPS, parameter_values, loop, tfp);

}
#line 351 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
		if (mm->suppress_newline_after_expanding) PPS->suppress_newline = TRUE;
	}
	Preprocessor__expand(after_matter, tfp, PPS);

}
#line 274 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
		}
		Regexp__dispose_of(&mr);
	}

}
#line 241 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	} else {
		WRITE_TO(PPS->dest, "%S", text);
	}
	DISCARD_TEXT(before_matter)
	DISCARD_TEXT(braced_matter)
	DISCARD_TEXT(after_matter)
}

#line 457 "inweb/foundation-module/Chapter 4/Preprocessor.w"
int Preprocessor__acceptable_variable_name(text_stream *name) {
	LOOP_THROUGH_TEXT(pos, name) {
		inchar32_t c = Str__get(pos);
		if ((c >= '0') && (c <= '9')) continue;
		if ((c >= 'A') && (c <= 'Z')) continue;
		if (c == '_') continue;
		return FALSE;
	}
	return TRUE;
}

#line 476 "inweb/foundation-module/Chapter 4/Preprocessor.w"

text_stream *Preprocessor__read_variable(preprocessor_variable *var) {
	if (var == NULL) internal_error("no such pp variable");
	return var->value;
}
void Preprocessor__write_variable(preprocessor_variable *var, text_stream *val) {
	if (var == NULL) internal_error("no such pp variable");
	var->value = Str__duplicate(val);
}

#line 496 "inweb/foundation-module/Chapter 4/Preprocessor.w"

preprocessor_variable_set *Preprocessor__new_variable_set(preprocessor_variable_set *outer) {
	preprocessor_variable_set *set = CREATE(preprocessor_variable_set);
	set->variables = NEW_LINKED_LIST(preprocessor_variable);
	set->outer = outer;
	return set;
}

preprocessor_variable *Preprocessor__find_variable_in_one(text_stream *name,
	preprocessor_variable_set *set) {
	if (set == NULL) return NULL;
	preprocessor_variable *var;
	LOOP_OVER_LINKED_LIST(var, preprocessor_variable, set->variables)
		if (Str__eq(name, var->name))
			return var;
	return NULL;
}

preprocessor_variable *Preprocessor__find_variable(text_stream *name,
	preprocessor_variable_set *set) {
	while (set) {
		preprocessor_variable *var = Preprocessor__find_variable_in_one(name, set);
		if (var) return var;
		set = set->outer;
	}
	return NULL;
}

#line 528 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_variable *Preprocessor__ensure_variable(text_stream *name,
	preprocessor_variable_set *in_set) {
	if (in_set == NULL) internal_error("variable without set");
	preprocessor_variable *var = Preprocessor__find_variable_in_one(name, in_set);
	if (var == NULL) {
		var = CREATE(preprocessor_variable);
		var->name = Str__duplicate(name);
		Preprocessor__write_variable(var, TL_IS_4);
		ADD_TO_LINKED_LIST(var, preprocessor_variable, in_set->variables);
	}
	return var;
}

#line 587 "inweb/foundation-module/Chapter 4/Preprocessor.w"

#line 594 "inweb/foundation-module/Chapter 4/Preprocessor.w"

#line 605 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_macro *Preprocessor__new_macro(linked_list *L, text_stream *name,
	text_stream *parameter_specification,
	void (*expander)(preprocessor_macro *, preprocessor_state *, text_stream **, preprocessor_loop *, text_file_position *),
	text_file_position *tfp) {
	if (Preprocessor__find_macro(L, name))
		Errors__in_text_file("a macro with this name already exists", tfp);
	preprocessor_macro *new_macro = CREATE(preprocessor_macro);
	
{
#line 619 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	new_macro->identifier = Str__duplicate(name);
	new_macro->no_parameters = 0;

	new_macro->no_lines = 0;
	new_macro->expander = expander;
	new_macro->begins_loop = FALSE;
	new_macro->ends_loop = FALSE;
	new_macro->loop_name = NULL;
	new_macro->span = FALSE;

	new_macro->suppress_newline_after_expanding = TRUE;
	new_macro->suppress_whitespace_when_expanding = TRUE;

}
#line 612 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	
{
#line 633 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	text_stream *spec = Str__duplicate(parameter_specification);
	match_results mr = Regexp__create_mr();
	while (Regexp__match(&mr, spec, U" *(%C+): *(%C+) *(%c*)")) {
		text_stream *par_name = mr.exp[0];
		text_stream *token_name = mr.exp[1];
		Str__clear(spec);
		Str__copy(spec, mr.exp[2]);
		if (new_macro->no_parameters >= MAX_PP_MACRO_PARAMETERS) {
			Errors__in_text_file("too many parameters in this definition", tfp);
		} else {
			
{
#line 651 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	preprocessor_macro_parameter *new_parameter = CREATE(preprocessor_macro_parameter);
	new_parameter->name = Str__duplicate(par_name);
	new_parameter->definition_token = Str__duplicate(token_name);
	new_parameter->optional = FALSE;
	if (Str__get_first_char(new_parameter->name) == '?') {
		new_parameter->optional = TRUE;
		Str__delete_first_character(new_parameter->name);
	}
	new_macro->parameters[new_macro->no_parameters++] = new_parameter;

}
#line 643 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
		}
	}
	Regexp__dispose_of(&mr);
	if (Str__is_whitespace(spec) == FALSE)
		Errors__in_text_file("parameter list for this definition is malformed", tfp);

}
#line 613 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
	ADD_TO_LINKED_LIST(new_macro, preprocessor_macro, L);
	return new_macro;
}

#line 665 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__add_line_to_macro(preprocessor_macro *mm, text_stream *line,
	text_file_position *tfp) {
	if (mm->no_lines >= MAX_PP_MACRO_LINES) {
		Errors__in_text_file("too many lines in this definition", tfp);
	} else {
		mm->lines[mm->no_lines++] = Str__duplicate(line);
	}
}

#line 683 "inweb/foundation-module/Chapter 4/Preprocessor.w"
linked_list *Preprocessor__list_of_reserved_macros(linked_list *special_macros) {
	linked_list *L = NEW_LINKED_LIST(preprocessor_macro);
	Preprocessor__new_loop_macro(L, TL_IS_5, TL_IS_6,
		Preprocessor__repeat_expander, NULL);
	Preprocessor__new_macro(L, TL_IS_7, TL_IS_8,
		Preprocessor__set_expander, NULL);

	preprocessor_macro *mm;
	LOOP_OVER_LINKED_LIST(mm, preprocessor_macro, special_macros)
		ADD_TO_LINKED_LIST(mm, preprocessor_macro, L);
	return L;
}

void Preprocessor__do_not_suppress_whitespace(preprocessor_macro *mm) {
	mm->suppress_newline_after_expanding = FALSE;
	mm->suppress_whitespace_when_expanding = FALSE;
}

void Preprocessor__new_loop_macro(linked_list *L, text_stream *name,
	text_stream *parameter_specification,
	void (*expander)(preprocessor_macro *, preprocessor_state *, text_stream **, preprocessor_loop *, text_file_position *),
	text_file_position *tfp) {
	TEMPORARY_TEXT(subname)

	WRITE_TO(subname, "%S-block", name);
	preprocessor_macro *mm = Preprocessor__new_macro(L, subname, parameter_specification, expander, tfp);
	mm->begins_loop = TRUE;
	mm->loop_name = Str__duplicate(name);

	Str__clear(subname);
	WRITE_TO(subname, "end-%S-block", name);
	mm = Preprocessor__new_macro(L, subname, NULL, Preprocessor__end_loop_expander, tfp);
	mm->ends_loop = TRUE;
	mm->loop_name = Str__duplicate(name);

	Str__clear(subname);
	WRITE_TO(subname, "%S-span", name);
	mm = Preprocessor__new_macro(L, subname, parameter_specification, expander, tfp);
	mm->begins_loop = TRUE;
	mm->loop_name = Str__duplicate(name);
	mm->span = TRUE;
	Preprocessor__do_not_suppress_whitespace(mm);

	Str__clear(subname);
	WRITE_TO(subname, "end-%S-span", name);
	mm = Preprocessor__new_macro(L, subname, NULL, Preprocessor__end_loop_expander, tfp);
	mm->ends_loop = TRUE;
	mm->loop_name = Str__duplicate(name);
	mm->span = TRUE;
	Preprocessor__do_not_suppress_whitespace(mm);

	DISCARD_TEXT(subname)
}

#line 740 "inweb/foundation-module/Chapter 4/Preprocessor.w"
preprocessor_macro *Preprocessor__find_macro(linked_list *L, text_stream *name) {
	preprocessor_macro *mm;
	LOOP_OVER_LINKED_LIST(mm, preprocessor_macro, L)
		if (Str__eq(mm->identifier, name))
			return mm;
	return NULL;
}

#line 755 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__default_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	PPS->stack_frame = Preprocessor__new_variable_set(PPS->stack_frame);
	for (int i=0; i<mm->no_parameters; i++) {
		preprocessor_variable *var =
			Preprocessor__ensure_variable(mm->parameters[i]->definition_token, PPS->stack_frame);
		Preprocessor__write_variable(var, parameter_values[i]);
	}
	for (int i=0; i<mm->no_lines; i++)
		Preprocessor__scan_line(mm->lines[i], tfp, (void *) PPS);
	PPS->stack_frame = PPS->stack_frame->outer;
}

#line 772 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__set_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	text_stream *name = parameter_values[0];
	text_stream *value = parameter_values[1];

	if (Preprocessor__acceptable_variable_name(name) == FALSE)
		Errors__in_text_file("improper variable name", tfp);

	preprocessor_variable *var = Preprocessor__ensure_variable(name, PPS->stack_frame);
	Preprocessor__write_variable(var, value);
}

#line 787 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__repeat_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	text_stream *with = parameter_values[0];
	text_stream *in = parameter_values[1];
	Preprocessor__set_loop_var_name(loop, with);
	match_results mr = Regexp__create_mr();
	while (Regexp__match(&mr, in, U"(%c*?),(%c*)")) {
		text_stream *value = mr.exp[0];
		Str__trim_white_space(value);
		Preprocessor__add_loop_iteration(loop, value);
		Str__clear(in);
		Str__copy(in, mr.exp[1]);
	}
	Regexp__dispose_of(&mr);
	text_stream *value = in;
	Str__trim_white_space(value);
	Preprocessor__add_loop_iteration(loop, value);
}

#line 816 "inweb/foundation-module/Chapter 4/Preprocessor.w"
void Preprocessor__end_loop_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	PPS->shadow_sp = 0;
	if (PPS->repeat_sp == 0) Errors__in_text_file("end without repeat", tfp);
	else {
		preprocessor_loop *loop = &(PPS->repeat_data[--(PPS->repeat_sp)]);
		text_stream *matter = PPS->dest;
		PPS->dest = loop->repeat_saved_dest;
		PPS->stack_frame = Preprocessor__new_variable_set(PPS->stack_frame);
		preprocessor_variable *loop_var =
			Preprocessor__ensure_variable(loop->loop_var_name, PPS->stack_frame);
		text_stream *value;
		LOOP_OVER_LINKED_LIST(value, text_stream, loop->iterations)
			
{
#line 835 "inweb/foundation-module/Chapter 4/Preprocessor.w"
	Preprocessor__write_variable(loop_var, value);
	if (mm->span) {
		Preprocessor__expand(matter, tfp, PPS);
	} else {
		TEMPORARY_TEXT(line)
		LOOP_THROUGH_TEXT(pos, matter) {
			if (Str__get(pos) == '\n') {
				Preprocessor__scan_line(line, tfp, (void *) PPS);
				Str__clear(line);
			} else {
				PUT_TO(line, Str__get(pos));
			}
		}
		DISCARD_TEXT(line)
	}

}
#line 829 "inweb/foundation-module/Chapter 4/Preprocessor.w"
;
		PPS->stack_frame = PPS->stack_frame->outer;
	}
}

#line 49 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"

#line 77 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
inchar32_t *Tries__search(match_trie *T, text_stream *p, inchar32_t *add_outcome) {
	if (T == NULL) internal_error("no trie to search");

	int start, endpoint, delta;
	
{
#line 140 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	start = 0; endpoint = Str__len(p); delta = 1;
	if (T->match_character == TRIE_END) { start = Str__len(p)-1; endpoint = -1; delta = -1; }

}
#line 81 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;

	match_trie *prev = NULL, *pos = T;
	
{
#line 217 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	if (pos == NULL) internal_error("trie invariant broken");
	prev = pos; pos = prev->on_success;

}
#line 84 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;

	int rewind_sp = 0;
	int rewind_points[MAX_TRIE_REWIND];
	match_trie *rewind_positions[MAX_TRIE_REWIND];
	match_trie *rewind_prev_positions[MAX_TRIE_REWIND];

	for (int i = start; i != endpoint+delta; i += delta) {
		inchar32_t group[MAX_TRIE_GROUP_SIZE+1];
		int g = 0; /* size of group */
		inchar32_t c = (i<0)?0:(Str__get_at(p, i)); /* i.e., zero at the two ends of the text */
		if ((c >= 0x20) && (c <= 0x7f)) c = Characters__tolower(c); /* normalise it within ASCII */
		if (c == 0x20) { c = 0; i = endpoint - delta; } /* force any space to be equivalent to the final 0 */
		if (add_outcome) {
			inchar32_t pairc = 0;
			if (c == '<') pairc = '>';
			if (c == '>') pairc = '<';
			if (pairc) {
				int j;
				for (j = i+delta; j != endpoint; j += delta) {
					inchar32_t ch = (j<0)?0:(Str__get_at(p, j));
					if (ch == pairc) break;
					if (g > MAX_TRIE_GROUP_SIZE) { g = 0; break; }
					group[g++] = ch;
				}
				group[g] = 0;
				if (g > 0) i = j;
			}
		}
		if (c == '*') endpoint -= delta;

		RewindHere:
		
{
#line 153 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	int ambig = 0, unambig = 0;
	match_trie *point;
	for (point = pos; point; point = point->next)
		if (Tries__is_ambiguous(point)) ambig++;
		else unambig++;

	FauxWhileLoop:
	if (pos) {
		if ((add_outcome == NULL) || (Tries__is_ambiguous(pos) == FALSE))
			if (Tries__matches(pos, c)) {
				if (pos->match_character == TRIE_ANYTHING) break;
				if ((add_outcome == NULL) && (ambig > 0) && (ambig+unambig > 1)
					&& (rewind_sp < MAX_TRIE_REWIND)) {
					rewind_points[rewind_sp] = i;
					rewind_positions[rewind_sp] = pos->next;
					rewind_prev_positions[rewind_sp] = prev;
					rewind_sp++;
				}
				
{
#line 217 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	if (pos == NULL) internal_error("trie invariant broken");
	prev = pos; pos = prev->on_success;

}
#line 171 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;
				continue;
			}
		pos = pos->next;
		goto FauxWhileLoop;
	}

}
#line 116 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;
		if (add_outcome == NULL) {
			if (rewind_sp > 0) {
				i = rewind_points[rewind_sp-1];
				pos = rewind_positions[rewind_sp-1];
				prev = rewind_prev_positions[rewind_sp-1];
				rewind_sp--;
				goto RewindHere;
			}
			return NULL; /* failure! */
		}
		
{
#line 179 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	match_trie *new_pos = NULL;
	if (g > 0) {
		int nt = TRIE_ANY_GROUP;
		inchar32_t *from = group;
		if (group[0] == '!') { from++; nt = TRIE_NOT_GROUP; }
		if (group[(int) Wide__len(group)-1] == '!') {
			group[(int) Wide__len(group)-1] = 0; nt = TRIE_NOT_GROUP;
		}
		new_pos = Tries__new(nt);
		Wide__copy(new_pos->group_characters, from);
	} else if (c == '*') new_pos = Tries__new(TRIE_ANYTHING);
	else new_pos = Tries__new((int)c);

	if (prev->on_success == NULL) prev->on_success = new_pos;
	else {
		match_trie *ppoint = NULL, *point;
		for (point = prev->on_success; point; ppoint = point, point = point->next) {
			if (new_pos->match_character < point->match_character) {
				if (ppoint == NULL) {
					new_pos->next = prev->on_success;
					prev->on_success = new_pos;
				} else {
					ppoint->next = new_pos;
					new_pos->next = point;
				}
				break;
			}
			if (point->next == NULL) {
				point->next = new_pos;
				break;
			}
		}
	}

	pos = new_pos;
	
{
#line 217 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	if (pos == NULL) internal_error("trie invariant broken");
	prev = pos; pos = prev->on_success;

}
#line 214 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
; continue;

}
#line 127 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;
	}
	if ((pos) && (pos->match_character == TRIE_ANYTHING)) 
{
#line 217 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	if (pos == NULL) internal_error("trie invariant broken");
	prev = pos; pos = prev->on_success;

}
#line 129 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;
	if ((pos) && (pos->match_outcome)) return pos->match_outcome; /* success! */
	if (add_outcome == NULL) return NULL; /* failure! */

	if (pos == NULL)
		
{
#line 225 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	prev->on_success = Tries__new(TRIE_STOP);
	prev->on_success->match_outcome = add_outcome;
	return add_outcome;

}
#line 134 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"

	else
		
{
#line 230 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
	prev->on_success = Tries__new(TRIE_STOP);
	prev->on_success->match_outcome = add_outcome;
	return add_outcome;

}
#line 136 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
;
}

#line 237 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
int Tries__matches(match_trie *pos, inchar32_t c) {
	if (pos->match_character == TRIE_ANYTHING) return TRUE;
	if (pos->match_character == TRIE_ANY_GROUP) {
		int k;
		for (k = 0; pos->group_characters[k]; k++)
			if (c == pos->group_characters[k])
				return TRUE;
		return FALSE;
	}
	if (pos->match_character == TRIE_NOT_GROUP) {
		int k;
		for (k = 0; pos->group_characters[k]; k++)
			if (c == pos->group_characters[k])
				return FALSE;
		return TRUE;
	}
	if (pos->match_character == (int)c) return TRUE;
	return FALSE;
}

int Tries__is_ambiguous(match_trie *pos) {
	if (pos->match_character == TRIE_ANYTHING) return TRUE;
	if (pos->match_character == TRIE_ANY_GROUP) return TRUE;
	if (pos->match_character == TRIE_NOT_GROUP) return TRUE;
	return FALSE;
}

#line 267 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
match_trie *Tries__new(int mc) {
	match_trie *T = CREATE(match_trie);
	T->match_character = mc;
	T->match_outcome = NULL;
	T->on_success = NULL;
	T->next = NULL;
	return T;
}

#line 288 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"

#line 293 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
match_avinue *Tries__new_avinue(int from_start) {
	match_avinue *A = CREATE(match_avinue);
	A->next = NULL;
	A->the_trie = Tries__new(from_start);
	return A;
}

void Tries__add_to_avinue(match_avinue *mt, text_stream *from, inchar32_t *to) {
	if ((mt == NULL) || (mt->the_trie == NULL)) internal_error("null trie");
	Tries__search(mt->the_trie, from, to);
}

#line 309 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
match_avinue *Tries__duplicate_avinue(match_avinue *A) {
	match_avinue *F = NULL, *FL = NULL;
	while (A) {
		match_avinue *FN = CREATE(match_avinue);
		FN->next = NULL;
		FN->the_trie = A->the_trie;
		A = A->next;
		if (FL) FL->next = FN;
		if (F == NULL) F = FN;
		FL = FN;
	}
	return F;
}

#line 327 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
inchar32_t *Tries__search_avinue(match_avinue *T, text_stream *p) {
	inchar32_t *result = NULL;
	while ((T) && (result == NULL)) {
		result = Tries__search(T->the_trie, p, NULL);
		T = T->next;
	}
	return result;
}

#line 339 "inweb/foundation-module/Chapter 4/Tries and Avinues.w"
void Tries__log_avinue(OUTPUT_STREAM, void *vA) {
	match_avinue *A = (match_avinue *) vA;
	WRITE("Avinue:\n"); INDENT;
	int n = 1;
	while (A) {
		WRITE("Trie %d:\n", n++); INDENT;
		Tries__log(OUT, A->the_trie);
		OUTDENT;
		A = A->next;
	}
	OUTDENT;
}

void Tries__log(OUTPUT_STREAM, match_trie *T) {
	for (; T; T = T->next) {
		switch (T->match_character) {
			case TRIE_START: WRITE("Start"); break;
			case TRIE_END: WRITE("End"); break;
			case TRIE_ANYTHING: WRITE("Anything"); break;
			case TRIE_ANY_GROUP: WRITE("Group <%w>", T->group_characters); break;
			case TRIE_NOT_GROUP: WRITE("Negated group <%w>", T->group_characters); break;
			case TRIE_STOP: WRITE("Stop"); break;
			case 0: WRITE("00"); break;
			default: WRITE("%c", T->match_character); break;
		}
		if (T->match_outcome) WRITE(" --> %s", T->match_outcome);
		WRITE("\n");
		if (T->on_success) {
			INDENT; Tries__log(OUT, T->on_success); OUTDENT;
		}
	}
}

#line 10 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__white_space(inchar32_t c) {
	if ((c == ' ') || (c == '\t')) return TRUE;
	return FALSE;
}

#line 20 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__identifier_char(inchar32_t c) {
	if ((c == '_') || (c == ':') ||
		((c >= 'A') && (c <= 'Z')) ||
		((c >= 'a') && (c <= 'z')) ||
		((c >= '0') && (c <= '9'))) return TRUE;
	return FALSE;
}

#line 35 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__find_expansion(text_stream *text, inchar32_t on1, inchar32_t on2,
	inchar32_t off1, inchar32_t off2, int *len) {
	for (int i = 0; i < Str__len(text); i++)
		if ((Str__get_at(text, i) == on1) && (Str__get_at(text, i+1) == on2)) {
			for (int j=i+2; j < Str__len(text); j++)
				if ((Str__get_at(text, j) == off1) && (Str__get_at(text, j+1) == off2)) {
					*len = j+2-i;
					return i;
				}
		}
	return -1;
}

#line 51 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__find_open_brace(text_stream *text) {
	for (int i=0; i < Str__len(text); i++)
		if (Str__get_at(text, i) == '{')
			return i;
	return -1;
}

#line 62 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__string_is_white_space(text_stream *text) {
	LOOP_THROUGH_TEXT(P, text)
		if (Regexp__white_space(Str__get(P)) == FALSE)
			return FALSE;
	return TRUE;
}

#line 119 "inweb/foundation-module/Chapter 4/Pattern Matching.w"

#line 136 "inweb/foundation-module/Chapter 4/Pattern Matching.w"

#line 144 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
match_results Regexp__create_mr(void) {
	match_results mr;
	mr.no_matched_texts = 0;
	for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++) {
		mr.exp[i] = NULL;
		mr.exp_at[i] = -1;
	}
	return mr;
}

void Regexp__dispose_of(match_results *mr) {
	if (mr) {
		for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++)
			if (mr->exp[i]) {
				STREAM_CLOSE(mr->exp[i]);
				mr->exp[i] = NULL;
			}
		mr->no_matched_texts = 0;
	}
}

#line 168 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__match(match_results *mr, text_stream *text, inchar32_t *pattern) {
	if (mr) Regexp__prepare(mr);
	int rv = (Regexp__match_r(mr, text, pattern, NULL, FALSE) >= 0)?TRUE:FALSE;
	if ((mr) && (rv == FALSE)) Regexp__dispose_of(mr);
	return rv;
}

int Regexp__match_from(match_results *mr, text_stream *text, inchar32_t *pattern,
	int x, int allow_partial) {
	int match_to = x;
	if (x < Str__len(text)) {
		if (mr) Regexp__prepare(mr);
		match_position at;
		at.tpos = x; at.ppos = 0; at.bc = 0; at.bl = 0;
		match_to = Regexp__match_r(mr, text, pattern, &at, allow_partial);
		if (match_to == -1) {
			match_to = x;
			if (mr) Regexp__dispose_of(mr);
		}
	}
	return match_to - x;
}

void Regexp__prepare(match_results *mr) {
	if (mr) {
		mr->no_matched_texts = 0;
		for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++) {
			mr->exp_at[i] = -1;
			if (mr->exp[i]) STREAM_CLOSE(mr->exp[i]);
			mr->exp_storage[i].match_text_struct =
				Streams__new_buffer(
					MATCH_TEXT_INITIAL_ALLOCATION, mr->exp_storage[i].match_text_storage);
			mr->exp_storage[i].match_text_struct.stream_flags |= FOR_RE_STRF;
			mr->exp[i] = &(mr->exp_storage[i].match_text_struct);
		}
	}
}

#line 207 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__match_r(match_results *mr, text_stream *text, inchar32_t *pattern,
	match_position *scan_from, int allow_partial) {
	match_position at;
	if (scan_from) at = *scan_from;
	else { at.tpos = 0; at.ppos = 0; at.bc = 0; at.bl = 0; }
	while ((Str__get_at(text, at.tpos)) || (pattern[at.ppos])) {
		if ((allow_partial) && (pattern[at.ppos] == 0)) break;
		
{
#line 241 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	if (pattern[at.ppos] == '(') {
		if (at.bl < MAX_BRACKETED_SUBEXPRESSIONS) at.bracket_nesting[at.bl] = -1;
		if (at.bc < MAX_BRACKETED_SUBEXPRESSIONS) {
			at.bracket_nesting[at.bl] = at.bc;
			at.brackets_start[at.bc] = at.tpos; at.brackets_end[at.bc] = -1;
		}
		at.bl++; at.bc++; at.ppos++;
		continue;
	}
	if (pattern[at.ppos] == ')') {
		at.bl--;
		if ((at.bl >= 0) && (at.bl < MAX_BRACKETED_SUBEXPRESSIONS) && (at.bracket_nesting[at.bl] >= 0))
			at.brackets_end[at.bracket_nesting[at.bl]] = at.tpos-1;
		at.ppos++;
		continue;
	}

}
#line 214 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
;

		int chcl, /* what class of characters to match: a |*_CHARCLASS| value */
			range_from, range_to, /* for |LITERAL_CHARCLASS| only */
			reverse = FALSE; /* require a non-match rather than a match */
		
{
#line 259 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	if (pattern[at.ppos] == 0) return -1;
	int len = 0;
	chcl = Regexp__get_cclass(pattern, at.ppos, &len, &range_from, &range_to, &reverse);
	if (at.ppos+len > Wide__len(pattern)) internal_error("Yikes");
	else at.ppos += len;

}
#line 219 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
;

		int rep_from = 1, rep_to = 1; /* minimum and maximum number of repetitions */
		int greedy = TRUE; /* go for a maximal-length match if possible */
		
{
#line 269 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	if (chcl == WHITESPACE_CHARCLASS) {
		rep_from = 1; rep_to = Str__len(text)-at.tpos;
	}
	if (pattern[at.ppos] == '+') {
		rep_from = 1; rep_to = Str__len(text)-at.tpos; at.ppos++;
	} else if (pattern[at.ppos] == '*') {
		rep_from = 0; rep_to = Str__len(text)-at.tpos; at.ppos++;
	}
	if (pattern[at.ppos] == '?') { greedy = FALSE; at.ppos++; }

}
#line 223 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
;

		int reps = 0;
		
{
#line 280 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	for (reps = 0; ((Str__get_at(text, at.tpos+reps)) && (reps < rep_to)); reps++)
		if (Regexp__test_cclass(Str__get_at(text, at.tpos+reps), chcl,
			range_from, range_to, pattern, reverse) == FALSE)
			break;

}
#line 226 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
;
		if (reps < rep_from) return -1;

		/* we can now accept anything from |rep_from| to |reps| repetitions */
		if (rep_from == reps) { at.tpos += reps; continue; }
		
{
#line 286 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	int from = rep_from, to = reps, dj = 1, from_tpos = at.tpos;
	if (greedy) { from = reps; to = rep_from; dj = -1; }
	for (int j = from; j != to+dj; j += dj) {
		at.tpos = from_tpos + j;
		int try = Regexp__match_r(mr, text, pattern, &at, allow_partial);
		if (try >= 0) return try;
	}

}
#line 231 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
;

		/* no match length worked, so no match */
		return -1;
	}
	
{
#line 295 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	if (mr) {
		for (int i=0; i<at.bc; i++) {
			Str__clear(mr->exp[i]);
			for (int j = at.brackets_start[i]; j <= at.brackets_end[i]; j++)
				PUT_TO(mr->exp[i], Str__get_at(text, j));
			mr->exp_at[i] = at.brackets_start[i];
		}
		mr->no_matched_texts = at.bc;
	}

}
#line 236 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
;
	return at.tpos;
}

#line 338 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__get_cclass(inchar32_t *pattern, int ppos, int *len, int *from, int *to, int *reverse) {
	if (pattern[ppos] == '^') { ppos++; *reverse = TRUE; } else { *reverse = FALSE; }
	switch (pattern[ppos]) {
		case '%':
			ppos++;
			*len = 2;
			switch (pattern[ppos]) {
				case 'd': return DIGIT_CHARCLASS;
				case 'c': return ANY_CHARCLASS;
				case 'C': return NONWHITESPACE_CHARCLASS;
				case 'i': return IDENTIFIER_CHARCLASS;
				case 'p': return PREFORM_CHARCLASS;
				case 'P': return PREFORMC_CHARCLASS;
				case 'q': return QUOTE_CHARCLASS;
				case 't': return TAB_CHARCLASS;
			}
			*from = ppos; *to = ppos; return LITERAL_CHARCLASS;
		case '[':
			*from = ppos+1;
			ppos += 2;
			while ((pattern[ppos]) && (pattern[ppos] != ']')) ppos++;
			*to = ppos - 1; *len = ppos - *from + 2;
			return LITERAL_CHARCLASS;
		case ' ':
			*len = 1; return WHITESPACE_CHARCLASS;
	}
	*len = 1; *from = ppos; *to = ppos; return LITERAL_CHARCLASS;
}

#line 368 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__test_cclass(inchar32_t c, int chcl, int range_from, int range_to, inchar32_t *drawn_from, int reverse) {
	int match = FALSE;
	switch (chcl) {
		case ANY_CHARCLASS: if (c) match = TRUE; break;
		case DIGIT_CHARCLASS: if (Characters__isdigit(c)) match = TRUE; break;
		case WHITESPACE_CHARCLASS: if (Characters__is_whitespace(c)) match = TRUE; break;
		case TAB_CHARCLASS: if (c == '\t') match = TRUE; break;
		case NONWHITESPACE_CHARCLASS: if (!(Characters__is_whitespace(c))) match = TRUE; break;
		case QUOTE_CHARCLASS: if (c != '\"') match = TRUE; break;
		case IDENTIFIER_CHARCLASS: if (Regexp__identifier_char(c)) match = TRUE; break;
		case PREFORM_CHARCLASS: if ((c == '-') || (c == '_') ||
			((c >= 'a') && (c <= 'z')) ||
			((c >= '0') && (c <= '9'))) match = TRUE; break;
		case PREFORMC_CHARCLASS: if ((c == '-') || (c == '_') || (c == ':') ||
			((c >= 'a') && (c <= 'z')) ||
			((c >= '0') && (c <= '9'))) match = TRUE; break;
		case LITERAL_CHARCLASS:
			if ((range_to > range_from) && (drawn_from[range_from] == '^')) {
				range_from++; reverse = reverse?FALSE:TRUE;
			}
			for (int j = range_from; j <= range_to; j++) {
				inchar32_t c1 = drawn_from[j], c2 = c1;
				if ((j+1 < range_to) && (drawn_from[j+1] == '-')) { c2 = drawn_from[j+2]; j += 2; }
				if ((c >= c1) && (c <= c2)) {
					match = TRUE; break;
				}
			}
			break;
	}
	if (reverse) match = (match)?FALSE:TRUE;
	return match;
}

#line 415 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
int Regexp__replace(text_stream *text, inchar32_t *pattern, inchar32_t *replacement, int options) {
	TEMPORARY_TEXT(altered)
	match_results mr = Regexp__create_mr();
	int changes = 0;
	for (int i=0, L=Str__len(text); i<L; i++) {
		match_position mp; mp.tpos = i; mp.ppos = 0; mp.bc = 0; mp.bl = 0;
		Regexp__prepare(&mr);
		int try = Regexp__match_r(&mr, text, pattern, &mp, TRUE);
		if (try >= 0) {
			if (replacement)
				for (int j=0; replacement[j]; j++) {
					inchar32_t c = replacement[j];
					if (c == '%') {
						j++;
						inchar32_t ind = replacement[j] - '0';
						if (ind < MAX_BRACKETED_SUBEXPRESSIONS)
							WRITE_TO(altered, "%S", mr.exp[ind]);
						else
							PUT_TO(altered, replacement[j]);
					} else {
						PUT_TO(altered, replacement[j]);
					}
				}
			int left = L - try;
			changes++;
			Regexp__dispose_of(&mr);
			L = Str__len(text); i = L-left-1;
			if ((options & REP_REPEATING) == 0) { 
{
#line 454 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	for (i++; i<L; i++)
		PUT_TO(altered, Str__get_at(text, i));

}
#line 442 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
; break; }
			continue;
		} else PUT_TO(altered, Str__get_at(text, i));
		if (options & REP_ATSTART) { 
{
#line 454 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
	for (i++; i<L; i++)
		PUT_TO(altered, Str__get_at(text, i));

}
#line 445 "inweb/foundation-module/Chapter 4/Pattern Matching.w"
; break; }
	}
	Regexp__dispose_of(&mr);
	if (changes > 0) Str__copy(text, altered);
	DISCARD_TEXT(altered)
	return changes;
}

#line 47 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__write_type(OUTPUT_STREAM, int t) {
	switch (t) {
		case NUMBER_JSONTYPE:  WRITE("number"); break;
		case DOUBLE_JSONTYPE:  WRITE("double"); break;
		case STRING_JSONTYPE:  WRITE("string"); break;
		case BOOLEAN_JSONTYPE: WRITE("boolean"); break;
		case ARRAY_JSONTYPE:   WRITE("array"); break;
		case OBJECT_JSONTYPE:  WRITE("object"); break;
		case NULL_JSONTYPE:    WRITE("null"); break;
		case ERROR_JSONTYPE:   WRITE("<error>"); break;
		default:               WRITE("<invalid %d>", t); break;
	}
}

#line 76 "inweb/foundation-module/Chapter 4/JSON.w"

#line 80 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__new_null(void) {
	JSON_value *value = CREATE(JSON_value);
	value->JSON_type = NULL_JSONTYPE;
	value->if_integer = 0;
	value->if_double = 0;
	value->if_string = NULL;
	value->if_boolean = NOT_APPLICABLE;
	value->if_list = NULL;
	value->dictionary_if_object = NULL;
	value->list_if_object = NULL;
	value->if_error = NULL;
	return value;
}

JSON_value *JSON__new_boolean(int b) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = BOOLEAN_JSONTYPE;
	value->if_boolean = b;
	if ((b != TRUE) && (b != FALSE)) internal_error("improper JSON boolean");
	return value;
}

JSON_value *JSON__new_number(int b) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = NUMBER_JSONTYPE;
	value->if_integer = b;
	return value;
}

JSON_value *JSON__new_double(double d) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = DOUBLE_JSONTYPE;
	value->if_double = d;
	return value;
}

JSON_value *JSON__new_string(text_stream *S) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = STRING_JSONTYPE;
	value->if_string = Str__duplicate(S);
	return value;
}

#line 127 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__new_array(void) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = ARRAY_JSONTYPE;
	value->if_list = NEW_LINKED_LIST(JSON_value);
	return value;
}

JSON_value *JSON__add_to_array(JSON_value *array, JSON_value *new_entry) {
	if (array == NULL) internal_error("no array");
	if (array->JSON_type == ERROR_JSONTYPE) return array;
	if (array->JSON_type != ARRAY_JSONTYPE) internal_error("not an array");
	if (new_entry == NULL) internal_error("no new entry");
	if (new_entry->JSON_type == ERROR_JSONTYPE) return new_entry;
	ADD_TO_LINKED_LIST(new_entry, JSON_value, array->if_list);
	return array;
}

#line 148 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__new_object(void) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = OBJECT_JSONTYPE;
	value->dictionary_if_object = Dictionaries__new(16, FALSE);
	value->list_if_object = NEW_LINKED_LIST(text_stream);
	return value;
}

JSON_value *JSON__add_to_object(JSON_value *obj, text_stream *key, JSON_value *value) {
	if (obj == NULL) internal_error("no object");
	if (obj->JSON_type == ERROR_JSONTYPE) return obj;
	if (obj->JSON_type != OBJECT_JSONTYPE) internal_error("not an object");
	if (value == NULL) internal_error("no new entry");
	if (value->JSON_type == ERROR_JSONTYPE) return value;
	key = Str__duplicate(key);
	ADD_TO_LINKED_LIST(key, text_stream, obj->list_if_object);
	dict_entry *de = Dictionaries__create(obj->dictionary_if_object, key);
	if (de) de->value = value;
	return obj;
}

#line 173 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__look_up_object(JSON_value *obj, text_stream *key) {
	if (obj == NULL) internal_error("no object");
	if (obj->JSON_type == ERROR_JSONTYPE) return NULL;
	if (obj->JSON_type != OBJECT_JSONTYPE) internal_error("not an object");
	dict_entry *de = Dictionaries__find(obj->dictionary_if_object, key);
	if (de == NULL) return NULL;
	return de->value;
}

#line 185 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__change_object(JSON_value *obj, text_stream *key, JSON_value *val) {
	if (obj == NULL) internal_error("no object");
	if (obj->JSON_type == ERROR_JSONTYPE) internal_error("erroneous object");
	if (obj->JSON_type != OBJECT_JSONTYPE) internal_error("not an object");
	dict_entry *de = Dictionaries__find(obj->dictionary_if_object, key);
	if (de == NULL) JSON__add_to_object(obj, key, val);
	else de->value = val;
}

#line 198 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__error(text_stream *msg) {
	JSON_value *value = JSON__new_null();
	value->JSON_type = ERROR_JSONTYPE;
	value->if_error = Str__duplicate(msg);
	return value;
}

#line 209 "inweb/foundation-module/Chapter 4/JSON.w"
int JSON__eq(JSON_value *val1, JSON_value *val2) {
	if ((val1 == NULL) && (val2)) return FALSE;
	if ((val1) && (val2 == NULL)) return FALSE;
	if (val1 == NULL) return TRUE;
	if (val1->JSON_type != val2->JSON_type) return FALSE;
	switch (val1->JSON_type) {
		case NUMBER_JSONTYPE:  if (val1->if_integer == val2->if_integer) return TRUE; break;
		case STRING_JSONTYPE:  if (Str__eq(val1->if_string, val2->if_string)) return TRUE; break;
		case BOOLEAN_JSONTYPE: if (val1->if_boolean == val2->if_boolean) return TRUE; break;
		case NULL_JSONTYPE:    return TRUE;
	}
	return FALSE;
}

#line 233 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode(text_stream *T, text_file_position *tfp) {
	return JSON__decode_range(T, 0, Str__len(T), tfp);
}

JSON_value *JSON__decode_error(text_stream *err, text_file_position *tfp) {
	TEMPORARY_TEXT(msg)
	if (tfp) WRITE_TO(msg, "%f: ", tfp->text_file_filename);
	WRITE_TO(msg, "%S", err);
	JSON_value *value = JSON__error(msg);
	DISCARD_TEXT(msg)
	return value;
}

JSON_value *JSON__decode_error_q(text_stream *err, text_file_position *tfp,
	text_stream *T, int from, int to) {
	TEMPORARY_TEXT(msg)
	WRITE_TO(msg, "%S", err);
	if ((T) && (from < to)) {
		WRITE_TO(msg, ": '");
		for (int i=from; ((i<to) && (i-from < 40)); i++) {
			if (Str__get_at(T, i) == '\n') WRITE_TO(msg, " ");
			else WRITE_TO(msg, "%c", Str__get_at(T, i));
		}
		WRITE_TO(msg, "'");
	}
	JSON_value *value = JSON__decode_error(msg, tfp);
	DISCARD_TEXT(msg)
	return value;
}

#line 272 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode_range(text_stream *T, int from, int to, text_file_position *tfp) {
	int first_nws = -1, last_nws = -1;
	inchar32_t first_c = 0, last_c = 0;
	
{
#line 301 "inweb/foundation-module/Chapter 4/JSON.w"
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE) {
			first_nws = i; break;
		}
	for (int i=to-1; i>=from; i--)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE) {
			last_nws = i; break;
		}
	if (first_nws < 0) return JSON__decode_error(TL_IS_16, tfp);
	first_c = Str__get_at(T, first_nws);
	last_c = Str__get_at(T, last_nws);

}
#line 275 "inweb/foundation-module/Chapter 4/JSON.w"
;
	switch (first_c) {
		case '[':
			if (last_c != ']') return JSON__decode_error(TL_IS_9, tfp);
			JSON_value *array = JSON__new_array();
			return JSON__decode_array(array, T, first_nws+1, last_nws, tfp);
		case '{':
			if (last_c != '}') return JSON__decode_error(TL_IS_10, tfp);
			JSON_value *obj = JSON__new_object();
			return JSON__decode_object(obj, T, first_nws+1, last_nws, tfp);
		case '"':
			if (last_c != '"') return JSON__decode_error(TL_IS_11, tfp);
			return JSON__decode_string(T, first_nws+1, last_nws, tfp);
	}
	if ((Characters__isdigit(first_c)) || (first_c == '-'))
		return JSON__decode_number(T, first_nws, last_nws+1, tfp);
	if ((Str__includes_at(T, first_nws, TL_IS_12)) && (last_nws - first_nws == 3))
		return JSON__new_boolean(TRUE);
	if ((Str__includes_at(T, first_nws, TL_IS_13)) && (last_nws - first_nws == 4))
		return JSON__new_boolean(FALSE);
	if ((Str__includes_at(T, first_nws, TL_IS_14)) && (last_nws - first_nws == 3))
		return JSON__new_null();
	return JSON__decode_error(TL_IS_15, tfp);
}

#line 319 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode_array(JSON_value *array, text_stream *T, int from, int to,
	text_file_position *tfp) {
	int content = FALSE;
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE)
			content = TRUE;
	if (content == FALSE) return array;
	NextEntry: ;
	int first_comma = -1, bl = 0;
	for (int i=from, quoted = FALSE; i<to; i++) {
		inchar32_t c = Str__get_at(T, i);
		switch (c) {
			case '"': quoted = (quoted)?FALSE:TRUE; break;
			case '\\': if (quoted) i++; break;
			case ',': if ((quoted == FALSE) && ((first_comma < 0) && (bl == 0)))
				first_comma = i; break;
			case '[': case '{': if (quoted == FALSE) bl++; break;
			case ']': case '}': if (quoted == FALSE) bl--; break;
		}
	}
	if (first_comma >= 0) {
		array = JSON__decode_array_entry(array, T, from, first_comma, tfp);
		from = first_comma + 1;
		goto NextEntry;
	}
	return JSON__decode_array_entry(array, T, from, to, tfp);
}

JSON_value *JSON__decode_array_entry(JSON_value *array, text_stream *T, int from, int to,
	text_file_position *tfp) {
	JSON_value *value = JSON__decode_range(T, from, to, tfp);
	return JSON__add_to_array(array, value);
}

#line 356 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode_object(JSON_value *obj, text_stream *T, int from, int to,
	text_file_position *tfp) {
	int content = FALSE;
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE)
			content = TRUE;
	if (content == FALSE) return obj;
	NextEntry: ;
	int first_comma = -1, bl = 0;
	for (int i=from, quoted = FALSE; i<to; i++) {
		inchar32_t c = Str__get_at(T, i);
		switch (c) {
			case '"': quoted = (quoted)?FALSE:TRUE; break;
			case '\\': if (quoted) i++; break;
			case ',': if ((quoted == FALSE) && ((first_comma < 0) && (bl == 0)))
				first_comma = i; break;
			case '[': case '{': if (quoted == FALSE) bl++; break;
			case ']': case '}': if (quoted == FALSE) bl--; break;
		}
	}
	if (first_comma >= 0) {
		obj = JSON__decode_object_entry(obj, T, from, first_comma, tfp);
		from = first_comma + 1;
		goto NextEntry;
	}
	return JSON__decode_object_entry(obj, T, from, to, tfp);
}

#line 392 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode_object_entry(JSON_value *obj, text_stream *T, int from, int to,
	text_file_position *tfp) {
	while (Characters__is_whitespace(Str__get_at(T, from))) from++;
	int saved_from = from, saved_to = to;
	if (from >= to)
		return JSON__decode_error(TL_IS_17, tfp);
	if (Str__get_at(T, from) != '"')
		return JSON__decode_error_q(TL_IS_18, tfp, T, saved_from, saved_to);
	from++;
	int ended = FALSE;
	TEMPORARY_TEXT(key)
	while (from < to) {
		inchar32_t c = Str__get_at(T, from++);
		if (c == '\"') { ended = TRUE; break; }
		PUT_TO(key, c);
		if ((c == '\\') && (from+1 < to)) {
			c = Str__get_at(T, from++);
			PUT_TO(key, c);
		}
	}
	if (ended == FALSE) return JSON__decode_error_q(TL_IS_19, tfp, T, saved_from, saved_to);
	while (Characters__is_whitespace(Str__get_at(T, from))) from++;
	if ((from >= to) || (Str__get_at(T, from) != ':'))
		return JSON__decode_error_q(TL_IS_20, tfp, T, saved_from, saved_to);
	from++;
	if (JSON__look_up_object(obj, key)) return JSON__decode_error_q(TL_IS_21, tfp, T, saved_from, saved_to);
	JSON_value *value = JSON__decode_range(T, from, to, tfp);
	obj = JSON__add_to_object(obj, key, value);
	DISCARD_TEXT(key)
	return obj;
}

#line 430 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode_number(text_stream *T, int from, int to, text_file_position *tfp) {
	while (Characters__is_whitespace(Str__get_at(T, from))) from++;
	while ((to > from) && (Characters__is_whitespace(Str__get_at(T, to-1)))) to--;
	if (to <= from) return JSON__decode_error(TL_IS_22, tfp);
	TEMPORARY_TEXT(integer)
	int at = from;
	if ((Str__get_at(T, at) == '-') && (to > at+1)) { PUT_TO(integer, '-'); at++; }
	int double_me = FALSE;
	for (int i=at; i<to; i++)
		if (Characters__isdigit(Str__get_at(T, i)))
			PUT_TO(integer, Str__get_at(T, i));
		else if ((Str__get_at(T, i) == 'E') || (Str__get_at(T, i) == 'e') ||
			(Str__get_at(T, i) == '.') || (Str__get_at(T, i) == '+'))
			double_me = TRUE;
		else
			return JSON__decode_error(TL_IS_23, tfp);
	JSON_value *value = NULL;
	if (double_me) {
		char double_buffer[32];
		for (int i=0; i<32; i++) double_buffer[i] = 0;
		for (int i=from; (i<to) && (i-from<31); i++)
			double_buffer[i-from] = (char) Str__get_at(T, i);
		double d = atof(double_buffer);
		if (isnan(d)) return JSON__decode_error(TL_IS_24, tfp);
		value = JSON__new_double(d);
	} else {
		int N = Str__atoi(integer, 0);
		value = JSON__new_number(N);
	}
	DISCARD_TEXT(integer)
	return value;
}

#line 467 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_value *JSON__decode_string(text_stream *T, int from, int to, text_file_position *tfp) {
	TEMPORARY_TEXT(string)
	for (int i=from; i<to; i++) {
		inchar32_t c = Str__get_at(T, i);
		if (c == '\\') {
			i++;
			c = Str__get_at(T, i);
			if (Characters__iscntrl(c)) return JSON__decode_error(TL_IS_25, tfp);
			switch (c) {
				case 'b': c = 8; break;
				case 't': c = 9; break;
				case 'n': c = 10; break;
				case 'f': c = 12; break;
				case 'r': c = 13; break;
				case '\\': break;
				case '/': break;
				case '"': break;
				case 'u': 
{
#line 502 "inweb/foundation-module/Chapter 4/JSON.w"
	if (i+4 >= to) return JSON__decode_error(TL_IS_27, tfp);
	int hex = 0;
	for (int j=0; j<4; j++) {
		int v = 0;
		inchar32_t digit = Str__get_at(T, i+1+j);
		if ((digit >= '0') && (digit <= '9')) v = (int) (digit-'0');
		else if ((digit >= 'a') && (digit <= 'f')) v = 10 + ((int) (digit-'a'));
		else if ((digit >= 'A') && (digit <= 'F')) v = 10 + ((int) (digit-'A'));
		else return JSON__decode_error(TL_IS_28, tfp);
		hex = hex * 16 + v;
	}
	c = (inchar32_t) hex;
	i += 4;

}
#line 484 "inweb/foundation-module/Chapter 4/JSON.w"
; break;
				default: return JSON__decode_error(TL_IS_26, tfp);
			}
			PUT_TO(string, c);
		} else {
			PUT_TO(string, c);
		}
	}
	JSON_value *val = JSON__new_string(string);
	DISCARD_TEXT(string)
	return val;
}

#line 519 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__encode(OUTPUT_STREAM, JSON_value *J) {
	if (J == NULL) internal_error("no JSON value supplied");
	switch (J->JSON_type) {
		case ERROR_JSONTYPE:
			internal_error("tried to encode erroneous JSON");
		case NUMBER_JSONTYPE:
			WRITE("%d", J->if_integer);
			break;
		case DOUBLE_JSONTYPE:
			WRITE("%g", J->if_double);
			break;
		case STRING_JSONTYPE:
			WRITE("\""); JSON__encode_string(OUT, J->if_string); WRITE("\"");
			break;
		case BOOLEAN_JSONTYPE:
			if (J->if_boolean == TRUE) WRITE("true");
			else if (J->if_boolean == FALSE) WRITE("false");
			else internal_error("improper boolean JSON value");
			break;
		case ARRAY_JSONTYPE: {
			WRITE("[");
			int count = 0;
			JSON_value *E;
			LOOP_OVER_LINKED_LIST(E, JSON_value, J->if_list) {
				if (count++ > 0) WRITE(",");
				WRITE(" ");
				JSON__encode(OUT, E);
			}
			if (count > 0) WRITE(" ");
			WRITE("]");
			break;
		}
		case OBJECT_JSONTYPE: {
			WRITE("{\n"); INDENT;
			int count = 0;
			text_stream *key;
			LOOP_OVER_LINKED_LIST(key, text_stream, J->list_if_object) {
				if (count++ > 0) WRITE(",\n");
				JSON_value *E = Dictionaries__read_value(J->dictionary_if_object, key);
				if (E == NULL) internal_error("broken JSON object dictionary");
				WRITE("\"");
				JSON__encode_string(OUT, key);
				WRITE("\": ");
				JSON__encode(OUT, E);
			}
			if (count > 0) WRITE("\n");
			OUTDENT; WRITE("}");
			break;
		}
		case NULL_JSONTYPE:
			WRITE("null");
			break;
		default: internal_error("unsupported JSON value type");
	}
}

#line 579 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__encode_string(OUTPUT_STREAM, text_stream *T) {
	LOOP_THROUGH_TEXT(pos, T) {
		inchar32_t c = Str__get(pos);
		switch (c) {
			case '\\': WRITE("\\\\"); break;
			case 8: WRITE("\\b"); break;
			case 9: WRITE("\\t"); break;
			case 10: WRITE("\\n"); break;
			case 12: WRITE("\\f"); break;
			case 13: WRITE("\\r"); break;
			default:
				if (Characters__iscntrl(c)) WRITE("\\u%04x", (int)c);
				else PUT(c);
				break;
		}
	}
}

#line 611 "inweb/foundation-module/Chapter 4/JSON.w"

JSON_requirement *JSON__single_choice(JSON_single_requirement *sing) {
	JSON_requirement *req = CREATE(JSON_requirement);
	req->alternatives = NEW_LINKED_LIST(JSON_single_requirement);
	ADD_TO_LINKED_LIST(sing, JSON_single_requirement, req->alternatives);
	return req;
}

JSON_requirement *JSON__add_alternative(JSON_requirement *so_far,
	JSON_single_requirement *sing) {
	if (so_far == NULL) return JSON__single_choice(sing);
	ADD_TO_LINKED_LIST(sing, JSON_single_requirement, so_far->alternatives);
	return so_far;
}

#line 637 "inweb/foundation-module/Chapter 4/JSON.w"

#line 642 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement *JSON__require_requirement(JSON_requirement *req) {
	JSON_single_requirement *sing = CREATE(JSON_single_requirement);
	sing->this_requirement = req;
	sing->this_value = NULL;
	sing->this_type = NULL;
	return sing;
}

JSON_single_requirement *JSON__require_value(JSON_value *value) {
	JSON_single_requirement *sing = CREATE(JSON_single_requirement);
	sing->this_requirement = NULL;
	sing->this_value = value;
	sing->this_type = NULL;
	return sing;
}

JSON_single_requirement *JSON__require_type(int t) {
	JSON_single_requirement *sing = CREATE(JSON_single_requirement);
	sing->this_requirement = NULL;
	sing->this_value = NULL;
	sing->this_type = JSON__new_type_requirement(t);
	return sing;
}

#line 681 "inweb/foundation-module/Chapter 4/JSON.w"

#line 687 "inweb/foundation-module/Chapter 4/JSON.w"

JSON_type *JSON__new_type_requirement(int t) {
	JSON_type *type = CREATE(JSON_type);
	type->JSON_type = t;

	if (t == ARRAY_JSONTYPE) {
		type->if_list = NEW_LINKED_LIST(JSON_requirement);
		type->all_if_list = NULL;
	} else {
		type->if_list = NULL;
		type->all_if_list = NULL;
	}

	if (t == OBJECT_JSONTYPE) {
		type->dictionary_if_object = Dictionaries__new(16, FALSE);
		type->list_if_object = NEW_LINKED_LIST(text_stream);
	} else {
		type->dictionary_if_object = NULL;
		type->list_if_object = NULL;
	}

	type->if_error = NULL;
	return type;
}

#line 716 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement *JSON__require_array_of(JSON_requirement *E_req) {
	JSON_single_requirement *req = JSON__require_type(ARRAY_JSONTYPE);
	req->this_type->all_if_list = E_req;
	return req;
}

#line 727 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__require_entry(JSON_single_requirement *array_sr, JSON_requirement *entry_sr) {
	if (array_sr == NULL) internal_error("no array");
	if ((array_sr->this_type == NULL) ||
		(array_sr->this_type->JSON_type != ARRAY_JSONTYPE)) internal_error("not an array");
	if (entry_sr == NULL) internal_error("no new entry");
	ADD_TO_LINKED_LIST(entry_sr, JSON_requirement, array_sr->this_type->if_list);
}

#line 739 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__require_pair(JSON_single_requirement *obj_sr, text_stream *key, JSON_requirement *req) {
	JSON__require_pair_inner(obj_sr, key, req, FALSE);
}

void JSON__allow_pair(JSON_single_requirement *obj_sr, text_stream *key, JSON_requirement *req) {
	JSON__require_pair_inner(obj_sr, key, req, TRUE);
}

void JSON__require_pair_inner(JSON_single_requirement *obj_sr, text_stream *key,
	JSON_requirement *req, int opt) {
	if (obj_sr == NULL) internal_error("no object");
	if ((obj_sr->this_type == NULL) ||
		(obj_sr->this_type->JSON_type != OBJECT_JSONTYPE)) internal_error("not an object");
	if (req == NULL) internal_error("no val req");
	key = Str__duplicate(key);
	ADD_TO_LINKED_LIST(key, text_stream, obj_sr->this_type->list_if_object);
	JSON_pair_requirement *pr = CREATE(JSON_pair_requirement);
	pr->req = req;
	pr->optional = opt;
	dict_entry *de = Dictionaries__create(obj_sr->this_type->dictionary_if_object, key);
	if (de) de->value = pr;
}

#line 766 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_pair_requirement *JSON__look_up_pair(JSON_single_requirement *obj_sr, text_stream *key) {
	if (obj_sr == NULL) internal_error("no object");
	if ((obj_sr->this_type == NULL) ||
		(obj_sr->this_type->JSON_type != OBJECT_JSONTYPE)) internal_error("not an object");
	dict_entry *de = Dictionaries__find(obj_sr->this_type->dictionary_if_object, key);
	if (de == NULL) return NULL;
	return de->value;
}

#line 779 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement *JSON__error_sr(text_stream *msg) {
	JSON_single_requirement *req = JSON__require_type(ERROR_JSONTYPE);
	req->this_type->if_error = Str__duplicate(msg);
	return req;
}

#line 797 "inweb/foundation-module/Chapter 4/JSON.w"
int JSON__validate(JSON_value *val, JSON_requirement *req, linked_list *errs) {
	lifo_stack *location = NEW_LIFO_STACK(text_stream);
	if ((val) && (val->JSON_type == ARRAY_JSONTYPE)) {
		PUSH_TO_LIFO_STACK(TL_IS_29, text_stream, location);
	}
	if ((val) && (val->JSON_type == OBJECT_JSONTYPE)) {
		PUSH_TO_LIFO_STACK(TL_IS_30, text_stream, location);
	}
	return JSON__validate_r(val, req, errs, location);
}

void JSON__validation_error(linked_list *errs, text_stream *err, lifo_stack *location) {
	if (errs) {
		text_stream *msg = Str__new();
		int S = LinkedLists__len(location);
		for (int i=S-1; i>=0; i--) {
			int c = 0;
			text_stream *seg;
			LOOP_OVER_LINKED_LIST(seg, text_stream, location)
				if (c++ == i)
					WRITE_TO(msg, "%S", seg);
		}
		if (Str__len(msg) > 0) WRITE_TO(msg, ": ");
		WRITE_TO(msg, "%S", err);
		ADD_TO_LINKED_LIST(msg, text_stream, errs);
	}
}

#line 831 "inweb/foundation-module/Chapter 4/JSON.w"
int JSON__validate_r(JSON_value *val, JSON_requirement *req, linked_list *errs,
	lifo_stack *location) {
	if (val == NULL) internal_error("no value");
	if (req == NULL) internal_error("no req");
	JSON_single_requirement *sing;
	LOOP_OVER_LINKED_LIST(sing, JSON_single_requirement, req->alternatives) {
		int rv = JSON__validate_single_r(val, sing, NULL, location);
		if (rv) return TRUE;
	}
	LOOP_OVER_LINKED_LIST(sing, JSON_single_requirement, req->alternatives) {
		JSON__validate_single_r(val, sing, errs, location);
		break;
	}
	return FALSE;
}

#line 850 "inweb/foundation-module/Chapter 4/JSON.w"
int JSON__validate_single_r(JSON_value *val, JSON_single_requirement *req,
	linked_list *errs, lifo_stack *location) {
	if (val->JSON_type == ERROR_JSONTYPE) {
		JSON__validation_error(errs,
			TL_IS_31, location);
		return FALSE;
	}
	if (req->this_requirement) 
{
#line 864 "inweb/foundation-module/Chapter 4/JSON.w"
	return JSON__validate_r(val, req->this_requirement, errs, location);

}
#line 857 "inweb/foundation-module/Chapter 4/JSON.w"
;
	if (req->this_value) 
{
#line 867 "inweb/foundation-module/Chapter 4/JSON.w"
	if (JSON__eq(val, req->this_value) == FALSE) {
		TEMPORARY_TEXT(msg)
		WRITE_TO(msg, "value ");
		JSON__encode(msg, val);
		WRITE_TO(msg, " not one of those allowed");
		JSON__validation_error(errs, msg, location);
		DISCARD_TEXT(msg)
		return FALSE;
	}
	return TRUE;

}
#line 858 "inweb/foundation-module/Chapter 4/JSON.w"
;
	if (req->this_type) 
{
#line 879 "inweb/foundation-module/Chapter 4/JSON.w"
	
{
#line 888 "inweb/foundation-module/Chapter 4/JSON.w"
	if (val->JSON_type != req->this_type->JSON_type) {
		if (errs) {
			TEMPORARY_TEXT(msg)
			WRITE_TO(msg, "expected ");
			JSON__write_type(msg, req->this_type->JSON_type);
			WRITE_TO(msg, " but found ");
			JSON__write_type(msg, val->JSON_type);
			JSON__validation_error(errs, msg, location);
			DISCARD_TEXT(msg)
		}
		return FALSE;
	}

}
#line 879 "inweb/foundation-module/Chapter 4/JSON.w"
;
	int outcome = TRUE;
	if (val->JSON_type == ARRAY_JSONTYPE)
		
{
#line 902 "inweb/foundation-module/Chapter 4/JSON.w"
	int count = 0;
	JSON_value *E;
	LOOP_OVER_LINKED_LIST(E, JSON_value, val->if_list) {
		JSON_requirement *E_req = req->this_type->all_if_list;
		if (E_req == NULL) {
			JSON_requirement *A_req;
			int rcount = 0;
			LOOP_OVER_LINKED_LIST(A_req, JSON_requirement, req->this_type->if_list)
				if (rcount++ == count)
					E_req = A_req;
		}
		TEMPORARY_TEXT(at)
		WRITE_TO(at, "[%d]", count);
		PUSH_TO_LIFO_STACK(at, text_stream, location);
		if (E_req == NULL) {
			JSON__validation_error(errs, TL_IS_32, location);
			outcome = FALSE;
		} else {
			if (JSON__validate_r(E, E_req, errs, location) == FALSE) outcome = FALSE;
		}
		POP_LIFO_STACK(text_stream, location);
		DISCARD_TEXT(at)
		count++;
	}

}
#line 882 "inweb/foundation-module/Chapter 4/JSON.w"
;
	if (val->JSON_type == OBJECT_JSONTYPE)
		
{
#line 928 "inweb/foundation-module/Chapter 4/JSON.w"
	text_stream *key;
	LOOP_OVER_LINKED_LIST(key, text_stream, val->list_if_object)
		
{
#line 940 "inweb/foundation-module/Chapter 4/JSON.w"
	JSON_value *E = Dictionaries__read_value(val->dictionary_if_object, key);
	if (E == NULL) internal_error("broken JSON object dictionary");
	JSON_pair_requirement *pr = JSON__look_up_pair(req, key);
	TEMPORARY_TEXT(at)
	WRITE_TO(at, ".%S", key);
	PUSH_TO_LIFO_STACK(at, text_stream, location);
	if (pr == NULL) {
		TEMPORARY_TEXT(msg)
		WRITE_TO(msg, "unexpected member '%S'", key);
		JSON__validation_error(errs, msg, location);
		DISCARD_TEXT(msg)
		outcome = FALSE;
	} else {
		if (JSON__validate_r(E, pr->req, errs, location) == FALSE) outcome = FALSE;
	}
	POP_LIFO_STACK(text_stream, location);
	DISCARD_TEXT(at)

}
#line 930 "inweb/foundation-module/Chapter 4/JSON.w"
;
	LOOP_OVER_LINKED_LIST(key, text_stream, req->this_type->list_if_object) {
		JSON_pair_requirement *pr =
			Dictionaries__read_value(req->this_type->dictionary_if_object, key);
		if (pr == NULL) internal_error("broken JSON object requirement");
		if (pr->optional == FALSE)
			
{
#line 959 "inweb/foundation-module/Chapter 4/JSON.w"
	JSON_value *E = JSON__look_up_object(val, key);
	if (E == NULL) {
		TEMPORARY_TEXT(msg)
		WRITE_TO(msg, "member '%S' missing", key);
		JSON__validation_error(errs, msg, location);
		DISCARD_TEXT(msg)
		outcome = FALSE;
	}

}
#line 936 "inweb/foundation-module/Chapter 4/JSON.w"
;
	}

}
#line 884 "inweb/foundation-module/Chapter 4/JSON.w"
;
	return outcome;

}
#line 859 "inweb/foundation-module/Chapter 4/JSON.w"
;
	internal_error("bad single requirement");
}

#line 1000 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement *JSON__decode_req(text_stream *T, dictionary *known_names) {
	return JSON__decode_req_range(T, 0, Str__len(T), known_names);
}

#line 1008 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_requirement *JSON__decode_req_range(text_stream *T, int from, int to,
	dictionary *known_names) {
	int first_nws = -1, last_nws = -1;
	inchar32_t first_c = 0, last_c = 0;
	
{
#line 1126 "inweb/foundation-module/Chapter 4/JSON.w"
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE) {
			first_nws = i; break;
		}
	for (int i=to-1; i>=from; i--)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE) {
			last_nws = i; break;
		}
	first_c = Str__get_at(T, first_nws);
	last_c = Str__get_at(T, last_nws);

}
#line 1012 "inweb/foundation-module/Chapter 4/JSON.w"
;
	if (first_c == '(') {
		if (last_c != ')')
			return JSON__single_choice(JSON__error_sr(TL_IS_33));
		from = first_nws + 1;
		to = last_nws;
		JSON_requirement *req = NULL;
		NextEntry: ;
		int first_pipe = -1, bl = 0;
		for (int i=from, quoted = FALSE; i<to; i++) {
			inchar32_t c = Str__get_at(T, i);
			switch (c) {
				case '"': quoted = (quoted)?FALSE:TRUE; break;
				case '\\': if (quoted) i++; break;
				case '|': if ((first_pipe < 0) && (bl == 0)) first_pipe = i; break;
				case '[': case '{': case '(': if (quoted == FALSE) bl++; break;
				case ']': case '}': case ')': if (quoted == FALSE) bl--; break;
			}
		}
		if (first_pipe >= 0) {
			req = JSON__decode_req_alternative(req, T, from, first_pipe, known_names);
			from = first_pipe + 1;
			goto NextEntry;
		}
		return JSON__decode_req_alternative(req, T, from, to, known_names);
	}
	return JSON__single_choice(JSON__decode_sreq_range(T, from, to, known_names));
}

JSON_requirement *JSON__decode_req_alternative(JSON_requirement *req, text_stream *T,
	int from, int to, dictionary *known_names) {
	JSON_single_requirement *sing = JSON__decode_sreq_range(T, from, to, known_names);
	return JSON__add_alternative(req, sing);
}

#line 1053 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement *JSON__decode_sreq_range(text_stream *T, int from, int to,
	dictionary *known_names) {
	int first_nws = -1, last_nws = -1;
	inchar32_t first_c = 0, last_c = 0;
	
{
#line 1126 "inweb/foundation-module/Chapter 4/JSON.w"
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE) {
			first_nws = i; break;
		}
	for (int i=to-1; i>=from; i--)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE) {
			last_nws = i; break;
		}
	first_c = Str__get_at(T, first_nws);
	last_c = Str__get_at(T, last_nws);

}
#line 1057 "inweb/foundation-module/Chapter 4/JSON.w"
;
	if (first_nws < 0) return JSON__error_sr(TL_IS_34);
	switch (first_c) {
		case '[':
			if (last_c != ']') return JSON__error_sr(TL_IS_35);
			JSON_single_requirement *array_sr = JSON__require_type(ARRAY_JSONTYPE);
			return JSON__decode_req_array(array_sr, T, first_nws+1, last_nws, known_names);
		case '{':
			if (last_c != '}') return JSON__error_sr(TL_IS_36);
			JSON_single_requirement *obj_sr = JSON__require_type(OBJECT_JSONTYPE);
			return JSON__decode_req_object(obj_sr, T, first_nws+1, last_nws, known_names);
		case '<':
			if (last_c != '>') return JSON__error_sr(TL_IS_37);
			JSON_requirement *known = NULL;
			TEMPORARY_TEXT(name)
			for (int i = first_nws+1; i<last_nws; i++)
				PUT_TO(name, Str__get_at(T, i));
			if (known_names) {
				dict_entry *de = Dictionaries__find(known_names, name);
				if (de == NULL) return JSON__error_sr(TL_IS_38);
				known = de->value;
			} else {
				return JSON__error_sr(TL_IS_39);
			}
			DISCARD_TEXT(name)
			if (known) return JSON__require_requirement(known);
			return NULL;
	}

	int require_value = FALSE;

	if ((first_c == '"') || (first_c == '-') || (Characters__isdigit(first_c)))
		require_value = TRUE;
	if ((Str__includes_at(T, first_nws, TL_IS_40)) && (last_nws - first_nws == 3))
		require_value = TRUE;
	if ((Str__includes_at(T, first_nws, TL_IS_41)) && (last_nws - first_nws == 4))
		require_value = TRUE;
	if ((Str__includes_at(T, first_nws, TL_IS_42)) && (last_nws - first_nws == 3))
		require_value = TRUE;

	if (require_value) {
		JSON_value *value = JSON__decode_range(T, from, to, NULL);
		if (value->JSON_type == ERROR_JSONTYPE) {
			TEMPORARY_TEXT(err)
			WRITE_TO(err, "JSON value error: %S", value->if_error);
			JSON_single_requirement *sing = JSON__error_sr(err);
			DISCARD_TEXT(err)
			return sing;
		}
		return JSON__require_value(value);
	}

	if ((Str__includes_at(T, first_nws, TL_IS_43)) && (last_nws - first_nws == 5))
		return JSON__require_type(NUMBER_JSONTYPE);
	if ((Str__includes_at(T, first_nws, TL_IS_44)) && (last_nws - first_nws == 5))
		return JSON__require_type(DOUBLE_JSONTYPE);
	if ((Str__includes_at(T, first_nws, TL_IS_45)) && (last_nws - first_nws == 5))
		return JSON__require_type(STRING_JSONTYPE);
	if ((Str__includes_at(T, first_nws, TL_IS_46)) && (last_nws - first_nws == 6))
		return JSON__require_type(BOOLEAN_JSONTYPE);

	text_stream *msg = Str__new();
	WRITE_TO(msg, "unknown JSON type '");
	for (int i=first_nws; i<last_nws; i++) PUT_TO(msg, Str__get_at(T, i));
	WRITE_TO(msg, "'");
	return JSON__error_sr(msg);
}

#line 1140 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement *JSON__decode_req_array(JSON_single_requirement *array_sr,
	text_stream *T, int from, int to, dictionary *known_names) {
	int content = FALSE;
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE)
			content = TRUE;
	if (content == FALSE) return array_sr;
	while ((to > from) && (Characters__is_whitespace(Str__get_at(T, to-1)))) to--;
	if (Str__get_at(T, to-1) == '*') {
		to--;
		return JSON__require_array_of(JSON__decode_req_range(T, from, to, known_names));
	}
	NextEntry: ;
	int first_comma = -1, bl = 0;
	for (int i=from, quoted = FALSE; i<to; i++) {
		inchar32_t c = Str__get_at(T, i);
		switch (c) {
			case '"': quoted = (quoted)?FALSE:TRUE; break;
			case '\\': if (quoted) i++; break;
			case ',': if ((quoted == FALSE) && ((first_comma < 0) && (bl == 0)))
				first_comma = i; break;
			case '[': case '{': case '(': if (quoted == FALSE) bl++; break;
			case ']': case '}': case ')': if (quoted == FALSE) bl--; break;
		}
	}
	if (first_comma >= 0) {
		array_sr = JSON__decode_req_array_entry(array_sr, T, from, first_comma, known_names);
		from = first_comma + 1;
		goto NextEntry;
	}
	return JSON__decode_req_array_entry(array_sr, T, from, to, known_names);
}

JSON_single_requirement *JSON__decode_req_array_entry(JSON_single_requirement *array_sr,
	text_stream *T, int from, int to, dictionary *known_names) {
	JSON_requirement *req = JSON__decode_req_range(T, from, to, known_names);
	JSON__require_entry(array_sr, req);
	return array_sr;
}

#line 1183 "inweb/foundation-module/Chapter 4/JSON.w"
JSON_single_requirement *JSON__decode_req_object(JSON_single_requirement *obj,
	text_stream *T, int from, int to, dictionary *known_names) {
	int content = FALSE;
	for (int i=from; i<to; i++)
		if (Characters__is_whitespace(Str__get_at(T, i)) == FALSE)
			content = TRUE;
	if (content == FALSE) return obj;
	NextEntry: ;
	int first_comma = -1, bl = 0;
	for (int i=from, quoted = FALSE; i<to; i++) {
		inchar32_t c = Str__get_at(T, i);
		switch (c) {
			case '"': quoted = (quoted)?FALSE:TRUE; break;
			case '\\': if (quoted) i++; break;
			case ',': if ((quoted == FALSE) && ((first_comma < 0) && (bl == 0)))
				first_comma = i; break;
			case '[': case '{': case '(': if (quoted == FALSE) bl++; break;
			case ']': case '}': case ')': if (quoted == FALSE) bl--; break;
		}
	}
	if (first_comma >= 0) {
		obj = JSON__decode_req_object_entry(obj, T, from, first_comma, known_names);
		from = first_comma + 1;
		goto NextEntry;
	}
	return JSON__decode_req_object_entry(obj, T, from, to, known_names);
}

JSON_single_requirement *JSON__decode_req_object_entry(JSON_single_requirement *obj,
	text_stream *T, int from, int to, dictionary *known_names) {
	int optional = FALSE;
	while (Characters__is_whitespace(Str__get_at(T, from))) from++;
	if (Str__get_at(T, from) == '?') { optional = TRUE; from++; }
	while (Characters__is_whitespace(Str__get_at(T, from))) from++;
	if (Str__get_at(T, from) != '"')
		return JSON__error_sr(TL_IS_47);
	from++;
	int ended = FALSE;
	TEMPORARY_TEXT(key)
	while (from < to) {
		inchar32_t c = Str__get_at(T, from++);
		if (c == '\"') { ended = TRUE; break; }
		PUT_TO(key, c);
		if ((c == '\\') && (from+1 < to)) {
			c = Str__get_at(T, from++);
			PUT_TO(key, c);
		}
	}
	if (ended == FALSE) return JSON__error_sr(TL_IS_48);
	while (Characters__is_whitespace(Str__get_at(T, from))) from++;
	if ((from >= to) || (Str__get_at(T, from) != ':'))
		return JSON__error_sr(TL_IS_49);
	from++;
	if (JSON__look_up_pair(obj, key)) return JSON__error_sr(TL_IS_50);
	JSON_requirement *req = JSON__decode_req_range(T, from, to, known_names);
	if (optional) JSON__allow_pair(obj, key, req);
	else JSON__require_pair(obj, key, req);
	DISCARD_TEXT(key)
	return obj;
}

#line 1259 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__encode_req(OUTPUT_STREAM, JSON_requirement *req) {
	JSON__encode_req_r(OUT, req);
}

void JSON__encode_req_r(OUTPUT_STREAM, JSON_requirement *req) {
	if (req == NULL) internal_error("no JSON value supplied");
	int L = LinkedLists__len(req->alternatives);
	if (L > 1) WRITE("( ");
	int c = 0;
	JSON_single_requirement *sing;
	LOOP_OVER_LINKED_LIST(sing, JSON_single_requirement, req->alternatives) {
		if (c++ > 0) WRITE(" | ");
		JSON__encode_sreq_r(OUT, sing);
	}
	if (L > 1) WRITE(" )");
}

void JSON__encode_sreq_r(OUTPUT_STREAM, JSON_single_requirement *sing) {
	if (sing->this_requirement) JSON__encode_req_r(OUT, sing->this_requirement);
	if (sing->this_value) JSON__encode(OUT, sing->this_value);
	if (sing->this_type) JSON__encode_type(OUT, sing->this_type);
}

void JSON__encode_type(OUTPUT_STREAM, JSON_type *type) {
	switch (type->JSON_type) {
		case ARRAY_JSONTYPE: {
			WRITE("[");
			if (type->all_if_list) {
				WRITE(" ");
				JSON__encode_req_r(OUT, type->all_if_list);
				WRITE("* ");
			} else {
				int count = 0;
				JSON_requirement *E_req;
				LOOP_OVER_LINKED_LIST(E_req, JSON_requirement, type->if_list) {
					if (count++ > 0) WRITE(",");
					WRITE(" ");
					JSON__encode_req_r(OUT, E_req);
				}
				if (count > 0) WRITE(" ");
			}
			WRITE("]");
			break;
		}
		case OBJECT_JSONTYPE: {
			WRITE("{\n"); INDENT;
			int count = 0;
			text_stream *key;
			LOOP_OVER_LINKED_LIST(key, text_stream, type->list_if_object) {
				if (count++ > 0) WRITE(",\n");
				JSON_pair_requirement *pr =
					Dictionaries__read_value(type->dictionary_if_object, key);
				if (pr == NULL) internal_error("broken JSON req dictionary");
				if (pr->optional) WRITE("?");
				WRITE("\"");
				JSON__encode_string(OUT, key);
				WRITE("\": ");
				JSON__encode_req_r(OUT, pr->req);
			}
			if (count > 0) WRITE("\n");
			OUTDENT; WRITE("}");
			break;
		}
		default: JSON__write_type(OUT, type->JSON_type);
	}
}

#line 1358 "inweb/foundation-module/Chapter 4/JSON.w"

dictionary *JSON__read_requirements_file(dictionary *known, filename *F) {
	if (known == NULL) known = Dictionaries__new(32, FALSE);
	JSON_rrf_state state;
	state.name = Str__new();
	state.defn = Str__new();
	state.dict = known;
	TextFiles__read(F, FALSE, "unable to read file of JSON requirements", TRUE,
		&JSON__read_requirements_file_helper, NULL, (void *) &state);
	JSON__process_req_defn(&state);
	return known;
}

void JSON__read_requirements_file_helper(text_stream *text, text_file_position *tfp,
	void *v_state) {
	JSON_rrf_state *state = (JSON_rrf_state *) v_state;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, text, U" *<(%C+)> *::= *(%c*)")) {
		JSON__process_req_defn(state);
		WRITE_TO(state->name, "%S", mr.exp[0]);
		WRITE_TO(state->defn, "%S", mr.exp[1]);
		state->at = *tfp;
	} else if (Regexp__match(&mr, text, U" *!%c*")) {
		/* do nothing: this line is a comment */
	} else if (Regexp__match(&mr, text, U" *")) {
		/* do nothing: this line is blank */
	} else if (Str__len(state->name) > 0) {
		WRITE_TO(state->defn, "%S\n", text);
	} else {
		Errors__in_text_file_S(TL_IS_51, tfp);
	}
}

#line 1395 "inweb/foundation-module/Chapter 4/JSON.w"
void JSON__process_req_defn(JSON_rrf_state *state) {
	if (Str__len(state->name) > 0) {
		JSON_requirement *req =
			JSON__decode_printing_errors(state->defn, state->dict, &(state->at));
		if (req) {
			dict_entry *de = Dictionaries__create(state->dict, state->name);
			if (de) de->value = req;
		}
	}
	Str__clear(state->name);
	Str__clear(state->defn);
}

JSON_requirement *JSON__decode_printing_errors(text_stream *defn, dictionary *dict,
	text_file_position *tfp) {
	JSON_requirement *req = JSON__decode_req(defn, dict);
	if (req == NULL) internal_error("decode_req returned NULL");
	int errors_found = FALSE;
	JSON_single_requirement *sing;
	LOOP_OVER_LINKED_LIST(sing, JSON_single_requirement, req->alternatives) {
		if ((sing->this_type) && (sing->this_type->JSON_type == ERROR_JSONTYPE)) {
			TEMPORARY_TEXT(err)
			WRITE_TO(err, "JSON requirement error: %S", sing->this_type->if_error);
			Errors__in_text_file_S(err, tfp);
			errors_found = TRUE;
			DISCARD_TEXT(err)
		}
	}
	if (errors_found == FALSE) return req;
	return NULL;
}

JSON_requirement *JSON__look_up_requirements(dictionary *known, text_stream *name) {
	dict_entry *de = Dictionaries__find(known, name);
	if (de == NULL) return NULL;
	return de->value;
}

#line 8 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__header(OUTPUT_STREAM, text_stream *title, filename *css1, filename *css2,
	filename *js1, filename *js2, void *state) {
	HTML__declare_as_HTML(OUT, FALSE);
	HTML__begin_head(OUT, NULL);
	HTML__title(OUT, title);
	if (css1) HTML__incorporate_CSS(OUT, css1);
	if (css2) HTML__incorporate_CSS(OUT, css2);
	if (js1) HTML__incorporate_javascript(OUT, TRUE, js1);
	if (js2) HTML__incorporate_javascript(OUT, TRUE, js2);
	#ifdef ADDITIONAL_SCRIPTING_HTML_CALLBACK
	ADDITIONAL_SCRIPTING_HTML_CALLBACK(OUT, state);
	#endif
	HTML__end_head(OUT);
	HTML__begin_body(OUT, NULL);
	HTML__comment(OUT, TL_IS_52);
}

void HTML__footer(OUTPUT_STREAM) {
	WRITE("\n");
	HTML__comment(OUT, TL_IS_53);
	HTML__end_body(OUT);
}

#line 63 "inweb/foundation-module/Chapter 5/HTML.w"

void HTML__declare_as_HTML(OUTPUT_STREAM, int XHTML) {
	HTML_file_state *hs = CREATE(HTML_file_state);
	hs->XHTML_flag = XHTML;
	hs->tag_stack = NEW_LIFO_STACK(HTML_tag);
	hs->CSS_included = 0;
	hs->JS_included = 0;
	Streams__declare_as_HTML(OUT, hs);
}

#line 78 "inweb/foundation-module/Chapter 5/HTML.w"
int unique_xref = 0;
#line 86 "inweb/foundation-module/Chapter 5/HTML.w"

int HTML__push_tag(OUTPUT_STREAM, char *tag, char *fn, int lc) {
	int u = unique_xref++;
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs) {
		HTML_tag *ht = CREATE(HTML_tag);
		ht->tag_name = tag;
		ht->tag_xref = u;
		ht->from_filename = fn;
		ht->from_line = lc;
		PUSH_TO_LIFO_STACK(ht, HTML_tag, hs->tag_stack);
	}
	return u;
}

#line 102 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__pop_tag(OUTPUT_STREAM, char *tag, char *fn, int lc) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs) {
		if (LIFO_STACK_EMPTY(HTML_tag, hs->tag_stack)) {
			LOG("Trying to close %s at line %d of '%s', but:\n", tag, lc, fn);
			tag_error("closed HTML tag which wasn't open");
		} else {
			HTML_tag *ht = TOP_OF_LIFO_STACK(HTML_tag, hs->tag_stack);
			if ((ht == NULL) || (strcmp(tag, ht->tag_name) != 0)) {
				LOG("Trying to close %s at line %d of '%s', but:\n", tag, lc, fn);
				tag_error("closed HTML tag which wasn't open");
			}
			POP_LIFO_STACK(HTML_tag, hs->tag_stack);
		}
	}
}

#line 122 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__completed(OUTPUT_STREAM) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if ((hs) && (LIFO_STACK_EMPTY(HTML_tag, hs->tag_stack) == FALSE)) {
		tag_error("HTML tags still open");
	}
}

#line 137 "inweb/foundation-module/Chapter 5/HTML.w"
#define HTML_TAG_WITH(tag, args...) { \
	TEMPORARY_TEXT(details) \
	WRITE_TO(details, args); \
	HTML__tag(OUT, tag, details); \
	DISCARD_TEXT(details) \
}

#define HTML_OPEN_WITH(tag, args...) { \
	TEMPORARY_TEXT(details) \
	WRITE_TO(details, args); \
	HTML__open(OUT, tag, details, __FILE__, __LINE__); \
	DISCARD_TEXT(details) \
}

#line 154 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__tag(OUTPUT_STREAM, char *tag, text_stream *details) {
	WRITE("<%s", tag);
	if (Str__len(details) > 0) WRITE(" %S", details);
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if ((hs) && (hs->XHTML_flag)) WRITE(" /");
	WRITE(">");
	if (HTML__tag_formatting(tag) >= 1) WRITE("\n");
}

void HTML__tag_sc(OUTPUT_STREAM, char *tag, text_stream *details) {
	WRITE("<%s", tag);
	if (Str__len(details) > 0) WRITE(" %S", details);
	WRITE(" />");
	if (HTML__tag_formatting(tag) >= 1) WRITE("\n");
}

int HTML__tag_formatting(char *tag) {
	if (strcmp(tag, "meta") == 0) return 1;
	if (strcmp(tag, "link") == 0) return 1;
	if (strcmp(tag, "hr") == 0) return 1;
	if (strcmp(tag, "br") == 0) return 1;

	return 0;
}

void HTML__open(OUTPUT_STREAM, char *tag, text_stream *details, char *fn, int lc) {
	int f = HTML__pair_formatting(tag);
	HTML__push_tag(OUT, tag, fn, lc);
	WRITE("<%s", tag);
	if (Str__len(details) > 0) WRITE(" %S", details);
	WRITE(">");
	if (f >= 2) { WRITE("\n"); INDENT; }
}

void HTML__close(OUTPUT_STREAM, char *tag, char *fn, int lc) {
	int f = HTML__pair_formatting(tag);
	if (f >= 3) WRITE("\n");
	if (f >= 2) OUTDENT;
	WRITE("</%s>", tag);
	HTML__pop_tag(OUT, tag, fn, lc);
	if (f >= 1) WRITE("\n");
}

void HTML__open_indented_p(OUTPUT_STREAM, int depth, char *class) {
	int margin = depth;
	if (margin < 1) internal_error("minimal HTML indentation is 1");
	if (margin > 9) margin = 9;
	HTML_OPEN_WITH("p", "class=\"%sin%d\"", class, margin);
	while (depth > 9) { depth--; WRITE("&nbsp;&nbsp;&nbsp;&nbsp;"); }
}

int HTML__pair_formatting(char *tag) {
	if (strcmp(tag, "td") == 0) return 3;

	if (strcmp(tag, "head") == 0) return 2;
	if (strcmp(tag, "body") == 0) return 2;
	if (strcmp(tag, "div") == 0) return 2;
	if (strcmp(tag, "table") == 0) return 2;
	if (strcmp(tag, "tr") == 0) return 2;
	if (strcmp(tag, "script") == 0) return 2;
	if (strcmp(tag, "style") == 0) return 2;

	if (strcmp(tag, "html") == 0) return 1;
	if (strcmp(tag, "p") == 0) return 1;
	if (strcmp(tag, "title") == 0) return 1;
	if (strcmp(tag, "blockquote") == 0) return 1;

	return 0;
}

#line 227 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_head(OUTPUT_STREAM, filename *CSS_file) {
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if ((hs) && (hs->XHTML_flag)) {
		WRITE("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" ");
		WRITE("\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n");
		HTML_OPEN_WITH("html", "xmlns=\"http://www.w3.org/1999/xhtml\"");
	} else {
		WRITE("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" ");
		WRITE("\"http://www.w3.org/TR/html4/loose.dtd\">\n");
		HTML_OPEN("html");
	}
	WRITE("\n");
	HTML_OPEN("head");
	HTML_TAG_WITH("meta", "http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"");
	if (CSS_file)
		HTML_TAG_WITH("link", "href=\"%/f\" rel=\"stylesheet\" type=\"text/css\"", CSS_file);
}

void HTML__end_head(OUTPUT_STREAM) {
	HTML_CLOSE("head");
}

#line 250 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__title(OUTPUT_STREAM, text_stream *title) {
	HTML_OPEN("title");
	WRITE("%S", title);
	HTML_CLOSE("title");
}

#line 259 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__open_javascript(OUTPUT_STREAM, int define_project) {
	HTML_OPEN_WITH("script", "type=\"text/javascript\"");
	if (define_project) {
		WRITE("function project() {\n"); INDENT;
		WRITE("return window.Project;\n");
		OUTDENT; WRITE("}\n");
	}
}

void HTML__close_javascript(OUTPUT_STREAM) {
	HTML_CLOSE("script");
}

dictionary *HTML_incorporation_cache = NULL;

void HTML__incorporate_javascript(OUTPUT_STREAM, int define_project, filename *M) {
	HTML__open_javascript(OUT, define_project);
	if (HTML_incorporation_cache == NULL)
		HTML_incorporation_cache = Dictionaries__new(32, TRUE);
	TEMPORARY_TEXT(key)
	WRITE_TO(key, "%f", M);
	text_stream *existing_entry = Dictionaries__get_text(HTML_incorporation_cache, key);
	if (existing_entry) {
		WRITE("%S", existing_entry);
	} else {
		text_stream *new_entry = Dictionaries__create_text(HTML_incorporation_cache, key);
		HTML__incorporate_javascript_from_file(new_entry, M);
		WRITE("%S", new_entry);
	}
	DISCARD_TEXT(key)
	HTML__close_javascript(OUT);
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs) hs->JS_included++;
}

void HTML__incorporate_javascript_from_file(OUTPUT_STREAM, filename *M) {
	if (TextFiles__read(M, FALSE, NULL, FALSE, HTML__incorporate_helper, NULL, OUT) == FALSE) {
		WRITE_TO(STDERR, "%f", M);
		internal_error("Unable to open model JS material for reading");
	}
}

void HTML__open_CSS(OUTPUT_STREAM) {
	HTML_OPEN_WITH("style", "type=\"text/css\"");
	WRITE("<!--\n");
}

void HTML__close_CSS(OUTPUT_STREAM) {
	WRITE("-->\n");
	HTML_CLOSE("style");
}

void HTML__incorporate_CSS(OUTPUT_STREAM, filename *M) {
	if (HTML_incorporation_cache == NULL)
		HTML_incorporation_cache = Dictionaries__new(32, TRUE);
	TEMPORARY_TEXT(key)
	WRITE_TO(key, "%f", M);
	text_stream *existing_entry = Dictionaries__get_text(HTML_incorporation_cache, key);
	if (existing_entry) {
		WRITE("%S", existing_entry);
	} else {
		text_stream *new_entry = Dictionaries__create_text(HTML_incorporation_cache, key);
		HTML__incorporate_CSS_from_file(new_entry, M);
		WRITE("%S", new_entry);
	}
	DISCARD_TEXT(key)
	HTML_file_state *hs = Streams__get_HTML_file_state(OUT);
	if (hs) hs->CSS_included++;
}

void HTML__incorporate_CSS_from_file(OUTPUT_STREAM, filename *M) {
	HTML__open_CSS(OUT);
	if (TextFiles__read(M, FALSE, NULL, FALSE, HTML__incorporate_helper, NULL, OUT) == FALSE)
		internal_error("Unable to open model CSS material for reading");
	HTML__close_CSS(OUT);
}

void HTML__incorporate_HTML(OUTPUT_STREAM, filename *M) {
	if (HTML_incorporation_cache == NULL)
		HTML_incorporation_cache = Dictionaries__new(32, TRUE);
	TEMPORARY_TEXT(key)
	WRITE_TO(key, "%f", M);
	text_stream *existing_entry = Dictionaries__get_text(HTML_incorporation_cache, key);
	if (existing_entry) {
		WRITE("%S", existing_entry);
	} else {
		text_stream *new_entry = Dictionaries__create_text(HTML_incorporation_cache, key);
		HTML__incorporate_HTML_from_file(new_entry, M);
		WRITE("%S", new_entry);
	}
	DISCARD_TEXT(key)
}

void HTML__incorporate_HTML_from_file(OUTPUT_STREAM, filename *M) {
	if (TextFiles__read(M, FALSE, NULL, FALSE, HTML__incorporate_helper, NULL, OUT) == FALSE)
		internal_error("Unable to open model HTML material for reading");
}

#line 360 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__incorporate_helper(text_stream *line_of_template,
	text_file_position *tfp, void *OUT) {
	WRITE("%S\n", line_of_template);
}

#line 368 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_body(OUTPUT_STREAM, text_stream *class) {
	if (class) HTML_OPEN_WITH("body", "class=\"%S\"", class)
	else HTML_OPEN("body");
}

void HTML__end_body(OUTPUT_STREAM) {
	HTML_CLOSE("body");
	HTML_CLOSE("html");
}

#line 381 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_div_with_id(OUTPUT_STREAM, char *id) {
	HTML_OPEN_WITH("div", "id=\"%s\"", id);
}

void HTML__begin_div_with_class(OUTPUT_STREAM, char *cl) {
	HTML_OPEN_WITH("div", "class=\"%s\"", cl);
}

void HTML__begin_div_with_class_and_id(OUTPUT_STREAM, char *cl, char *id, int hide) {
	if (hide) HTML_OPEN_WITH("div", "class=\"%s\" id=\"%s\" style=\"display: none;\"", cl, id)
	else HTML_OPEN_WITH("div", "class=\"%s\" id=\"%s\"", cl, id);
}

void HTML__begin_div_with_id_S(OUTPUT_STREAM, text_stream *id, char *fn, int lc) {
	TEMPORARY_TEXT(details)
	WRITE_TO(details, "id=\"%S\"", id);
	HTML__open(OUT, "div", details, fn, lc);
	DISCARD_TEXT(details)
}

void HTML__begin_div_with_class_S(OUTPUT_STREAM, text_stream *cl, char *fn, int lc) {
	TEMPORARY_TEXT(details)
	WRITE_TO(details, "class=\"%S\"", cl);
	HTML__open(OUT, "div", details, fn, lc);
	DISCARD_TEXT(details)
}

void HTML__begin_div_with_class_and_id_S(OUTPUT_STREAM, text_stream *cl,
	text_stream *id, int hide, char *fn, int lc) {
	TEMPORARY_TEXT(details)
	WRITE_TO(details, "class=\"%S\" id=\"%S\"", cl, id);
	if (hide) WRITE_TO(details, " style=\"display: none;\"");
	HTML__open(OUT, "div", details, fn, lc);
	DISCARD_TEXT(details)
}

void HTML__end_div(OUTPUT_STREAM) {
	HTML_CLOSE("div");
}

#line 424 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__image(OUTPUT_STREAM, filename *F) {
	HTML_TAG_WITH("img", "src=\"%/f\"", F);
}

void HTML__image_to_dimensions(OUTPUT_STREAM, filename *F, int w, int h) {
	if ((w > 0) && (h > 0)) {
		HTML_TAG_WITH("img", "src=\"%/f\" alt=\"%S\" width=\"%d\" height=\"%d\"",
			F, Filenames__get_leafname(F), w, h);
	} else if (w > 0) {
		HTML_TAG_WITH("img", "src=\"%/f\" alt=\"%S\" width=\"%d\"",
			F, Filenames__get_leafname(F), w);
	} else if (h > 0) {
		HTML_TAG_WITH("img", "src=\"%/f\" alt=\"%S\" height=\"%d\"",
			F, Filenames__get_leafname(F), h);
	} else {
		HTML_TAG_WITH("img", "src=\"%/f\" alt=\"%S\"",
			F, Filenames__get_leafname(F));
	}
}

#line 449 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__icon_with_tooltip(OUTPUT_STREAM, text_stream *icon_name,
	text_stream *tip, text_stream *tip2) {
	TEMPORARY_TEXT(img)
	WRITE_TO(img, "border=0 src=%S ", icon_name);
	if (tip) {
		WRITE_TO(img, "title=\"%S", tip);
		if (tip2) WRITE_TO(img, " %S", tip2);
		WRITE_TO(img, "\"");
	}
	HTML_TAG_WITH("img", "%S", img);
	DISCARD_TEXT(img)
}

#line 465 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__anchor(OUTPUT_STREAM, text_stream *id) {
	HTML_OPEN_WITH("a", "id=\"%S\"", id); HTML_CLOSE("a");
}

void HTML__anchor_with_class(OUTPUT_STREAM, text_stream *id, text_stream *cl) {
	HTML_OPEN_WITH("a", "id=\"%S\" class=\"%S\"", id, cl); HTML_CLOSE("a");
}

void HTML__begin_link(OUTPUT_STREAM, text_stream *to) {
	HTML_OPEN_WITH("a", "href=\"%S\"", to);
}

void HTML__begin_download_link(OUTPUT_STREAM, text_stream *to) {
	HTML_OPEN_WITH("a", "href=\"%S\" download", to);
}

void HTML__begin_link_with_class(OUTPUT_STREAM, text_stream *cl, text_stream *to) {
	HTML__begin_link_with_class_onclick(OUT, cl, to, NULL);
}

void HTML__begin_link_with_class_title(OUTPUT_STREAM, text_stream *cl, text_stream *to, text_stream *ti) {
	HTML__begin_link_with_class_title_onclick(OUT, cl, to, ti, NULL);
}

void HTML__begin_link_with_class_onclick(OUTPUT_STREAM, text_stream *cl, text_stream *to, text_stream *on) {
	HTML__begin_link_with_class_title_onclick(OUT, cl, to, NULL, on);
}

void HTML__begin_link_with_class_title_onclick(OUTPUT_STREAM, text_stream *cl, text_stream *to, text_stream *ti, text_stream *on) {
	WRITE("<a href=\"%S\" class=\"%S\"", to, cl);
	if (Str__len(ti) > 0) WRITE(" title=\"%S\"", ti);
	if (Str__len(on) > 0) WRITE(" onclick=\"%S\"", on);
	WRITE(">");
}

void HTML__end_link(OUTPUT_STREAM) {
	HTML_CLOSE("a");
}

#line 508 "inweb/foundation-module/Chapter 5/HTML.w"
pathname *abbreviate_links_within = NULL;
void HTML__set_link_abbreviation_path(pathname *P) {
	abbreviate_links_within = P;
}
pathname *HTML__get_link_abbreviation_path(void) {
	return abbreviate_links_within;
}

#line 520 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_plain_html_table(OUTPUT_STREAM) {
	HTML__begin_html_table(OUT, NULL, FALSE, 0, 0, 0, 0, 0);
}

void HTML__begin_wide_html_table(OUTPUT_STREAM) {
	HTML__begin_html_table(OUT, NULL, TRUE, 0, 0, 0, 0, 0);
}

#line 531 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_html_table(OUTPUT_STREAM, text_stream *classname, int full_width,
	int border, int cellspacing, int cellpadding, int height, int width) {
	TEMPORARY_TEXT(tab)
	WRITE_TO(tab, "border=\"%d\" cellspacing=\"%d\" cellpadding=\"%d\"",
		border, cellspacing, cellpadding);
	if (Str__len(classname) > 0) WRITE_TO(tab, " class=\"%S\"", classname);
	if (full_width) WRITE_TO(tab, " width=100%%");
	if (width > 0) WRITE_TO(tab, " width=\"%d\"", width);
	if (height > 0) WRITE_TO(tab, " height=\"%d\"", height);
	HTML_OPEN_WITH("table", "%S", tab);
	DISCARD_TEXT(tab)
}
void HTML__begin_html_table_bg(OUTPUT_STREAM, text_stream *classname, int full_width,
	int border, int cellspacing, int cellpadding, int height, int width, text_stream *bg) {
	TEMPORARY_TEXT(tab)
	WRITE_TO(tab, "border=\"%d\" cellspacing=\"%d\" cellpadding=\"%d\"",
		border, cellspacing, cellpadding);
	if (Str__len(bg) > 0) WRITE_TO(tab, " background=\"inform:/%S\"", bg);
	if (Str__len(classname) > 0) WRITE_TO(tab, " class=\"%S\"", classname);
	if (full_width) WRITE_TO(tab, " width=100%%");
	if (width > 0) WRITE_TO(tab, " width=\"%d\"", width);
	if (height > 0) WRITE_TO(tab, " height=\"%d\"", height);
	HTML_OPEN_WITH("table", "%S", tab);
	DISCARD_TEXT(tab)
}
void HTML__first_html_column(OUTPUT_STREAM, int width) {
	HTML_OPEN("tr");
	if (width > 0) HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\"");
}
void HTML__first_html_column_nowrap(OUTPUT_STREAM, int width, text_stream *classname) {
	if (Str__len(classname) > 0)
		HTML_OPEN_WITH("tr", "class=\"%S\"", classname)
	else
		HTML_OPEN("tr");
	TEMPORARY_TEXT(col)
	WRITE_TO(col, "style=\"white-space:nowrap;\" align=\"left\" valign=\"top\" height=\"20\"");
	if (width > 0) WRITE_TO(col, " width=\"%d\"", width);
	HTML_OPEN_WITH("td", "%S", col);
	DISCARD_TEXT(col)
}
void HTML__first_html_column_spaced(OUTPUT_STREAM, int width) {
	HTML_OPEN("tr");
	TEMPORARY_TEXT(col)
	WRITE_TO(col, "style=\"padding-top: 3px;\" align=\"left\" valign=\"top\"");
	if (width > 0) WRITE_TO(col, " width=\"%d\"", width);
	HTML_OPEN_WITH("td", "%S", col);
	DISCARD_TEXT(col)
}
void HTML__first_html_column_coloured(OUTPUT_STREAM, int width, text_stream *classname,
	int cs) {
	if (Str__len(classname) > 0)
		HTML_OPEN_WITH("tr", "class=\"%S\"", classname)
	else
		HTML_OPEN("tr");
	TEMPORARY_TEXT(col)
	WRITE_TO(col, "nowrap=\"nowrap\" align=\"left\" valign=\"top\"");
	if (width > 0) WRITE_TO(col, " width=\"%d\"", width);
	if (cs > 0) WRITE_TO(col, " colspan=\"%d\"", cs);
	HTML_OPEN_WITH("td", "%S", col);
	DISCARD_TEXT(col)
}
void HTML__next_html_column(OUTPUT_STREAM, int width) {
	WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\"");
}
void HTML__next_html_column_centred(OUTPUT_STREAM, int width) {
	WRITE("&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "align=\"center\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "align=\"center\" valign=\"top\"");
}
void HTML__next_html_column_spanning(OUTPUT_STREAM, int width, int sp) {
	WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\" colspan=\"%d\" width=\"%d\"", sp, width)
	else HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\" colspan=\"%d\"", sp);
}
void HTML__next_html_column_nowrap(OUTPUT_STREAM, int width) {
	WRITE("&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "style=\"white-space:nowrap;\" align=\"left\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "style=\"white-space:nowrap;\" align=\"left\" valign=\"top\"");
}
void HTML__next_html_column_spaced(OUTPUT_STREAM, int width) {
	WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "style=\"padding-top: 3px;\" align=\"left\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "style=\"padding-top: 3px;\" align=\"left\" valign=\"top\"");
}
void HTML__next_html_column_nw(OUTPUT_STREAM, int width) {
	WRITE("&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "nowrap=\"nowrap\" align=\"left\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "nowrap=\"nowrap\" align=\"left\" valign=\"top\"");
}
void HTML__next_html_column_w(OUTPUT_STREAM, int width) {
	WRITE("&nbsp;");
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "align=\"left\" valign=\"top\"");
}
void HTML__next_html_column_right_justified(OUTPUT_STREAM, int width) {
	HTML_CLOSE("td");
	if (width > 0) HTML_OPEN_WITH("td", "align=\"right\" valign=\"top\" width=\"%d\"", width)
	else HTML_OPEN_WITH("td", "align=\"right\" valign=\"top\"");
}
void HTML__end_html_row(OUTPUT_STREAM) {
	HTML_CLOSE("td");
	HTML_CLOSE("tr");
}
void HTML__end_html_table(OUTPUT_STREAM) {
	HTML_CLOSE("table");
}

#line 655 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__open_coloured_box(OUTPUT_STREAM, text_stream *classname, int rounding) {
	HTML_OPEN_WITH("table",
		"width=\"100%%\" cellpadding=\"6\" cellspacing=\"0\" border=\"0\" "
		"class=\"%S\"", classname);
	HTML_OPEN("tr");
	HTML_OPEN("td");
}

void HTML__close_coloured_box(OUTPUT_STREAM, text_stream *classname, int rounding) {
	HTML_CLOSE("td");
	HTML_CLOSE("tr");
	HTML__end_html_table(OUT);
}

void HTML__box_corner(OUTPUT_STREAM, text_stream *classname, text_stream *corner) {
	HTML_TAG_WITH("img",
		"src=\"inform:/bg_images/%S_corner_%S.gif\" "
		"width=\"%d\" height=\"%d\" border=\"0\" alt=\"...\"",
		corner, classname, CORNER_SIZE, CORNER_SIZE);
}

#line 679 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__comment(OUTPUT_STREAM, text_stream *text) {
	WRITE("<!--%S-->\n", text);
}

void HTML__heading(OUTPUT_STREAM, char *tag, text_stream *text) {
	HTML_OPEN(tag);
	WRITE("%S", text);
	HTML_CLOSE(tag);
	WRITE("\n");
}

void HTML__hr(OUTPUT_STREAM, char *class) {
	if (class) HTML_TAG_WITH("hr", "class=\"%s\"", class)
	else HTML_TAG("hr");
}

#line 703 "inweb/foundation-module/Chapter 5/HTML.w"

colour_translation table_of_translations[] = {
	{ U"Alice Blue", U"F0F8FF" },
	{ U"Antique White", U"FAEBD7" },
	{ U"Aqua", U"00FFFF" },
	{ U"Aquamarine", U"7FFFD4" },
	{ U"Azure", U"F0FFFF" },
	{ U"Beige", U"F5F5DC" },
	{ U"Bisque", U"FFE4C4" },
	{ U"Black", U"000000" },
	{ U"Blanched Almond", U"FFEBCD" },
	{ U"Blue", U"0000FF" },
	{ U"Blue Violet", U"8A2BE2" },
	{ U"Brown", U"A52A2A" },
	{ U"Burly Wood", U"DEB887" },
	{ U"Cadet Blue", U"5F9EA0" },
	{ U"Chartreuse", U"7FFF00" },
	{ U"Chocolate", U"D2691E" },
	{ U"Coral", U"FF7F50" },
	{ U"Cornflower Blue", U"6495ED" },
	{ U"Cornsilk", U"FFF8DC" },
	{ U"Crimson", U"DC143C" },
	{ U"Cyan", U"00FFFF" },
	{ U"Dark Blue", U"00008B" },
	{ U"Dark Cyan", U"008B8B" },
	{ U"Dark Golden Rod", U"B8860B" },
	{ U"Dark Gray", U"A9A9A9" },
	{ U"Dark Green", U"006400" },
	{ U"Dark Khaki", U"BDB76B" },
	{ U"Dark Magenta", U"8B008B" },
	{ U"Dark Olive Green", U"556B2F" },
	{ U"Dark Orange", U"FF8C00" },
	{ U"Dark Orchid", U"9932CC" },
	{ U"Dark Red", U"8B0000" },
	{ U"Dark Salmon", U"E9967A" },
	{ U"Dark Sea Green", U"8FBC8F" },
	{ U"Dark Slate Blue", U"483D8B" },
	{ U"Dark Slate Gray", U"2F4F4F" },
	{ U"Dark Turquoise", U"00CED1" },
	{ U"Dark Violet", U"9400D3" },
	{ U"Deep Pink", U"FF1493" },
	{ U"Deep Sky Blue", U"00BFFF" },
	{ U"Dim Gray", U"696969" },
	{ U"Dodger Blue", U"1E90FF" },
	{ U"Feldspar", U"D19275" },
	{ U"Fire Brick", U"B22222" },
	{ U"Floral White", U"FFFAF0" },
	{ U"Forest Green", U"228B22" },
	{ U"Fuchsia", U"FF00FF" },
	{ U"Gainsboro", U"DCDCDC" },
	{ U"Ghost White", U"F8F8FF" },
	{ U"Gold", U"FFD700" },
	{ U"Golden Rod", U"DAA520" },
	{ U"Gray", U"808080" },
	{ U"Green", U"008000" },
	{ U"Green Yellow", U"ADFF2F" },
	{ U"Honey Dew", U"F0FFF0" },
	{ U"Hot Pink", U"FF69B4" },
	{ U"Indian Red", U"CD5C5C" },
	{ U"Indigo", U"4B0082" },
	{ U"Ivory", U"FFFFF0" },
	{ U"Khaki", U"F0E68C" },
	{ U"Lavender", U"E6E6FA" },
	{ U"Lavender Blush", U"FFF0F5" },
	{ U"Lawn Green", U"7CFC00" },
	{ U"Lemon Chiffon", U"FFFACD" },
	{ U"Light Blue", U"ADD8E6" },
	{ U"Light Coral", U"F08080" },
	{ U"Light Cyan", U"E0FFFF" },
	{ U"Light Golden Rod Yellow", U"FAFAD2" },
	{ U"Light Grey", U"D3D3D3" },
	{ U"Light Green", U"90EE90" },
	{ U"Light Pink", U"FFB6C1" },
	{ U"Light Salmon", U"FFA07A" },
	{ U"Light Sea Green", U"20B2AA" },
	{ U"Light Sky Blue", U"87CEFA" },
	{ U"Light Slate Blue", U"8470FF" },
	{ U"Light Slate Gray", U"778899" },
	{ U"Light Steel Blue", U"B0C4DE" },
	{ U"Light Yellow", U"FFFFE0" },
	{ U"Lime", U"00FF00" },
	{ U"Lime Green", U"32CD32" },
	{ U"Linen", U"FAF0E6" },
	{ U"Magenta", U"FF00FF" },
	{ U"Maroon", U"800000" },
	{ U"Medium Aquamarine", U"66CDAA" },
	{ U"Medium Blue", U"0000CD" },
	{ U"Medium Orchid", U"BA55D3" },
	{ U"Medium Purple", U"9370D8" },
	{ U"Medium Sea Green", U"3CB371" },
	{ U"Medium Slate Blue", U"7B68EE" },
	{ U"Medium Spring Green", U"00FA9A" },
	{ U"Medium Turquoise", U"48D1CC" },
	{ U"Medium Violet Red", U"CA226B" },
	{ U"Midnight Blue", U"191970" },
	{ U"Mint Cream", U"F5FFFA" },
	{ U"Misty Rose", U"FFE4E1" },
	{ U"Moccasin", U"FFE4B5" },
	{ U"Navajo White", U"FFDEAD" },
	{ U"Navy", U"000080" },
	{ U"Old Lace", U"FDF5E6" },
	{ U"Olive", U"808000" },
	{ U"Olive Drab", U"6B8E23" },
	{ U"Orange", U"FFA500" },
	{ U"Orange Red", U"FF4500" },
	{ U"Orchid", U"DA70D6" },
	{ U"Pale Golden Rod", U"EEE8AA" },
	{ U"Pale Green", U"98FB98" },
	{ U"Pale Turquoise", U"AFEEEE" },
	{ U"Pale Violet Red", U"D87093" },
	{ U"Papaya Whip", U"FFEFD5" },
	{ U"Peach Puff", U"FFDAB9" },
	{ U"Peru", U"CD853F" },
	{ U"Pink", U"FFC0CB" },
	{ U"Plum", U"DDA0DD" },
	{ U"Powder Blue", U"B0E0E6" },
	{ U"Purple", U"800080" },
	{ U"Red", U"FF0000" },
	{ U"Rosy Brown", U"BC8F8F" },
	{ U"Royal Blue", U"4169E1" },
	{ U"Saddle Brown", U"8B4513" },
	{ U"Salmon", U"FA8072" },
	{ U"Sandy Brown", U"F4A460" },
	{ U"Sea Green", U"2E8B57" },
	{ U"Sea Shell", U"FFF5EE" },
	{ U"Sienna", U"A0522D" },
	{ U"Silver", U"C0C0C0" },
	{ U"Sky Blue", U"87CEEB" },
	{ U"Slate Blue", U"6A5ACD" },
	{ U"Slate Gray", U"708090" },
	{ U"Snow", U"FFFAFA" },
	{ U"Spring Green", U"00FF7F" },
	{ U"Steel Blue", U"4682B4" },
	{ U"Tan", U"D2B48C" },
	{ U"Teal", U"008080" },
	{ U"Thistle", U"D8BFD8" },
	{ U"Tomato", U"FF6347" },
	{ U"Turquoise", U"40E0D0" },
	{ U"Violet", U"EE82EE" },
	{ U"Violet Red", U"D02090" },
	{ U"Wheat", U"F5DEB3" },
	{ U"White", U"FFFFFF" },
	{ U"White Smoke", U"F5F5F5" },
	{ U"Yellow", U"FFFF00" },
	{ U"Yellow Green", U"9ACD32" },
	{ U"", U"" }
};

#line 855 "inweb/foundation-module/Chapter 5/HTML.w"
inchar32_t *HTML__translate_colour_name(inchar32_t *original) {
	for (int j=0; Wide__cmp(table_of_translations[j].chip_name, U""); j++)
		if (Wide__cmp(table_of_translations[j].chip_name, original) == 0)
			return table_of_translations[j].html_colour;
	return NULL;
}

#line 863 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_colour(OUTPUT_STREAM, text_stream *col) {
	HTML_OPEN_WITH("span", "style='color:#%S'", col);
}
void HTML__end_colour(OUTPUT_STREAM) {
	HTML_CLOSE("span");
}

#line 873 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__begin_span(OUTPUT_STREAM, text_stream *class_name) {
	if (Str__len(class_name) > 0) {
		HTML_OPEN_WITH("span", "class=\"%S\"", class_name);
	} else {
		HTML_OPEN("span");
	}
}
void HTML__end_span(OUTPUT_STREAM) {
	HTML_CLOSE("span");
}

#line 888 "inweb/foundation-module/Chapter 5/HTML.w"
void HTML__write_xml_safe_text(OUTPUT_STREAM, text_stream *txt) {
	LOOP_THROUGH_TEXT(pos, txt) {
		inchar32_t c = Str__get(pos);
		switch(c) {
			case '&': WRITE("&amp;"); break;
			case '<': WRITE("&lt;"); break;
			case '>': WRITE("&gt;"); break;
			default: PUT(c); break;
		}
	}
}

#line 916 "inweb/foundation-module/Chapter 5/HTML.w"
text_stream *source_ref_fields[3] = { NULL, NULL, NULL }; /* paraphrase, filename, line */
int source_ref_field = -1; /* which field we are buffering */

void HTML__put(OUTPUT_STREAM, inchar32_t charcode) {
	
{
#line 943 "inweb/foundation-module/Chapter 5/HTML.w"
	if ((source_ref_field >= 0) && (charcode != SOURCE_REF_CHAR)) {
		PUT_TO(source_ref_fields[source_ref_field], charcode); return;
	}

}
#line 920 "inweb/foundation-module/Chapter 5/HTML.w"
;
	switch(charcode) {
		case '"': WRITE("&quot;"); break;
		case '<': WRITE("&lt;"); break;
		case '>': WRITE("&gt;"); break;
		case '&': WRITE("&amp;"); break;
		case NEWLINE_IN_STRING: HTML_TAG("br"); break;

		#ifdef PROBLEMS_MODULE
		case FORCE_NEW_PARA_CHAR: HTML_CLOSE("p"); HTML_OPEN_WITH("p", "class=\"in2\"");
			HTML__icon_with_tooltip(OUT, TL_IS_54, NULL, NULL);
			WRITE("&nbsp;"); break;
		#endif

		#ifdef WORDS_MODULE
		case SOURCE_REF_CHAR: 
{
#line 948 "inweb/foundation-module/Chapter 5/HTML.w"
	source_ref_field++;
	if (source_ref_field == 3) {
		source_ref_field = -1;
		source_location sl;
		sl.file_of_origin = TextFromFiles__filename_to_source_file(source_ref_fields[1]);
		sl.line_number = Str__atoi(source_ref_fields[2], 0);
		#ifdef HTML_MODULE
		SourceLinks__link(OUT, sl, TRUE);
		#endif
	} else {
		if (source_ref_fields[source_ref_field] == NULL)
			source_ref_fields[source_ref_field] = Str__new();
		Str__clear(source_ref_fields[source_ref_field]);
	}

}
#line 935 "inweb/foundation-module/Chapter 5/HTML.w"
; break;
		#endif

		default: PUT(charcode); break;
	}
}

#line 16 "inweb/foundation-module/Chapter 5/HTML Entities.w"
int HTMLEntities__parse(text_stream *entity, inchar32_t *A, inchar32_t *B) {
	if (Str__get_at(entity, 0) != '&') return FALSE;
	if (Str__get_at(entity, 1) == '#') {
		int base = 10, from = 2;
		if ((Str__get_at(entity, 2) == 'x') || (Str__get_at(entity, 2) == 'X')) {
			base = 16; from = 3;
		}
		int total = 0, dc = 0;
		while (Str__get_at(entity, from)) {
			int dval = -1;
			inchar32_t digit = Str__get_at(entity, from);
			if ((digit >= '0') && (digit <= '9')) dval = (int) digit - (int) '0';
			else if ((base == 16) && (digit >= 'a') && (digit <= 'f')) dval = 10 + (int) digit - (int) 'a';
			else if ((base == 16) && (digit >= 'A') && (digit <= 'F')) dval = 10 + (int) digit - (int) 'A';
			else if (digit == ';') break;
			else return FALSE;
			total = base*total + dval; dc++;
			from++;
			if (dc > 7) return FALSE;
		}
		if (dc == 0) return FALSE;
		if (A) *A = (inchar32_t)total; if (B) *B = 0;
		return TRUE;
	} else {
		switch (Str__get_at(entity, 1)) {
			case 'A':
				if (Str__eq(entity, TL_IS_55)) { if (A) *A = 198; return TRUE; }
				if (Str__eq(entity, TL_IS_56)) { if (A) *A = 198; return TRUE; }
				if (Str__eq(entity, TL_IS_57)) { if (A) *A = 38; return TRUE; }
				if (Str__eq(entity, TL_IS_58)) { if (A) *A = 38; return TRUE; }
				if (Str__eq(entity, TL_IS_59)) { if (A) *A = 193; return TRUE; }
				if (Str__eq(entity, TL_IS_60)) { if (A) *A = 193; return TRUE; }
				if (Str__eq(entity, TL_IS_61)) { if (A) *A = 258; return TRUE; }
				if (Str__eq(entity, TL_IS_62)) { if (A) *A = 194; return TRUE; }
				if (Str__eq(entity, TL_IS_63)) { if (A) *A = 194; return TRUE; }
				if (Str__eq(entity, TL_IS_64)) { if (A) *A = 1040; return TRUE; }
				if (Str__eq(entity, TL_IS_65)) { if (A) *A = 120068; return TRUE; }
				if (Str__eq(entity, TL_IS_66)) { if (A) *A = 192; return TRUE; }
				if (Str__eq(entity, TL_IS_67)) { if (A) *A = 192; return TRUE; }
				if (Str__eq(entity, TL_IS_68)) { if (A) *A = 913; return TRUE; }
				if (Str__eq(entity, TL_IS_69)) { if (A) *A = 256; return TRUE; }
				if (Str__eq(entity, TL_IS_70)) { if (A) *A = 10835; return TRUE; }
				if (Str__eq(entity, TL_IS_71)) { if (A) *A = 260; return TRUE; }
				if (Str__eq(entity, TL_IS_72)) { if (A) *A = 120120; return TRUE; }
				if (Str__eq(entity, TL_IS_73)) { if (A) *A = 8289; return TRUE; }
				if (Str__eq(entity, TL_IS_74)) { if (A) *A = 197; return TRUE; }
				if (Str__eq(entity, TL_IS_75)) { if (A) *A = 197; return TRUE; }
				if (Str__eq(entity, TL_IS_76)) { if (A) *A = 119964; return TRUE; }
				if (Str__eq(entity, TL_IS_77)) { if (A) *A = 8788; return TRUE; }
				if (Str__eq(entity, TL_IS_78)) { if (A) *A = 195; return TRUE; }
				if (Str__eq(entity, TL_IS_79)) { if (A) *A = 195; return TRUE; }
				if (Str__eq(entity, TL_IS_80)) { if (A) *A = 196; return TRUE; }
				if (Str__eq(entity, TL_IS_81)) { if (A) *A = 196; return TRUE; }
				break;
			case 'B':
				if (Str__eq(entity, TL_IS_82)) { if (A) *A = 8726; return TRUE; }
				if (Str__eq(entity, TL_IS_83)) { if (A) *A = 10983; return TRUE; }
				if (Str__eq(entity, TL_IS_84)) { if (A) *A = 8966; return TRUE; }
				if (Str__eq(entity, TL_IS_85)) { if (A) *A = 1041; return TRUE; }
				if (Str__eq(entity, TL_IS_86)) { if (A) *A = 8757; return TRUE; }
				if (Str__eq(entity, TL_IS_87)) { if (A) *A = 8492; return TRUE; }
				if (Str__eq(entity, TL_IS_88)) { if (A) *A = 914; return TRUE; }
				if (Str__eq(entity, TL_IS_89)) { if (A) *A = 120069; return TRUE; }
				if (Str__eq(entity, TL_IS_90)) { if (A) *A = 120121; return TRUE; }
				if (Str__eq(entity, TL_IS_91)) { if (A) *A = 728; return TRUE; }
				if (Str__eq(entity, TL_IS_92)) { if (A) *A = 8492; return TRUE; }
				if (Str__eq(entity, TL_IS_93)) { if (A) *A = 8782; return TRUE; }
				break;
			case 'C':
				if (Str__eq(entity, TL_IS_94)) { if (A) *A = 1063; return TRUE; }
				if (Str__eq(entity, TL_IS_95)) { if (A) *A = 169; return TRUE; }
				if (Str__eq(entity, TL_IS_96)) { if (A) *A = 169; return TRUE; }
				if (Str__eq(entity, TL_IS_97)) { if (A) *A = 262; return TRUE; }
				if (Str__eq(entity, TL_IS_98)) { if (A) *A = 8914; return TRUE; }
				if (Str__eq(entity, TL_IS_99)) { if (A) *A = 8517; return TRUE; }
				if (Str__eq(entity, TL_IS_100)) { if (A) *A = 8493; return TRUE; }
				if (Str__eq(entity, TL_IS_101)) { if (A) *A = 268; return TRUE; }
				if (Str__eq(entity, TL_IS_102)) { if (A) *A = 199; return TRUE; }
				if (Str__eq(entity, TL_IS_103)) { if (A) *A = 199; return TRUE; }
				if (Str__eq(entity, TL_IS_104)) { if (A) *A = 264; return TRUE; }
				if (Str__eq(entity, TL_IS_105)) { if (A) *A = 8752; return TRUE; }
				if (Str__eq(entity, TL_IS_106)) { if (A) *A = 266; return TRUE; }
				if (Str__eq(entity, TL_IS_107)) { if (A) *A = 184; return TRUE; }
				if (Str__eq(entity, TL_IS_108)) { if (A) *A = 183; return TRUE; }
				if (Str__eq(entity, TL_IS_109)) { if (A) *A = 8493; return TRUE; }
				if (Str__eq(entity, TL_IS_110)) { if (A) *A = 935; return TRUE; }
				if (Str__eq(entity, TL_IS_111)) { if (A) *A = 8857; return TRUE; }
				if (Str__eq(entity, TL_IS_112)) { if (A) *A = 8854; return TRUE; }
				if (Str__eq(entity, TL_IS_113)) { if (A) *A = 8853; return TRUE; }
				if (Str__eq(entity, TL_IS_114)) { if (A) *A = 8855; return TRUE; }
				if (Str__eq(entity, TL_IS_115)) { if (A) *A = 8754; return TRUE; }
				if (Str__eq(entity, TL_IS_116)) { if (A) *A = 8221; return TRUE; }
				if (Str__eq(entity, TL_IS_117)) { if (A) *A = 8217; return TRUE; }
				if (Str__eq(entity, TL_IS_118)) { if (A) *A = 8759; return TRUE; }
				if (Str__eq(entity, TL_IS_119)) { if (A) *A = 10868; return TRUE; }
				if (Str__eq(entity, TL_IS_120)) { if (A) *A = 8801; return TRUE; }
				if (Str__eq(entity, TL_IS_121)) { if (A) *A = 8751; return TRUE; }
				if (Str__eq(entity, TL_IS_122)) { if (A) *A = 8750; return TRUE; }
				if (Str__eq(entity, TL_IS_123)) { if (A) *A = 8450; return TRUE; }
				if (Str__eq(entity, TL_IS_124)) { if (A) *A = 8720; return TRUE; }
				if (Str__eq(entity, TL_IS_125)) { if (A) *A = 8755; return TRUE; }
				if (Str__eq(entity, TL_IS_126)) { if (A) *A = 10799; return TRUE; }
				if (Str__eq(entity, TL_IS_127)) { if (A) *A = 119966; return TRUE; }
				if (Str__eq(entity, TL_IS_128)) { if (A) *A = 8915; return TRUE; }
				if (Str__eq(entity, TL_IS_129)) { if (A) *A = 8781; return TRUE; }
				break;
			case 'D':
				if (Str__eq(entity, TL_IS_130)) { if (A) *A = 8517; return TRUE; }
				if (Str__eq(entity, TL_IS_131)) { if (A) *A = 10513; return TRUE; }
				if (Str__eq(entity, TL_IS_132)) { if (A) *A = 1026; return TRUE; }
				if (Str__eq(entity, TL_IS_133)) { if (A) *A = 1029; return TRUE; }
				if (Str__eq(entity, TL_IS_134)) { if (A) *A = 1039; return TRUE; }
				if (Str__eq(entity, TL_IS_135)) { if (A) *A = 8225; return TRUE; }
				if (Str__eq(entity, TL_IS_136)) { if (A) *A = 8609; return TRUE; }
				if (Str__eq(entity, TL_IS_137)) { if (A) *A = 10980; return TRUE; }
				if (Str__eq(entity, TL_IS_138)) { if (A) *A = 270; return TRUE; }
				if (Str__eq(entity, TL_IS_139)) { if (A) *A = 1044; return TRUE; }
				if (Str__eq(entity, TL_IS_140)) { if (A) *A = 8711; return TRUE; }
				if (Str__eq(entity, TL_IS_141)) { if (A) *A = 916; return TRUE; }
				if (Str__eq(entity, TL_IS_142)) { if (A) *A = 120071; return TRUE; }
				if (Str__eq(entity, TL_IS_143)) { if (A) *A = 180; return TRUE; }
				if (Str__eq(entity, TL_IS_144)) { if (A) *A = 729; return TRUE; }
				if (Str__eq(entity, TL_IS_145)) { if (A) *A = 733; return TRUE; }
				if (Str__eq(entity, TL_IS_146)) { if (A) *A = 96; return TRUE; }
				if (Str__eq(entity, TL_IS_147)) { if (A) *A = 732; return TRUE; }
				if (Str__eq(entity, TL_IS_148)) { if (A) *A = 8900; return TRUE; }
				if (Str__eq(entity, TL_IS_149)) { if (A) *A = 8518; return TRUE; }
				if (Str__eq(entity, TL_IS_150)) { if (A) *A = 120123; return TRUE; }
				if (Str__eq(entity, TL_IS_151)) { if (A) *A = 168; return TRUE; }
				if (Str__eq(entity, TL_IS_152)) { if (A) *A = 8412; return TRUE; }
				if (Str__eq(entity, TL_IS_153)) { if (A) *A = 8784; return TRUE; }
				if (Str__eq(entity, TL_IS_154)) { if (A) *A = 8751; return TRUE; }
				if (Str__eq(entity, TL_IS_155)) { if (A) *A = 168; return TRUE; }
				if (Str__eq(entity, TL_IS_156)) { if (A) *A = 8659; return TRUE; }
				if (Str__eq(entity, TL_IS_157)) { if (A) *A = 8656; return TRUE; }
				if (Str__eq(entity, TL_IS_158)) { if (A) *A = 8660; return TRUE; }
				if (Str__eq(entity, TL_IS_159)) { if (A) *A = 10980; return TRUE; }
				if (Str__eq(entity, TL_IS_160)) { if (A) *A = 10232; return TRUE; }
				if (Str__eq(entity, TL_IS_161)) { if (A) *A = 10234; return TRUE; }
				if (Str__eq(entity, TL_IS_162)) { if (A) *A = 10233; return TRUE; }
				if (Str__eq(entity, TL_IS_163)) { if (A) *A = 8658; return TRUE; }
				if (Str__eq(entity, TL_IS_164)) { if (A) *A = 8872; return TRUE; }
				if (Str__eq(entity, TL_IS_165)) { if (A) *A = 8657; return TRUE; }
				if (Str__eq(entity, TL_IS_166)) { if (A) *A = 8661; return TRUE; }
				if (Str__eq(entity, TL_IS_167)) { if (A) *A = 8741; return TRUE; }
				if (Str__eq(entity, TL_IS_168)) { if (A) *A = 8595; return TRUE; }
				if (Str__eq(entity, TL_IS_169)) { if (A) *A = 10515; return TRUE; }
				if (Str__eq(entity, TL_IS_170)) { if (A) *A = 8693; return TRUE; }
				if (Str__eq(entity, TL_IS_171)) { if (A) *A = 785; return TRUE; }
				if (Str__eq(entity, TL_IS_172)) { if (A) *A = 10576; return TRUE; }
				if (Str__eq(entity, TL_IS_173)) { if (A) *A = 10590; return TRUE; }
				if (Str__eq(entity, TL_IS_174)) { if (A) *A = 8637; return TRUE; }
				if (Str__eq(entity, TL_IS_175)) { if (A) *A = 10582; return TRUE; }
				if (Str__eq(entity, TL_IS_176)) { if (A) *A = 10591; return TRUE; }
				if (Str__eq(entity, TL_IS_177)) { if (A) *A = 8641; return TRUE; }
				if (Str__eq(entity, TL_IS_178)) { if (A) *A = 10583; return TRUE; }
				if (Str__eq(entity, TL_IS_179)) { if (A) *A = 8868; return TRUE; }
				if (Str__eq(entity, TL_IS_180)) { if (A) *A = 8615; return TRUE; }
				if (Str__eq(entity, TL_IS_181)) { if (A) *A = 8659; return TRUE; }
				if (Str__eq(entity, TL_IS_182)) { if (A) *A = 119967; return TRUE; }
				if (Str__eq(entity, TL_IS_183)) { if (A) *A = 272; return TRUE; }
				break;
			case 'E':
				if (Str__eq(entity, TL_IS_184)) { if (A) *A = 330; return TRUE; }
				if (Str__eq(entity, TL_IS_185)) { if (A) *A = 208; return TRUE; }
				if (Str__eq(entity, TL_IS_186)) { if (A) *A = 208; return TRUE; }
				if (Str__eq(entity, TL_IS_187)) { if (A) *A = 201; return TRUE; }
				if (Str__eq(entity, TL_IS_188)) { if (A) *A = 201; return TRUE; }
				if (Str__eq(entity, TL_IS_189)) { if (A) *A = 282; return TRUE; }
				if (Str__eq(entity, TL_IS_190)) { if (A) *A = 202; return TRUE; }
				if (Str__eq(entity, TL_IS_191)) { if (A) *A = 202; return TRUE; }
				if (Str__eq(entity, TL_IS_192)) { if (A) *A = 1069; return TRUE; }
				if (Str__eq(entity, TL_IS_193)) { if (A) *A = 278; return TRUE; }
				if (Str__eq(entity, TL_IS_194)) { if (A) *A = 120072; return TRUE; }
				if (Str__eq(entity, TL_IS_195)) { if (A) *A = 200; return TRUE; }
				if (Str__eq(entity, TL_IS_196)) { if (A) *A = 200; return TRUE; }
				if (Str__eq(entity, TL_IS_197)) { if (A) *A = 8712; return TRUE; }
				if (Str__eq(entity, TL_IS_198)) { if (A) *A = 274; return TRUE; }
				if (Str__eq(entity, TL_IS_199)) { if (A) *A = 9723; return TRUE; }
				if (Str__eq(entity, TL_IS_200)) { if (A) *A = 9643; return TRUE; }
				if (Str__eq(entity, TL_IS_201)) { if (A) *A = 280; return TRUE; }
				if (Str__eq(entity, TL_IS_202)) { if (A) *A = 120124; return TRUE; }
				if (Str__eq(entity, TL_IS_203)) { if (A) *A = 917; return TRUE; }
				if (Str__eq(entity, TL_IS_204)) { if (A) *A = 10869; return TRUE; }
				if (Str__eq(entity, TL_IS_205)) { if (A) *A = 8770; return TRUE; }
				if (Str__eq(entity, TL_IS_206)) { if (A) *A = 8652; return TRUE; }
				if (Str__eq(entity, TL_IS_207)) { if (A) *A = 8496; return TRUE; }
				if (Str__eq(entity, TL_IS_208)) { if (A) *A = 10867; return TRUE; }
				if (Str__eq(entity, TL_IS_209)) { if (A) *A = 919; return TRUE; }
				if (Str__eq(entity, TL_IS_210)) { if (A) *A = 203; return TRUE; }
				if (Str__eq(entity, TL_IS_211)) { if (A) *A = 203; return TRUE; }
				if (Str__eq(entity, TL_IS_212)) { if (A) *A = 8707; return TRUE; }
				if (Str__eq(entity, TL_IS_213)) { if (A) *A = 8519; return TRUE; }
				break;
			case 'F':
				if (Str__eq(entity, TL_IS_214)) { if (A) *A = 1060; return TRUE; }
				if (Str__eq(entity, TL_IS_215)) { if (A) *A = 120073; return TRUE; }
				if (Str__eq(entity, TL_IS_216)) { if (A) *A = 9724; return TRUE; }
				if (Str__eq(entity, TL_IS_217)) { if (A) *A = 9642; return TRUE; }
				if (Str__eq(entity, TL_IS_218)) { if (A) *A = 120125; return TRUE; }
				if (Str__eq(entity, TL_IS_219)) { if (A) *A = 8704; return TRUE; }
				if (Str__eq(entity, TL_IS_220)) { if (A) *A = 8497; return TRUE; }
				if (Str__eq(entity, TL_IS_221)) { if (A) *A = 8497; return TRUE; }
				break;
			case 'G':
				if (Str__eq(entity, TL_IS_222)) { if (A) *A = 1027; return TRUE; }
				if (Str__eq(entity, TL_IS_223)) { if (A) *A = 62; return TRUE; }
				if (Str__eq(entity, TL_IS_224)) { if (A) *A = 62; return TRUE; }
				if (Str__eq(entity, TL_IS_225)) { if (A) *A = 915; return TRUE; }
				if (Str__eq(entity, TL_IS_226)) { if (A) *A = 988; return TRUE; }
				if (Str__eq(entity, TL_IS_227)) { if (A) *A = 286; return TRUE; }
				if (Str__eq(entity, TL_IS_228)) { if (A) *A = 290; return TRUE; }
				if (Str__eq(entity, TL_IS_229)) { if (A) *A = 284; return TRUE; }
				if (Str__eq(entity, TL_IS_230)) { if (A) *A = 1043; return TRUE; }
				if (Str__eq(entity, TL_IS_231)) { if (A) *A = 288; return TRUE; }
				if (Str__eq(entity, TL_IS_232)) { if (A) *A = 120074; return TRUE; }
				if (Str__eq(entity, TL_IS_233)) { if (A) *A = 8921; return TRUE; }
				if (Str__eq(entity, TL_IS_234)) { if (A) *A = 120126; return TRUE; }
				if (Str__eq(entity, TL_IS_235)) { if (A) *A = 8805; return TRUE; }
				if (Str__eq(entity, TL_IS_236)) { if (A) *A = 8923; return TRUE; }
				if (Str__eq(entity, TL_IS_237)) { if (A) *A = 8807; return TRUE; }
				if (Str__eq(entity, TL_IS_238)) { if (A) *A = 10914; return TRUE; }
				if (Str__eq(entity, TL_IS_239)) { if (A) *A = 8823; return TRUE; }
				if (Str__eq(entity, TL_IS_240)) { if (A) *A = 10878; return TRUE; }
				if (Str__eq(entity, TL_IS_241)) { if (A) *A = 8819; return TRUE; }
				if (Str__eq(entity, TL_IS_242)) { if (A) *A = 119970; return TRUE; }
				if (Str__eq(entity, TL_IS_243)) { if (A) *A = 8811; return TRUE; }
				break;
			case 'H':
				if (Str__eq(entity, TL_IS_244)) { if (A) *A = 1066; return TRUE; }
				if (Str__eq(entity, TL_IS_245)) { if (A) *A = 711; return TRUE; }
				if (Str__eq(entity, TL_IS_246)) { if (A) *A = 94; return TRUE; }
				if (Str__eq(entity, TL_IS_247)) { if (A) *A = 292; return TRUE; }
				if (Str__eq(entity, TL_IS_248)) { if (A) *A = 8460; return TRUE; }
				if (Str__eq(entity, TL_IS_249)) { if (A) *A = 8459; return TRUE; }
				if (Str__eq(entity, TL_IS_250)) { if (A) *A = 8461; return TRUE; }
				if (Str__eq(entity, TL_IS_251)) { if (A) *A = 9472; return TRUE; }
				if (Str__eq(entity, TL_IS_252)) { if (A) *A = 8459; return TRUE; }
				if (Str__eq(entity, TL_IS_253)) { if (A) *A = 294; return TRUE; }
				if (Str__eq(entity, TL_IS_254)) { if (A) *A = 8782; return TRUE; }
				if (Str__eq(entity, TL_IS_255)) { if (A) *A = 8783; return TRUE; }
				break;
			case 'I':
				if (Str__eq(entity, TL_IS_256)) { if (A) *A = 1045; return TRUE; }
				if (Str__eq(entity, TL_IS_257)) { if (A) *A = 306; return TRUE; }
				if (Str__eq(entity, TL_IS_258)) { if (A) *A = 1025; return TRUE; }
				if (Str__eq(entity, TL_IS_259)) { if (A) *A = 205; return TRUE; }
				if (Str__eq(entity, TL_IS_260)) { if (A) *A = 205; return TRUE; }
				if (Str__eq(entity, TL_IS_261)) { if (A) *A = 206; return TRUE; }
				if (Str__eq(entity, TL_IS_262)) { if (A) *A = 206; return TRUE; }
				if (Str__eq(entity, TL_IS_263)) { if (A) *A = 1048; return TRUE; }
				if (Str__eq(entity, TL_IS_264)) { if (A) *A = 304; return TRUE; }
				if (Str__eq(entity, TL_IS_265)) { if (A) *A = 8465; return TRUE; }
				if (Str__eq(entity, TL_IS_266)) { if (A) *A = 204; return TRUE; }
				if (Str__eq(entity, TL_IS_267)) { if (A) *A = 204; return TRUE; }
				if (Str__eq(entity, TL_IS_268)) { if (A) *A = 8465; return TRUE; }
				if (Str__eq(entity, TL_IS_269)) { if (A) *A = 298; return TRUE; }
				if (Str__eq(entity, TL_IS_270)) { if (A) *A = 8520; return TRUE; }
				if (Str__eq(entity, TL_IS_271)) { if (A) *A = 8658; return TRUE; }
				if (Str__eq(entity, TL_IS_272)) { if (A) *A = 8748; return TRUE; }
				if (Str__eq(entity, TL_IS_273)) { if (A) *A = 8747; return TRUE; }
				if (Str__eq(entity, TL_IS_274)) { if (A) *A = 8898; return TRUE; }
				if (Str__eq(entity, TL_IS_275)) { if (A) *A = 8291; return TRUE; }
				if (Str__eq(entity, TL_IS_276)) { if (A) *A = 8290; return TRUE; }
				if (Str__eq(entity, TL_IS_277)) { if (A) *A = 302; return TRUE; }
				if (Str__eq(entity, TL_IS_278)) { if (A) *A = 120128; return TRUE; }
				if (Str__eq(entity, TL_IS_279)) { if (A) *A = 921; return TRUE; }
				if (Str__eq(entity, TL_IS_280)) { if (A) *A = 8464; return TRUE; }
				if (Str__eq(entity, TL_IS_281)) { if (A) *A = 296; return TRUE; }
				if (Str__eq(entity, TL_IS_282)) { if (A) *A = 1030; return TRUE; }
				if (Str__eq(entity, TL_IS_283)) { if (A) *A = 207; return TRUE; }
				if (Str__eq(entity, TL_IS_284)) { if (A) *A = 207; return TRUE; }
				break;
			case 'J':
				if (Str__eq(entity, TL_IS_285)) { if (A) *A = 308; return TRUE; }
				if (Str__eq(entity, TL_IS_286)) { if (A) *A = 1049; return TRUE; }
				if (Str__eq(entity, TL_IS_287)) { if (A) *A = 120077; return TRUE; }
				if (Str__eq(entity, TL_IS_288)) { if (A) *A = 120129; return TRUE; }
				if (Str__eq(entity, TL_IS_289)) { if (A) *A = 119973; return TRUE; }
				if (Str__eq(entity, TL_IS_290)) { if (A) *A = 1032; return TRUE; }
				if (Str__eq(entity, TL_IS_291)) { if (A) *A = 1028; return TRUE; }
				break;
			case 'K':
				if (Str__eq(entity, TL_IS_292)) { if (A) *A = 1061; return TRUE; }
				if (Str__eq(entity, TL_IS_293)) { if (A) *A = 1036; return TRUE; }
				if (Str__eq(entity, TL_IS_294)) { if (A) *A = 922; return TRUE; }
				if (Str__eq(entity, TL_IS_295)) { if (A) *A = 310; return TRUE; }
				if (Str__eq(entity, TL_IS_296)) { if (A) *A = 1050; return TRUE; }
				if (Str__eq(entity, TL_IS_297)) { if (A) *A = 120078; return TRUE; }
				if (Str__eq(entity, TL_IS_298)) { if (A) *A = 120130; return TRUE; }
				if (Str__eq(entity, TL_IS_299)) { if (A) *A = 119974; return TRUE; }
				break;
			case 'L':
				if (Str__eq(entity, TL_IS_300)) { if (A) *A = 1033; return TRUE; }
				if (Str__eq(entity, TL_IS_301)) { if (A) *A = 60; return TRUE; }
				if (Str__eq(entity, TL_IS_302)) { if (A) *A = 60; return TRUE; }
				if (Str__eq(entity, TL_IS_303)) { if (A) *A = 313; return TRUE; }
				if (Str__eq(entity, TL_IS_304)) { if (A) *A = 923; return TRUE; }
				if (Str__eq(entity, TL_IS_305)) { if (A) *A = 10218; return TRUE; }
				if (Str__eq(entity, TL_IS_306)) { if (A) *A = 8466; return TRUE; }
				if (Str__eq(entity, TL_IS_307)) { if (A) *A = 8606; return TRUE; }
				if (Str__eq(entity, TL_IS_308)) { if (A) *A = 317; return TRUE; }
				if (Str__eq(entity, TL_IS_309)) { if (A) *A = 315; return TRUE; }
				if (Str__eq(entity, TL_IS_310)) { if (A) *A = 1051; return TRUE; }
				if (Str__eq(entity, TL_IS_311)) { if (A) *A = 10216; return TRUE; }
				if (Str__eq(entity, TL_IS_312)) { if (A) *A = 8592; return TRUE; }
				if (Str__eq(entity, TL_IS_313)) { if (A) *A = 8676; return TRUE; }
				if (Str__eq(entity, TL_IS_314)) { if (A) *A = 8646; return TRUE; }
				if (Str__eq(entity, TL_IS_315)) { if (A) *A = 8968; return TRUE; }
				if (Str__eq(entity, TL_IS_316)) { if (A) *A = 10214; return TRUE; }
				if (Str__eq(entity, TL_IS_317)) { if (A) *A = 10593; return TRUE; }
				if (Str__eq(entity, TL_IS_318)) { if (A) *A = 8643; return TRUE; }
				if (Str__eq(entity, TL_IS_319)) { if (A) *A = 10585; return TRUE; }
				if (Str__eq(entity, TL_IS_320)) { if (A) *A = 8970; return TRUE; }
				if (Str__eq(entity, TL_IS_321)) { if (A) *A = 8596; return TRUE; }
				if (Str__eq(entity, TL_IS_322)) { if (A) *A = 10574; return TRUE; }
				if (Str__eq(entity, TL_IS_323)) { if (A) *A = 8867; return TRUE; }
				if (Str__eq(entity, TL_IS_324)) { if (A) *A = 8612; return TRUE; }
				if (Str__eq(entity, TL_IS_325)) { if (A) *A = 10586; return TRUE; }
				if (Str__eq(entity, TL_IS_326)) { if (A) *A = 8882; return TRUE; }
				if (Str__eq(entity, TL_IS_327)) { if (A) *A = 10703; return TRUE; }
				if (Str__eq(entity, TL_IS_328)) { if (A) *A = 8884; return TRUE; }
				if (Str__eq(entity, TL_IS_329)) { if (A) *A = 10577; return TRUE; }
				if (Str__eq(entity, TL_IS_330)) { if (A) *A = 10592; return TRUE; }
				if (Str__eq(entity, TL_IS_331)) { if (A) *A = 8639; return TRUE; }
				if (Str__eq(entity, TL_IS_332)) { if (A) *A = 10584; return TRUE; }
				if (Str__eq(entity, TL_IS_333)) { if (A) *A = 8636; return TRUE; }
				if (Str__eq(entity, TL_IS_334)) { if (A) *A = 10578; return TRUE; }
				if (Str__eq(entity, TL_IS_335)) { if (A) *A = 8656; return TRUE; }
				if (Str__eq(entity, TL_IS_336)) { if (A) *A = 8660; return TRUE; }
				if (Str__eq(entity, TL_IS_337)) { if (A) *A = 8922; return TRUE; }
				if (Str__eq(entity, TL_IS_338)) { if (A) *A = 8806; return TRUE; }
				if (Str__eq(entity, TL_IS_339)) { if (A) *A = 8822; return TRUE; }
				if (Str__eq(entity, TL_IS_340)) { if (A) *A = 10913; return TRUE; }
				if (Str__eq(entity, TL_IS_341)) { if (A) *A = 10877; return TRUE; }
				if (Str__eq(entity, TL_IS_342)) { if (A) *A = 8818; return TRUE; }
				if (Str__eq(entity, TL_IS_343)) { if (A) *A = 120079; return TRUE; }
				if (Str__eq(entity, TL_IS_344)) { if (A) *A = 8920; return TRUE; }
				if (Str__eq(entity, TL_IS_345)) { if (A) *A = 8666; return TRUE; }
				if (Str__eq(entity, TL_IS_346)) { if (A) *A = 319; return TRUE; }
				if (Str__eq(entity, TL_IS_347)) { if (A) *A = 10229; return TRUE; }
				if (Str__eq(entity, TL_IS_348)) { if (A) *A = 10231; return TRUE; }
				if (Str__eq(entity, TL_IS_349)) { if (A) *A = 10230; return TRUE; }
				if (Str__eq(entity, TL_IS_350)) { if (A) *A = 10232; return TRUE; }
				if (Str__eq(entity, TL_IS_351)) { if (A) *A = 10234; return TRUE; }
				if (Str__eq(entity, TL_IS_352)) { if (A) *A = 10233; return TRUE; }
				if (Str__eq(entity, TL_IS_353)) { if (A) *A = 120131; return TRUE; }
				if (Str__eq(entity, TL_IS_354)) { if (A) *A = 8601; return TRUE; }
				if (Str__eq(entity, TL_IS_355)) { if (A) *A = 8600; return TRUE; }
				if (Str__eq(entity, TL_IS_356)) { if (A) *A = 8466; return TRUE; }
				if (Str__eq(entity, TL_IS_357)) { if (A) *A = 8624; return TRUE; }
				if (Str__eq(entity, TL_IS_358)) { if (A) *A = 321; return TRUE; }
				if (Str__eq(entity, TL_IS_359)) { if (A) *A = 8810; return TRUE; }
				break;
			case 'M':
				if (Str__eq(entity, TL_IS_360)) { if (A) *A = 10501; return TRUE; }
				if (Str__eq(entity, TL_IS_361)) { if (A) *A = 1052; return TRUE; }
				if (Str__eq(entity, TL_IS_362)) { if (A) *A = 8287; return TRUE; }
				if (Str__eq(entity, TL_IS_363)) { if (A) *A = 8499; return TRUE; }
				if (Str__eq(entity, TL_IS_364)) { if (A) *A = 120080; return TRUE; }
				if (Str__eq(entity, TL_IS_365)) { if (A) *A = 8723; return TRUE; }
				if (Str__eq(entity, TL_IS_366)) { if (A) *A = 120132; return TRUE; }
				if (Str__eq(entity, TL_IS_367)) { if (A) *A = 8499; return TRUE; }
				if (Str__eq(entity, TL_IS_368)) { if (A) *A = 924; return TRUE; }
				break;
			case 'N':
				if (Str__eq(entity, TL_IS_369)) { if (A) *A = 1034; return TRUE; }
				if (Str__eq(entity, TL_IS_370)) { if (A) *A = 323; return TRUE; }
				if (Str__eq(entity, TL_IS_371)) { if (A) *A = 327; return TRUE; }
				if (Str__eq(entity, TL_IS_372)) { if (A) *A = 325; return TRUE; }
				if (Str__eq(entity, TL_IS_373)) { if (A) *A = 1053; return TRUE; }
				if (Str__eq(entity, TL_IS_374)) { if (A) *A = 8203; return TRUE; }
				if (Str__eq(entity, TL_IS_375)) { if (A) *A = 8203; return TRUE; }
				if (Str__eq(entity, TL_IS_376)) { if (A) *A = 8203; return TRUE; }
				if (Str__eq(entity, TL_IS_377)) { if (A) *A = 8203; return TRUE; }
				if (Str__eq(entity, TL_IS_378)) { if (A) *A = 8811; return TRUE; }
				if (Str__eq(entity, TL_IS_379)) { if (A) *A = 8810; return TRUE; }
				if (Str__eq(entity, TL_IS_380)) { if (A) *A = 10; return TRUE; }
				if (Str__eq(entity, TL_IS_381)) { if (A) *A = 120081; return TRUE; }
				if (Str__eq(entity, TL_IS_382)) { if (A) *A = 8288; return TRUE; }
				if (Str__eq(entity, TL_IS_383)) { if (A) *A = 160; return TRUE; }
				if (Str__eq(entity, TL_IS_384)) { if (A) *A = 8469; return TRUE; }
				if (Str__eq(entity, TL_IS_385)) { if (A) *A = 10988; return TRUE; }
				if (Str__eq(entity, TL_IS_386)) { if (A) *A = 8802; return TRUE; }
				if (Str__eq(entity, TL_IS_387)) { if (A) *A = 8813; return TRUE; }
				if (Str__eq(entity, TL_IS_388)) { if (A) *A = 8742; return TRUE; }
				if (Str__eq(entity, TL_IS_389)) { if (A) *A = 8713; return TRUE; }
				if (Str__eq(entity, TL_IS_390)) { if (A) *A = 8800; return TRUE; }
				if (Str__eq(entity, TL_IS_391)) { if (A) *A = 8770; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_392)) { if (A) *A = 8708; return TRUE; }
				if (Str__eq(entity, TL_IS_393)) { if (A) *A = 8815; return TRUE; }
				if (Str__eq(entity, TL_IS_394)) { if (A) *A = 8817; return TRUE; }
				if (Str__eq(entity, TL_IS_395)) { if (A) *A = 8807; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_396)) { if (A) *A = 8811; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_397)) { if (A) *A = 8825; return TRUE; }
				if (Str__eq(entity, TL_IS_398)) { if (A) *A = 10878; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_399)) { if (A) *A = 8821; return TRUE; }
				if (Str__eq(entity, TL_IS_400)) { if (A) *A = 8782; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_401)) { if (A) *A = 8783; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_402)) { if (A) *A = 8938; return TRUE; }
				if (Str__eq(entity, TL_IS_403)) { if (A) *A = 10703; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_404)) { if (A) *A = 8940; return TRUE; }
				if (Str__eq(entity, TL_IS_405)) { if (A) *A = 8814; return TRUE; }
				if (Str__eq(entity, TL_IS_406)) { if (A) *A = 8816; return TRUE; }
				if (Str__eq(entity, TL_IS_407)) { if (A) *A = 8824; return TRUE; }
				if (Str__eq(entity, TL_IS_408)) { if (A) *A = 8810; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_409)) { if (A) *A = 10877; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_410)) { if (A) *A = 8820; return TRUE; }
				if (Str__eq(entity, TL_IS_411)) { if (A) *A = 10914; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_412)) { if (A) *A = 10913; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_413)) { if (A) *A = 8832; return TRUE; }
				if (Str__eq(entity, TL_IS_414)) { if (A) *A = 10927; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_415)) { if (A) *A = 8928; return TRUE; }
				if (Str__eq(entity, TL_IS_416)) { if (A) *A = 8716; return TRUE; }
				if (Str__eq(entity, TL_IS_417)) { if (A) *A = 8939; return TRUE; }
				if (Str__eq(entity, TL_IS_418)) { if (A) *A = 10704; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_419)) { if (A) *A = 8941; return TRUE; }
				if (Str__eq(entity, TL_IS_420)) { if (A) *A = 8847; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_421)) { if (A) *A = 8930; return TRUE; }
				if (Str__eq(entity, TL_IS_422)) { if (A) *A = 8848; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_423)) { if (A) *A = 8931; return TRUE; }
				if (Str__eq(entity, TL_IS_424)) { if (A) *A = 8834; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_425)) { if (A) *A = 8840; return TRUE; }
				if (Str__eq(entity, TL_IS_426)) { if (A) *A = 8833; return TRUE; }
				if (Str__eq(entity, TL_IS_427)) { if (A) *A = 10928; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_428)) { if (A) *A = 8929; return TRUE; }
				if (Str__eq(entity, TL_IS_429)) { if (A) *A = 8831; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_430)) { if (A) *A = 8835; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_431)) { if (A) *A = 8841; return TRUE; }
				if (Str__eq(entity, TL_IS_432)) { if (A) *A = 8769; return TRUE; }
				if (Str__eq(entity, TL_IS_433)) { if (A) *A = 8772; return TRUE; }
				if (Str__eq(entity, TL_IS_434)) { if (A) *A = 8775; return TRUE; }
				if (Str__eq(entity, TL_IS_435)) { if (A) *A = 8777; return TRUE; }
				if (Str__eq(entity, TL_IS_436)) { if (A) *A = 8740; return TRUE; }
				if (Str__eq(entity, TL_IS_437)) { if (A) *A = 119977; return TRUE; }
				if (Str__eq(entity, TL_IS_438)) { if (A) *A = 209; return TRUE; }
				if (Str__eq(entity, TL_IS_439)) { if (A) *A = 209; return TRUE; }
				if (Str__eq(entity, TL_IS_440)) { if (A) *A = 925; return TRUE; }
				break;
			case 'O':
				if (Str__eq(entity, TL_IS_441)) { if (A) *A = 338; return TRUE; }
				if (Str__eq(entity, TL_IS_442)) { if (A) *A = 211; return TRUE; }
				if (Str__eq(entity, TL_IS_443)) { if (A) *A = 211; return TRUE; }
				if (Str__eq(entity, TL_IS_444)) { if (A) *A = 212; return TRUE; }
				if (Str__eq(entity, TL_IS_445)) { if (A) *A = 212; return TRUE; }
				if (Str__eq(entity, TL_IS_446)) { if (A) *A = 1054; return TRUE; }
				if (Str__eq(entity, TL_IS_447)) { if (A) *A = 336; return TRUE; }
				if (Str__eq(entity, TL_IS_448)) { if (A) *A = 120082; return TRUE; }
				if (Str__eq(entity, TL_IS_449)) { if (A) *A = 210; return TRUE; }
				if (Str__eq(entity, TL_IS_450)) { if (A) *A = 210; return TRUE; }
				if (Str__eq(entity, TL_IS_451)) { if (A) *A = 332; return TRUE; }
				if (Str__eq(entity, TL_IS_452)) { if (A) *A = 937; return TRUE; }
				if (Str__eq(entity, TL_IS_453)) { if (A) *A = 927; return TRUE; }
				if (Str__eq(entity, TL_IS_454)) { if (A) *A = 120134; return TRUE; }
				if (Str__eq(entity, TL_IS_455)) { if (A) *A = 8220; return TRUE; }
				if (Str__eq(entity, TL_IS_456)) { if (A) *A = 8216; return TRUE; }
				if (Str__eq(entity, TL_IS_457)) { if (A) *A = 10836; return TRUE; }
				if (Str__eq(entity, TL_IS_458)) { if (A) *A = 119978; return TRUE; }
				if (Str__eq(entity, TL_IS_459)) { if (A) *A = 216; return TRUE; }
				if (Str__eq(entity, TL_IS_460)) { if (A) *A = 216; return TRUE; }
				if (Str__eq(entity, TL_IS_461)) { if (A) *A = 213; return TRUE; }
				if (Str__eq(entity, TL_IS_462)) { if (A) *A = 213; return TRUE; }
				if (Str__eq(entity, TL_IS_463)) { if (A) *A = 10807; return TRUE; }
				if (Str__eq(entity, TL_IS_464)) { if (A) *A = 214; return TRUE; }
				if (Str__eq(entity, TL_IS_465)) { if (A) *A = 214; return TRUE; }
				if (Str__eq(entity, TL_IS_466)) { if (A) *A = 8254; return TRUE; }
				if (Str__eq(entity, TL_IS_467)) { if (A) *A = 9182; return TRUE; }
				if (Str__eq(entity, TL_IS_468)) { if (A) *A = 9140; return TRUE; }
				if (Str__eq(entity, TL_IS_469)) { if (A) *A = 9180; return TRUE; }
				break;
			case 'P':
				if (Str__eq(entity, TL_IS_470)) { if (A) *A = 8706; return TRUE; }
				if (Str__eq(entity, TL_IS_471)) { if (A) *A = 1055; return TRUE; }
				if (Str__eq(entity, TL_IS_472)) { if (A) *A = 120083; return TRUE; }
				if (Str__eq(entity, TL_IS_473)) { if (A) *A = 934; return TRUE; }
				if (Str__eq(entity, TL_IS_474)) { if (A) *A = 928; return TRUE; }
				if (Str__eq(entity, TL_IS_475)) { if (A) *A = 177; return TRUE; }
				if (Str__eq(entity, TL_IS_476)) { if (A) *A = 8460; return TRUE; }
				if (Str__eq(entity, TL_IS_477)) { if (A) *A = 8473; return TRUE; }
				if (Str__eq(entity, TL_IS_478)) { if (A) *A = 10939; return TRUE; }
				if (Str__eq(entity, TL_IS_479)) { if (A) *A = 8826; return TRUE; }
				if (Str__eq(entity, TL_IS_480)) { if (A) *A = 10927; return TRUE; }
				if (Str__eq(entity, TL_IS_481)) { if (A) *A = 8828; return TRUE; }
				if (Str__eq(entity, TL_IS_482)) { if (A) *A = 8830; return TRUE; }
				if (Str__eq(entity, TL_IS_483)) { if (A) *A = 8243; return TRUE; }
				if (Str__eq(entity, TL_IS_484)) { if (A) *A = 8719; return TRUE; }
				if (Str__eq(entity, TL_IS_485)) { if (A) *A = 8759; return TRUE; }
				if (Str__eq(entity, TL_IS_486)) { if (A) *A = 8733; return TRUE; }
				if (Str__eq(entity, TL_IS_487)) { if (A) *A = 119979; return TRUE; }
				if (Str__eq(entity, TL_IS_488)) { if (A) *A = 936; return TRUE; }
				break;
			case 'Q':
				if (Str__eq(entity, TL_IS_489)) { if (A) *A = 34; return TRUE; }
				if (Str__eq(entity, TL_IS_490)) { if (A) *A = 34; return TRUE; }
				if (Str__eq(entity, TL_IS_491)) { if (A) *A = 120084; return TRUE; }
				if (Str__eq(entity, TL_IS_492)) { if (A) *A = 8474; return TRUE; }
				if (Str__eq(entity, TL_IS_493)) { if (A) *A = 119980; return TRUE; }
				break;
			case 'R':
				if (Str__eq(entity, TL_IS_494)) { if (A) *A = 10512; return TRUE; }
				if (Str__eq(entity, TL_IS_495)) { if (A) *A = 174; return TRUE; }
				if (Str__eq(entity, TL_IS_496)) { if (A) *A = 174; return TRUE; }
				if (Str__eq(entity, TL_IS_497)) { if (A) *A = 340; return TRUE; }
				if (Str__eq(entity, TL_IS_498)) { if (A) *A = 10219; return TRUE; }
				if (Str__eq(entity, TL_IS_499)) { if (A) *A = 8608; return TRUE; }
				if (Str__eq(entity, TL_IS_500)) { if (A) *A = 10518; return TRUE; }
				if (Str__eq(entity, TL_IS_501)) { if (A) *A = 344; return TRUE; }
				if (Str__eq(entity, TL_IS_502)) { if (A) *A = 342; return TRUE; }
				if (Str__eq(entity, TL_IS_503)) { if (A) *A = 1056; return TRUE; }
				if (Str__eq(entity, TL_IS_504)) { if (A) *A = 8476; return TRUE; }
				if (Str__eq(entity, TL_IS_505)) { if (A) *A = 8715; return TRUE; }
				if (Str__eq(entity, TL_IS_506)) { if (A) *A = 8651; return TRUE; }
				if (Str__eq(entity, TL_IS_507)) { if (A) *A = 10607; return TRUE; }
				if (Str__eq(entity, TL_IS_508)) { if (A) *A = 8476; return TRUE; }
				if (Str__eq(entity, TL_IS_509)) { if (A) *A = 929; return TRUE; }
				if (Str__eq(entity, TL_IS_510)) { if (A) *A = 10217; return TRUE; }
				if (Str__eq(entity, TL_IS_511)) { if (A) *A = 8594; return TRUE; }
				if (Str__eq(entity, TL_IS_512)) { if (A) *A = 8677; return TRUE; }
				if (Str__eq(entity, TL_IS_513)) { if (A) *A = 8644; return TRUE; }
				if (Str__eq(entity, TL_IS_514)) { if (A) *A = 8969; return TRUE; }
				if (Str__eq(entity, TL_IS_515)) { if (A) *A = 10215; return TRUE; }
				if (Str__eq(entity, TL_IS_516)) { if (A) *A = 10589; return TRUE; }
				if (Str__eq(entity, TL_IS_517)) { if (A) *A = 8642; return TRUE; }
				if (Str__eq(entity, TL_IS_518)) { if (A) *A = 10581; return TRUE; }
				if (Str__eq(entity, TL_IS_519)) { if (A) *A = 8971; return TRUE; }
				if (Str__eq(entity, TL_IS_520)) { if (A) *A = 8866; return TRUE; }
				if (Str__eq(entity, TL_IS_521)) { if (A) *A = 8614; return TRUE; }
				if (Str__eq(entity, TL_IS_522)) { if (A) *A = 10587; return TRUE; }
				if (Str__eq(entity, TL_IS_523)) { if (A) *A = 8883; return TRUE; }
				if (Str__eq(entity, TL_IS_524)) { if (A) *A = 10704; return TRUE; }
				if (Str__eq(entity, TL_IS_525)) { if (A) *A = 8885; return TRUE; }
				if (Str__eq(entity, TL_IS_526)) { if (A) *A = 10575; return TRUE; }
				if (Str__eq(entity, TL_IS_527)) { if (A) *A = 10588; return TRUE; }
				if (Str__eq(entity, TL_IS_528)) { if (A) *A = 8638; return TRUE; }
				if (Str__eq(entity, TL_IS_529)) { if (A) *A = 10580; return TRUE; }
				if (Str__eq(entity, TL_IS_530)) { if (A) *A = 8640; return TRUE; }
				if (Str__eq(entity, TL_IS_531)) { if (A) *A = 10579; return TRUE; }
				if (Str__eq(entity, TL_IS_532)) { if (A) *A = 8658; return TRUE; }
				if (Str__eq(entity, TL_IS_533)) { if (A) *A = 8477; return TRUE; }
				if (Str__eq(entity, TL_IS_534)) { if (A) *A = 10608; return TRUE; }
				if (Str__eq(entity, TL_IS_535)) { if (A) *A = 8667; return TRUE; }
				if (Str__eq(entity, TL_IS_536)) { if (A) *A = 8475; return TRUE; }
				if (Str__eq(entity, TL_IS_537)) { if (A) *A = 8625; return TRUE; }
				if (Str__eq(entity, TL_IS_538)) { if (A) *A = 10740; return TRUE; }
				break;
			case 'S':
				if (Str__eq(entity, TL_IS_539)) { if (A) *A = 1065; return TRUE; }
				if (Str__eq(entity, TL_IS_540)) { if (A) *A = 1064; return TRUE; }
				if (Str__eq(entity, TL_IS_541)) { if (A) *A = 1068; return TRUE; }
				if (Str__eq(entity, TL_IS_542)) { if (A) *A = 346; return TRUE; }
				if (Str__eq(entity, TL_IS_543)) { if (A) *A = 10940; return TRUE; }
				if (Str__eq(entity, TL_IS_544)) { if (A) *A = 352; return TRUE; }
				if (Str__eq(entity, TL_IS_545)) { if (A) *A = 350; return TRUE; }
				if (Str__eq(entity, TL_IS_546)) { if (A) *A = 348; return TRUE; }
				if (Str__eq(entity, TL_IS_547)) { if (A) *A = 1057; return TRUE; }
				if (Str__eq(entity, TL_IS_548)) { if (A) *A = 120086; return TRUE; }
				if (Str__eq(entity, TL_IS_549)) { if (A) *A = 8595; return TRUE; }
				if (Str__eq(entity, TL_IS_550)) { if (A) *A = 8592; return TRUE; }
				if (Str__eq(entity, TL_IS_551)) { if (A) *A = 8594; return TRUE; }
				if (Str__eq(entity, TL_IS_552)) { if (A) *A = 8593; return TRUE; }
				if (Str__eq(entity, TL_IS_553)) { if (A) *A = 931; return TRUE; }
				if (Str__eq(entity, TL_IS_554)) { if (A) *A = 8728; return TRUE; }
				if (Str__eq(entity, TL_IS_555)) { if (A) *A = 120138; return TRUE; }
				if (Str__eq(entity, TL_IS_556)) { if (A) *A = 8730; return TRUE; }
				if (Str__eq(entity, TL_IS_557)) { if (A) *A = 9633; return TRUE; }
				if (Str__eq(entity, TL_IS_558)) { if (A) *A = 8851; return TRUE; }
				if (Str__eq(entity, TL_IS_559)) { if (A) *A = 8847; return TRUE; }
				if (Str__eq(entity, TL_IS_560)) { if (A) *A = 8849; return TRUE; }
				if (Str__eq(entity, TL_IS_561)) { if (A) *A = 8848; return TRUE; }
				if (Str__eq(entity, TL_IS_562)) { if (A) *A = 8850; return TRUE; }
				if (Str__eq(entity, TL_IS_563)) { if (A) *A = 8852; return TRUE; }
				if (Str__eq(entity, TL_IS_564)) { if (A) *A = 119982; return TRUE; }
				if (Str__eq(entity, TL_IS_565)) { if (A) *A = 8902; return TRUE; }
				if (Str__eq(entity, TL_IS_566)) { if (A) *A = 8912; return TRUE; }
				if (Str__eq(entity, TL_IS_567)) { if (A) *A = 8912; return TRUE; }
				if (Str__eq(entity, TL_IS_568)) { if (A) *A = 8838; return TRUE; }
				if (Str__eq(entity, TL_IS_569)) { if (A) *A = 8827; return TRUE; }
				if (Str__eq(entity, TL_IS_570)) { if (A) *A = 10928; return TRUE; }
				if (Str__eq(entity, TL_IS_571)) { if (A) *A = 8829; return TRUE; }
				if (Str__eq(entity, TL_IS_572)) { if (A) *A = 8831; return TRUE; }
				if (Str__eq(entity, TL_IS_573)) { if (A) *A = 8715; return TRUE; }
				if (Str__eq(entity, TL_IS_574)) { if (A) *A = 8721; return TRUE; }
				if (Str__eq(entity, TL_IS_575)) { if (A) *A = 8913; return TRUE; }
				if (Str__eq(entity, TL_IS_576)) { if (A) *A = 8835; return TRUE; }
				if (Str__eq(entity, TL_IS_577)) { if (A) *A = 8839; return TRUE; }
				if (Str__eq(entity, TL_IS_578)) { if (A) *A = 8913; return TRUE; }
				break;
			case 'T':
				if (Str__eq(entity, TL_IS_579)) { if (A) *A = 222; return TRUE; }
				if (Str__eq(entity, TL_IS_580)) { if (A) *A = 222; return TRUE; }
				if (Str__eq(entity, TL_IS_581)) { if (A) *A = 8482; return TRUE; }
				if (Str__eq(entity, TL_IS_582)) { if (A) *A = 1035; return TRUE; }
				if (Str__eq(entity, TL_IS_583)) { if (A) *A = 1062; return TRUE; }
				if (Str__eq(entity, TL_IS_584)) { if (A) *A = 9; return TRUE; }
				if (Str__eq(entity, TL_IS_585)) { if (A) *A = 932; return TRUE; }
				if (Str__eq(entity, TL_IS_586)) { if (A) *A = 356; return TRUE; }
				if (Str__eq(entity, TL_IS_587)) { if (A) *A = 354; return TRUE; }
				if (Str__eq(entity, TL_IS_588)) { if (A) *A = 1058; return TRUE; }
				if (Str__eq(entity, TL_IS_589)) { if (A) *A = 120087; return TRUE; }
				if (Str__eq(entity, TL_IS_590)) { if (A) *A = 8756; return TRUE; }
				if (Str__eq(entity, TL_IS_591)) { if (A) *A = 920; return TRUE; }
				if (Str__eq(entity, TL_IS_592)) { if (A) *A = 8287; if (B) *B = 8202; return TRUE; }
				if (Str__eq(entity, TL_IS_593)) { if (A) *A = 8201; return TRUE; }
				if (Str__eq(entity, TL_IS_594)) { if (A) *A = 8764; return TRUE; }
				if (Str__eq(entity, TL_IS_595)) { if (A) *A = 8771; return TRUE; }
				if (Str__eq(entity, TL_IS_596)) { if (A) *A = 8773; return TRUE; }
				if (Str__eq(entity, TL_IS_597)) { if (A) *A = 8776; return TRUE; }
				if (Str__eq(entity, TL_IS_598)) { if (A) *A = 120139; return TRUE; }
				if (Str__eq(entity, TL_IS_599)) { if (A) *A = 8411; return TRUE; }
				if (Str__eq(entity, TL_IS_600)) { if (A) *A = 119983; return TRUE; }
				if (Str__eq(entity, TL_IS_601)) { if (A) *A = 358; return TRUE; }
				break;
			case 'U':
				if (Str__eq(entity, TL_IS_602)) { if (A) *A = 218; return TRUE; }
				if (Str__eq(entity, TL_IS_603)) { if (A) *A = 218; return TRUE; }
				if (Str__eq(entity, TL_IS_604)) { if (A) *A = 8607; return TRUE; }
				if (Str__eq(entity, TL_IS_605)) { if (A) *A = 10569; return TRUE; }
				if (Str__eq(entity, TL_IS_606)) { if (A) *A = 1038; return TRUE; }
				if (Str__eq(entity, TL_IS_607)) { if (A) *A = 364; return TRUE; }
				if (Str__eq(entity, TL_IS_608)) { if (A) *A = 219; return TRUE; }
				if (Str__eq(entity, TL_IS_609)) { if (A) *A = 219; return TRUE; }
				if (Str__eq(entity, TL_IS_610)) { if (A) *A = 1059; return TRUE; }
				if (Str__eq(entity, TL_IS_611)) { if (A) *A = 368; return TRUE; }
				if (Str__eq(entity, TL_IS_612)) { if (A) *A = 120088; return TRUE; }
				if (Str__eq(entity, TL_IS_613)) { if (A) *A = 217; return TRUE; }
				if (Str__eq(entity, TL_IS_614)) { if (A) *A = 217; return TRUE; }
				if (Str__eq(entity, TL_IS_615)) { if (A) *A = 362; return TRUE; }
				if (Str__eq(entity, TL_IS_616)) { if (A) *A = 95; return TRUE; }
				if (Str__eq(entity, TL_IS_617)) { if (A) *A = 9183; return TRUE; }
				if (Str__eq(entity, TL_IS_618)) { if (A) *A = 9141; return TRUE; }
				if (Str__eq(entity, TL_IS_619)) { if (A) *A = 9181; return TRUE; }
				if (Str__eq(entity, TL_IS_620)) { if (A) *A = 8899; return TRUE; }
				if (Str__eq(entity, TL_IS_621)) { if (A) *A = 8846; return TRUE; }
				if (Str__eq(entity, TL_IS_622)) { if (A) *A = 370; return TRUE; }
				if (Str__eq(entity, TL_IS_623)) { if (A) *A = 120140; return TRUE; }
				if (Str__eq(entity, TL_IS_624)) { if (A) *A = 8593; return TRUE; }
				if (Str__eq(entity, TL_IS_625)) { if (A) *A = 10514; return TRUE; }
				if (Str__eq(entity, TL_IS_626)) { if (A) *A = 8645; return TRUE; }
				if (Str__eq(entity, TL_IS_627)) { if (A) *A = 8597; return TRUE; }
				if (Str__eq(entity, TL_IS_628)) { if (A) *A = 10606; return TRUE; }
				if (Str__eq(entity, TL_IS_629)) { if (A) *A = 8869; return TRUE; }
				if (Str__eq(entity, TL_IS_630)) { if (A) *A = 8613; return TRUE; }
				if (Str__eq(entity, TL_IS_631)) { if (A) *A = 8657; return TRUE; }
				if (Str__eq(entity, TL_IS_632)) { if (A) *A = 8661; return TRUE; }
				if (Str__eq(entity, TL_IS_633)) { if (A) *A = 8598; return TRUE; }
				if (Str__eq(entity, TL_IS_634)) { if (A) *A = 8599; return TRUE; }
				if (Str__eq(entity, TL_IS_635)) { if (A) *A = 978; return TRUE; }
				if (Str__eq(entity, TL_IS_636)) { if (A) *A = 933; return TRUE; }
				if (Str__eq(entity, TL_IS_637)) { if (A) *A = 366; return TRUE; }
				if (Str__eq(entity, TL_IS_638)) { if (A) *A = 119984; return TRUE; }
				if (Str__eq(entity, TL_IS_639)) { if (A) *A = 360; return TRUE; }
				if (Str__eq(entity, TL_IS_640)) { if (A) *A = 220; return TRUE; }
				if (Str__eq(entity, TL_IS_641)) { if (A) *A = 220; return TRUE; }
				break;
			case 'V':
				if (Str__eq(entity, TL_IS_642)) { if (A) *A = 8875; return TRUE; }
				if (Str__eq(entity, TL_IS_643)) { if (A) *A = 10987; return TRUE; }
				if (Str__eq(entity, TL_IS_644)) { if (A) *A = 1042; return TRUE; }
				if (Str__eq(entity, TL_IS_645)) { if (A) *A = 8873; return TRUE; }
				if (Str__eq(entity, TL_IS_646)) { if (A) *A = 10982; return TRUE; }
				if (Str__eq(entity, TL_IS_647)) { if (A) *A = 8897; return TRUE; }
				if (Str__eq(entity, TL_IS_648)) { if (A) *A = 8214; return TRUE; }
				if (Str__eq(entity, TL_IS_649)) { if (A) *A = 8214; return TRUE; }
				if (Str__eq(entity, TL_IS_650)) { if (A) *A = 8739; return TRUE; }
				if (Str__eq(entity, TL_IS_651)) { if (A) *A = 124; return TRUE; }
				if (Str__eq(entity, TL_IS_652)) { if (A) *A = 10072; return TRUE; }
				if (Str__eq(entity, TL_IS_653)) { if (A) *A = 8768; return TRUE; }
				if (Str__eq(entity, TL_IS_654)) { if (A) *A = 8202; return TRUE; }
				if (Str__eq(entity, TL_IS_655)) { if (A) *A = 120089; return TRUE; }
				if (Str__eq(entity, TL_IS_656)) { if (A) *A = 120141; return TRUE; }
				if (Str__eq(entity, TL_IS_657)) { if (A) *A = 119985; return TRUE; }
				if (Str__eq(entity, TL_IS_658)) { if (A) *A = 8874; return TRUE; }
				break;
			case 'W':
				if (Str__eq(entity, TL_IS_659)) { if (A) *A = 372; return TRUE; }
				if (Str__eq(entity, TL_IS_660)) { if (A) *A = 8896; return TRUE; }
				if (Str__eq(entity, TL_IS_661)) { if (A) *A = 120090; return TRUE; }
				if (Str__eq(entity, TL_IS_662)) { if (A) *A = 120142; return TRUE; }
				if (Str__eq(entity, TL_IS_663)) { if (A) *A = 119986; return TRUE; }
				break;
			case 'X':
				if (Str__eq(entity, TL_IS_664)) { if (A) *A = 120091; return TRUE; }
				if (Str__eq(entity, TL_IS_665)) { if (A) *A = 926; return TRUE; }
				if (Str__eq(entity, TL_IS_666)) { if (A) *A = 120143; return TRUE; }
				if (Str__eq(entity, TL_IS_667)) { if (A) *A = 119987; return TRUE; }
				break;
			case 'Y':
				if (Str__eq(entity, TL_IS_668)) { if (A) *A = 1071; return TRUE; }
				if (Str__eq(entity, TL_IS_669)) { if (A) *A = 1031; return TRUE; }
				if (Str__eq(entity, TL_IS_670)) { if (A) *A = 1070; return TRUE; }
				if (Str__eq(entity, TL_IS_671)) { if (A) *A = 221; return TRUE; }
				if (Str__eq(entity, TL_IS_672)) { if (A) *A = 221; return TRUE; }
				if (Str__eq(entity, TL_IS_673)) { if (A) *A = 374; return TRUE; }
				if (Str__eq(entity, TL_IS_674)) { if (A) *A = 1067; return TRUE; }
				if (Str__eq(entity, TL_IS_675)) { if (A) *A = 120092; return TRUE; }
				if (Str__eq(entity, TL_IS_676)) { if (A) *A = 120144; return TRUE; }
				if (Str__eq(entity, TL_IS_677)) { if (A) *A = 119988; return TRUE; }
				if (Str__eq(entity, TL_IS_678)) { if (A) *A = 376; return TRUE; }
				break;
			case 'Z':
				if (Str__eq(entity, TL_IS_679)) { if (A) *A = 1046; return TRUE; }
				if (Str__eq(entity, TL_IS_680)) { if (A) *A = 377; return TRUE; }
				if (Str__eq(entity, TL_IS_681)) { if (A) *A = 381; return TRUE; }
				if (Str__eq(entity, TL_IS_682)) { if (A) *A = 1047; return TRUE; }
				if (Str__eq(entity, TL_IS_683)) { if (A) *A = 379; return TRUE; }
				if (Str__eq(entity, TL_IS_684)) { if (A) *A = 8203; return TRUE; }
				if (Str__eq(entity, TL_IS_685)) { if (A) *A = 918; return TRUE; }
				if (Str__eq(entity, TL_IS_686)) { if (A) *A = 8488; return TRUE; }
				if (Str__eq(entity, TL_IS_687)) { if (A) *A = 8484; return TRUE; }
				if (Str__eq(entity, TL_IS_688)) { if (A) *A = 119989; return TRUE; }
				break;
			case 'a':
				if (Str__eq(entity, TL_IS_689)) { if (A) *A = 225; return TRUE; }
				if (Str__eq(entity, TL_IS_690)) { if (A) *A = 225; return TRUE; }
				if (Str__eq(entity, TL_IS_691)) { if (A) *A = 259; return TRUE; }
				if (Str__eq(entity, TL_IS_692)) { if (A) *A = 8766; return TRUE; }
				if (Str__eq(entity, TL_IS_693)) { if (A) *A = 8766; if (B) *B = 819; return TRUE; }
				if (Str__eq(entity, TL_IS_694)) { if (A) *A = 8767; return TRUE; }
				if (Str__eq(entity, TL_IS_695)) { if (A) *A = 226; return TRUE; }
				if (Str__eq(entity, TL_IS_696)) { if (A) *A = 226; return TRUE; }
				if (Str__eq(entity, TL_IS_697)) { if (A) *A = 180; return TRUE; }
				if (Str__eq(entity, TL_IS_698)) { if (A) *A = 180; return TRUE; }
				if (Str__eq(entity, TL_IS_699)) { if (A) *A = 1072; return TRUE; }
				if (Str__eq(entity, TL_IS_700)) { if (A) *A = 230; return TRUE; }
				if (Str__eq(entity, TL_IS_701)) { if (A) *A = 230; return TRUE; }
				if (Str__eq(entity, TL_IS_702)) { if (A) *A = 8289; return TRUE; }
				if (Str__eq(entity, TL_IS_703)) { if (A) *A = 120094; return TRUE; }
				if (Str__eq(entity, TL_IS_704)) { if (A) *A = 224; return TRUE; }
				if (Str__eq(entity, TL_IS_705)) { if (A) *A = 224; return TRUE; }
				if (Str__eq(entity, TL_IS_706)) { if (A) *A = 8501; return TRUE; }
				if (Str__eq(entity, TL_IS_707)) { if (A) *A = 8501; return TRUE; }
				if (Str__eq(entity, TL_IS_708)) { if (A) *A = 945; return TRUE; }
				if (Str__eq(entity, TL_IS_709)) { if (A) *A = 257; return TRUE; }
				if (Str__eq(entity, TL_IS_710)) { if (A) *A = 10815; return TRUE; }
				if (Str__eq(entity, TL_IS_711)) { if (A) *A = 38; return TRUE; }
				if (Str__eq(entity, TL_IS_712)) { if (A) *A = 38; return TRUE; }
				if (Str__eq(entity, TL_IS_713)) { if (A) *A = 8743; return TRUE; }
				if (Str__eq(entity, TL_IS_714)) { if (A) *A = 10837; return TRUE; }
				if (Str__eq(entity, TL_IS_715)) { if (A) *A = 10844; return TRUE; }
				if (Str__eq(entity, TL_IS_716)) { if (A) *A = 10840; return TRUE; }
				if (Str__eq(entity, TL_IS_717)) { if (A) *A = 10842; return TRUE; }
				if (Str__eq(entity, TL_IS_718)) { if (A) *A = 8736; return TRUE; }
				if (Str__eq(entity, TL_IS_719)) { if (A) *A = 10660; return TRUE; }
				if (Str__eq(entity, TL_IS_720)) { if (A) *A = 8736; return TRUE; }
				if (Str__eq(entity, TL_IS_721)) { if (A) *A = 8737; return TRUE; }
				if (Str__eq(entity, TL_IS_722)) { if (A) *A = 10664; return TRUE; }
				if (Str__eq(entity, TL_IS_723)) { if (A) *A = 10665; return TRUE; }
				if (Str__eq(entity, TL_IS_724)) { if (A) *A = 10666; return TRUE; }
				if (Str__eq(entity, TL_IS_725)) { if (A) *A = 10667; return TRUE; }
				if (Str__eq(entity, TL_IS_726)) { if (A) *A = 10668; return TRUE; }
				if (Str__eq(entity, TL_IS_727)) { if (A) *A = 10669; return TRUE; }
				if (Str__eq(entity, TL_IS_728)) { if (A) *A = 10670; return TRUE; }
				if (Str__eq(entity, TL_IS_729)) { if (A) *A = 10671; return TRUE; }
				if (Str__eq(entity, TL_IS_730)) { if (A) *A = 8735; return TRUE; }
				if (Str__eq(entity, TL_IS_731)) { if (A) *A = 8894; return TRUE; }
				if (Str__eq(entity, TL_IS_732)) { if (A) *A = 10653; return TRUE; }
				if (Str__eq(entity, TL_IS_733)) { if (A) *A = 8738; return TRUE; }
				if (Str__eq(entity, TL_IS_734)) { if (A) *A = 197; return TRUE; }
				if (Str__eq(entity, TL_IS_735)) { if (A) *A = 9084; return TRUE; }
				if (Str__eq(entity, TL_IS_736)) { if (A) *A = 261; return TRUE; }
				if (Str__eq(entity, TL_IS_737)) { if (A) *A = 120146; return TRUE; }
				if (Str__eq(entity, TL_IS_738)) { if (A) *A = 8776; return TRUE; }
				if (Str__eq(entity, TL_IS_739)) { if (A) *A = 10864; return TRUE; }
				if (Str__eq(entity, TL_IS_740)) { if (A) *A = 10863; return TRUE; }
				if (Str__eq(entity, TL_IS_741)) { if (A) *A = 8778; return TRUE; }
				if (Str__eq(entity, TL_IS_742)) { if (A) *A = 8779; return TRUE; }
				if (Str__eq(entity, TL_IS_743)) { if (A) *A = 39; return TRUE; }
				if (Str__eq(entity, TL_IS_744)) { if (A) *A = 8776; return TRUE; }
				if (Str__eq(entity, TL_IS_745)) { if (A) *A = 8778; return TRUE; }
				if (Str__eq(entity, TL_IS_746)) { if (A) *A = 229; return TRUE; }
				if (Str__eq(entity, TL_IS_747)) { if (A) *A = 229; return TRUE; }
				if (Str__eq(entity, TL_IS_748)) { if (A) *A = 119990; return TRUE; }
				if (Str__eq(entity, TL_IS_749)) { if (A) *A = 42; return TRUE; }
				if (Str__eq(entity, TL_IS_750)) { if (A) *A = 8776; return TRUE; }
				if (Str__eq(entity, TL_IS_751)) { if (A) *A = 8781; return TRUE; }
				if (Str__eq(entity, TL_IS_752)) { if (A) *A = 227; return TRUE; }
				if (Str__eq(entity, TL_IS_753)) { if (A) *A = 227; return TRUE; }
				if (Str__eq(entity, TL_IS_754)) { if (A) *A = 228; return TRUE; }
				if (Str__eq(entity, TL_IS_755)) { if (A) *A = 228; return TRUE; }
				if (Str__eq(entity, TL_IS_756)) { if (A) *A = 8755; return TRUE; }
				if (Str__eq(entity, TL_IS_757)) { if (A) *A = 10769; return TRUE; }
				break;
			case 'b':
				if (Str__eq(entity, TL_IS_758)) { if (A) *A = 10989; return TRUE; }
				if (Str__eq(entity, TL_IS_759)) { if (A) *A = 8780; return TRUE; }
				if (Str__eq(entity, TL_IS_760)) { if (A) *A = 1014; return TRUE; }
				if (Str__eq(entity, TL_IS_761)) { if (A) *A = 8245; return TRUE; }
				if (Str__eq(entity, TL_IS_762)) { if (A) *A = 8765; return TRUE; }
				if (Str__eq(entity, TL_IS_763)) { if (A) *A = 8909; return TRUE; }
				if (Str__eq(entity, TL_IS_764)) { if (A) *A = 8893; return TRUE; }
				if (Str__eq(entity, TL_IS_765)) { if (A) *A = 8965; return TRUE; }
				if (Str__eq(entity, TL_IS_766)) { if (A) *A = 8965; return TRUE; }
				if (Str__eq(entity, TL_IS_767)) { if (A) *A = 9141; return TRUE; }
				if (Str__eq(entity, TL_IS_768)) { if (A) *A = 9142; return TRUE; }
				if (Str__eq(entity, TL_IS_769)) { if (A) *A = 8780; return TRUE; }
				if (Str__eq(entity, TL_IS_770)) { if (A) *A = 1073; return TRUE; }
				if (Str__eq(entity, TL_IS_771)) { if (A) *A = 8222; return TRUE; }
				if (Str__eq(entity, TL_IS_772)) { if (A) *A = 8757; return TRUE; }
				if (Str__eq(entity, TL_IS_773)) { if (A) *A = 8757; return TRUE; }
				if (Str__eq(entity, TL_IS_774)) { if (A) *A = 10672; return TRUE; }
				if (Str__eq(entity, TL_IS_775)) { if (A) *A = 1014; return TRUE; }
				if (Str__eq(entity, TL_IS_776)) { if (A) *A = 8492; return TRUE; }
				if (Str__eq(entity, TL_IS_777)) { if (A) *A = 946; return TRUE; }
				if (Str__eq(entity, TL_IS_778)) { if (A) *A = 8502; return TRUE; }
				if (Str__eq(entity, TL_IS_779)) { if (A) *A = 8812; return TRUE; }
				if (Str__eq(entity, TL_IS_780)) { if (A) *A = 120095; return TRUE; }
				if (Str__eq(entity, TL_IS_781)) { if (A) *A = 8898; return TRUE; }
				if (Str__eq(entity, TL_IS_782)) { if (A) *A = 9711; return TRUE; }
				if (Str__eq(entity, TL_IS_783)) { if (A) *A = 8899; return TRUE; }
				if (Str__eq(entity, TL_IS_784)) { if (A) *A = 10752; return TRUE; }
				if (Str__eq(entity, TL_IS_785)) { if (A) *A = 10753; return TRUE; }
				if (Str__eq(entity, TL_IS_786)) { if (A) *A = 10754; return TRUE; }
				if (Str__eq(entity, TL_IS_787)) { if (A) *A = 10758; return TRUE; }
				if (Str__eq(entity, TL_IS_788)) { if (A) *A = 9733; return TRUE; }
				if (Str__eq(entity, TL_IS_789)) { if (A) *A = 9661; return TRUE; }
				if (Str__eq(entity, TL_IS_790)) { if (A) *A = 9651; return TRUE; }
				if (Str__eq(entity, TL_IS_791)) { if (A) *A = 10756; return TRUE; }
				if (Str__eq(entity, TL_IS_792)) { if (A) *A = 8897; return TRUE; }
				if (Str__eq(entity, TL_IS_793)) { if (A) *A = 8896; return TRUE; }
				if (Str__eq(entity, TL_IS_794)) { if (A) *A = 10509; return TRUE; }
				if (Str__eq(entity, TL_IS_795)) { if (A) *A = 10731; return TRUE; }
				if (Str__eq(entity, TL_IS_796)) { if (A) *A = 9642; return TRUE; }
				if (Str__eq(entity, TL_IS_797)) { if (A) *A = 9652; return TRUE; }
				if (Str__eq(entity, TL_IS_798)) { if (A) *A = 9662; return TRUE; }
				if (Str__eq(entity, TL_IS_799)) { if (A) *A = 9666; return TRUE; }
				if (Str__eq(entity, TL_IS_800)) { if (A) *A = 9656; return TRUE; }
				if (Str__eq(entity, TL_IS_801)) { if (A) *A = 9251; return TRUE; }
				if (Str__eq(entity, TL_IS_802)) { if (A) *A = 9618; return TRUE; }
				if (Str__eq(entity, TL_IS_803)) { if (A) *A = 9617; return TRUE; }
				if (Str__eq(entity, TL_IS_804)) { if (A) *A = 9619; return TRUE; }
				if (Str__eq(entity, TL_IS_805)) { if (A) *A = 9608; return TRUE; }
				if (Str__eq(entity, TL_IS_806)) { if (A) *A = 61; if (B) *B = 8421; return TRUE; }
				if (Str__eq(entity, TL_IS_807)) { if (A) *A = 8801; if (B) *B = 8421; return TRUE; }
				if (Str__eq(entity, TL_IS_808)) { if (A) *A = 8976; return TRUE; }
				if (Str__eq(entity, TL_IS_809)) { if (A) *A = 120147; return TRUE; }
				if (Str__eq(entity, TL_IS_810)) { if (A) *A = 8869; return TRUE; }
				if (Str__eq(entity, TL_IS_811)) { if (A) *A = 8869; return TRUE; }
				if (Str__eq(entity, TL_IS_812)) { if (A) *A = 8904; return TRUE; }
				if (Str__eq(entity, TL_IS_813)) { if (A) *A = 9559; return TRUE; }
				if (Str__eq(entity, TL_IS_814)) { if (A) *A = 9556; return TRUE; }
				if (Str__eq(entity, TL_IS_815)) { if (A) *A = 9558; return TRUE; }
				if (Str__eq(entity, TL_IS_816)) { if (A) *A = 9555; return TRUE; }
				if (Str__eq(entity, TL_IS_817)) { if (A) *A = 9552; return TRUE; }
				if (Str__eq(entity, TL_IS_818)) { if (A) *A = 9574; return TRUE; }
				if (Str__eq(entity, TL_IS_819)) { if (A) *A = 9577; return TRUE; }
				if (Str__eq(entity, TL_IS_820)) { if (A) *A = 9572; return TRUE; }
				if (Str__eq(entity, TL_IS_821)) { if (A) *A = 9575; return TRUE; }
				if (Str__eq(entity, TL_IS_822)) { if (A) *A = 9565; return TRUE; }
				if (Str__eq(entity, TL_IS_823)) { if (A) *A = 9562; return TRUE; }
				if (Str__eq(entity, TL_IS_824)) { if (A) *A = 9564; return TRUE; }
				if (Str__eq(entity, TL_IS_825)) { if (A) *A = 9561; return TRUE; }
				if (Str__eq(entity, TL_IS_826)) { if (A) *A = 9553; return TRUE; }
				if (Str__eq(entity, TL_IS_827)) { if (A) *A = 9580; return TRUE; }
				if (Str__eq(entity, TL_IS_828)) { if (A) *A = 9571; return TRUE; }
				if (Str__eq(entity, TL_IS_829)) { if (A) *A = 9568; return TRUE; }
				if (Str__eq(entity, TL_IS_830)) { if (A) *A = 9579; return TRUE; }
				if (Str__eq(entity, TL_IS_831)) { if (A) *A = 9570; return TRUE; }
				if (Str__eq(entity, TL_IS_832)) { if (A) *A = 9567; return TRUE; }
				if (Str__eq(entity, TL_IS_833)) { if (A) *A = 10697; return TRUE; }
				if (Str__eq(entity, TL_IS_834)) { if (A) *A = 9557; return TRUE; }
				if (Str__eq(entity, TL_IS_835)) { if (A) *A = 9554; return TRUE; }
				if (Str__eq(entity, TL_IS_836)) { if (A) *A = 9488; return TRUE; }
				if (Str__eq(entity, TL_IS_837)) { if (A) *A = 9484; return TRUE; }
				if (Str__eq(entity, TL_IS_838)) { if (A) *A = 9472; return TRUE; }
				if (Str__eq(entity, TL_IS_839)) { if (A) *A = 9573; return TRUE; }
				if (Str__eq(entity, TL_IS_840)) { if (A) *A = 9576; return TRUE; }
				if (Str__eq(entity, TL_IS_841)) { if (A) *A = 9516; return TRUE; }
				if (Str__eq(entity, TL_IS_842)) { if (A) *A = 9524; return TRUE; }
				if (Str__eq(entity, TL_IS_843)) { if (A) *A = 8863; return TRUE; }
				if (Str__eq(entity, TL_IS_844)) { if (A) *A = 8862; return TRUE; }
				if (Str__eq(entity, TL_IS_845)) { if (A) *A = 8864; return TRUE; }
				if (Str__eq(entity, TL_IS_846)) { if (A) *A = 9563; return TRUE; }
				if (Str__eq(entity, TL_IS_847)) { if (A) *A = 9560; return TRUE; }
				if (Str__eq(entity, TL_IS_848)) { if (A) *A = 9496; return TRUE; }
				if (Str__eq(entity, TL_IS_849)) { if (A) *A = 9492; return TRUE; }
				if (Str__eq(entity, TL_IS_850)) { if (A) *A = 9474; return TRUE; }
				if (Str__eq(entity, TL_IS_851)) { if (A) *A = 9578; return TRUE; }
				if (Str__eq(entity, TL_IS_852)) { if (A) *A = 9569; return TRUE; }
				if (Str__eq(entity, TL_IS_853)) { if (A) *A = 9566; return TRUE; }
				if (Str__eq(entity, TL_IS_854)) { if (A) *A = 9532; return TRUE; }
				if (Str__eq(entity, TL_IS_855)) { if (A) *A = 9508; return TRUE; }
				if (Str__eq(entity, TL_IS_856)) { if (A) *A = 9500; return TRUE; }
				if (Str__eq(entity, TL_IS_857)) { if (A) *A = 8245; return TRUE; }
				if (Str__eq(entity, TL_IS_858)) { if (A) *A = 728; return TRUE; }
				if (Str__eq(entity, TL_IS_859)) { if (A) *A = 166; return TRUE; }
				if (Str__eq(entity, TL_IS_860)) { if (A) *A = 166; return TRUE; }
				if (Str__eq(entity, TL_IS_861)) { if (A) *A = 119991; return TRUE; }
				if (Str__eq(entity, TL_IS_862)) { if (A) *A = 8271; return TRUE; }
				if (Str__eq(entity, TL_IS_863)) { if (A) *A = 8765; return TRUE; }
				if (Str__eq(entity, TL_IS_864)) { if (A) *A = 8909; return TRUE; }
				if (Str__eq(entity, TL_IS_865)) { if (A) *A = 92; return TRUE; }
				if (Str__eq(entity, TL_IS_866)) { if (A) *A = 10693; return TRUE; }
				if (Str__eq(entity, TL_IS_867)) { if (A) *A = 10184; return TRUE; }
				if (Str__eq(entity, TL_IS_868)) { if (A) *A = 8226; return TRUE; }
				if (Str__eq(entity, TL_IS_869)) { if (A) *A = 8226; return TRUE; }
				if (Str__eq(entity, TL_IS_870)) { if (A) *A = 8782; return TRUE; }
				if (Str__eq(entity, TL_IS_871)) { if (A) *A = 10926; return TRUE; }
				if (Str__eq(entity, TL_IS_872)) { if (A) *A = 8783; return TRUE; }
				if (Str__eq(entity, TL_IS_873)) { if (A) *A = 8783; return TRUE; }
				break;
			case 'c':
				if (Str__eq(entity, TL_IS_874)) { if (A) *A = 263; return TRUE; }
				if (Str__eq(entity, TL_IS_875)) { if (A) *A = 8745; return TRUE; }
				if (Str__eq(entity, TL_IS_876)) { if (A) *A = 10820; return TRUE; }
				if (Str__eq(entity, TL_IS_877)) { if (A) *A = 10825; return TRUE; }
				if (Str__eq(entity, TL_IS_878)) { if (A) *A = 10827; return TRUE; }
				if (Str__eq(entity, TL_IS_879)) { if (A) *A = 10823; return TRUE; }
				if (Str__eq(entity, TL_IS_880)) { if (A) *A = 10816; return TRUE; }
				if (Str__eq(entity, TL_IS_881)) { if (A) *A = 8745; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_882)) { if (A) *A = 8257; return TRUE; }
				if (Str__eq(entity, TL_IS_883)) { if (A) *A = 711; return TRUE; }
				if (Str__eq(entity, TL_IS_884)) { if (A) *A = 10829; return TRUE; }
				if (Str__eq(entity, TL_IS_885)) { if (A) *A = 269; return TRUE; }
				if (Str__eq(entity, TL_IS_886)) { if (A) *A = 231; return TRUE; }
				if (Str__eq(entity, TL_IS_887)) { if (A) *A = 231; return TRUE; }
				if (Str__eq(entity, TL_IS_888)) { if (A) *A = 265; return TRUE; }
				if (Str__eq(entity, TL_IS_889)) { if (A) *A = 10828; return TRUE; }
				if (Str__eq(entity, TL_IS_890)) { if (A) *A = 10832; return TRUE; }
				if (Str__eq(entity, TL_IS_891)) { if (A) *A = 267; return TRUE; }
				if (Str__eq(entity, TL_IS_892)) { if (A) *A = 184; return TRUE; }
				if (Str__eq(entity, TL_IS_893)) { if (A) *A = 184; return TRUE; }
				if (Str__eq(entity, TL_IS_894)) { if (A) *A = 10674; return TRUE; }
				if (Str__eq(entity, TL_IS_895)) { if (A) *A = 162; return TRUE; }
				if (Str__eq(entity, TL_IS_896)) { if (A) *A = 162; return TRUE; }
				if (Str__eq(entity, TL_IS_897)) { if (A) *A = 183; return TRUE; }
				if (Str__eq(entity, TL_IS_898)) { if (A) *A = 120096; return TRUE; }
				if (Str__eq(entity, TL_IS_899)) { if (A) *A = 1095; return TRUE; }
				if (Str__eq(entity, TL_IS_900)) { if (A) *A = 10003; return TRUE; }
				if (Str__eq(entity, TL_IS_901)) { if (A) *A = 10003; return TRUE; }
				if (Str__eq(entity, TL_IS_902)) { if (A) *A = 967; return TRUE; }
				if (Str__eq(entity, TL_IS_903)) { if (A) *A = 9675; return TRUE; }
				if (Str__eq(entity, TL_IS_904)) { if (A) *A = 10691; return TRUE; }
				if (Str__eq(entity, TL_IS_905)) { if (A) *A = 710; return TRUE; }
				if (Str__eq(entity, TL_IS_906)) { if (A) *A = 8791; return TRUE; }
				if (Str__eq(entity, TL_IS_907)) { if (A) *A = 8634; return TRUE; }
				if (Str__eq(entity, TL_IS_908)) { if (A) *A = 8635; return TRUE; }
				if (Str__eq(entity, TL_IS_909)) { if (A) *A = 174; return TRUE; }
				if (Str__eq(entity, TL_IS_910)) { if (A) *A = 9416; return TRUE; }
				if (Str__eq(entity, TL_IS_911)) { if (A) *A = 8859; return TRUE; }
				if (Str__eq(entity, TL_IS_912)) { if (A) *A = 8858; return TRUE; }
				if (Str__eq(entity, TL_IS_913)) { if (A) *A = 8861; return TRUE; }
				if (Str__eq(entity, TL_IS_914)) { if (A) *A = 8791; return TRUE; }
				if (Str__eq(entity, TL_IS_915)) { if (A) *A = 10768; return TRUE; }
				if (Str__eq(entity, TL_IS_916)) { if (A) *A = 10991; return TRUE; }
				if (Str__eq(entity, TL_IS_917)) { if (A) *A = 10690; return TRUE; }
				if (Str__eq(entity, TL_IS_918)) { if (A) *A = 9827; return TRUE; }
				if (Str__eq(entity, TL_IS_919)) { if (A) *A = 9827; return TRUE; }
				if (Str__eq(entity, TL_IS_920)) { if (A) *A = 58; return TRUE; }
				if (Str__eq(entity, TL_IS_921)) { if (A) *A = 8788; return TRUE; }
				if (Str__eq(entity, TL_IS_922)) { if (A) *A = 8788; return TRUE; }
				if (Str__eq(entity, TL_IS_923)) { if (A) *A = 44; return TRUE; }
				if (Str__eq(entity, TL_IS_924)) { if (A) *A = 64; return TRUE; }
				if (Str__eq(entity, TL_IS_925)) { if (A) *A = 8705; return TRUE; }
				if (Str__eq(entity, TL_IS_926)) { if (A) *A = 8728; return TRUE; }
				if (Str__eq(entity, TL_IS_927)) { if (A) *A = 8705; return TRUE; }
				if (Str__eq(entity, TL_IS_928)) { if (A) *A = 8450; return TRUE; }
				if (Str__eq(entity, TL_IS_929)) { if (A) *A = 8773; return TRUE; }
				if (Str__eq(entity, TL_IS_930)) { if (A) *A = 10861; return TRUE; }
				if (Str__eq(entity, TL_IS_931)) { if (A) *A = 8750; return TRUE; }
				if (Str__eq(entity, TL_IS_932)) { if (A) *A = 120148; return TRUE; }
				if (Str__eq(entity, TL_IS_933)) { if (A) *A = 8720; return TRUE; }
				if (Str__eq(entity, TL_IS_934)) { if (A) *A = 169; return TRUE; }
				if (Str__eq(entity, TL_IS_935)) { if (A) *A = 169; return TRUE; }
				if (Str__eq(entity, TL_IS_936)) { if (A) *A = 8471; return TRUE; }
				if (Str__eq(entity, TL_IS_937)) { if (A) *A = 8629; return TRUE; }
				if (Str__eq(entity, TL_IS_938)) { if (A) *A = 10007; return TRUE; }
				if (Str__eq(entity, TL_IS_939)) { if (A) *A = 119992; return TRUE; }
				if (Str__eq(entity, TL_IS_940)) { if (A) *A = 10959; return TRUE; }
				if (Str__eq(entity, TL_IS_941)) { if (A) *A = 10961; return TRUE; }
				if (Str__eq(entity, TL_IS_942)) { if (A) *A = 10960; return TRUE; }
				if (Str__eq(entity, TL_IS_943)) { if (A) *A = 10962; return TRUE; }
				if (Str__eq(entity, TL_IS_944)) { if (A) *A = 8943; return TRUE; }
				if (Str__eq(entity, TL_IS_945)) { if (A) *A = 10552; return TRUE; }
				if (Str__eq(entity, TL_IS_946)) { if (A) *A = 10549; return TRUE; }
				if (Str__eq(entity, TL_IS_947)) { if (A) *A = 8926; return TRUE; }
				if (Str__eq(entity, TL_IS_948)) { if (A) *A = 8927; return TRUE; }
				if (Str__eq(entity, TL_IS_949)) { if (A) *A = 8630; return TRUE; }
				if (Str__eq(entity, TL_IS_950)) { if (A) *A = 10557; return TRUE; }
				if (Str__eq(entity, TL_IS_951)) { if (A) *A = 8746; return TRUE; }
				if (Str__eq(entity, TL_IS_952)) { if (A) *A = 10824; return TRUE; }
				if (Str__eq(entity, TL_IS_953)) { if (A) *A = 10822; return TRUE; }
				if (Str__eq(entity, TL_IS_954)) { if (A) *A = 10826; return TRUE; }
				if (Str__eq(entity, TL_IS_955)) { if (A) *A = 8845; return TRUE; }
				if (Str__eq(entity, TL_IS_956)) { if (A) *A = 10821; return TRUE; }
				if (Str__eq(entity, TL_IS_957)) { if (A) *A = 8746; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_958)) { if (A) *A = 8631; return TRUE; }
				if (Str__eq(entity, TL_IS_959)) { if (A) *A = 10556; return TRUE; }
				if (Str__eq(entity, TL_IS_960)) { if (A) *A = 8926; return TRUE; }
				if (Str__eq(entity, TL_IS_961)) { if (A) *A = 8927; return TRUE; }
				if (Str__eq(entity, TL_IS_962)) { if (A) *A = 8910; return TRUE; }
				if (Str__eq(entity, TL_IS_963)) { if (A) *A = 8911; return TRUE; }
				if (Str__eq(entity, TL_IS_964)) { if (A) *A = 164; return TRUE; }
				if (Str__eq(entity, TL_IS_965)) { if (A) *A = 164; return TRUE; }
				if (Str__eq(entity, TL_IS_966)) { if (A) *A = 8630; return TRUE; }
				if (Str__eq(entity, TL_IS_967)) { if (A) *A = 8631; return TRUE; }
				if (Str__eq(entity, TL_IS_968)) { if (A) *A = 8910; return TRUE; }
				if (Str__eq(entity, TL_IS_969)) { if (A) *A = 8911; return TRUE; }
				if (Str__eq(entity, TL_IS_970)) { if (A) *A = 8754; return TRUE; }
				if (Str__eq(entity, TL_IS_971)) { if (A) *A = 8753; return TRUE; }
				if (Str__eq(entity, TL_IS_972)) { if (A) *A = 9005; return TRUE; }
				break;
			case 'd':
				if (Str__eq(entity, TL_IS_973)) { if (A) *A = 8659; return TRUE; }
				if (Str__eq(entity, TL_IS_974)) { if (A) *A = 10597; return TRUE; }
				if (Str__eq(entity, TL_IS_975)) { if (A) *A = 8224; return TRUE; }
				if (Str__eq(entity, TL_IS_976)) { if (A) *A = 8504; return TRUE; }
				if (Str__eq(entity, TL_IS_977)) { if (A) *A = 8595; return TRUE; }
				if (Str__eq(entity, TL_IS_978)) { if (A) *A = 8208; return TRUE; }
				if (Str__eq(entity, TL_IS_979)) { if (A) *A = 8867; return TRUE; }
				if (Str__eq(entity, TL_IS_980)) { if (A) *A = 10511; return TRUE; }
				if (Str__eq(entity, TL_IS_981)) { if (A) *A = 733; return TRUE; }
				if (Str__eq(entity, TL_IS_982)) { if (A) *A = 271; return TRUE; }
				if (Str__eq(entity, TL_IS_983)) { if (A) *A = 1076; return TRUE; }
				if (Str__eq(entity, TL_IS_984)) { if (A) *A = 8518; return TRUE; }
				if (Str__eq(entity, TL_IS_985)) { if (A) *A = 8225; return TRUE; }
				if (Str__eq(entity, TL_IS_986)) { if (A) *A = 8650; return TRUE; }
				if (Str__eq(entity, TL_IS_987)) { if (A) *A = 10871; return TRUE; }
				if (Str__eq(entity, TL_IS_988)) { if (A) *A = 176; return TRUE; }
				if (Str__eq(entity, TL_IS_989)) { if (A) *A = 176; return TRUE; }
				if (Str__eq(entity, TL_IS_990)) { if (A) *A = 948; return TRUE; }
				if (Str__eq(entity, TL_IS_991)) { if (A) *A = 10673; return TRUE; }
				if (Str__eq(entity, TL_IS_992)) { if (A) *A = 10623; return TRUE; }
				if (Str__eq(entity, TL_IS_993)) { if (A) *A = 120097; return TRUE; }
				if (Str__eq(entity, TL_IS_994)) { if (A) *A = 8643; return TRUE; }
				if (Str__eq(entity, TL_IS_995)) { if (A) *A = 8642; return TRUE; }
				if (Str__eq(entity, TL_IS_996)) { if (A) *A = 8900; return TRUE; }
				if (Str__eq(entity, TL_IS_997)) { if (A) *A = 8900; return TRUE; }
				if (Str__eq(entity, TL_IS_998)) { if (A) *A = 9830; return TRUE; }
				if (Str__eq(entity, TL_IS_999)) { if (A) *A = 9830; return TRUE; }
				if (Str__eq(entity, TL_IS_1000)) { if (A) *A = 168; return TRUE; }
				if (Str__eq(entity, TL_IS_1001)) { if (A) *A = 989; return TRUE; }
				if (Str__eq(entity, TL_IS_1002)) { if (A) *A = 8946; return TRUE; }
				if (Str__eq(entity, TL_IS_1003)) { if (A) *A = 247; return TRUE; }
				if (Str__eq(entity, TL_IS_1004)) { if (A) *A = 247; return TRUE; }
				if (Str__eq(entity, TL_IS_1005)) { if (A) *A = 247; return TRUE; }
				if (Str__eq(entity, TL_IS_1006)) { if (A) *A = 8903; return TRUE; }
				if (Str__eq(entity, TL_IS_1007)) { if (A) *A = 8903; return TRUE; }
				if (Str__eq(entity, TL_IS_1008)) { if (A) *A = 1106; return TRUE; }
				if (Str__eq(entity, TL_IS_1009)) { if (A) *A = 8990; return TRUE; }
				if (Str__eq(entity, TL_IS_1010)) { if (A) *A = 8973; return TRUE; }
				if (Str__eq(entity, TL_IS_1011)) { if (A) *A = 36; return TRUE; }
				if (Str__eq(entity, TL_IS_1012)) { if (A) *A = 120149; return TRUE; }
				if (Str__eq(entity, TL_IS_1013)) { if (A) *A = 729; return TRUE; }
				if (Str__eq(entity, TL_IS_1014)) { if (A) *A = 8784; return TRUE; }
				if (Str__eq(entity, TL_IS_1015)) { if (A) *A = 8785; return TRUE; }
				if (Str__eq(entity, TL_IS_1016)) { if (A) *A = 8760; return TRUE; }
				if (Str__eq(entity, TL_IS_1017)) { if (A) *A = 8724; return TRUE; }
				if (Str__eq(entity, TL_IS_1018)) { if (A) *A = 8865; return TRUE; }
				if (Str__eq(entity, TL_IS_1019)) { if (A) *A = 8966; return TRUE; }
				if (Str__eq(entity, TL_IS_1020)) { if (A) *A = 8595; return TRUE; }
				if (Str__eq(entity, TL_IS_1021)) { if (A) *A = 8650; return TRUE; }
				if (Str__eq(entity, TL_IS_1022)) { if (A) *A = 8643; return TRUE; }
				if (Str__eq(entity, TL_IS_1023)) { if (A) *A = 8642; return TRUE; }
				if (Str__eq(entity, TL_IS_1024)) { if (A) *A = 10512; return TRUE; }
				if (Str__eq(entity, TL_IS_1025)) { if (A) *A = 8991; return TRUE; }
				if (Str__eq(entity, TL_IS_1026)) { if (A) *A = 8972; return TRUE; }
				if (Str__eq(entity, TL_IS_1027)) { if (A) *A = 119993; return TRUE; }
				if (Str__eq(entity, TL_IS_1028)) { if (A) *A = 1109; return TRUE; }
				if (Str__eq(entity, TL_IS_1029)) { if (A) *A = 10742; return TRUE; }
				if (Str__eq(entity, TL_IS_1030)) { if (A) *A = 273; return TRUE; }
				if (Str__eq(entity, TL_IS_1031)) { if (A) *A = 8945; return TRUE; }
				if (Str__eq(entity, TL_IS_1032)) { if (A) *A = 9663; return TRUE; }
				if (Str__eq(entity, TL_IS_1033)) { if (A) *A = 9662; return TRUE; }
				if (Str__eq(entity, TL_IS_1034)) { if (A) *A = 8693; return TRUE; }
				if (Str__eq(entity, TL_IS_1035)) { if (A) *A = 10607; return TRUE; }
				if (Str__eq(entity, TL_IS_1036)) { if (A) *A = 10662; return TRUE; }
				if (Str__eq(entity, TL_IS_1037)) { if (A) *A = 1119; return TRUE; }
				if (Str__eq(entity, TL_IS_1038)) { if (A) *A = 10239; return TRUE; }
				break;
			case 'e':
				if (Str__eq(entity, TL_IS_1039)) { if (A) *A = 10871; return TRUE; }
				if (Str__eq(entity, TL_IS_1040)) { if (A) *A = 8785; return TRUE; }
				if (Str__eq(entity, TL_IS_1041)) { if (A) *A = 233; return TRUE; }
				if (Str__eq(entity, TL_IS_1042)) { if (A) *A = 233; return TRUE; }
				if (Str__eq(entity, TL_IS_1043)) { if (A) *A = 10862; return TRUE; }
				if (Str__eq(entity, TL_IS_1044)) { if (A) *A = 283; return TRUE; }
				if (Str__eq(entity, TL_IS_1045)) { if (A) *A = 8790; return TRUE; }
				if (Str__eq(entity, TL_IS_1046)) { if (A) *A = 234; return TRUE; }
				if (Str__eq(entity, TL_IS_1047)) { if (A) *A = 234; return TRUE; }
				if (Str__eq(entity, TL_IS_1048)) { if (A) *A = 8789; return TRUE; }
				if (Str__eq(entity, TL_IS_1049)) { if (A) *A = 1101; return TRUE; }
				if (Str__eq(entity, TL_IS_1050)) { if (A) *A = 279; return TRUE; }
				if (Str__eq(entity, TL_IS_1051)) { if (A) *A = 8519; return TRUE; }
				if (Str__eq(entity, TL_IS_1052)) { if (A) *A = 8786; return TRUE; }
				if (Str__eq(entity, TL_IS_1053)) { if (A) *A = 120098; return TRUE; }
				if (Str__eq(entity, TL_IS_1054)) { if (A) *A = 10906; return TRUE; }
				if (Str__eq(entity, TL_IS_1055)) { if (A) *A = 232; return TRUE; }
				if (Str__eq(entity, TL_IS_1056)) { if (A) *A = 232; return TRUE; }
				if (Str__eq(entity, TL_IS_1057)) { if (A) *A = 10902; return TRUE; }
				if (Str__eq(entity, TL_IS_1058)) { if (A) *A = 10904; return TRUE; }
				if (Str__eq(entity, TL_IS_1059)) { if (A) *A = 10905; return TRUE; }
				if (Str__eq(entity, TL_IS_1060)) { if (A) *A = 9191; return TRUE; }
				if (Str__eq(entity, TL_IS_1061)) { if (A) *A = 8467; return TRUE; }
				if (Str__eq(entity, TL_IS_1062)) { if (A) *A = 10901; return TRUE; }
				if (Str__eq(entity, TL_IS_1063)) { if (A) *A = 10903; return TRUE; }
				if (Str__eq(entity, TL_IS_1064)) { if (A) *A = 275; return TRUE; }
				if (Str__eq(entity, TL_IS_1065)) { if (A) *A = 8709; return TRUE; }
				if (Str__eq(entity, TL_IS_1066)) { if (A) *A = 8709; return TRUE; }
				if (Str__eq(entity, TL_IS_1067)) { if (A) *A = 8709; return TRUE; }
				if (Str__eq(entity, TL_IS_1068)) { if (A) *A = 8196; return TRUE; }
				if (Str__eq(entity, TL_IS_1069)) { if (A) *A = 8197; return TRUE; }
				if (Str__eq(entity, TL_IS_1070)) { if (A) *A = 8195; return TRUE; }
				if (Str__eq(entity, TL_IS_1071)) { if (A) *A = 331; return TRUE; }
				if (Str__eq(entity, TL_IS_1072)) { if (A) *A = 8194; return TRUE; }
				if (Str__eq(entity, TL_IS_1073)) { if (A) *A = 281; return TRUE; }
				if (Str__eq(entity, TL_IS_1074)) { if (A) *A = 120150; return TRUE; }
				if (Str__eq(entity, TL_IS_1075)) { if (A) *A = 8917; return TRUE; }
				if (Str__eq(entity, TL_IS_1076)) { if (A) *A = 10723; return TRUE; }
				if (Str__eq(entity, TL_IS_1077)) { if (A) *A = 10865; return TRUE; }
				if (Str__eq(entity, TL_IS_1078)) { if (A) *A = 949; return TRUE; }
				if (Str__eq(entity, TL_IS_1079)) { if (A) *A = 949; return TRUE; }
				if (Str__eq(entity, TL_IS_1080)) { if (A) *A = 1013; return TRUE; }
				if (Str__eq(entity, TL_IS_1081)) { if (A) *A = 8790; return TRUE; }
				if (Str__eq(entity, TL_IS_1082)) { if (A) *A = 8789; return TRUE; }
				if (Str__eq(entity, TL_IS_1083)) { if (A) *A = 8770; return TRUE; }
				if (Str__eq(entity, TL_IS_1084)) { if (A) *A = 10902; return TRUE; }
				if (Str__eq(entity, TL_IS_1085)) { if (A) *A = 10901; return TRUE; }
				if (Str__eq(entity, TL_IS_1086)) { if (A) *A = 61; return TRUE; }
				if (Str__eq(entity, TL_IS_1087)) { if (A) *A = 8799; return TRUE; }
				if (Str__eq(entity, TL_IS_1088)) { if (A) *A = 8801; return TRUE; }
				if (Str__eq(entity, TL_IS_1089)) { if (A) *A = 10872; return TRUE; }
				if (Str__eq(entity, TL_IS_1090)) { if (A) *A = 10725; return TRUE; }
				if (Str__eq(entity, TL_IS_1091)) { if (A) *A = 8787; return TRUE; }
				if (Str__eq(entity, TL_IS_1092)) { if (A) *A = 10609; return TRUE; }
				if (Str__eq(entity, TL_IS_1093)) { if (A) *A = 8495; return TRUE; }
				if (Str__eq(entity, TL_IS_1094)) { if (A) *A = 8784; return TRUE; }
				if (Str__eq(entity, TL_IS_1095)) { if (A) *A = 8770; return TRUE; }
				if (Str__eq(entity, TL_IS_1096)) { if (A) *A = 951; return TRUE; }
				if (Str__eq(entity, TL_IS_1097)) { if (A) *A = 240; return TRUE; }
				if (Str__eq(entity, TL_IS_1098)) { if (A) *A = 240; return TRUE; }
				if (Str__eq(entity, TL_IS_1099)) { if (A) *A = 235; return TRUE; }
				if (Str__eq(entity, TL_IS_1100)) { if (A) *A = 235; return TRUE; }
				if (Str__eq(entity, TL_IS_1101)) { if (A) *A = 8364; return TRUE; }
				if (Str__eq(entity, TL_IS_1102)) { if (A) *A = 33; return TRUE; }
				if (Str__eq(entity, TL_IS_1103)) { if (A) *A = 8707; return TRUE; }
				if (Str__eq(entity, TL_IS_1104)) { if (A) *A = 8496; return TRUE; }
				if (Str__eq(entity, TL_IS_1105)) { if (A) *A = 8519; return TRUE; }
				break;
			case 'f':
				if (Str__eq(entity, TL_IS_1106)) { if (A) *A = 8786; return TRUE; }
				if (Str__eq(entity, TL_IS_1107)) { if (A) *A = 1092; return TRUE; }
				if (Str__eq(entity, TL_IS_1108)) { if (A) *A = 9792; return TRUE; }
				if (Str__eq(entity, TL_IS_1109)) { if (A) *A = 64259; return TRUE; }
				if (Str__eq(entity, TL_IS_1110)) { if (A) *A = 64256; return TRUE; }
				if (Str__eq(entity, TL_IS_1111)) { if (A) *A = 64260; return TRUE; }
				if (Str__eq(entity, TL_IS_1112)) { if (A) *A = 120099; return TRUE; }
				if (Str__eq(entity, TL_IS_1113)) { if (A) *A = 64257; return TRUE; }
				if (Str__eq(entity, TL_IS_1114)) { if (A) *A = 102; if (B) *B = 106; return TRUE; }
				if (Str__eq(entity, TL_IS_1115)) { if (A) *A = 9837; return TRUE; }
				if (Str__eq(entity, TL_IS_1116)) { if (A) *A = 64258; return TRUE; }
				if (Str__eq(entity, TL_IS_1117)) { if (A) *A = 9649; return TRUE; }
				if (Str__eq(entity, TL_IS_1118)) { if (A) *A = 402; return TRUE; }
				if (Str__eq(entity, TL_IS_1119)) { if (A) *A = 120151; return TRUE; }
				if (Str__eq(entity, TL_IS_1120)) { if (A) *A = 8704; return TRUE; }
				if (Str__eq(entity, TL_IS_1121)) { if (A) *A = 8916; return TRUE; }
				if (Str__eq(entity, TL_IS_1122)) { if (A) *A = 10969; return TRUE; }
				if (Str__eq(entity, TL_IS_1123)) { if (A) *A = 10765; return TRUE; }
				if (Str__eq(entity, TL_IS_1124)) { if (A) *A = 189; return TRUE; }
				if (Str__eq(entity, TL_IS_1125)) { if (A) *A = 189; return TRUE; }
				if (Str__eq(entity, TL_IS_1126)) { if (A) *A = 8531; return TRUE; }
				if (Str__eq(entity, TL_IS_1127)) { if (A) *A = 188; return TRUE; }
				if (Str__eq(entity, TL_IS_1128)) { if (A) *A = 188; return TRUE; }
				if (Str__eq(entity, TL_IS_1129)) { if (A) *A = 8533; return TRUE; }
				if (Str__eq(entity, TL_IS_1130)) { if (A) *A = 8537; return TRUE; }
				if (Str__eq(entity, TL_IS_1131)) { if (A) *A = 8539; return TRUE; }
				if (Str__eq(entity, TL_IS_1132)) { if (A) *A = 8532; return TRUE; }
				if (Str__eq(entity, TL_IS_1133)) { if (A) *A = 8534; return TRUE; }
				if (Str__eq(entity, TL_IS_1134)) { if (A) *A = 190; return TRUE; }
				if (Str__eq(entity, TL_IS_1135)) { if (A) *A = 190; return TRUE; }
				if (Str__eq(entity, TL_IS_1136)) { if (A) *A = 8535; return TRUE; }
				if (Str__eq(entity, TL_IS_1137)) { if (A) *A = 8540; return TRUE; }
				if (Str__eq(entity, TL_IS_1138)) { if (A) *A = 8536; return TRUE; }
				if (Str__eq(entity, TL_IS_1139)) { if (A) *A = 8538; return TRUE; }
				if (Str__eq(entity, TL_IS_1140)) { if (A) *A = 8541; return TRUE; }
				if (Str__eq(entity, TL_IS_1141)) { if (A) *A = 8542; return TRUE; }
				if (Str__eq(entity, TL_IS_1142)) { if (A) *A = 8260; return TRUE; }
				if (Str__eq(entity, TL_IS_1143)) { if (A) *A = 8994; return TRUE; }
				if (Str__eq(entity, TL_IS_1144)) { if (A) *A = 119995; return TRUE; }
				break;
			case 'g':
				if (Str__eq(entity, TL_IS_1145)) { if (A) *A = 8807; return TRUE; }
				if (Str__eq(entity, TL_IS_1146)) { if (A) *A = 10892; return TRUE; }
				if (Str__eq(entity, TL_IS_1147)) { if (A) *A = 501; return TRUE; }
				if (Str__eq(entity, TL_IS_1148)) { if (A) *A = 947; return TRUE; }
				if (Str__eq(entity, TL_IS_1149)) { if (A) *A = 989; return TRUE; }
				if (Str__eq(entity, TL_IS_1150)) { if (A) *A = 10886; return TRUE; }
				if (Str__eq(entity, TL_IS_1151)) { if (A) *A = 287; return TRUE; }
				if (Str__eq(entity, TL_IS_1152)) { if (A) *A = 285; return TRUE; }
				if (Str__eq(entity, TL_IS_1153)) { if (A) *A = 1075; return TRUE; }
				if (Str__eq(entity, TL_IS_1154)) { if (A) *A = 289; return TRUE; }
				if (Str__eq(entity, TL_IS_1155)) { if (A) *A = 8805; return TRUE; }
				if (Str__eq(entity, TL_IS_1156)) { if (A) *A = 8923; return TRUE; }
				if (Str__eq(entity, TL_IS_1157)) { if (A) *A = 8805; return TRUE; }
				if (Str__eq(entity, TL_IS_1158)) { if (A) *A = 8807; return TRUE; }
				if (Str__eq(entity, TL_IS_1159)) { if (A) *A = 10878; return TRUE; }
				if (Str__eq(entity, TL_IS_1160)) { if (A) *A = 10878; return TRUE; }
				if (Str__eq(entity, TL_IS_1161)) { if (A) *A = 10921; return TRUE; }
				if (Str__eq(entity, TL_IS_1162)) { if (A) *A = 10880; return TRUE; }
				if (Str__eq(entity, TL_IS_1163)) { if (A) *A = 10882; return TRUE; }
				if (Str__eq(entity, TL_IS_1164)) { if (A) *A = 10884; return TRUE; }
				if (Str__eq(entity, TL_IS_1165)) { if (A) *A = 8923; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1166)) { if (A) *A = 10900; return TRUE; }
				if (Str__eq(entity, TL_IS_1167)) { if (A) *A = 120100; return TRUE; }
				if (Str__eq(entity, TL_IS_1168)) { if (A) *A = 8811; return TRUE; }
				if (Str__eq(entity, TL_IS_1169)) { if (A) *A = 8921; return TRUE; }
				if (Str__eq(entity, TL_IS_1170)) { if (A) *A = 8503; return TRUE; }
				if (Str__eq(entity, TL_IS_1171)) { if (A) *A = 1107; return TRUE; }
				if (Str__eq(entity, TL_IS_1172)) { if (A) *A = 8823; return TRUE; }
				if (Str__eq(entity, TL_IS_1173)) { if (A) *A = 10898; return TRUE; }
				if (Str__eq(entity, TL_IS_1174)) { if (A) *A = 10917; return TRUE; }
				if (Str__eq(entity, TL_IS_1175)) { if (A) *A = 10916; return TRUE; }
				if (Str__eq(entity, TL_IS_1176)) { if (A) *A = 8809; return TRUE; }
				if (Str__eq(entity, TL_IS_1177)) { if (A) *A = 10890; return TRUE; }
				if (Str__eq(entity, TL_IS_1178)) { if (A) *A = 10890; return TRUE; }
				if (Str__eq(entity, TL_IS_1179)) { if (A) *A = 10888; return TRUE; }
				if (Str__eq(entity, TL_IS_1180)) { if (A) *A = 10888; return TRUE; }
				if (Str__eq(entity, TL_IS_1181)) { if (A) *A = 8809; return TRUE; }
				if (Str__eq(entity, TL_IS_1182)) { if (A) *A = 8935; return TRUE; }
				if (Str__eq(entity, TL_IS_1183)) { if (A) *A = 120152; return TRUE; }
				if (Str__eq(entity, TL_IS_1184)) { if (A) *A = 96; return TRUE; }
				if (Str__eq(entity, TL_IS_1185)) { if (A) *A = 8458; return TRUE; }
				if (Str__eq(entity, TL_IS_1186)) { if (A) *A = 8819; return TRUE; }
				if (Str__eq(entity, TL_IS_1187)) { if (A) *A = 10894; return TRUE; }
				if (Str__eq(entity, TL_IS_1188)) { if (A) *A = 10896; return TRUE; }
				if (Str__eq(entity, TL_IS_1189)) { if (A) *A = 62; return TRUE; }
				if (Str__eq(entity, TL_IS_1190)) { if (A) *A = 62; return TRUE; }
				if (Str__eq(entity, TL_IS_1191)) { if (A) *A = 10919; return TRUE; }
				if (Str__eq(entity, TL_IS_1192)) { if (A) *A = 10874; return TRUE; }
				if (Str__eq(entity, TL_IS_1193)) { if (A) *A = 8919; return TRUE; }
				if (Str__eq(entity, TL_IS_1194)) { if (A) *A = 10645; return TRUE; }
				if (Str__eq(entity, TL_IS_1195)) { if (A) *A = 10876; return TRUE; }
				if (Str__eq(entity, TL_IS_1196)) { if (A) *A = 10886; return TRUE; }
				if (Str__eq(entity, TL_IS_1197)) { if (A) *A = 10616; return TRUE; }
				if (Str__eq(entity, TL_IS_1198)) { if (A) *A = 8919; return TRUE; }
				if (Str__eq(entity, TL_IS_1199)) { if (A) *A = 8923; return TRUE; }
				if (Str__eq(entity, TL_IS_1200)) { if (A) *A = 10892; return TRUE; }
				if (Str__eq(entity, TL_IS_1201)) { if (A) *A = 8823; return TRUE; }
				if (Str__eq(entity, TL_IS_1202)) { if (A) *A = 8819; return TRUE; }
				if (Str__eq(entity, TL_IS_1203)) { if (A) *A = 8809; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1204)) { if (A) *A = 8809; if (B) *B = 65024; return TRUE; }
				break;
			case 'h':
				if (Str__eq(entity, TL_IS_1205)) { if (A) *A = 8660; return TRUE; }
				if (Str__eq(entity, TL_IS_1206)) { if (A) *A = 8202; return TRUE; }
				if (Str__eq(entity, TL_IS_1207)) { if (A) *A = 189; return TRUE; }
				if (Str__eq(entity, TL_IS_1208)) { if (A) *A = 8459; return TRUE; }
				if (Str__eq(entity, TL_IS_1209)) { if (A) *A = 1098; return TRUE; }
				if (Str__eq(entity, TL_IS_1210)) { if (A) *A = 8596; return TRUE; }
				if (Str__eq(entity, TL_IS_1211)) { if (A) *A = 10568; return TRUE; }
				if (Str__eq(entity, TL_IS_1212)) { if (A) *A = 8621; return TRUE; }
				if (Str__eq(entity, TL_IS_1213)) { if (A) *A = 8463; return TRUE; }
				if (Str__eq(entity, TL_IS_1214)) { if (A) *A = 293; return TRUE; }
				if (Str__eq(entity, TL_IS_1215)) { if (A) *A = 9829; return TRUE; }
				if (Str__eq(entity, TL_IS_1216)) { if (A) *A = 9829; return TRUE; }
				if (Str__eq(entity, TL_IS_1217)) { if (A) *A = 8230; return TRUE; }
				if (Str__eq(entity, TL_IS_1218)) { if (A) *A = 8889; return TRUE; }
				if (Str__eq(entity, TL_IS_1219)) { if (A) *A = 120101; return TRUE; }
				if (Str__eq(entity, TL_IS_1220)) { if (A) *A = 10533; return TRUE; }
				if (Str__eq(entity, TL_IS_1221)) { if (A) *A = 10534; return TRUE; }
				if (Str__eq(entity, TL_IS_1222)) { if (A) *A = 8703; return TRUE; }
				if (Str__eq(entity, TL_IS_1223)) { if (A) *A = 8763; return TRUE; }
				if (Str__eq(entity, TL_IS_1224)) { if (A) *A = 8617; return TRUE; }
				if (Str__eq(entity, TL_IS_1225)) { if (A) *A = 8618; return TRUE; }
				if (Str__eq(entity, TL_IS_1226)) { if (A) *A = 120153; return TRUE; }
				if (Str__eq(entity, TL_IS_1227)) { if (A) *A = 8213; return TRUE; }
				if (Str__eq(entity, TL_IS_1228)) { if (A) *A = 119997; return TRUE; }
				if (Str__eq(entity, TL_IS_1229)) { if (A) *A = 8463; return TRUE; }
				if (Str__eq(entity, TL_IS_1230)) { if (A) *A = 295; return TRUE; }
				if (Str__eq(entity, TL_IS_1231)) { if (A) *A = 8259; return TRUE; }
				if (Str__eq(entity, TL_IS_1232)) { if (A) *A = 8208; return TRUE; }
				break;
			case 'i':
				if (Str__eq(entity, TL_IS_1233)) { if (A) *A = 237; return TRUE; }
				if (Str__eq(entity, TL_IS_1234)) { if (A) *A = 237; return TRUE; }
				if (Str__eq(entity, TL_IS_1235)) { if (A) *A = 8291; return TRUE; }
				if (Str__eq(entity, TL_IS_1236)) { if (A) *A = 238; return TRUE; }
				if (Str__eq(entity, TL_IS_1237)) { if (A) *A = 238; return TRUE; }
				if (Str__eq(entity, TL_IS_1238)) { if (A) *A = 1080; return TRUE; }
				if (Str__eq(entity, TL_IS_1239)) { if (A) *A = 1077; return TRUE; }
				if (Str__eq(entity, TL_IS_1240)) { if (A) *A = 161; return TRUE; }
				if (Str__eq(entity, TL_IS_1241)) { if (A) *A = 161; return TRUE; }
				if (Str__eq(entity, TL_IS_1242)) { if (A) *A = 8660; return TRUE; }
				if (Str__eq(entity, TL_IS_1243)) { if (A) *A = 120102; return TRUE; }
				if (Str__eq(entity, TL_IS_1244)) { if (A) *A = 236; return TRUE; }
				if (Str__eq(entity, TL_IS_1245)) { if (A) *A = 236; return TRUE; }
				if (Str__eq(entity, TL_IS_1246)) { if (A) *A = 8520; return TRUE; }
				if (Str__eq(entity, TL_IS_1247)) { if (A) *A = 10764; return TRUE; }
				if (Str__eq(entity, TL_IS_1248)) { if (A) *A = 8749; return TRUE; }
				if (Str__eq(entity, TL_IS_1249)) { if (A) *A = 10716; return TRUE; }
				if (Str__eq(entity, TL_IS_1250)) { if (A) *A = 8489; return TRUE; }
				if (Str__eq(entity, TL_IS_1251)) { if (A) *A = 307; return TRUE; }
				if (Str__eq(entity, TL_IS_1252)) { if (A) *A = 299; return TRUE; }
				if (Str__eq(entity, TL_IS_1253)) { if (A) *A = 8465; return TRUE; }
				if (Str__eq(entity, TL_IS_1254)) { if (A) *A = 8464; return TRUE; }
				if (Str__eq(entity, TL_IS_1255)) { if (A) *A = 8465; return TRUE; }
				if (Str__eq(entity, TL_IS_1256)) { if (A) *A = 305; return TRUE; }
				if (Str__eq(entity, TL_IS_1257)) { if (A) *A = 8887; return TRUE; }
				if (Str__eq(entity, TL_IS_1258)) { if (A) *A = 437; return TRUE; }
				if (Str__eq(entity, TL_IS_1259)) { if (A) *A = 8712; return TRUE; }
				if (Str__eq(entity, TL_IS_1260)) { if (A) *A = 8453; return TRUE; }
				if (Str__eq(entity, TL_IS_1261)) { if (A) *A = 8734; return TRUE; }
				if (Str__eq(entity, TL_IS_1262)) { if (A) *A = 10717; return TRUE; }
				if (Str__eq(entity, TL_IS_1263)) { if (A) *A = 305; return TRUE; }
				if (Str__eq(entity, TL_IS_1264)) { if (A) *A = 8747; return TRUE; }
				if (Str__eq(entity, TL_IS_1265)) { if (A) *A = 8890; return TRUE; }
				if (Str__eq(entity, TL_IS_1266)) { if (A) *A = 8484; return TRUE; }
				if (Str__eq(entity, TL_IS_1267)) { if (A) *A = 8890; return TRUE; }
				if (Str__eq(entity, TL_IS_1268)) { if (A) *A = 10775; return TRUE; }
				if (Str__eq(entity, TL_IS_1269)) { if (A) *A = 10812; return TRUE; }
				if (Str__eq(entity, TL_IS_1270)) { if (A) *A = 1105; return TRUE; }
				if (Str__eq(entity, TL_IS_1271)) { if (A) *A = 303; return TRUE; }
				if (Str__eq(entity, TL_IS_1272)) { if (A) *A = 120154; return TRUE; }
				if (Str__eq(entity, TL_IS_1273)) { if (A) *A = 953; return TRUE; }
				if (Str__eq(entity, TL_IS_1274)) { if (A) *A = 10812; return TRUE; }
				if (Str__eq(entity, TL_IS_1275)) { if (A) *A = 191; return TRUE; }
				if (Str__eq(entity, TL_IS_1276)) { if (A) *A = 191; return TRUE; }
				if (Str__eq(entity, TL_IS_1277)) { if (A) *A = 119998; return TRUE; }
				if (Str__eq(entity, TL_IS_1278)) { if (A) *A = 8712; return TRUE; }
				if (Str__eq(entity, TL_IS_1279)) { if (A) *A = 8953; return TRUE; }
				if (Str__eq(entity, TL_IS_1280)) { if (A) *A = 8949; return TRUE; }
				if (Str__eq(entity, TL_IS_1281)) { if (A) *A = 8948; return TRUE; }
				if (Str__eq(entity, TL_IS_1282)) { if (A) *A = 8947; return TRUE; }
				if (Str__eq(entity, TL_IS_1283)) { if (A) *A = 8712; return TRUE; }
				if (Str__eq(entity, TL_IS_1284)) { if (A) *A = 8290; return TRUE; }
				if (Str__eq(entity, TL_IS_1285)) { if (A) *A = 297; return TRUE; }
				if (Str__eq(entity, TL_IS_1286)) { if (A) *A = 1110; return TRUE; }
				if (Str__eq(entity, TL_IS_1287)) { if (A) *A = 239; return TRUE; }
				if (Str__eq(entity, TL_IS_1288)) { if (A) *A = 239; return TRUE; }
				break;
			case 'j':
				if (Str__eq(entity, TL_IS_1289)) { if (A) *A = 309; return TRUE; }
				if (Str__eq(entity, TL_IS_1290)) { if (A) *A = 1081; return TRUE; }
				if (Str__eq(entity, TL_IS_1291)) { if (A) *A = 120103; return TRUE; }
				if (Str__eq(entity, TL_IS_1292)) { if (A) *A = 567; return TRUE; }
				if (Str__eq(entity, TL_IS_1293)) { if (A) *A = 120155; return TRUE; }
				if (Str__eq(entity, TL_IS_1294)) { if (A) *A = 119999; return TRUE; }
				if (Str__eq(entity, TL_IS_1295)) { if (A) *A = 1112; return TRUE; }
				if (Str__eq(entity, TL_IS_1296)) { if (A) *A = 1108; return TRUE; }
				break;
			case 'k':
				if (Str__eq(entity, TL_IS_1297)) { if (A) *A = 954; return TRUE; }
				if (Str__eq(entity, TL_IS_1298)) { if (A) *A = 1008; return TRUE; }
				if (Str__eq(entity, TL_IS_1299)) { if (A) *A = 311; return TRUE; }
				if (Str__eq(entity, TL_IS_1300)) { if (A) *A = 1082; return TRUE; }
				if (Str__eq(entity, TL_IS_1301)) { if (A) *A = 120104; return TRUE; }
				if (Str__eq(entity, TL_IS_1302)) { if (A) *A = 312; return TRUE; }
				if (Str__eq(entity, TL_IS_1303)) { if (A) *A = 1093; return TRUE; }
				if (Str__eq(entity, TL_IS_1304)) { if (A) *A = 1116; return TRUE; }
				if (Str__eq(entity, TL_IS_1305)) { if (A) *A = 120156; return TRUE; }
				if (Str__eq(entity, TL_IS_1306)) { if (A) *A = 120000; return TRUE; }
				break;
			case 'l':
				if (Str__eq(entity, TL_IS_1307)) { if (A) *A = 8666; return TRUE; }
				if (Str__eq(entity, TL_IS_1308)) { if (A) *A = 8656; return TRUE; }
				if (Str__eq(entity, TL_IS_1309)) { if (A) *A = 10523; return TRUE; }
				if (Str__eq(entity, TL_IS_1310)) { if (A) *A = 10510; return TRUE; }
				if (Str__eq(entity, TL_IS_1311)) { if (A) *A = 8806; return TRUE; }
				if (Str__eq(entity, TL_IS_1312)) { if (A) *A = 10891; return TRUE; }
				if (Str__eq(entity, TL_IS_1313)) { if (A) *A = 10594; return TRUE; }
				if (Str__eq(entity, TL_IS_1314)) { if (A) *A = 314; return TRUE; }
				if (Str__eq(entity, TL_IS_1315)) { if (A) *A = 10676; return TRUE; }
				if (Str__eq(entity, TL_IS_1316)) { if (A) *A = 8466; return TRUE; }
				if (Str__eq(entity, TL_IS_1317)) { if (A) *A = 955; return TRUE; }
				if (Str__eq(entity, TL_IS_1318)) { if (A) *A = 10216; return TRUE; }
				if (Str__eq(entity, TL_IS_1319)) { if (A) *A = 10641; return TRUE; }
				if (Str__eq(entity, TL_IS_1320)) { if (A) *A = 10216; return TRUE; }
				if (Str__eq(entity, TL_IS_1321)) { if (A) *A = 10885; return TRUE; }
				if (Str__eq(entity, TL_IS_1322)) { if (A) *A = 171; return TRUE; }
				if (Str__eq(entity, TL_IS_1323)) { if (A) *A = 171; return TRUE; }
				if (Str__eq(entity, TL_IS_1324)) { if (A) *A = 8592; return TRUE; }
				if (Str__eq(entity, TL_IS_1325)) { if (A) *A = 8676; return TRUE; }
				if (Str__eq(entity, TL_IS_1326)) { if (A) *A = 10527; return TRUE; }
				if (Str__eq(entity, TL_IS_1327)) { if (A) *A = 10525; return TRUE; }
				if (Str__eq(entity, TL_IS_1328)) { if (A) *A = 8617; return TRUE; }
				if (Str__eq(entity, TL_IS_1329)) { if (A) *A = 8619; return TRUE; }
				if (Str__eq(entity, TL_IS_1330)) { if (A) *A = 10553; return TRUE; }
				if (Str__eq(entity, TL_IS_1331)) { if (A) *A = 10611; return TRUE; }
				if (Str__eq(entity, TL_IS_1332)) { if (A) *A = 8610; return TRUE; }
				if (Str__eq(entity, TL_IS_1333)) { if (A) *A = 10923; return TRUE; }
				if (Str__eq(entity, TL_IS_1334)) { if (A) *A = 10521; return TRUE; }
				if (Str__eq(entity, TL_IS_1335)) { if (A) *A = 10925; return TRUE; }
				if (Str__eq(entity, TL_IS_1336)) { if (A) *A = 10925; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1337)) { if (A) *A = 10508; return TRUE; }
				if (Str__eq(entity, TL_IS_1338)) { if (A) *A = 10098; return TRUE; }
				if (Str__eq(entity, TL_IS_1339)) { if (A) *A = 123; return TRUE; }
				if (Str__eq(entity, TL_IS_1340)) { if (A) *A = 91; return TRUE; }
				if (Str__eq(entity, TL_IS_1341)) { if (A) *A = 10635; return TRUE; }
				if (Str__eq(entity, TL_IS_1342)) { if (A) *A = 10639; return TRUE; }
				if (Str__eq(entity, TL_IS_1343)) { if (A) *A = 10637; return TRUE; }
				if (Str__eq(entity, TL_IS_1344)) { if (A) *A = 318; return TRUE; }
				if (Str__eq(entity, TL_IS_1345)) { if (A) *A = 316; return TRUE; }
				if (Str__eq(entity, TL_IS_1346)) { if (A) *A = 8968; return TRUE; }
				if (Str__eq(entity, TL_IS_1347)) { if (A) *A = 123; return TRUE; }
				if (Str__eq(entity, TL_IS_1348)) { if (A) *A = 1083; return TRUE; }
				if (Str__eq(entity, TL_IS_1349)) { if (A) *A = 10550; return TRUE; }
				if (Str__eq(entity, TL_IS_1350)) { if (A) *A = 8220; return TRUE; }
				if (Str__eq(entity, TL_IS_1351)) { if (A) *A = 8222; return TRUE; }
				if (Str__eq(entity, TL_IS_1352)) { if (A) *A = 10599; return TRUE; }
				if (Str__eq(entity, TL_IS_1353)) { if (A) *A = 10571; return TRUE; }
				if (Str__eq(entity, TL_IS_1354)) { if (A) *A = 8626; return TRUE; }
				if (Str__eq(entity, TL_IS_1355)) { if (A) *A = 8804; return TRUE; }
				if (Str__eq(entity, TL_IS_1356)) { if (A) *A = 8592; return TRUE; }
				if (Str__eq(entity, TL_IS_1357)) { if (A) *A = 8610; return TRUE; }
				if (Str__eq(entity, TL_IS_1358)) { if (A) *A = 8637; return TRUE; }
				if (Str__eq(entity, TL_IS_1359)) { if (A) *A = 8636; return TRUE; }
				if (Str__eq(entity, TL_IS_1360)) { if (A) *A = 8647; return TRUE; }
				if (Str__eq(entity, TL_IS_1361)) { if (A) *A = 8596; return TRUE; }
				if (Str__eq(entity, TL_IS_1362)) { if (A) *A = 8646; return TRUE; }
				if (Str__eq(entity, TL_IS_1363)) { if (A) *A = 8651; return TRUE; }
				if (Str__eq(entity, TL_IS_1364)) { if (A) *A = 8621; return TRUE; }
				if (Str__eq(entity, TL_IS_1365)) { if (A) *A = 8907; return TRUE; }
				if (Str__eq(entity, TL_IS_1366)) { if (A) *A = 8922; return TRUE; }
				if (Str__eq(entity, TL_IS_1367)) { if (A) *A = 8804; return TRUE; }
				if (Str__eq(entity, TL_IS_1368)) { if (A) *A = 8806; return TRUE; }
				if (Str__eq(entity, TL_IS_1369)) { if (A) *A = 10877; return TRUE; }
				if (Str__eq(entity, TL_IS_1370)) { if (A) *A = 10877; return TRUE; }
				if (Str__eq(entity, TL_IS_1371)) { if (A) *A = 10920; return TRUE; }
				if (Str__eq(entity, TL_IS_1372)) { if (A) *A = 10879; return TRUE; }
				if (Str__eq(entity, TL_IS_1373)) { if (A) *A = 10881; return TRUE; }
				if (Str__eq(entity, TL_IS_1374)) { if (A) *A = 10883; return TRUE; }
				if (Str__eq(entity, TL_IS_1375)) { if (A) *A = 8922; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1376)) { if (A) *A = 10899; return TRUE; }
				if (Str__eq(entity, TL_IS_1377)) { if (A) *A = 10885; return TRUE; }
				if (Str__eq(entity, TL_IS_1378)) { if (A) *A = 8918; return TRUE; }
				if (Str__eq(entity, TL_IS_1379)) { if (A) *A = 8922; return TRUE; }
				if (Str__eq(entity, TL_IS_1380)) { if (A) *A = 10891; return TRUE; }
				if (Str__eq(entity, TL_IS_1381)) { if (A) *A = 8822; return TRUE; }
				if (Str__eq(entity, TL_IS_1382)) { if (A) *A = 8818; return TRUE; }
				if (Str__eq(entity, TL_IS_1383)) { if (A) *A = 10620; return TRUE; }
				if (Str__eq(entity, TL_IS_1384)) { if (A) *A = 8970; return TRUE; }
				if (Str__eq(entity, TL_IS_1385)) { if (A) *A = 120105; return TRUE; }
				if (Str__eq(entity, TL_IS_1386)) { if (A) *A = 8822; return TRUE; }
				if (Str__eq(entity, TL_IS_1387)) { if (A) *A = 10897; return TRUE; }
				if (Str__eq(entity, TL_IS_1388)) { if (A) *A = 8637; return TRUE; }
				if (Str__eq(entity, TL_IS_1389)) { if (A) *A = 8636; return TRUE; }
				if (Str__eq(entity, TL_IS_1390)) { if (A) *A = 10602; return TRUE; }
				if (Str__eq(entity, TL_IS_1391)) { if (A) *A = 9604; return TRUE; }
				if (Str__eq(entity, TL_IS_1392)) { if (A) *A = 1113; return TRUE; }
				if (Str__eq(entity, TL_IS_1393)) { if (A) *A = 8810; return TRUE; }
				if (Str__eq(entity, TL_IS_1394)) { if (A) *A = 8647; return TRUE; }
				if (Str__eq(entity, TL_IS_1395)) { if (A) *A = 8990; return TRUE; }
				if (Str__eq(entity, TL_IS_1396)) { if (A) *A = 10603; return TRUE; }
				if (Str__eq(entity, TL_IS_1397)) { if (A) *A = 9722; return TRUE; }
				if (Str__eq(entity, TL_IS_1398)) { if (A) *A = 320; return TRUE; }
				if (Str__eq(entity, TL_IS_1399)) { if (A) *A = 9136; return TRUE; }
				if (Str__eq(entity, TL_IS_1400)) { if (A) *A = 9136; return TRUE; }
				if (Str__eq(entity, TL_IS_1401)) { if (A) *A = 8808; return TRUE; }
				if (Str__eq(entity, TL_IS_1402)) { if (A) *A = 10889; return TRUE; }
				if (Str__eq(entity, TL_IS_1403)) { if (A) *A = 10889; return TRUE; }
				if (Str__eq(entity, TL_IS_1404)) { if (A) *A = 10887; return TRUE; }
				if (Str__eq(entity, TL_IS_1405)) { if (A) *A = 10887; return TRUE; }
				if (Str__eq(entity, TL_IS_1406)) { if (A) *A = 8808; return TRUE; }
				if (Str__eq(entity, TL_IS_1407)) { if (A) *A = 8934; return TRUE; }
				if (Str__eq(entity, TL_IS_1408)) { if (A) *A = 10220; return TRUE; }
				if (Str__eq(entity, TL_IS_1409)) { if (A) *A = 8701; return TRUE; }
				if (Str__eq(entity, TL_IS_1410)) { if (A) *A = 10214; return TRUE; }
				if (Str__eq(entity, TL_IS_1411)) { if (A) *A = 10229; return TRUE; }
				if (Str__eq(entity, TL_IS_1412)) { if (A) *A = 10231; return TRUE; }
				if (Str__eq(entity, TL_IS_1413)) { if (A) *A = 10236; return TRUE; }
				if (Str__eq(entity, TL_IS_1414)) { if (A) *A = 10230; return TRUE; }
				if (Str__eq(entity, TL_IS_1415)) { if (A) *A = 8619; return TRUE; }
				if (Str__eq(entity, TL_IS_1416)) { if (A) *A = 8620; return TRUE; }
				if (Str__eq(entity, TL_IS_1417)) { if (A) *A = 10629; return TRUE; }
				if (Str__eq(entity, TL_IS_1418)) { if (A) *A = 120157; return TRUE; }
				if (Str__eq(entity, TL_IS_1419)) { if (A) *A = 10797; return TRUE; }
				if (Str__eq(entity, TL_IS_1420)) { if (A) *A = 10804; return TRUE; }
				if (Str__eq(entity, TL_IS_1421)) { if (A) *A = 8727; return TRUE; }
				if (Str__eq(entity, TL_IS_1422)) { if (A) *A = 95; return TRUE; }
				if (Str__eq(entity, TL_IS_1423)) { if (A) *A = 9674; return TRUE; }
				if (Str__eq(entity, TL_IS_1424)) { if (A) *A = 9674; return TRUE; }
				if (Str__eq(entity, TL_IS_1425)) { if (A) *A = 10731; return TRUE; }
				if (Str__eq(entity, TL_IS_1426)) { if (A) *A = 40; return TRUE; }
				if (Str__eq(entity, TL_IS_1427)) { if (A) *A = 10643; return TRUE; }
				if (Str__eq(entity, TL_IS_1428)) { if (A) *A = 8646; return TRUE; }
				if (Str__eq(entity, TL_IS_1429)) { if (A) *A = 8991; return TRUE; }
				if (Str__eq(entity, TL_IS_1430)) { if (A) *A = 8651; return TRUE; }
				if (Str__eq(entity, TL_IS_1431)) { if (A) *A = 10605; return TRUE; }
				if (Str__eq(entity, TL_IS_1432)) { if (A) *A = 8206; return TRUE; }
				if (Str__eq(entity, TL_IS_1433)) { if (A) *A = 8895; return TRUE; }
				if (Str__eq(entity, TL_IS_1434)) { if (A) *A = 8249; return TRUE; }
				if (Str__eq(entity, TL_IS_1435)) { if (A) *A = 120001; return TRUE; }
				if (Str__eq(entity, TL_IS_1436)) { if (A) *A = 8624; return TRUE; }
				if (Str__eq(entity, TL_IS_1437)) { if (A) *A = 8818; return TRUE; }
				if (Str__eq(entity, TL_IS_1438)) { if (A) *A = 10893; return TRUE; }
				if (Str__eq(entity, TL_IS_1439)) { if (A) *A = 10895; return TRUE; }
				if (Str__eq(entity, TL_IS_1440)) { if (A) *A = 91; return TRUE; }
				if (Str__eq(entity, TL_IS_1441)) { if (A) *A = 8216; return TRUE; }
				if (Str__eq(entity, TL_IS_1442)) { if (A) *A = 8218; return TRUE; }
				if (Str__eq(entity, TL_IS_1443)) { if (A) *A = 322; return TRUE; }
				if (Str__eq(entity, TL_IS_1444)) { if (A) *A = 60; return TRUE; }
				if (Str__eq(entity, TL_IS_1445)) { if (A) *A = 60; return TRUE; }
				if (Str__eq(entity, TL_IS_1446)) { if (A) *A = 10918; return TRUE; }
				if (Str__eq(entity, TL_IS_1447)) { if (A) *A = 10873; return TRUE; }
				if (Str__eq(entity, TL_IS_1448)) { if (A) *A = 8918; return TRUE; }
				if (Str__eq(entity, TL_IS_1449)) { if (A) *A = 8907; return TRUE; }
				if (Str__eq(entity, TL_IS_1450)) { if (A) *A = 8905; return TRUE; }
				if (Str__eq(entity, TL_IS_1451)) { if (A) *A = 10614; return TRUE; }
				if (Str__eq(entity, TL_IS_1452)) { if (A) *A = 10875; return TRUE; }
				if (Str__eq(entity, TL_IS_1453)) { if (A) *A = 10646; return TRUE; }
				if (Str__eq(entity, TL_IS_1454)) { if (A) *A = 9667; return TRUE; }
				if (Str__eq(entity, TL_IS_1455)) { if (A) *A = 8884; return TRUE; }
				if (Str__eq(entity, TL_IS_1456)) { if (A) *A = 9666; return TRUE; }
				if (Str__eq(entity, TL_IS_1457)) { if (A) *A = 10570; return TRUE; }
				if (Str__eq(entity, TL_IS_1458)) { if (A) *A = 10598; return TRUE; }
				if (Str__eq(entity, TL_IS_1459)) { if (A) *A = 8808; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1460)) { if (A) *A = 8808; if (B) *B = 65024; return TRUE; }
				break;
			case 'm':
				if (Str__eq(entity, TL_IS_1461)) { if (A) *A = 8762; return TRUE; }
				if (Str__eq(entity, TL_IS_1462)) { if (A) *A = 175; return TRUE; }
				if (Str__eq(entity, TL_IS_1463)) { if (A) *A = 175; return TRUE; }
				if (Str__eq(entity, TL_IS_1464)) { if (A) *A = 9794; return TRUE; }
				if (Str__eq(entity, TL_IS_1465)) { if (A) *A = 10016; return TRUE; }
				if (Str__eq(entity, TL_IS_1466)) { if (A) *A = 10016; return TRUE; }
				if (Str__eq(entity, TL_IS_1467)) { if (A) *A = 8614; return TRUE; }
				if (Str__eq(entity, TL_IS_1468)) { if (A) *A = 8614; return TRUE; }
				if (Str__eq(entity, TL_IS_1469)) { if (A) *A = 8615; return TRUE; }
				if (Str__eq(entity, TL_IS_1470)) { if (A) *A = 8612; return TRUE; }
				if (Str__eq(entity, TL_IS_1471)) { if (A) *A = 8613; return TRUE; }
				if (Str__eq(entity, TL_IS_1472)) { if (A) *A = 9646; return TRUE; }
				if (Str__eq(entity, TL_IS_1473)) { if (A) *A = 10793; return TRUE; }
				if (Str__eq(entity, TL_IS_1474)) { if (A) *A = 1084; return TRUE; }
				if (Str__eq(entity, TL_IS_1475)) { if (A) *A = 8212; return TRUE; }
				if (Str__eq(entity, TL_IS_1476)) { if (A) *A = 8737; return TRUE; }
				if (Str__eq(entity, TL_IS_1477)) { if (A) *A = 120106; return TRUE; }
				if (Str__eq(entity, TL_IS_1478)) { if (A) *A = 8487; return TRUE; }
				if (Str__eq(entity, TL_IS_1479)) { if (A) *A = 181; return TRUE; }
				if (Str__eq(entity, TL_IS_1480)) { if (A) *A = 181; return TRUE; }
				if (Str__eq(entity, TL_IS_1481)) { if (A) *A = 8739; return TRUE; }
				if (Str__eq(entity, TL_IS_1482)) { if (A) *A = 42; return TRUE; }
				if (Str__eq(entity, TL_IS_1483)) { if (A) *A = 10992; return TRUE; }
				if (Str__eq(entity, TL_IS_1484)) { if (A) *A = 183; return TRUE; }
				if (Str__eq(entity, TL_IS_1485)) { if (A) *A = 183; return TRUE; }
				if (Str__eq(entity, TL_IS_1486)) { if (A) *A = 8722; return TRUE; }
				if (Str__eq(entity, TL_IS_1487)) { if (A) *A = 8863; return TRUE; }
				if (Str__eq(entity, TL_IS_1488)) { if (A) *A = 8760; return TRUE; }
				if (Str__eq(entity, TL_IS_1489)) { if (A) *A = 10794; return TRUE; }
				if (Str__eq(entity, TL_IS_1490)) { if (A) *A = 10971; return TRUE; }
				if (Str__eq(entity, TL_IS_1491)) { if (A) *A = 8230; return TRUE; }
				if (Str__eq(entity, TL_IS_1492)) { if (A) *A = 8723; return TRUE; }
				if (Str__eq(entity, TL_IS_1493)) { if (A) *A = 8871; return TRUE; }
				if (Str__eq(entity, TL_IS_1494)) { if (A) *A = 120158; return TRUE; }
				if (Str__eq(entity, TL_IS_1495)) { if (A) *A = 8723; return TRUE; }
				if (Str__eq(entity, TL_IS_1496)) { if (A) *A = 120002; return TRUE; }
				if (Str__eq(entity, TL_IS_1497)) { if (A) *A = 8766; return TRUE; }
				if (Str__eq(entity, TL_IS_1498)) { if (A) *A = 956; return TRUE; }
				if (Str__eq(entity, TL_IS_1499)) { if (A) *A = 8888; return TRUE; }
				if (Str__eq(entity, TL_IS_1500)) { if (A) *A = 8888; return TRUE; }
				break;
			case 'n':
				if (Str__eq(entity, TL_IS_1501)) { if (A) *A = 8921; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1502)) { if (A) *A = 8811; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1503)) { if (A) *A = 8811; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1504)) { if (A) *A = 8653; return TRUE; }
				if (Str__eq(entity, TL_IS_1505)) { if (A) *A = 8654; return TRUE; }
				if (Str__eq(entity, TL_IS_1506)) { if (A) *A = 8920; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1507)) { if (A) *A = 8810; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1508)) { if (A) *A = 8810; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1509)) { if (A) *A = 8655; return TRUE; }
				if (Str__eq(entity, TL_IS_1510)) { if (A) *A = 8879; return TRUE; }
				if (Str__eq(entity, TL_IS_1511)) { if (A) *A = 8878; return TRUE; }
				if (Str__eq(entity, TL_IS_1512)) { if (A) *A = 8711; return TRUE; }
				if (Str__eq(entity, TL_IS_1513)) { if (A) *A = 324; return TRUE; }
				if (Str__eq(entity, TL_IS_1514)) { if (A) *A = 8736; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1515)) { if (A) *A = 8777; return TRUE; }
				if (Str__eq(entity, TL_IS_1516)) { if (A) *A = 10864; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1517)) { if (A) *A = 8779; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1518)) { if (A) *A = 329; return TRUE; }
				if (Str__eq(entity, TL_IS_1519)) { if (A) *A = 8777; return TRUE; }
				if (Str__eq(entity, TL_IS_1520)) { if (A) *A = 9838; return TRUE; }
				if (Str__eq(entity, TL_IS_1521)) { if (A) *A = 9838; return TRUE; }
				if (Str__eq(entity, TL_IS_1522)) { if (A) *A = 8469; return TRUE; }
				if (Str__eq(entity, TL_IS_1523)) { if (A) *A = 160; return TRUE; }
				if (Str__eq(entity, TL_IS_1524)) { if (A) *A = 160; return TRUE; }
				if (Str__eq(entity, TL_IS_1525)) { if (A) *A = 8782; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1526)) { if (A) *A = 8783; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1527)) { if (A) *A = 10819; return TRUE; }
				if (Str__eq(entity, TL_IS_1528)) { if (A) *A = 328; return TRUE; }
				if (Str__eq(entity, TL_IS_1529)) { if (A) *A = 326; return TRUE; }
				if (Str__eq(entity, TL_IS_1530)) { if (A) *A = 8775; return TRUE; }
				if (Str__eq(entity, TL_IS_1531)) { if (A) *A = 10861; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1532)) { if (A) *A = 10818; return TRUE; }
				if (Str__eq(entity, TL_IS_1533)) { if (A) *A = 1085; return TRUE; }
				if (Str__eq(entity, TL_IS_1534)) { if (A) *A = 8211; return TRUE; }
				if (Str__eq(entity, TL_IS_1535)) { if (A) *A = 8800; return TRUE; }
				if (Str__eq(entity, TL_IS_1536)) { if (A) *A = 8663; return TRUE; }
				if (Str__eq(entity, TL_IS_1537)) { if (A) *A = 10532; return TRUE; }
				if (Str__eq(entity, TL_IS_1538)) { if (A) *A = 8599; return TRUE; }
				if (Str__eq(entity, TL_IS_1539)) { if (A) *A = 8599; return TRUE; }
				if (Str__eq(entity, TL_IS_1540)) { if (A) *A = 8784; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1541)) { if (A) *A = 8802; return TRUE; }
				if (Str__eq(entity, TL_IS_1542)) { if (A) *A = 10536; return TRUE; }
				if (Str__eq(entity, TL_IS_1543)) { if (A) *A = 8770; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1544)) { if (A) *A = 8708; return TRUE; }
				if (Str__eq(entity, TL_IS_1545)) { if (A) *A = 8708; return TRUE; }
				if (Str__eq(entity, TL_IS_1546)) { if (A) *A = 120107; return TRUE; }
				if (Str__eq(entity, TL_IS_1547)) { if (A) *A = 8807; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1548)) { if (A) *A = 8817; return TRUE; }
				if (Str__eq(entity, TL_IS_1549)) { if (A) *A = 8817; return TRUE; }
				if (Str__eq(entity, TL_IS_1550)) { if (A) *A = 8807; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1551)) { if (A) *A = 10878; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1552)) { if (A) *A = 10878; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1553)) { if (A) *A = 8821; return TRUE; }
				if (Str__eq(entity, TL_IS_1554)) { if (A) *A = 8815; return TRUE; }
				if (Str__eq(entity, TL_IS_1555)) { if (A) *A = 8815; return TRUE; }
				if (Str__eq(entity, TL_IS_1556)) { if (A) *A = 8654; return TRUE; }
				if (Str__eq(entity, TL_IS_1557)) { if (A) *A = 8622; return TRUE; }
				if (Str__eq(entity, TL_IS_1558)) { if (A) *A = 10994; return TRUE; }
				if (Str__eq(entity, TL_IS_1559)) { if (A) *A = 8715; return TRUE; }
				if (Str__eq(entity, TL_IS_1560)) { if (A) *A = 8956; return TRUE; }
				if (Str__eq(entity, TL_IS_1561)) { if (A) *A = 8954; return TRUE; }
				if (Str__eq(entity, TL_IS_1562)) { if (A) *A = 8715; return TRUE; }
				if (Str__eq(entity, TL_IS_1563)) { if (A) *A = 1114; return TRUE; }
				if (Str__eq(entity, TL_IS_1564)) { if (A) *A = 8653; return TRUE; }
				if (Str__eq(entity, TL_IS_1565)) { if (A) *A = 8806; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1566)) { if (A) *A = 8602; return TRUE; }
				if (Str__eq(entity, TL_IS_1567)) { if (A) *A = 8229; return TRUE; }
				if (Str__eq(entity, TL_IS_1568)) { if (A) *A = 8816; return TRUE; }
				if (Str__eq(entity, TL_IS_1569)) { if (A) *A = 8602; return TRUE; }
				if (Str__eq(entity, TL_IS_1570)) { if (A) *A = 8622; return TRUE; }
				if (Str__eq(entity, TL_IS_1571)) { if (A) *A = 8816; return TRUE; }
				if (Str__eq(entity, TL_IS_1572)) { if (A) *A = 8806; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1573)) { if (A) *A = 10877; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1574)) { if (A) *A = 10877; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1575)) { if (A) *A = 8814; return TRUE; }
				if (Str__eq(entity, TL_IS_1576)) { if (A) *A = 8820; return TRUE; }
				if (Str__eq(entity, TL_IS_1577)) { if (A) *A = 8814; return TRUE; }
				if (Str__eq(entity, TL_IS_1578)) { if (A) *A = 8938; return TRUE; }
				if (Str__eq(entity, TL_IS_1579)) { if (A) *A = 8940; return TRUE; }
				if (Str__eq(entity, TL_IS_1580)) { if (A) *A = 8740; return TRUE; }
				if (Str__eq(entity, TL_IS_1581)) { if (A) *A = 120159; return TRUE; }
				if (Str__eq(entity, TL_IS_1582)) { if (A) *A = 172; return TRUE; }
				if (Str__eq(entity, TL_IS_1583)) { if (A) *A = 172; return TRUE; }
				if (Str__eq(entity, TL_IS_1584)) { if (A) *A = 8713; return TRUE; }
				if (Str__eq(entity, TL_IS_1585)) { if (A) *A = 8953; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1586)) { if (A) *A = 8949; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1587)) { if (A) *A = 8713; return TRUE; }
				if (Str__eq(entity, TL_IS_1588)) { if (A) *A = 8951; return TRUE; }
				if (Str__eq(entity, TL_IS_1589)) { if (A) *A = 8950; return TRUE; }
				if (Str__eq(entity, TL_IS_1590)) { if (A) *A = 8716; return TRUE; }
				if (Str__eq(entity, TL_IS_1591)) { if (A) *A = 8716; return TRUE; }
				if (Str__eq(entity, TL_IS_1592)) { if (A) *A = 8958; return TRUE; }
				if (Str__eq(entity, TL_IS_1593)) { if (A) *A = 8957; return TRUE; }
				if (Str__eq(entity, TL_IS_1594)) { if (A) *A = 8742; return TRUE; }
				if (Str__eq(entity, TL_IS_1595)) { if (A) *A = 8742; return TRUE; }
				if (Str__eq(entity, TL_IS_1596)) { if (A) *A = 11005; if (B) *B = 8421; return TRUE; }
				if (Str__eq(entity, TL_IS_1597)) { if (A) *A = 8706; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1598)) { if (A) *A = 10772; return TRUE; }
				if (Str__eq(entity, TL_IS_1599)) { if (A) *A = 8832; return TRUE; }
				if (Str__eq(entity, TL_IS_1600)) { if (A) *A = 8928; return TRUE; }
				if (Str__eq(entity, TL_IS_1601)) { if (A) *A = 10927; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1602)) { if (A) *A = 8832; return TRUE; }
				if (Str__eq(entity, TL_IS_1603)) { if (A) *A = 10927; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1604)) { if (A) *A = 8655; return TRUE; }
				if (Str__eq(entity, TL_IS_1605)) { if (A) *A = 8603; return TRUE; }
				if (Str__eq(entity, TL_IS_1606)) { if (A) *A = 10547; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1607)) { if (A) *A = 8605; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1608)) { if (A) *A = 8603; return TRUE; }
				if (Str__eq(entity, TL_IS_1609)) { if (A) *A = 8939; return TRUE; }
				if (Str__eq(entity, TL_IS_1610)) { if (A) *A = 8941; return TRUE; }
				if (Str__eq(entity, TL_IS_1611)) { if (A) *A = 8833; return TRUE; }
				if (Str__eq(entity, TL_IS_1612)) { if (A) *A = 8929; return TRUE; }
				if (Str__eq(entity, TL_IS_1613)) { if (A) *A = 10928; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1614)) { if (A) *A = 120003; return TRUE; }
				if (Str__eq(entity, TL_IS_1615)) { if (A) *A = 8740; return TRUE; }
				if (Str__eq(entity, TL_IS_1616)) { if (A) *A = 8742; return TRUE; }
				if (Str__eq(entity, TL_IS_1617)) { if (A) *A = 8769; return TRUE; }
				if (Str__eq(entity, TL_IS_1618)) { if (A) *A = 8772; return TRUE; }
				if (Str__eq(entity, TL_IS_1619)) { if (A) *A = 8772; return TRUE; }
				if (Str__eq(entity, TL_IS_1620)) { if (A) *A = 8740; return TRUE; }
				if (Str__eq(entity, TL_IS_1621)) { if (A) *A = 8742; return TRUE; }
				if (Str__eq(entity, TL_IS_1622)) { if (A) *A = 8930; return TRUE; }
				if (Str__eq(entity, TL_IS_1623)) { if (A) *A = 8931; return TRUE; }
				if (Str__eq(entity, TL_IS_1624)) { if (A) *A = 8836; return TRUE; }
				if (Str__eq(entity, TL_IS_1625)) { if (A) *A = 10949; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1626)) { if (A) *A = 8840; return TRUE; }
				if (Str__eq(entity, TL_IS_1627)) { if (A) *A = 8834; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1628)) { if (A) *A = 8840; return TRUE; }
				if (Str__eq(entity, TL_IS_1629)) { if (A) *A = 10949; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1630)) { if (A) *A = 8833; return TRUE; }
				if (Str__eq(entity, TL_IS_1631)) { if (A) *A = 10928; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1632)) { if (A) *A = 8837; return TRUE; }
				if (Str__eq(entity, TL_IS_1633)) { if (A) *A = 10950; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1634)) { if (A) *A = 8841; return TRUE; }
				if (Str__eq(entity, TL_IS_1635)) { if (A) *A = 8835; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1636)) { if (A) *A = 8841; return TRUE; }
				if (Str__eq(entity, TL_IS_1637)) { if (A) *A = 10950; if (B) *B = 824; return TRUE; }
				if (Str__eq(entity, TL_IS_1638)) { if (A) *A = 8825; return TRUE; }
				if (Str__eq(entity, TL_IS_1639)) { if (A) *A = 241; return TRUE; }
				if (Str__eq(entity, TL_IS_1640)) { if (A) *A = 241; return TRUE; }
				if (Str__eq(entity, TL_IS_1641)) { if (A) *A = 8824; return TRUE; }
				if (Str__eq(entity, TL_IS_1642)) { if (A) *A = 8938; return TRUE; }
				if (Str__eq(entity, TL_IS_1643)) { if (A) *A = 8940; return TRUE; }
				if (Str__eq(entity, TL_IS_1644)) { if (A) *A = 8939; return TRUE; }
				if (Str__eq(entity, TL_IS_1645)) { if (A) *A = 8941; return TRUE; }
				if (Str__eq(entity, TL_IS_1646)) { if (A) *A = 957; return TRUE; }
				if (Str__eq(entity, TL_IS_1647)) { if (A) *A = 35; return TRUE; }
				if (Str__eq(entity, TL_IS_1648)) { if (A) *A = 8470; return TRUE; }
				if (Str__eq(entity, TL_IS_1649)) { if (A) *A = 8199; return TRUE; }
				if (Str__eq(entity, TL_IS_1650)) { if (A) *A = 8877; return TRUE; }
				if (Str__eq(entity, TL_IS_1651)) { if (A) *A = 10500; return TRUE; }
				if (Str__eq(entity, TL_IS_1652)) { if (A) *A = 8781; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1653)) { if (A) *A = 8876; return TRUE; }
				if (Str__eq(entity, TL_IS_1654)) { if (A) *A = 8805; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1655)) { if (A) *A = 62; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1656)) { if (A) *A = 10718; return TRUE; }
				if (Str__eq(entity, TL_IS_1657)) { if (A) *A = 10498; return TRUE; }
				if (Str__eq(entity, TL_IS_1658)) { if (A) *A = 8804; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1659)) { if (A) *A = 60; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1660)) { if (A) *A = 8884; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1661)) { if (A) *A = 10499; return TRUE; }
				if (Str__eq(entity, TL_IS_1662)) { if (A) *A = 8885; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1663)) { if (A) *A = 8764; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_1664)) { if (A) *A = 8662; return TRUE; }
				if (Str__eq(entity, TL_IS_1665)) { if (A) *A = 10531; return TRUE; }
				if (Str__eq(entity, TL_IS_1666)) { if (A) *A = 8598; return TRUE; }
				if (Str__eq(entity, TL_IS_1667)) { if (A) *A = 8598; return TRUE; }
				if (Str__eq(entity, TL_IS_1668)) { if (A) *A = 10535; return TRUE; }
				break;
			case 'o':
				if (Str__eq(entity, TL_IS_1669)) { if (A) *A = 9416; return TRUE; }
				if (Str__eq(entity, TL_IS_1670)) { if (A) *A = 243; return TRUE; }
				if (Str__eq(entity, TL_IS_1671)) { if (A) *A = 243; return TRUE; }
				if (Str__eq(entity, TL_IS_1672)) { if (A) *A = 8859; return TRUE; }
				if (Str__eq(entity, TL_IS_1673)) { if (A) *A = 8858; return TRUE; }
				if (Str__eq(entity, TL_IS_1674)) { if (A) *A = 244; return TRUE; }
				if (Str__eq(entity, TL_IS_1675)) { if (A) *A = 244; return TRUE; }
				if (Str__eq(entity, TL_IS_1676)) { if (A) *A = 1086; return TRUE; }
				if (Str__eq(entity, TL_IS_1677)) { if (A) *A = 8861; return TRUE; }
				if (Str__eq(entity, TL_IS_1678)) { if (A) *A = 337; return TRUE; }
				if (Str__eq(entity, TL_IS_1679)) { if (A) *A = 10808; return TRUE; }
				if (Str__eq(entity, TL_IS_1680)) { if (A) *A = 8857; return TRUE; }
				if (Str__eq(entity, TL_IS_1681)) { if (A) *A = 10684; return TRUE; }
				if (Str__eq(entity, TL_IS_1682)) { if (A) *A = 339; return TRUE; }
				if (Str__eq(entity, TL_IS_1683)) { if (A) *A = 10687; return TRUE; }
				if (Str__eq(entity, TL_IS_1684)) { if (A) *A = 120108; return TRUE; }
				if (Str__eq(entity, TL_IS_1685)) { if (A) *A = 731; return TRUE; }
				if (Str__eq(entity, TL_IS_1686)) { if (A) *A = 242; return TRUE; }
				if (Str__eq(entity, TL_IS_1687)) { if (A) *A = 242; return TRUE; }
				if (Str__eq(entity, TL_IS_1688)) { if (A) *A = 10689; return TRUE; }
				if (Str__eq(entity, TL_IS_1689)) { if (A) *A = 10677; return TRUE; }
				if (Str__eq(entity, TL_IS_1690)) { if (A) *A = 937; return TRUE; }
				if (Str__eq(entity, TL_IS_1691)) { if (A) *A = 8750; return TRUE; }
				if (Str__eq(entity, TL_IS_1692)) { if (A) *A = 8634; return TRUE; }
				if (Str__eq(entity, TL_IS_1693)) { if (A) *A = 10686; return TRUE; }
				if (Str__eq(entity, TL_IS_1694)) { if (A) *A = 10683; return TRUE; }
				if (Str__eq(entity, TL_IS_1695)) { if (A) *A = 8254; return TRUE; }
				if (Str__eq(entity, TL_IS_1696)) { if (A) *A = 10688; return TRUE; }
				if (Str__eq(entity, TL_IS_1697)) { if (A) *A = 333; return TRUE; }
				if (Str__eq(entity, TL_IS_1698)) { if (A) *A = 969; return TRUE; }
				if (Str__eq(entity, TL_IS_1699)) { if (A) *A = 959; return TRUE; }
				if (Str__eq(entity, TL_IS_1700)) { if (A) *A = 10678; return TRUE; }
				if (Str__eq(entity, TL_IS_1701)) { if (A) *A = 8854; return TRUE; }
				if (Str__eq(entity, TL_IS_1702)) { if (A) *A = 120160; return TRUE; }
				if (Str__eq(entity, TL_IS_1703)) { if (A) *A = 10679; return TRUE; }
				if (Str__eq(entity, TL_IS_1704)) { if (A) *A = 10681; return TRUE; }
				if (Str__eq(entity, TL_IS_1705)) { if (A) *A = 8853; return TRUE; }
				if (Str__eq(entity, TL_IS_1706)) { if (A) *A = 8744; return TRUE; }
				if (Str__eq(entity, TL_IS_1707)) { if (A) *A = 8635; return TRUE; }
				if (Str__eq(entity, TL_IS_1708)) { if (A) *A = 10845; return TRUE; }
				if (Str__eq(entity, TL_IS_1709)) { if (A) *A = 8500; return TRUE; }
				if (Str__eq(entity, TL_IS_1710)) { if (A) *A = 8500; return TRUE; }
				if (Str__eq(entity, TL_IS_1711)) { if (A) *A = 170; return TRUE; }
				if (Str__eq(entity, TL_IS_1712)) { if (A) *A = 170; return TRUE; }
				if (Str__eq(entity, TL_IS_1713)) { if (A) *A = 186; return TRUE; }
				if (Str__eq(entity, TL_IS_1714)) { if (A) *A = 186; return TRUE; }
				if (Str__eq(entity, TL_IS_1715)) { if (A) *A = 8886; return TRUE; }
				if (Str__eq(entity, TL_IS_1716)) { if (A) *A = 10838; return TRUE; }
				if (Str__eq(entity, TL_IS_1717)) { if (A) *A = 10839; return TRUE; }
				if (Str__eq(entity, TL_IS_1718)) { if (A) *A = 10843; return TRUE; }
				if (Str__eq(entity, TL_IS_1719)) { if (A) *A = 8500; return TRUE; }
				if (Str__eq(entity, TL_IS_1720)) { if (A) *A = 248; return TRUE; }
				if (Str__eq(entity, TL_IS_1721)) { if (A) *A = 248; return TRUE; }
				if (Str__eq(entity, TL_IS_1722)) { if (A) *A = 8856; return TRUE; }
				if (Str__eq(entity, TL_IS_1723)) { if (A) *A = 245; return TRUE; }
				if (Str__eq(entity, TL_IS_1724)) { if (A) *A = 245; return TRUE; }
				if (Str__eq(entity, TL_IS_1725)) { if (A) *A = 8855; return TRUE; }
				if (Str__eq(entity, TL_IS_1726)) { if (A) *A = 10806; return TRUE; }
				if (Str__eq(entity, TL_IS_1727)) { if (A) *A = 246; return TRUE; }
				if (Str__eq(entity, TL_IS_1728)) { if (A) *A = 246; return TRUE; }
				if (Str__eq(entity, TL_IS_1729)) { if (A) *A = 9021; return TRUE; }
				break;
			case 'p':
				if (Str__eq(entity, TL_IS_1730)) { if (A) *A = 8741; return TRUE; }
				if (Str__eq(entity, TL_IS_1731)) { if (A) *A = 182; return TRUE; }
				if (Str__eq(entity, TL_IS_1732)) { if (A) *A = 182; return TRUE; }
				if (Str__eq(entity, TL_IS_1733)) { if (A) *A = 8741; return TRUE; }
				if (Str__eq(entity, TL_IS_1734)) { if (A) *A = 10995; return TRUE; }
				if (Str__eq(entity, TL_IS_1735)) { if (A) *A = 11005; return TRUE; }
				if (Str__eq(entity, TL_IS_1736)) { if (A) *A = 8706; return TRUE; }
				if (Str__eq(entity, TL_IS_1737)) { if (A) *A = 1087; return TRUE; }
				if (Str__eq(entity, TL_IS_1738)) { if (A) *A = 37; return TRUE; }
				if (Str__eq(entity, TL_IS_1739)) { if (A) *A = 46; return TRUE; }
				if (Str__eq(entity, TL_IS_1740)) { if (A) *A = 8240; return TRUE; }
				if (Str__eq(entity, TL_IS_1741)) { if (A) *A = 8869; return TRUE; }
				if (Str__eq(entity, TL_IS_1742)) { if (A) *A = 8241; return TRUE; }
				if (Str__eq(entity, TL_IS_1743)) { if (A) *A = 120109; return TRUE; }
				if (Str__eq(entity, TL_IS_1744)) { if (A) *A = 966; return TRUE; }
				if (Str__eq(entity, TL_IS_1745)) { if (A) *A = 981; return TRUE; }
				if (Str__eq(entity, TL_IS_1746)) { if (A) *A = 8499; return TRUE; }
				if (Str__eq(entity, TL_IS_1747)) { if (A) *A = 9742; return TRUE; }
				if (Str__eq(entity, TL_IS_1748)) { if (A) *A = 960; return TRUE; }
				if (Str__eq(entity, TL_IS_1749)) { if (A) *A = 8916; return TRUE; }
				if (Str__eq(entity, TL_IS_1750)) { if (A) *A = 982; return TRUE; }
				if (Str__eq(entity, TL_IS_1751)) { if (A) *A = 8463; return TRUE; }
				if (Str__eq(entity, TL_IS_1752)) { if (A) *A = 8462; return TRUE; }
				if (Str__eq(entity, TL_IS_1753)) { if (A) *A = 8463; return TRUE; }
				if (Str__eq(entity, TL_IS_1754)) { if (A) *A = 43; return TRUE; }
				if (Str__eq(entity, TL_IS_1755)) { if (A) *A = 10787; return TRUE; }
				if (Str__eq(entity, TL_IS_1756)) { if (A) *A = 8862; return TRUE; }
				if (Str__eq(entity, TL_IS_1757)) { if (A) *A = 10786; return TRUE; }
				if (Str__eq(entity, TL_IS_1758)) { if (A) *A = 8724; return TRUE; }
				if (Str__eq(entity, TL_IS_1759)) { if (A) *A = 10789; return TRUE; }
				if (Str__eq(entity, TL_IS_1760)) { if (A) *A = 10866; return TRUE; }
				if (Str__eq(entity, TL_IS_1761)) { if (A) *A = 177; return TRUE; }
				if (Str__eq(entity, TL_IS_1762)) { if (A) *A = 177; return TRUE; }
				if (Str__eq(entity, TL_IS_1763)) { if (A) *A = 10790; return TRUE; }
				if (Str__eq(entity, TL_IS_1764)) { if (A) *A = 10791; return TRUE; }
				if (Str__eq(entity, TL_IS_1765)) { if (A) *A = 177; return TRUE; }
				if (Str__eq(entity, TL_IS_1766)) { if (A) *A = 10773; return TRUE; }
				if (Str__eq(entity, TL_IS_1767)) { if (A) *A = 120161; return TRUE; }
				if (Str__eq(entity, TL_IS_1768)) { if (A) *A = 163; return TRUE; }
				if (Str__eq(entity, TL_IS_1769)) { if (A) *A = 163; return TRUE; }
				if (Str__eq(entity, TL_IS_1770)) { if (A) *A = 8826; return TRUE; }
				if (Str__eq(entity, TL_IS_1771)) { if (A) *A = 10931; return TRUE; }
				if (Str__eq(entity, TL_IS_1772)) { if (A) *A = 10935; return TRUE; }
				if (Str__eq(entity, TL_IS_1773)) { if (A) *A = 8828; return TRUE; }
				if (Str__eq(entity, TL_IS_1774)) { if (A) *A = 10927; return TRUE; }
				if (Str__eq(entity, TL_IS_1775)) { if (A) *A = 8826; return TRUE; }
				if (Str__eq(entity, TL_IS_1776)) { if (A) *A = 10935; return TRUE; }
				if (Str__eq(entity, TL_IS_1777)) { if (A) *A = 8828; return TRUE; }
				if (Str__eq(entity, TL_IS_1778)) { if (A) *A = 10927; return TRUE; }
				if (Str__eq(entity, TL_IS_1779)) { if (A) *A = 10937; return TRUE; }
				if (Str__eq(entity, TL_IS_1780)) { if (A) *A = 10933; return TRUE; }
				if (Str__eq(entity, TL_IS_1781)) { if (A) *A = 8936; return TRUE; }
				if (Str__eq(entity, TL_IS_1782)) { if (A) *A = 8830; return TRUE; }
				if (Str__eq(entity, TL_IS_1783)) { if (A) *A = 8242; return TRUE; }
				if (Str__eq(entity, TL_IS_1784)) { if (A) *A = 8473; return TRUE; }
				if (Str__eq(entity, TL_IS_1785)) { if (A) *A = 10933; return TRUE; }
				if (Str__eq(entity, TL_IS_1786)) { if (A) *A = 10937; return TRUE; }
				if (Str__eq(entity, TL_IS_1787)) { if (A) *A = 8936; return TRUE; }
				if (Str__eq(entity, TL_IS_1788)) { if (A) *A = 8719; return TRUE; }
				if (Str__eq(entity, TL_IS_1789)) { if (A) *A = 9006; return TRUE; }
				if (Str__eq(entity, TL_IS_1790)) { if (A) *A = 8978; return TRUE; }
				if (Str__eq(entity, TL_IS_1791)) { if (A) *A = 8979; return TRUE; }
				if (Str__eq(entity, TL_IS_1792)) { if (A) *A = 8733; return TRUE; }
				if (Str__eq(entity, TL_IS_1793)) { if (A) *A = 8733; return TRUE; }
				if (Str__eq(entity, TL_IS_1794)) { if (A) *A = 8830; return TRUE; }
				if (Str__eq(entity, TL_IS_1795)) { if (A) *A = 8880; return TRUE; }
				if (Str__eq(entity, TL_IS_1796)) { if (A) *A = 120005; return TRUE; }
				if (Str__eq(entity, TL_IS_1797)) { if (A) *A = 968; return TRUE; }
				if (Str__eq(entity, TL_IS_1798)) { if (A) *A = 8200; return TRUE; }
				break;
			case 'q':
				if (Str__eq(entity, TL_IS_1799)) { if (A) *A = 120110; return TRUE; }
				if (Str__eq(entity, TL_IS_1800)) { if (A) *A = 10764; return TRUE; }
				if (Str__eq(entity, TL_IS_1801)) { if (A) *A = 120162; return TRUE; }
				if (Str__eq(entity, TL_IS_1802)) { if (A) *A = 8279; return TRUE; }
				if (Str__eq(entity, TL_IS_1803)) { if (A) *A = 120006; return TRUE; }
				if (Str__eq(entity, TL_IS_1804)) { if (A) *A = 8461; return TRUE; }
				if (Str__eq(entity, TL_IS_1805)) { if (A) *A = 10774; return TRUE; }
				if (Str__eq(entity, TL_IS_1806)) { if (A) *A = 63; return TRUE; }
				if (Str__eq(entity, TL_IS_1807)) { if (A) *A = 8799; return TRUE; }
				if (Str__eq(entity, TL_IS_1808)) { if (A) *A = 34; return TRUE; }
				if (Str__eq(entity, TL_IS_1809)) { if (A) *A = 34; return TRUE; }
				break;
			case 'r':
				if (Str__eq(entity, TL_IS_1810)) { if (A) *A = 8667; return TRUE; }
				if (Str__eq(entity, TL_IS_1811)) { if (A) *A = 8658; return TRUE; }
				if (Str__eq(entity, TL_IS_1812)) { if (A) *A = 10524; return TRUE; }
				if (Str__eq(entity, TL_IS_1813)) { if (A) *A = 10511; return TRUE; }
				if (Str__eq(entity, TL_IS_1814)) { if (A) *A = 10596; return TRUE; }
				if (Str__eq(entity, TL_IS_1815)) { if (A) *A = 8765; if (B) *B = 817; return TRUE; }
				if (Str__eq(entity, TL_IS_1816)) { if (A) *A = 341; return TRUE; }
				if (Str__eq(entity, TL_IS_1817)) { if (A) *A = 8730; return TRUE; }
				if (Str__eq(entity, TL_IS_1818)) { if (A) *A = 10675; return TRUE; }
				if (Str__eq(entity, TL_IS_1819)) { if (A) *A = 10217; return TRUE; }
				if (Str__eq(entity, TL_IS_1820)) { if (A) *A = 10642; return TRUE; }
				if (Str__eq(entity, TL_IS_1821)) { if (A) *A = 10661; return TRUE; }
				if (Str__eq(entity, TL_IS_1822)) { if (A) *A = 10217; return TRUE; }
				if (Str__eq(entity, TL_IS_1823)) { if (A) *A = 187; return TRUE; }
				if (Str__eq(entity, TL_IS_1824)) { if (A) *A = 187; return TRUE; }
				if (Str__eq(entity, TL_IS_1825)) { if (A) *A = 8594; return TRUE; }
				if (Str__eq(entity, TL_IS_1826)) { if (A) *A = 10613; return TRUE; }
				if (Str__eq(entity, TL_IS_1827)) { if (A) *A = 8677; return TRUE; }
				if (Str__eq(entity, TL_IS_1828)) { if (A) *A = 10528; return TRUE; }
				if (Str__eq(entity, TL_IS_1829)) { if (A) *A = 10547; return TRUE; }
				if (Str__eq(entity, TL_IS_1830)) { if (A) *A = 10526; return TRUE; }
				if (Str__eq(entity, TL_IS_1831)) { if (A) *A = 8618; return TRUE; }
				if (Str__eq(entity, TL_IS_1832)) { if (A) *A = 8620; return TRUE; }
				if (Str__eq(entity, TL_IS_1833)) { if (A) *A = 10565; return TRUE; }
				if (Str__eq(entity, TL_IS_1834)) { if (A) *A = 10612; return TRUE; }
				if (Str__eq(entity, TL_IS_1835)) { if (A) *A = 8611; return TRUE; }
				if (Str__eq(entity, TL_IS_1836)) { if (A) *A = 8605; return TRUE; }
				if (Str__eq(entity, TL_IS_1837)) { if (A) *A = 10522; return TRUE; }
				if (Str__eq(entity, TL_IS_1838)) { if (A) *A = 8758; return TRUE; }
				if (Str__eq(entity, TL_IS_1839)) { if (A) *A = 8474; return TRUE; }
				if (Str__eq(entity, TL_IS_1840)) { if (A) *A = 10509; return TRUE; }
				if (Str__eq(entity, TL_IS_1841)) { if (A) *A = 10099; return TRUE; }
				if (Str__eq(entity, TL_IS_1842)) { if (A) *A = 125; return TRUE; }
				if (Str__eq(entity, TL_IS_1843)) { if (A) *A = 93; return TRUE; }
				if (Str__eq(entity, TL_IS_1844)) { if (A) *A = 10636; return TRUE; }
				if (Str__eq(entity, TL_IS_1845)) { if (A) *A = 10638; return TRUE; }
				if (Str__eq(entity, TL_IS_1846)) { if (A) *A = 10640; return TRUE; }
				if (Str__eq(entity, TL_IS_1847)) { if (A) *A = 345; return TRUE; }
				if (Str__eq(entity, TL_IS_1848)) { if (A) *A = 343; return TRUE; }
				if (Str__eq(entity, TL_IS_1849)) { if (A) *A = 8969; return TRUE; }
				if (Str__eq(entity, TL_IS_1850)) { if (A) *A = 125; return TRUE; }
				if (Str__eq(entity, TL_IS_1851)) { if (A) *A = 1088; return TRUE; }
				if (Str__eq(entity, TL_IS_1852)) { if (A) *A = 10551; return TRUE; }
				if (Str__eq(entity, TL_IS_1853)) { if (A) *A = 10601; return TRUE; }
				if (Str__eq(entity, TL_IS_1854)) { if (A) *A = 8221; return TRUE; }
				if (Str__eq(entity, TL_IS_1855)) { if (A) *A = 8221; return TRUE; }
				if (Str__eq(entity, TL_IS_1856)) { if (A) *A = 8627; return TRUE; }
				if (Str__eq(entity, TL_IS_1857)) { if (A) *A = 8476; return TRUE; }
				if (Str__eq(entity, TL_IS_1858)) { if (A) *A = 8475; return TRUE; }
				if (Str__eq(entity, TL_IS_1859)) { if (A) *A = 8476; return TRUE; }
				if (Str__eq(entity, TL_IS_1860)) { if (A) *A = 8477; return TRUE; }
				if (Str__eq(entity, TL_IS_1861)) { if (A) *A = 9645; return TRUE; }
				if (Str__eq(entity, TL_IS_1862)) { if (A) *A = 174; return TRUE; }
				if (Str__eq(entity, TL_IS_1863)) { if (A) *A = 174; return TRUE; }
				if (Str__eq(entity, TL_IS_1864)) { if (A) *A = 10621; return TRUE; }
				if (Str__eq(entity, TL_IS_1865)) { if (A) *A = 8971; return TRUE; }
				if (Str__eq(entity, TL_IS_1866)) { if (A) *A = 120111; return TRUE; }
				if (Str__eq(entity, TL_IS_1867)) { if (A) *A = 8641; return TRUE; }
				if (Str__eq(entity, TL_IS_1868)) { if (A) *A = 8640; return TRUE; }
				if (Str__eq(entity, TL_IS_1869)) { if (A) *A = 10604; return TRUE; }
				if (Str__eq(entity, TL_IS_1870)) { if (A) *A = 961; return TRUE; }
				if (Str__eq(entity, TL_IS_1871)) { if (A) *A = 1009; return TRUE; }
				if (Str__eq(entity, TL_IS_1872)) { if (A) *A = 8594; return TRUE; }
				if (Str__eq(entity, TL_IS_1873)) { if (A) *A = 8611; return TRUE; }
				if (Str__eq(entity, TL_IS_1874)) { if (A) *A = 8641; return TRUE; }
				if (Str__eq(entity, TL_IS_1875)) { if (A) *A = 8640; return TRUE; }
				if (Str__eq(entity, TL_IS_1876)) { if (A) *A = 8644; return TRUE; }
				if (Str__eq(entity, TL_IS_1877)) { if (A) *A = 8652; return TRUE; }
				if (Str__eq(entity, TL_IS_1878)) { if (A) *A = 8649; return TRUE; }
				if (Str__eq(entity, TL_IS_1879)) { if (A) *A = 8605; return TRUE; }
				if (Str__eq(entity, TL_IS_1880)) { if (A) *A = 8908; return TRUE; }
				if (Str__eq(entity, TL_IS_1881)) { if (A) *A = 730; return TRUE; }
				if (Str__eq(entity, TL_IS_1882)) { if (A) *A = 8787; return TRUE; }
				if (Str__eq(entity, TL_IS_1883)) { if (A) *A = 8644; return TRUE; }
				if (Str__eq(entity, TL_IS_1884)) { if (A) *A = 8652; return TRUE; }
				if (Str__eq(entity, TL_IS_1885)) { if (A) *A = 8207; return TRUE; }
				if (Str__eq(entity, TL_IS_1886)) { if (A) *A = 9137; return TRUE; }
				if (Str__eq(entity, TL_IS_1887)) { if (A) *A = 9137; return TRUE; }
				if (Str__eq(entity, TL_IS_1888)) { if (A) *A = 10990; return TRUE; }
				if (Str__eq(entity, TL_IS_1889)) { if (A) *A = 10221; return TRUE; }
				if (Str__eq(entity, TL_IS_1890)) { if (A) *A = 8702; return TRUE; }
				if (Str__eq(entity, TL_IS_1891)) { if (A) *A = 10215; return TRUE; }
				if (Str__eq(entity, TL_IS_1892)) { if (A) *A = 10630; return TRUE; }
				if (Str__eq(entity, TL_IS_1893)) { if (A) *A = 120163; return TRUE; }
				if (Str__eq(entity, TL_IS_1894)) { if (A) *A = 10798; return TRUE; }
				if (Str__eq(entity, TL_IS_1895)) { if (A) *A = 10805; return TRUE; }
				if (Str__eq(entity, TL_IS_1896)) { if (A) *A = 41; return TRUE; }
				if (Str__eq(entity, TL_IS_1897)) { if (A) *A = 10644; return TRUE; }
				if (Str__eq(entity, TL_IS_1898)) { if (A) *A = 10770; return TRUE; }
				if (Str__eq(entity, TL_IS_1899)) { if (A) *A = 8649; return TRUE; }
				if (Str__eq(entity, TL_IS_1900)) { if (A) *A = 8250; return TRUE; }
				if (Str__eq(entity, TL_IS_1901)) { if (A) *A = 120007; return TRUE; }
				if (Str__eq(entity, TL_IS_1902)) { if (A) *A = 8625; return TRUE; }
				if (Str__eq(entity, TL_IS_1903)) { if (A) *A = 93; return TRUE; }
				if (Str__eq(entity, TL_IS_1904)) { if (A) *A = 8217; return TRUE; }
				if (Str__eq(entity, TL_IS_1905)) { if (A) *A = 8217; return TRUE; }
				if (Str__eq(entity, TL_IS_1906)) { if (A) *A = 8908; return TRUE; }
				if (Str__eq(entity, TL_IS_1907)) { if (A) *A = 8906; return TRUE; }
				if (Str__eq(entity, TL_IS_1908)) { if (A) *A = 9657; return TRUE; }
				if (Str__eq(entity, TL_IS_1909)) { if (A) *A = 8885; return TRUE; }
				if (Str__eq(entity, TL_IS_1910)) { if (A) *A = 9656; return TRUE; }
				if (Str__eq(entity, TL_IS_1911)) { if (A) *A = 10702; return TRUE; }
				if (Str__eq(entity, TL_IS_1912)) { if (A) *A = 10600; return TRUE; }
				if (Str__eq(entity, TL_IS_1913)) { if (A) *A = 8478; return TRUE; }
				break;
			case 's':
				if (Str__eq(entity, TL_IS_1914)) { if (A) *A = 347; return TRUE; }
				if (Str__eq(entity, TL_IS_1915)) { if (A) *A = 8218; return TRUE; }
				if (Str__eq(entity, TL_IS_1916)) { if (A) *A = 8827; return TRUE; }
				if (Str__eq(entity, TL_IS_1917)) { if (A) *A = 10932; return TRUE; }
				if (Str__eq(entity, TL_IS_1918)) { if (A) *A = 10936; return TRUE; }
				if (Str__eq(entity, TL_IS_1919)) { if (A) *A = 353; return TRUE; }
				if (Str__eq(entity, TL_IS_1920)) { if (A) *A = 8829; return TRUE; }
				if (Str__eq(entity, TL_IS_1921)) { if (A) *A = 10928; return TRUE; }
				if (Str__eq(entity, TL_IS_1922)) { if (A) *A = 351; return TRUE; }
				if (Str__eq(entity, TL_IS_1923)) { if (A) *A = 349; return TRUE; }
				if (Str__eq(entity, TL_IS_1924)) { if (A) *A = 10934; return TRUE; }
				if (Str__eq(entity, TL_IS_1925)) { if (A) *A = 10938; return TRUE; }
				if (Str__eq(entity, TL_IS_1926)) { if (A) *A = 8937; return TRUE; }
				if (Str__eq(entity, TL_IS_1927)) { if (A) *A = 10771; return TRUE; }
				if (Str__eq(entity, TL_IS_1928)) { if (A) *A = 8831; return TRUE; }
				if (Str__eq(entity, TL_IS_1929)) { if (A) *A = 1089; return TRUE; }
				if (Str__eq(entity, TL_IS_1930)) { if (A) *A = 8901; return TRUE; }
				if (Str__eq(entity, TL_IS_1931)) { if (A) *A = 8865; return TRUE; }
				if (Str__eq(entity, TL_IS_1932)) { if (A) *A = 10854; return TRUE; }
				if (Str__eq(entity, TL_IS_1933)) { if (A) *A = 8664; return TRUE; }
				if (Str__eq(entity, TL_IS_1934)) { if (A) *A = 10533; return TRUE; }
				if (Str__eq(entity, TL_IS_1935)) { if (A) *A = 8600; return TRUE; }
				if (Str__eq(entity, TL_IS_1936)) { if (A) *A = 8600; return TRUE; }
				if (Str__eq(entity, TL_IS_1937)) { if (A) *A = 167; return TRUE; }
				if (Str__eq(entity, TL_IS_1938)) { if (A) *A = 167; return TRUE; }
				if (Str__eq(entity, TL_IS_1939)) { if (A) *A = 59; return TRUE; }
				if (Str__eq(entity, TL_IS_1940)) { if (A) *A = 10537; return TRUE; }
				if (Str__eq(entity, TL_IS_1941)) { if (A) *A = 8726; return TRUE; }
				if (Str__eq(entity, TL_IS_1942)) { if (A) *A = 8726; return TRUE; }
				if (Str__eq(entity, TL_IS_1943)) { if (A) *A = 10038; return TRUE; }
				if (Str__eq(entity, TL_IS_1944)) { if (A) *A = 120112; return TRUE; }
				if (Str__eq(entity, TL_IS_1945)) { if (A) *A = 8994; return TRUE; }
				if (Str__eq(entity, TL_IS_1946)) { if (A) *A = 9839; return TRUE; }
				if (Str__eq(entity, TL_IS_1947)) { if (A) *A = 1097; return TRUE; }
				if (Str__eq(entity, TL_IS_1948)) { if (A) *A = 1096; return TRUE; }
				if (Str__eq(entity, TL_IS_1949)) { if (A) *A = 8739; return TRUE; }
				if (Str__eq(entity, TL_IS_1950)) { if (A) *A = 8741; return TRUE; }
				if (Str__eq(entity, TL_IS_1951)) { if (A) *A = 173; return TRUE; }
				if (Str__eq(entity, TL_IS_1952)) { if (A) *A = 173; return TRUE; }
				if (Str__eq(entity, TL_IS_1953)) { if (A) *A = 963; return TRUE; }
				if (Str__eq(entity, TL_IS_1954)) { if (A) *A = 962; return TRUE; }
				if (Str__eq(entity, TL_IS_1955)) { if (A) *A = 962; return TRUE; }
				if (Str__eq(entity, TL_IS_1956)) { if (A) *A = 8764; return TRUE; }
				if (Str__eq(entity, TL_IS_1957)) { if (A) *A = 10858; return TRUE; }
				if (Str__eq(entity, TL_IS_1958)) { if (A) *A = 8771; return TRUE; }
				if (Str__eq(entity, TL_IS_1959)) { if (A) *A = 8771; return TRUE; }
				if (Str__eq(entity, TL_IS_1960)) { if (A) *A = 10910; return TRUE; }
				if (Str__eq(entity, TL_IS_1961)) { if (A) *A = 10912; return TRUE; }
				if (Str__eq(entity, TL_IS_1962)) { if (A) *A = 10909; return TRUE; }
				if (Str__eq(entity, TL_IS_1963)) { if (A) *A = 10911; return TRUE; }
				if (Str__eq(entity, TL_IS_1964)) { if (A) *A = 8774; return TRUE; }
				if (Str__eq(entity, TL_IS_1965)) { if (A) *A = 10788; return TRUE; }
				if (Str__eq(entity, TL_IS_1966)) { if (A) *A = 10610; return TRUE; }
				if (Str__eq(entity, TL_IS_1967)) { if (A) *A = 8592; return TRUE; }
				if (Str__eq(entity, TL_IS_1968)) { if (A) *A = 8726; return TRUE; }
				if (Str__eq(entity, TL_IS_1969)) { if (A) *A = 10803; return TRUE; }
				if (Str__eq(entity, TL_IS_1970)) { if (A) *A = 10724; return TRUE; }
				if (Str__eq(entity, TL_IS_1971)) { if (A) *A = 8739; return TRUE; }
				if (Str__eq(entity, TL_IS_1972)) { if (A) *A = 8995; return TRUE; }
				if (Str__eq(entity, TL_IS_1973)) { if (A) *A = 10922; return TRUE; }
				if (Str__eq(entity, TL_IS_1974)) { if (A) *A = 10924; return TRUE; }
				if (Str__eq(entity, TL_IS_1975)) { if (A) *A = 10924; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1976)) { if (A) *A = 1100; return TRUE; }
				if (Str__eq(entity, TL_IS_1977)) { if (A) *A = 47; return TRUE; }
				if (Str__eq(entity, TL_IS_1978)) { if (A) *A = 10692; return TRUE; }
				if (Str__eq(entity, TL_IS_1979)) { if (A) *A = 9023; return TRUE; }
				if (Str__eq(entity, TL_IS_1980)) { if (A) *A = 120164; return TRUE; }
				if (Str__eq(entity, TL_IS_1981)) { if (A) *A = 9824; return TRUE; }
				if (Str__eq(entity, TL_IS_1982)) { if (A) *A = 9824; return TRUE; }
				if (Str__eq(entity, TL_IS_1983)) { if (A) *A = 8741; return TRUE; }
				if (Str__eq(entity, TL_IS_1984)) { if (A) *A = 8851; return TRUE; }
				if (Str__eq(entity, TL_IS_1985)) { if (A) *A = 8851; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1986)) { if (A) *A = 8852; return TRUE; }
				if (Str__eq(entity, TL_IS_1987)) { if (A) *A = 8852; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_1988)) { if (A) *A = 8847; return TRUE; }
				if (Str__eq(entity, TL_IS_1989)) { if (A) *A = 8849; return TRUE; }
				if (Str__eq(entity, TL_IS_1990)) { if (A) *A = 8847; return TRUE; }
				if (Str__eq(entity, TL_IS_1991)) { if (A) *A = 8849; return TRUE; }
				if (Str__eq(entity, TL_IS_1992)) { if (A) *A = 8848; return TRUE; }
				if (Str__eq(entity, TL_IS_1993)) { if (A) *A = 8850; return TRUE; }
				if (Str__eq(entity, TL_IS_1994)) { if (A) *A = 8848; return TRUE; }
				if (Str__eq(entity, TL_IS_1995)) { if (A) *A = 8850; return TRUE; }
				if (Str__eq(entity, TL_IS_1996)) { if (A) *A = 9633; return TRUE; }
				if (Str__eq(entity, TL_IS_1997)) { if (A) *A = 9633; return TRUE; }
				if (Str__eq(entity, TL_IS_1998)) { if (A) *A = 9642; return TRUE; }
				if (Str__eq(entity, TL_IS_1999)) { if (A) *A = 9642; return TRUE; }
				if (Str__eq(entity, TL_IS_2000)) { if (A) *A = 8594; return TRUE; }
				if (Str__eq(entity, TL_IS_2001)) { if (A) *A = 120008; return TRUE; }
				if (Str__eq(entity, TL_IS_2002)) { if (A) *A = 8726; return TRUE; }
				if (Str__eq(entity, TL_IS_2003)) { if (A) *A = 8995; return TRUE; }
				if (Str__eq(entity, TL_IS_2004)) { if (A) *A = 8902; return TRUE; }
				if (Str__eq(entity, TL_IS_2005)) { if (A) *A = 9734; return TRUE; }
				if (Str__eq(entity, TL_IS_2006)) { if (A) *A = 9733; return TRUE; }
				if (Str__eq(entity, TL_IS_2007)) { if (A) *A = 1013; return TRUE; }
				if (Str__eq(entity, TL_IS_2008)) { if (A) *A = 981; return TRUE; }
				if (Str__eq(entity, TL_IS_2009)) { if (A) *A = 175; return TRUE; }
				if (Str__eq(entity, TL_IS_2010)) { if (A) *A = 8834; return TRUE; }
				if (Str__eq(entity, TL_IS_2011)) { if (A) *A = 10949; return TRUE; }
				if (Str__eq(entity, TL_IS_2012)) { if (A) *A = 10941; return TRUE; }
				if (Str__eq(entity, TL_IS_2013)) { if (A) *A = 8838; return TRUE; }
				if (Str__eq(entity, TL_IS_2014)) { if (A) *A = 10947; return TRUE; }
				if (Str__eq(entity, TL_IS_2015)) { if (A) *A = 10945; return TRUE; }
				if (Str__eq(entity, TL_IS_2016)) { if (A) *A = 10955; return TRUE; }
				if (Str__eq(entity, TL_IS_2017)) { if (A) *A = 8842; return TRUE; }
				if (Str__eq(entity, TL_IS_2018)) { if (A) *A = 10943; return TRUE; }
				if (Str__eq(entity, TL_IS_2019)) { if (A) *A = 10617; return TRUE; }
				if (Str__eq(entity, TL_IS_2020)) { if (A) *A = 8834; return TRUE; }
				if (Str__eq(entity, TL_IS_2021)) { if (A) *A = 8838; return TRUE; }
				if (Str__eq(entity, TL_IS_2022)) { if (A) *A = 10949; return TRUE; }
				if (Str__eq(entity, TL_IS_2023)) { if (A) *A = 8842; return TRUE; }
				if (Str__eq(entity, TL_IS_2024)) { if (A) *A = 10955; return TRUE; }
				if (Str__eq(entity, TL_IS_2025)) { if (A) *A = 10951; return TRUE; }
				if (Str__eq(entity, TL_IS_2026)) { if (A) *A = 10965; return TRUE; }
				if (Str__eq(entity, TL_IS_2027)) { if (A) *A = 10963; return TRUE; }
				if (Str__eq(entity, TL_IS_2028)) { if (A) *A = 8827; return TRUE; }
				if (Str__eq(entity, TL_IS_2029)) { if (A) *A = 10936; return TRUE; }
				if (Str__eq(entity, TL_IS_2030)) { if (A) *A = 8829; return TRUE; }
				if (Str__eq(entity, TL_IS_2031)) { if (A) *A = 10928; return TRUE; }
				if (Str__eq(entity, TL_IS_2032)) { if (A) *A = 10938; return TRUE; }
				if (Str__eq(entity, TL_IS_2033)) { if (A) *A = 10934; return TRUE; }
				if (Str__eq(entity, TL_IS_2034)) { if (A) *A = 8937; return TRUE; }
				if (Str__eq(entity, TL_IS_2035)) { if (A) *A = 8831; return TRUE; }
				if (Str__eq(entity, TL_IS_2036)) { if (A) *A = 8721; return TRUE; }
				if (Str__eq(entity, TL_IS_2037)) { if (A) *A = 9834; return TRUE; }
				if (Str__eq(entity, TL_IS_2038)) { if (A) *A = 185; return TRUE; }
				if (Str__eq(entity, TL_IS_2039)) { if (A) *A = 185; return TRUE; }
				if (Str__eq(entity, TL_IS_2040)) { if (A) *A = 178; return TRUE; }
				if (Str__eq(entity, TL_IS_2041)) { if (A) *A = 178; return TRUE; }
				if (Str__eq(entity, TL_IS_2042)) { if (A) *A = 179; return TRUE; }
				if (Str__eq(entity, TL_IS_2043)) { if (A) *A = 179; return TRUE; }
				if (Str__eq(entity, TL_IS_2044)) { if (A) *A = 8835; return TRUE; }
				if (Str__eq(entity, TL_IS_2045)) { if (A) *A = 10950; return TRUE; }
				if (Str__eq(entity, TL_IS_2046)) { if (A) *A = 10942; return TRUE; }
				if (Str__eq(entity, TL_IS_2047)) { if (A) *A = 10968; return TRUE; }
				if (Str__eq(entity, TL_IS_2048)) { if (A) *A = 8839; return TRUE; }
				if (Str__eq(entity, TL_IS_2049)) { if (A) *A = 10948; return TRUE; }
				if (Str__eq(entity, TL_IS_2050)) { if (A) *A = 10185; return TRUE; }
				if (Str__eq(entity, TL_IS_2051)) { if (A) *A = 10967; return TRUE; }
				if (Str__eq(entity, TL_IS_2052)) { if (A) *A = 10619; return TRUE; }
				if (Str__eq(entity, TL_IS_2053)) { if (A) *A = 10946; return TRUE; }
				if (Str__eq(entity, TL_IS_2054)) { if (A) *A = 10956; return TRUE; }
				if (Str__eq(entity, TL_IS_2055)) { if (A) *A = 8843; return TRUE; }
				if (Str__eq(entity, TL_IS_2056)) { if (A) *A = 10944; return TRUE; }
				if (Str__eq(entity, TL_IS_2057)) { if (A) *A = 8835; return TRUE; }
				if (Str__eq(entity, TL_IS_2058)) { if (A) *A = 8839; return TRUE; }
				if (Str__eq(entity, TL_IS_2059)) { if (A) *A = 10950; return TRUE; }
				if (Str__eq(entity, TL_IS_2060)) { if (A) *A = 8843; return TRUE; }
				if (Str__eq(entity, TL_IS_2061)) { if (A) *A = 10956; return TRUE; }
				if (Str__eq(entity, TL_IS_2062)) { if (A) *A = 10952; return TRUE; }
				if (Str__eq(entity, TL_IS_2063)) { if (A) *A = 10964; return TRUE; }
				if (Str__eq(entity, TL_IS_2064)) { if (A) *A = 10966; return TRUE; }
				if (Str__eq(entity, TL_IS_2065)) { if (A) *A = 8665; return TRUE; }
				if (Str__eq(entity, TL_IS_2066)) { if (A) *A = 10534; return TRUE; }
				if (Str__eq(entity, TL_IS_2067)) { if (A) *A = 8601; return TRUE; }
				if (Str__eq(entity, TL_IS_2068)) { if (A) *A = 8601; return TRUE; }
				if (Str__eq(entity, TL_IS_2069)) { if (A) *A = 10538; return TRUE; }
				if (Str__eq(entity, TL_IS_2070)) { if (A) *A = 223; return TRUE; }
				if (Str__eq(entity, TL_IS_2071)) { if (A) *A = 223; return TRUE; }
				break;
			case 't':
				if (Str__eq(entity, TL_IS_2072)) { if (A) *A = 8982; return TRUE; }
				if (Str__eq(entity, TL_IS_2073)) { if (A) *A = 964; return TRUE; }
				if (Str__eq(entity, TL_IS_2074)) { if (A) *A = 9140; return TRUE; }
				if (Str__eq(entity, TL_IS_2075)) { if (A) *A = 357; return TRUE; }
				if (Str__eq(entity, TL_IS_2076)) { if (A) *A = 355; return TRUE; }
				if (Str__eq(entity, TL_IS_2077)) { if (A) *A = 1090; return TRUE; }
				if (Str__eq(entity, TL_IS_2078)) { if (A) *A = 8411; return TRUE; }
				if (Str__eq(entity, TL_IS_2079)) { if (A) *A = 8981; return TRUE; }
				if (Str__eq(entity, TL_IS_2080)) { if (A) *A = 120113; return TRUE; }
				if (Str__eq(entity, TL_IS_2081)) { if (A) *A = 8756; return TRUE; }
				if (Str__eq(entity, TL_IS_2082)) { if (A) *A = 8756; return TRUE; }
				if (Str__eq(entity, TL_IS_2083)) { if (A) *A = 952; return TRUE; }
				if (Str__eq(entity, TL_IS_2084)) { if (A) *A = 977; return TRUE; }
				if (Str__eq(entity, TL_IS_2085)) { if (A) *A = 977; return TRUE; }
				if (Str__eq(entity, TL_IS_2086)) { if (A) *A = 8776; return TRUE; }
				if (Str__eq(entity, TL_IS_2087)) { if (A) *A = 8764; return TRUE; }
				if (Str__eq(entity, TL_IS_2088)) { if (A) *A = 8201; return TRUE; }
				if (Str__eq(entity, TL_IS_2089)) { if (A) *A = 8776; return TRUE; }
				if (Str__eq(entity, TL_IS_2090)) { if (A) *A = 8764; return TRUE; }
				if (Str__eq(entity, TL_IS_2091)) { if (A) *A = 254; return TRUE; }
				if (Str__eq(entity, TL_IS_2092)) { if (A) *A = 254; return TRUE; }
				if (Str__eq(entity, TL_IS_2093)) { if (A) *A = 732; return TRUE; }
				if (Str__eq(entity, TL_IS_2094)) { if (A) *A = 215; return TRUE; }
				if (Str__eq(entity, TL_IS_2095)) { if (A) *A = 215; return TRUE; }
				if (Str__eq(entity, TL_IS_2096)) { if (A) *A = 8864; return TRUE; }
				if (Str__eq(entity, TL_IS_2097)) { if (A) *A = 10801; return TRUE; }
				if (Str__eq(entity, TL_IS_2098)) { if (A) *A = 10800; return TRUE; }
				if (Str__eq(entity, TL_IS_2099)) { if (A) *A = 8749; return TRUE; }
				if (Str__eq(entity, TL_IS_2100)) { if (A) *A = 10536; return TRUE; }
				if (Str__eq(entity, TL_IS_2101)) { if (A) *A = 8868; return TRUE; }
				if (Str__eq(entity, TL_IS_2102)) { if (A) *A = 9014; return TRUE; }
				if (Str__eq(entity, TL_IS_2103)) { if (A) *A = 10993; return TRUE; }
				if (Str__eq(entity, TL_IS_2104)) { if (A) *A = 120165; return TRUE; }
				if (Str__eq(entity, TL_IS_2105)) { if (A) *A = 10970; return TRUE; }
				if (Str__eq(entity, TL_IS_2106)) { if (A) *A = 10537; return TRUE; }
				if (Str__eq(entity, TL_IS_2107)) { if (A) *A = 8244; return TRUE; }
				if (Str__eq(entity, TL_IS_2108)) { if (A) *A = 8482; return TRUE; }
				if (Str__eq(entity, TL_IS_2109)) { if (A) *A = 9653; return TRUE; }
				if (Str__eq(entity, TL_IS_2110)) { if (A) *A = 9663; return TRUE; }
				if (Str__eq(entity, TL_IS_2111)) { if (A) *A = 9667; return TRUE; }
				if (Str__eq(entity, TL_IS_2112)) { if (A) *A = 8884; return TRUE; }
				if (Str__eq(entity, TL_IS_2113)) { if (A) *A = 8796; return TRUE; }
				if (Str__eq(entity, TL_IS_2114)) { if (A) *A = 9657; return TRUE; }
				if (Str__eq(entity, TL_IS_2115)) { if (A) *A = 8885; return TRUE; }
				if (Str__eq(entity, TL_IS_2116)) { if (A) *A = 9708; return TRUE; }
				if (Str__eq(entity, TL_IS_2117)) { if (A) *A = 8796; return TRUE; }
				if (Str__eq(entity, TL_IS_2118)) { if (A) *A = 10810; return TRUE; }
				if (Str__eq(entity, TL_IS_2119)) { if (A) *A = 10809; return TRUE; }
				if (Str__eq(entity, TL_IS_2120)) { if (A) *A = 10701; return TRUE; }
				if (Str__eq(entity, TL_IS_2121)) { if (A) *A = 10811; return TRUE; }
				if (Str__eq(entity, TL_IS_2122)) { if (A) *A = 9186; return TRUE; }
				if (Str__eq(entity, TL_IS_2123)) { if (A) *A = 120009; return TRUE; }
				if (Str__eq(entity, TL_IS_2124)) { if (A) *A = 1094; return TRUE; }
				if (Str__eq(entity, TL_IS_2125)) { if (A) *A = 1115; return TRUE; }
				if (Str__eq(entity, TL_IS_2126)) { if (A) *A = 359; return TRUE; }
				if (Str__eq(entity, TL_IS_2127)) { if (A) *A = 8812; return TRUE; }
				if (Str__eq(entity, TL_IS_2128)) { if (A) *A = 8606; return TRUE; }
				if (Str__eq(entity, TL_IS_2129)) { if (A) *A = 8608; return TRUE; }
				break;
			case 'u':
				if (Str__eq(entity, TL_IS_2130)) { if (A) *A = 8657; return TRUE; }
				if (Str__eq(entity, TL_IS_2131)) { if (A) *A = 10595; return TRUE; }
				if (Str__eq(entity, TL_IS_2132)) { if (A) *A = 250; return TRUE; }
				if (Str__eq(entity, TL_IS_2133)) { if (A) *A = 250; return TRUE; }
				if (Str__eq(entity, TL_IS_2134)) { if (A) *A = 8593; return TRUE; }
				if (Str__eq(entity, TL_IS_2135)) { if (A) *A = 1118; return TRUE; }
				if (Str__eq(entity, TL_IS_2136)) { if (A) *A = 365; return TRUE; }
				if (Str__eq(entity, TL_IS_2137)) { if (A) *A = 251; return TRUE; }
				if (Str__eq(entity, TL_IS_2138)) { if (A) *A = 251; return TRUE; }
				if (Str__eq(entity, TL_IS_2139)) { if (A) *A = 1091; return TRUE; }
				if (Str__eq(entity, TL_IS_2140)) { if (A) *A = 8645; return TRUE; }
				if (Str__eq(entity, TL_IS_2141)) { if (A) *A = 369; return TRUE; }
				if (Str__eq(entity, TL_IS_2142)) { if (A) *A = 10606; return TRUE; }
				if (Str__eq(entity, TL_IS_2143)) { if (A) *A = 10622; return TRUE; }
				if (Str__eq(entity, TL_IS_2144)) { if (A) *A = 120114; return TRUE; }
				if (Str__eq(entity, TL_IS_2145)) { if (A) *A = 249; return TRUE; }
				if (Str__eq(entity, TL_IS_2146)) { if (A) *A = 249; return TRUE; }
				if (Str__eq(entity, TL_IS_2147)) { if (A) *A = 8639; return TRUE; }
				if (Str__eq(entity, TL_IS_2148)) { if (A) *A = 8638; return TRUE; }
				if (Str__eq(entity, TL_IS_2149)) { if (A) *A = 9600; return TRUE; }
				if (Str__eq(entity, TL_IS_2150)) { if (A) *A = 8988; return TRUE; }
				if (Str__eq(entity, TL_IS_2151)) { if (A) *A = 8988; return TRUE; }
				if (Str__eq(entity, TL_IS_2152)) { if (A) *A = 8975; return TRUE; }
				if (Str__eq(entity, TL_IS_2153)) { if (A) *A = 9720; return TRUE; }
				if (Str__eq(entity, TL_IS_2154)) { if (A) *A = 363; return TRUE; }
				if (Str__eq(entity, TL_IS_2155)) { if (A) *A = 168; return TRUE; }
				if (Str__eq(entity, TL_IS_2156)) { if (A) *A = 168; return TRUE; }
				if (Str__eq(entity, TL_IS_2157)) { if (A) *A = 371; return TRUE; }
				if (Str__eq(entity, TL_IS_2158)) { if (A) *A = 120166; return TRUE; }
				if (Str__eq(entity, TL_IS_2159)) { if (A) *A = 8593; return TRUE; }
				if (Str__eq(entity, TL_IS_2160)) { if (A) *A = 8597; return TRUE; }
				if (Str__eq(entity, TL_IS_2161)) { if (A) *A = 8639; return TRUE; }
				if (Str__eq(entity, TL_IS_2162)) { if (A) *A = 8638; return TRUE; }
				if (Str__eq(entity, TL_IS_2163)) { if (A) *A = 8846; return TRUE; }
				if (Str__eq(entity, TL_IS_2164)) { if (A) *A = 965; return TRUE; }
				if (Str__eq(entity, TL_IS_2165)) { if (A) *A = 978; return TRUE; }
				if (Str__eq(entity, TL_IS_2166)) { if (A) *A = 965; return TRUE; }
				if (Str__eq(entity, TL_IS_2167)) { if (A) *A = 8648; return TRUE; }
				if (Str__eq(entity, TL_IS_2168)) { if (A) *A = 8989; return TRUE; }
				if (Str__eq(entity, TL_IS_2169)) { if (A) *A = 8989; return TRUE; }
				if (Str__eq(entity, TL_IS_2170)) { if (A) *A = 8974; return TRUE; }
				if (Str__eq(entity, TL_IS_2171)) { if (A) *A = 367; return TRUE; }
				if (Str__eq(entity, TL_IS_2172)) { if (A) *A = 9721; return TRUE; }
				if (Str__eq(entity, TL_IS_2173)) { if (A) *A = 120010; return TRUE; }
				if (Str__eq(entity, TL_IS_2174)) { if (A) *A = 8944; return TRUE; }
				if (Str__eq(entity, TL_IS_2175)) { if (A) *A = 361; return TRUE; }
				if (Str__eq(entity, TL_IS_2176)) { if (A) *A = 9653; return TRUE; }
				if (Str__eq(entity, TL_IS_2177)) { if (A) *A = 9652; return TRUE; }
				if (Str__eq(entity, TL_IS_2178)) { if (A) *A = 8648; return TRUE; }
				if (Str__eq(entity, TL_IS_2179)) { if (A) *A = 252; return TRUE; }
				if (Str__eq(entity, TL_IS_2180)) { if (A) *A = 252; return TRUE; }
				if (Str__eq(entity, TL_IS_2181)) { if (A) *A = 10663; return TRUE; }
				break;
			case 'v':
				if (Str__eq(entity, TL_IS_2182)) { if (A) *A = 8661; return TRUE; }
				if (Str__eq(entity, TL_IS_2183)) { if (A) *A = 10984; return TRUE; }
				if (Str__eq(entity, TL_IS_2184)) { if (A) *A = 10985; return TRUE; }
				if (Str__eq(entity, TL_IS_2185)) { if (A) *A = 8872; return TRUE; }
				if (Str__eq(entity, TL_IS_2186)) { if (A) *A = 10652; return TRUE; }
				if (Str__eq(entity, TL_IS_2187)) { if (A) *A = 1013; return TRUE; }
				if (Str__eq(entity, TL_IS_2188)) { if (A) *A = 1008; return TRUE; }
				if (Str__eq(entity, TL_IS_2189)) { if (A) *A = 8709; return TRUE; }
				if (Str__eq(entity, TL_IS_2190)) { if (A) *A = 981; return TRUE; }
				if (Str__eq(entity, TL_IS_2191)) { if (A) *A = 982; return TRUE; }
				if (Str__eq(entity, TL_IS_2192)) { if (A) *A = 8733; return TRUE; }
				if (Str__eq(entity, TL_IS_2193)) { if (A) *A = 8597; return TRUE; }
				if (Str__eq(entity, TL_IS_2194)) { if (A) *A = 1009; return TRUE; }
				if (Str__eq(entity, TL_IS_2195)) { if (A) *A = 962; return TRUE; }
				if (Str__eq(entity, TL_IS_2196)) { if (A) *A = 8842; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2197)) { if (A) *A = 10955; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2198)) { if (A) *A = 8843; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2199)) { if (A) *A = 10956; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2200)) { if (A) *A = 977; return TRUE; }
				if (Str__eq(entity, TL_IS_2201)) { if (A) *A = 8882; return TRUE; }
				if (Str__eq(entity, TL_IS_2202)) { if (A) *A = 8883; return TRUE; }
				if (Str__eq(entity, TL_IS_2203)) { if (A) *A = 1074; return TRUE; }
				if (Str__eq(entity, TL_IS_2204)) { if (A) *A = 8866; return TRUE; }
				if (Str__eq(entity, TL_IS_2205)) { if (A) *A = 8744; return TRUE; }
				if (Str__eq(entity, TL_IS_2206)) { if (A) *A = 8891; return TRUE; }
				if (Str__eq(entity, TL_IS_2207)) { if (A) *A = 8794; return TRUE; }
				if (Str__eq(entity, TL_IS_2208)) { if (A) *A = 8942; return TRUE; }
				if (Str__eq(entity, TL_IS_2209)) { if (A) *A = 124; return TRUE; }
				if (Str__eq(entity, TL_IS_2210)) { if (A) *A = 124; return TRUE; }
				if (Str__eq(entity, TL_IS_2211)) { if (A) *A = 120115; return TRUE; }
				if (Str__eq(entity, TL_IS_2212)) { if (A) *A = 8882; return TRUE; }
				if (Str__eq(entity, TL_IS_2213)) { if (A) *A = 8834; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_2214)) { if (A) *A = 8835; if (B) *B = 8402; return TRUE; }
				if (Str__eq(entity, TL_IS_2215)) { if (A) *A = 120167; return TRUE; }
				if (Str__eq(entity, TL_IS_2216)) { if (A) *A = 8733; return TRUE; }
				if (Str__eq(entity, TL_IS_2217)) { if (A) *A = 8883; return TRUE; }
				if (Str__eq(entity, TL_IS_2218)) { if (A) *A = 120011; return TRUE; }
				if (Str__eq(entity, TL_IS_2219)) { if (A) *A = 10955; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2220)) { if (A) *A = 8842; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2221)) { if (A) *A = 10956; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2222)) { if (A) *A = 8843; if (B) *B = 65024; return TRUE; }
				if (Str__eq(entity, TL_IS_2223)) { if (A) *A = 10650; return TRUE; }
				break;
			case 'w':
				if (Str__eq(entity, TL_IS_2224)) { if (A) *A = 373; return TRUE; }
				if (Str__eq(entity, TL_IS_2225)) { if (A) *A = 10847; return TRUE; }
				if (Str__eq(entity, TL_IS_2226)) { if (A) *A = 8743; return TRUE; }
				if (Str__eq(entity, TL_IS_2227)) { if (A) *A = 8793; return TRUE; }
				if (Str__eq(entity, TL_IS_2228)) { if (A) *A = 8472; return TRUE; }
				if (Str__eq(entity, TL_IS_2229)) { if (A) *A = 120116; return TRUE; }
				if (Str__eq(entity, TL_IS_2230)) { if (A) *A = 120168; return TRUE; }
				if (Str__eq(entity, TL_IS_2231)) { if (A) *A = 8472; return TRUE; }
				if (Str__eq(entity, TL_IS_2232)) { if (A) *A = 8768; return TRUE; }
				if (Str__eq(entity, TL_IS_2233)) { if (A) *A = 8768; return TRUE; }
				if (Str__eq(entity, TL_IS_2234)) { if (A) *A = 120012; return TRUE; }
				break;
			case 'x':
				if (Str__eq(entity, TL_IS_2235)) { if (A) *A = 8898; return TRUE; }
				if (Str__eq(entity, TL_IS_2236)) { if (A) *A = 9711; return TRUE; }
				if (Str__eq(entity, TL_IS_2237)) { if (A) *A = 8899; return TRUE; }
				if (Str__eq(entity, TL_IS_2238)) { if (A) *A = 9661; return TRUE; }
				if (Str__eq(entity, TL_IS_2239)) { if (A) *A = 120117; return TRUE; }
				if (Str__eq(entity, TL_IS_2240)) { if (A) *A = 10234; return TRUE; }
				if (Str__eq(entity, TL_IS_2241)) { if (A) *A = 10231; return TRUE; }
				if (Str__eq(entity, TL_IS_2242)) { if (A) *A = 958; return TRUE; }
				if (Str__eq(entity, TL_IS_2243)) { if (A) *A = 10232; return TRUE; }
				if (Str__eq(entity, TL_IS_2244)) { if (A) *A = 10229; return TRUE; }
				if (Str__eq(entity, TL_IS_2245)) { if (A) *A = 10236; return TRUE; }
				if (Str__eq(entity, TL_IS_2246)) { if (A) *A = 8955; return TRUE; }
				if (Str__eq(entity, TL_IS_2247)) { if (A) *A = 10752; return TRUE; }
				if (Str__eq(entity, TL_IS_2248)) { if (A) *A = 120169; return TRUE; }
				if (Str__eq(entity, TL_IS_2249)) { if (A) *A = 10753; return TRUE; }
				if (Str__eq(entity, TL_IS_2250)) { if (A) *A = 10754; return TRUE; }
				if (Str__eq(entity, TL_IS_2251)) { if (A) *A = 10233; return TRUE; }
				if (Str__eq(entity, TL_IS_2252)) { if (A) *A = 10230; return TRUE; }
				if (Str__eq(entity, TL_IS_2253)) { if (A) *A = 120013; return TRUE; }
				if (Str__eq(entity, TL_IS_2254)) { if (A) *A = 10758; return TRUE; }
				if (Str__eq(entity, TL_IS_2255)) { if (A) *A = 10756; return TRUE; }
				if (Str__eq(entity, TL_IS_2256)) { if (A) *A = 9651; return TRUE; }
				if (Str__eq(entity, TL_IS_2257)) { if (A) *A = 8897; return TRUE; }
				if (Str__eq(entity, TL_IS_2258)) { if (A) *A = 8896; return TRUE; }
				break;
			case 'y':
				if (Str__eq(entity, TL_IS_2259)) { if (A) *A = 253; return TRUE; }
				if (Str__eq(entity, TL_IS_2260)) { if (A) *A = 253; return TRUE; }
				if (Str__eq(entity, TL_IS_2261)) { if (A) *A = 1103; return TRUE; }
				if (Str__eq(entity, TL_IS_2262)) { if (A) *A = 375; return TRUE; }
				if (Str__eq(entity, TL_IS_2263)) { if (A) *A = 1099; return TRUE; }
				if (Str__eq(entity, TL_IS_2264)) { if (A) *A = 165; return TRUE; }
				if (Str__eq(entity, TL_IS_2265)) { if (A) *A = 165; return TRUE; }
				if (Str__eq(entity, TL_IS_2266)) { if (A) *A = 120118; return TRUE; }
				if (Str__eq(entity, TL_IS_2267)) { if (A) *A = 1111; return TRUE; }
				if (Str__eq(entity, TL_IS_2268)) { if (A) *A = 120170; return TRUE; }
				if (Str__eq(entity, TL_IS_2269)) { if (A) *A = 120014; return TRUE; }
				if (Str__eq(entity, TL_IS_2270)) { if (A) *A = 1102; return TRUE; }
				if (Str__eq(entity, TL_IS_2271)) { if (A) *A = 255; return TRUE; }
				if (Str__eq(entity, TL_IS_2272)) { if (A) *A = 255; return TRUE; }
				break;
			case 'z':
				if (Str__eq(entity, TL_IS_2273)) { if (A) *A = 378; return TRUE; }
				if (Str__eq(entity, TL_IS_2274)) { if (A) *A = 382; return TRUE; }
				if (Str__eq(entity, TL_IS_2275)) { if (A) *A = 1079; return TRUE; }
				if (Str__eq(entity, TL_IS_2276)) { if (A) *A = 380; return TRUE; }
				if (Str__eq(entity, TL_IS_2277)) { if (A) *A = 8488; return TRUE; }
				if (Str__eq(entity, TL_IS_2278)) { if (A) *A = 950; return TRUE; }
				if (Str__eq(entity, TL_IS_2279)) { if (A) *A = 120119; return TRUE; }
				if (Str__eq(entity, TL_IS_2280)) { if (A) *A = 1078; return TRUE; }
				if (Str__eq(entity, TL_IS_2281)) { if (A) *A = 8669; return TRUE; }
				if (Str__eq(entity, TL_IS_2282)) { if (A) *A = 120171; return TRUE; }
				if (Str__eq(entity, TL_IS_2283)) { if (A) *A = 120015; return TRUE; }
				if (Str__eq(entity, TL_IS_2284)) { if (A) *A = 8205; return TRUE; }
				if (Str__eq(entity, TL_IS_2285)) { if (A) *A = 8204; return TRUE; }
				break;
		}
		return FALSE;
	}
}

#line 56 "inweb/foundation-module/Chapter 5/Markdown.w"
int tracing_Markdown_parser = FALSE;
void Markdown__set_tracing(int state) {
	tracing_Markdown_parser = state;
}

#line 99 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item *Markdown__parse(text_stream *text) {
	return Markdown__parse_general(NULL, text, NULL, TRUE, TRUE, NULL);
}

markdown_item *Markdown__parse_using(text_stream *text, md_links_dictionary *dict) {
	return Markdown__parse_general(NULL, text, dict, TRUE, TRUE, NULL);
}

markdown_item *Markdown__parse_block_structure(text_stream *text) {
	return Markdown__parse_general(NULL, text, NULL, TRUE, FALSE, NULL);
}

markdown_item *Markdown__parse_block_structure_using(text_stream *text,
	md_links_dictionary *dict) {
	return Markdown__parse_general(NULL, text, dict, TRUE, FALSE, NULL);
}

markdown_item *Markdown__parse_inline(text_stream *text) {
	return Markdown__parse_general(NULL, text, NULL, FALSE, TRUE, NULL);
}

markdown_item *Markdown__parse_inline_using(text_stream *text, md_links_dictionary *dict) {
	return Markdown__parse_general(NULL, text, dict, FALSE, TRUE, NULL);
}

markdown_item *Markdown__parse_all_blocks_inline(markdown_item *tree, text_stream *text) {
	return Markdown__parse_general(tree, text, NULL, FALSE, TRUE, NULL);
}

markdown_item *Markdown__parse_all_blocks_inline_using(markdown_item *tree,
	text_stream *text, md_links_dictionary *dict) {
	return Markdown__parse_general(tree, text, dict, FALSE, TRUE, NULL);
}

markdown_item *Markdown__parse_extended(text_stream *text, markdown_variation *variation) {
	return Markdown__parse_general(NULL, text, NULL, TRUE, TRUE, variation);
}

markdown_item *Markdown__parse_using_extended(text_stream *text, md_links_dictionary *dict,
	markdown_variation *variation) {
	return Markdown__parse_general(NULL, text, dict, TRUE, TRUE, variation);
}

markdown_item *Markdown__parse_block_structure_extended(text_stream *text,
	markdown_variation *variation) {
	return Markdown__parse_general(NULL, text, NULL, TRUE, FALSE, variation);
}

markdown_item *Markdown__parse_block_structure_using_extended(text_stream *text,
	md_links_dictionary *dict, markdown_variation *variation) {
	return Markdown__parse_general(NULL, text, dict, TRUE, FALSE, variation);
}

markdown_item *Markdown__parse_inline_extended(text_stream *text,
	markdown_variation *variation) {
	return Markdown__parse_general(NULL, text, NULL, FALSE, TRUE, variation);
}

markdown_item *Markdown__parse_inline_using_extended(text_stream *text,
	md_links_dictionary *dict, markdown_variation *variation) {
	return Markdown__parse_general(NULL, text, dict, FALSE, TRUE, variation);
}

markdown_item *Markdown__parse_all_blocks_inline_extended(markdown_item *tree,
	text_stream *text, markdown_variation *variation) {
	return Markdown__parse_general(tree, text, NULL, FALSE, TRUE, variation);
}

markdown_item *Markdown__parse_all_blocks_inline_using_extended(markdown_item *tree,
	text_stream *text, md_links_dictionary *dict, markdown_variation *variation) {
	return Markdown__parse_general(tree, text, dict, FALSE, TRUE, variation);
}

#line 176 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item *Markdown__parse_general(markdown_item *tree, text_stream *text,
	md_links_dictionary *dict, int phase_I, int phase_II, markdown_variation *variation) {
	if (variation == NULL) variation = MarkdownVariations__CommonMark();
	if (tracing_Markdown_parser) PRINT("Syntax variation: %S\n", variation->name);
	int tree_supplied = TRUE;
	if (tree == NULL) { tree_supplied = FALSE; tree = Markdown__new_item(DOCUMENT_MIT); }
	if (phase_I) {
		if (tracing_Markdown_parser) PRINT("Markdown parse, phase I\n");
		if (dict == NULL) dict = Markdown__new_links_dictionary();
		md_doc_state *state = MDBlockParser__initialise(variation, tree, dict);
		
{
#line 223 "inweb/foundation-module/Chapter 5/Markdown.w"
	TEMPORARY_TEXT(line)
	LOOP_THROUGH_TEXT(pos, text) {
		inchar32_t c = Str__get(pos);
		if (c == '\n') {
			MDBlockParser__add_to_document(state, line);
			Str__clear(line);
		} else {
			PUT_TO(line, c);
		}
	}
	if (Str__len(line) > 0) MDBlockParser__add_to_document(state, line);
	MDBlockParser__close_block(state, tree);
	if (tracing_Markdown_parser) PRINT("======\nGathering lists\n");
	MDBlockParser__gather_lists(state, tree);
	MDBlockParser__propagate_white_space_follows(state, tree);
	if (MarkdownVariations__supports(state->variation, TASK_LIST_ITEMS_MARKDOWNFEATURE))
		MDBlockParser__task_list_items(state, tree);
	MarkdownVariations__intervene_after_Phase_I(variation, tree, dict);
	MarkdownVariations__multifile_mode(variation, tree, dict);

}
#line 186 "inweb/foundation-module/Chapter 5/Markdown.w"
;
		if (tracing_Markdown_parser) {
			PRINT("Tree at end of phase I:\n");
			Markdown__debug_subtree(STDOUT, tree);
			PRINT("======\nPhase II\n");
		}
	} else {
		if (text != NULL) {
			tree->down = Markdown__new_item(PARAGRAPH_MIT);
			tree->down->stashed = Str__duplicate(text);
		}
	}
	if (phase_II) {
		if (tracing_Markdown_parser) PRINT("Markdown parse, phase II\n");
		
{
#line 247 "inweb/foundation-module/Chapter 5/Markdown.w"
	MDInlineParser__inline_recursion(variation, dict, tree);
	MarkdownVariations__intervene_after_Phase_II(variation, tree, dict);

}
#line 200 "inweb/foundation-module/Chapter 5/Markdown.w"
;
		if (tracing_Markdown_parser) {
			PRINT("======\nTree at end of phase II:\n");
			Markdown__debug_subtree(STDOUT, tree);
		}
	}
	if (tracing_Markdown_parser) PRINT("======\n");
	if (tree_supplied) return tree; /* i.e., the same tree we were given */
	if ((phase_I == FALSE) && (phase_II == TRUE))
		return tree->down->down;    /* i.e., just the |MATERIAL_MIT| subtree */
	return tree;                    /* i.e., the whole tree we made */
}

#line 253 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__render(OUTPUT_STREAM, markdown_item *tree) {
	MDRenderer__render_extended(OUT, tree, MarkdownVariations__CommonMark());
}

void Markdown__render_extended(OUTPUT_STREAM, markdown_item *tree,
	markdown_variation *variation) {
	MDRenderer__render_extended(OUT, tree, variation);
}

#line 275 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 285 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 297 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 303 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 309 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 313 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 317 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 320 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 325 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 334 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 338 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_type_metadata markdown_type_metadata_registry[NO_DEFINED_MIT_VALUES+1];

#line 348 "inweb/foundation-module/Chapter 5/Markdown.w"

void Markdown__new_item_type(int mit, text_stream *name) {
	markdown_type_metadata_registry[mit].name = Str__duplicate(name);
	markdown_type_metadata_registry[mit].is_container = FALSE;
	markdown_type_metadata_registry[mit].is_block = FALSE;
	markdown_type_metadata_registry[mit].is_inline = FALSE;
	markdown_type_metadata_registry[mit].is_plainish = FALSE;
	markdown_type_metadata_registry[mit].is_quasiplainish = FALSE;
}

void Markdown__new_container_block_type(int mit, text_stream *name) {
	Markdown__new_item_type(mit, name);
	markdown_type_metadata_registry[mit].is_container = TRUE;
	markdown_type_metadata_registry[mit].is_block = TRUE;
}

void Markdown__new_leaf_block_type(int mit, text_stream *name) {
	Markdown__new_item_type(mit, name);
	markdown_type_metadata_registry[mit].is_block = TRUE;
}

void Markdown__new_inline_type(int mit, text_stream *name) {
	Markdown__new_item_type(mit, name);
	markdown_type_metadata_registry[mit].is_inline = TRUE;
}

void Markdown__new_plainish_inline_type(int mit, text_stream *name) {
	Markdown__new_item_type(mit, name);
	markdown_type_metadata_registry[mit].is_inline = TRUE;
	markdown_type_metadata_registry[mit].is_plainish = TRUE;
	markdown_type_metadata_registry[mit].is_quasiplainish = TRUE;
}

void Markdown__new_quasiplainish_inline_type(int mit, text_stream *name) {
	Markdown__new_item_type(mit, name);
	markdown_type_metadata_registry[mit].is_inline = TRUE;
	markdown_type_metadata_registry[mit].is_quasiplainish = TRUE;
}

void Markdown__create_item_types(void) {
	for (int mit = 1; mit <= NO_DEFINED_MIT_VALUES; mit++)
		Markdown__new_item_type(mit, TL_IS_2286);

	Markdown__new_container_block_type(DOCUMENT_MIT, TL_IS_2287);
	Markdown__new_container_block_type(FILE_MIT, TL_IS_2288);

	Markdown__new_container_block_type(BLOCK_QUOTE_MIT, TL_IS_2289);
	Markdown__new_container_block_type(UNORDERED_LIST_MIT, TL_IS_2290);
	Markdown__new_container_block_type(ORDERED_LIST_MIT, TL_IS_2291);
	Markdown__new_container_block_type(UNORDERED_LIST_ITEM_MIT, TL_IS_2292);
	Markdown__new_container_block_type(ORDERED_LIST_ITEM_MIT, TL_IS_2293);

	Markdown__new_leaf_block_type(PARAGRAPH_MIT, TL_IS_2294);
	Markdown__new_leaf_block_type(THEMATIC_MIT, TL_IS_2295);
	Markdown__new_leaf_block_type(HEADING_MIT, TL_IS_2296);
	Markdown__new_leaf_block_type(CODE_BLOCK_MIT, TL_IS_2297);
	Markdown__new_leaf_block_type(HTML_MIT, TL_IS_2298);
	Markdown__new_leaf_block_type(EMPTY_MIT, TL_IS_2299);

	Markdown__new_inline_type(MATERIAL_MIT, TL_IS_2300);

	Markdown__new_plainish_inline_type(PLAIN_MIT, TL_IS_2301);
	Markdown__new_plainish_inline_type(LINE_BREAK_MIT, TL_IS_2302);
	Markdown__new_plainish_inline_type(SOFT_BREAK_MIT, TL_IS_2303);

	Markdown__new_quasiplainish_inline_type(INLINE_HTML_MIT, TL_IS_2304);

	Markdown__new_inline_type(EMPHASIS_MIT, TL_IS_2305);
	Markdown__new_inline_type(STRONG_MIT, TL_IS_2306);
	Markdown__new_inline_type(CODE_MIT, TL_IS_2307);
	Markdown__new_inline_type(URI_AUTOLINK_MIT, TL_IS_2308);
	Markdown__new_inline_type(EMAIL_AUTOLINK_MIT, TL_IS_2309);
	Markdown__new_inline_type(LINK_MIT, TL_IS_2310);
	Markdown__new_inline_type(IMAGE_MIT, TL_IS_2311);
	Markdown__new_inline_type(LINK_DEST_MIT, TL_IS_2312);
	Markdown__new_inline_type(LINK_TITLE_MIT, TL_IS_2313);

	Markdown__new_leaf_block_type(TABLE_MIT, TL_IS_2314);
	Markdown__new_leaf_block_type(TABLE_COLUMN_MIT, TL_IS_2315);
	Markdown__new_leaf_block_type(TABLE_ROW_MIT, TL_IS_2316);
	Markdown__new_inline_type(STRIKETHROUGH_MIT, TL_IS_2317);
	Markdown__new_leaf_block_type(TICKBOX_MIT, TL_IS_2318);
	Markdown__new_inline_type(XMPP_AUTOLINK_MIT, TL_IS_2319);
}

text_stream *Markdown__item_type_name(int t) {
	if ((t<1) || (t>NO_DEFINED_MIT_VALUES)) return TL_IS_2320;
	return markdown_type_metadata_registry[t].name;
}

int Markdown__item_type_container_block(int t) {
	if ((t<1) || (t>NO_DEFINED_MIT_VALUES)) return FALSE;
	return markdown_type_metadata_registry[t].is_container;
}

int Markdown__item_type_leaf_block(int t) {
	if ((t<1) || (t>NO_DEFINED_MIT_VALUES)) return FALSE;
	return ((markdown_type_metadata_registry[t].is_container == FALSE) &&
			(markdown_type_metadata_registry[t].is_block));
}

#line 452 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__item_type_inline(int t) {
	if ((t<1) || (t>NO_DEFINED_MIT_VALUES)) return FALSE;
	return markdown_type_metadata_registry[t].is_inline;
}

#line 460 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__plainish(markdown_item *md) {
	if (md) return Markdown__item_type_plainish(md->type);
	return FALSE;
}

int Markdown__item_type_plainish(int t) {
	if ((t<1) || (t>NO_DEFINED_MIT_VALUES)) return FALSE;
	return markdown_type_metadata_registry[t].is_plainish;
}

#line 473 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__quasi_plainish(markdown_item *md) {
	if (md) return Markdown__item_type_quasi_plainish(md->type);
	return FALSE;
}

int Markdown__item_type_quasi_plainish(int t) {
	if ((t<1) || (t>NO_DEFINED_MIT_VALUES)) return FALSE;
	return markdown_type_metadata_registry[t].is_quasiplainish;
}

#line 517 "inweb/foundation-module/Chapter 5/Markdown.w"

int md_ids = 1;
markdown_item *Markdown__new_item(int type) {
	markdown_item *md = CREATE(markdown_item);
	md->type = type;

	md->open = NOT_APPLICABLE;
	md->copied_from = NULL;

	md->info_string = NULL;
	md->details = 0;

	md->sliced_from = NULL; md->from = 0; md->to = -1;
	md->stashed = NULL;

	md->next = NULL; md->down = NULL;
	md->whitespace_follows = FALSE;

	md->user_state = NULL_GENERAL_POINTER;

	md->cycle_count = 0;
	md->id = md_ids++;
	return md;
}

#line 546 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item *Markdown__deep_copy(markdown_item *md) {
	if (md == NULL) internal_error("cannot copy null node");
	if (Markdown__item_type_inline(md->type) == FALSE)
		internal_error("can only copy inline nodes");
	markdown_item *copied = Markdown__new_item(md->type);
	if (Str__len(md->sliced_from) > 0) {
		copied->sliced_from = Str__duplicate(md->sliced_from);
	}
	copied->from = md->from;
	copied->to = md->to;
	copied->copied_from = md;
	for (markdown_item *c = md->down; c; c = c->next)
		Markdown__add_to(Markdown__deep_copy(c), copied);
	return copied;
}

#line 565 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__add_to(markdown_item *md, markdown_item *owner) {
	md->next = NULL;
	if (owner->down == NULL) { owner->down = md; return; }
	for (markdown_item *ch = owner->down; ch; ch = ch->next)
		if (ch->next == NULL) { ch->next = md; return; }
}

#line 575 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_heading_level(markdown_item *md) {
	if ((md == NULL) || (md->type != HEADING_MIT)) return 0;
	return md->details;
}

void Markdown__set_heading_level(markdown_item *md, int L) {
	if ((md == NULL) || (md->type != HEADING_MIT)) internal_error("not a heading");
	if ((L < 1) || (L > 6)) internal_error("bad heading level");
	md->details = L;
}

#line 589 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_column_count(markdown_item *md) {
	if ((md == NULL) || (md->type != TABLE_MIT)) return 0;
	return md->details;
}

void Markdown__set_column_count(markdown_item *md, int L) {
	if ((md == NULL) || (md->type != TABLE_MIT)) internal_error("not a table");
	if (L < 1) internal_error("bad column count");
	md->details = L;
}

#line 603 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_alignment(markdown_item *md) {
	if ((md == NULL) || (md->type != TABLE_COLUMN_MIT)) return 0;
	return md->details;
}

void Markdown__set_alignment(markdown_item *md, int L) {
	if ((md == NULL) || (md->type != TABLE_COLUMN_MIT)) internal_error("not a table col");
	if ((L < 0) || (L > 3)) internal_error("bad alignment");
	md->details = L;
}

#line 617 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_filtered_state(markdown_item *md) {
	if ((md == NULL) || (md->type != INLINE_HTML_MIT)) return FALSE;
	return md->details;
}

void Markdown__set_filtered_state(markdown_item *md, int L) {
	if ((md == NULL) || (md->type != INLINE_HTML_MIT)) internal_error("not inline HTML");
	if ((L != FALSE) && (L != TRUE)) internal_error("bad filtered state");
	md->details = L;
}

int Markdown__tag_should_be_filtered(text_stream *tag) {
	if (Str__eq_insensitive(tag, TL_IS_2321)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2322)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2323)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2324)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2325)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2326)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2327)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2328)) return TRUE;
	if (Str__eq_insensitive(tag, TL_IS_2329)) return TRUE;
	return FALSE;
}

#line 644 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_add_protocol_state(markdown_item *md) {
	if ((md == NULL) ||
		((md->type != URI_AUTOLINK_MIT) && (md->type != EMAIL_AUTOLINK_MIT) && (md->type != XMPP_AUTOLINK_MIT)))
		return FALSE;
	return md->details;
}

void Markdown__set_add_protocol_state(markdown_item *md, int L) {
	if ((md == NULL) ||
		((md->type != URI_AUTOLINK_MIT) && (md->type != EMAIL_AUTOLINK_MIT) && (md->type != XMPP_AUTOLINK_MIT)))
		internal_error("not an autolink");
	if ((L != FALSE) && (L != TRUE)) internal_error("bad add http state");
	md->details = L;
}

#line 662 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_tick_state(markdown_item *md) {
	if ((md == NULL) || (md->type != TICKBOX_MIT)) return FALSE;
	return md->details;
}

void Markdown__set_tick_state(markdown_item *md, int L) {
	if ((md == NULL) || (md->type != TICKBOX_MIT)) internal_error("not a tickbox");
	if ((L != FALSE) && (L != TRUE)) internal_error("bad tick state");
	md->details = L;
}

#line 677 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_backtick_count(markdown_item *md) {
	if ((md == NULL) || (md->type != CODE_MIT)) return FALSE;
	return md->details;
}

void Markdown__set_backtick_count(markdown_item *md, int L) {
	if ((md == NULL) || (md->type != CODE_MIT)) internal_error("not a code item");
	if (L < 0) internal_error("bad backtick count");
	md->details = L;
}

#line 691 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__get_item_number(markdown_item *md) {
	if ((md == NULL) || (md->type != ORDERED_LIST_ITEM_MIT)) return 0;
	if (md->details < 0) return -(md->details+1);
	return md->details;
}

inchar32_t Markdown__get_item_flavour(markdown_item *md) {
	if ((md == NULL) ||
		((md->type != ORDERED_LIST_ITEM_MIT) && (md->type != UNORDERED_LIST_ITEM_MIT)))
		return 0;
	if (md->type == ORDERED_LIST_ITEM_MIT) {
		if (md->details >= 0) return ')';
		return '.';
	}
	return (inchar32_t) md->details;
}

void Markdown__set_item_number_and_flavour(markdown_item *md, int L, inchar32_t f) {
	if (md->type == ORDERED_LIST_ITEM_MIT) {
		if (L < 0) internal_error("bad list item number");
		if (f == ')') md->details = L;
		else md->details = -1 - L;
	}
	if (md->type == UNORDERED_LIST_ITEM_MIT) {
		if (L != 0) internal_error("inappropriate list item number");
		md->details = (int)f;
	}
}

#line 728 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t Markdown__get_unescaped(md_charpos pos, int offset) {
	inchar32_t c = Markdown__get_offset(pos, offset);
	int preceding_backslashes = 0;
	while (Markdown__get_offset(pos, offset - 1 - preceding_backslashes) == '\\')
		preceding_backslashes++;
	if (preceding_backslashes % 2 == 1) return 'a';
	return c;
}

#line 741 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__unescaped_run(md_charpos pos, inchar32_t of) {
	int count = 0;
	while (Markdown__get_unescaped(pos, count) == of) count++;
	if (Markdown__get_unescaped(pos, -1) == of) count = 0;
	return count;
}

#line 751 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item *Markdown__new_file_marker(filename *F) {
	markdown_item *md = Markdown__new_item(FILE_MIT);
	md->user_state = STORE_POINTER_filename(F);
	return md;
}

filename *Markdown__get_filename(markdown_item *md) {
	if ((md == NULL) || (md->type != FILE_MIT)) return NULL;
	return RETRIEVE_POINTER_filename(md->user_state);
}

#line 769 "inweb/foundation-module/Chapter 5/Markdown.w"
markdown_item *Markdown__new_slice(int type, text_stream *text, int from, int to) {
	markdown_item *md = Markdown__new_item(type);
	md->sliced_from = text;
	md->from = from;
	md->to = to;
	return md;
}

#line 783 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t Markdown__get_at(markdown_item *md, int at) {
	if (md == NULL) return 0;
	if (Str__len(md->sliced_from) == 0) return 0;
	return Str__get_at(md->sliced_from, at);
}

#line 794 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__width(markdown_item *md) {
	if (md) {
		int width = 0;
		if (md->type == PLAIN_MIT) {
			for (int i=md->from; i<=md->to; i++) {
				inchar32_t c = Markdown__get_at(md, i);
				if (c == '\\') i++;
				width++;
			}
		}
		if ((md->type == CODE_MIT) || (md->type == URI_AUTOLINK_MIT) ||
			(md->type == EMAIL_AUTOLINK_MIT) || (md->type == INLINE_HTML_MIT)) {
			for (int i=md->from; i<=md->to; i++) {
				width++;
			}
		}
		if (md->type == LINE_BREAK_MIT) width++;
		if (md->type == SOFT_BREAK_MIT) width++;
		for (markdown_item *c = md->down; c; c = c->next)
			width += Markdown__width(c);
		return width;
	}
	return 0;
}

#line 829 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 833 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos Markdown__nowhere(void) {
	md_charpos pos;
	pos.md = NULL;
	pos.at = -1;
	return pos;
}

md_charpos Markdown__pos(markdown_item *md, int at) {
	if (md == NULL) return Markdown__nowhere();
	md_charpos pos;
	pos.md = md;
	pos.at = at;
	return pos;
}

int Markdown__somewhere(md_charpos pos) {
	if (pos.md) return TRUE;
	return FALSE;
}

#line 856 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__pos_eq(md_charpos A, md_charpos B) {
	if ((A.md) && (A.md == B.md) && (A.at == B.at)) return TRUE;
	if ((A.md == NULL) && (B.md == NULL)) return TRUE;
	return FALSE;
}

#line 867 "inweb/foundation-module/Chapter 5/Markdown.w"
int Markdown__is_in(md_charpos pos, markdown_item *md) {
	if ((Markdown__somewhere(pos)) && (md)) {
		if ((md->sliced_from) && (md->sliced_from == pos.md->sliced_from) &&
			(pos.at >= md->from) && (pos.at <= md->to)) return TRUE;
	}
	return FALSE;
}

#line 879 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos Markdown__left_edge_of(markdown_item *md) {
	if (md == NULL) return Markdown__nowhere();
	return Markdown__pos(md, md->from);
}

#line 889 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos Markdown__advance(md_charpos pos) {
	if (Markdown__somewhere(pos)) {
		if (pos.at < pos.md->to) { pos.at++; return pos; }
		pos.md = pos.md->next;
		while ((pos.md) && (Markdown__plainish(pos.md) == FALSE)) pos.md = pos.md->next;
		if (pos.md) { pos.at = pos.md->from; return pos; }
	}
	return Markdown__nowhere();
}

#line 902 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos Markdown__advance_plainish_only(md_charpos pos) {
	if (Markdown__somewhere(pos)) {
		if (pos.at < pos.md->to) { pos.at++; return pos; }
		pos.md = pos.md->next;
		if ((pos.md) && (Markdown__plainish(pos.md))) { pos.at = pos.md->from; return pos; }
	}
	return Markdown__nowhere();
}

#line 914 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos Markdown__advance_quasi_plainish_only(md_charpos pos) {
	if (Markdown__somewhere(pos)) {
		if (pos.at < pos.md->to) { pos.at++; return pos; }
		pos.md = pos.md->next;
		if ((pos.md) && (Markdown__quasi_plainish(pos.md))) { pos.at = pos.md->from; return pos; }
	}
	return Markdown__nowhere();
}

#line 926 "inweb/foundation-module/Chapter 5/Markdown.w"
md_charpos Markdown__advance_up_to(md_charpos pos, md_charpos end) {
	if ((Markdown__somewhere(end)) &&
		(pos.md->sliced_from == end.md->sliced_from) && (pos.at >= end.at))
		return Markdown__nowhere();
	return Markdown__advance(pos);
}

md_charpos Markdown__advance_up_to_plainish_only(md_charpos pos, md_charpos end) {
	if ((Markdown__somewhere(end)) &&
		(pos.md->sliced_from == end.md->sliced_from) && (pos.at >= end.at))
		return Markdown__nowhere();
	return Markdown__advance_plainish_only(pos);
}

md_charpos Markdown__advance_up_to_quasi_plainish_only(md_charpos pos, md_charpos end) {
	if ((Markdown__somewhere(end)) &&
		(pos.md->sliced_from == end.md->sliced_from) && (pos.at >= end.at))
		return Markdown__nowhere();
	return Markdown__advance_quasi_plainish_only(pos);
}

#line 950 "inweb/foundation-module/Chapter 5/Markdown.w"
inchar32_t Markdown__get(md_charpos pos) {
	return Markdown__get_offset(pos, 0);
}

inchar32_t Markdown__get_offset(md_charpos pos, int by) {
	if (Markdown__somewhere(pos)) return Markdown__get_at(pos.md, pos.at + by);
	return 0;
}

void Markdown__put(md_charpos pos, inchar32_t c) {
	Markdown__put_offset(pos, 0, c);
}

void Markdown__put_offset(md_charpos pos, int by, inchar32_t c) {
	if (Markdown__somewhere(pos)) Str__put_at(pos.md->sliced_from, pos.at + by, c);
}

#line 976 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__cut_to_just_before(markdown_item *chain_from, md_charpos cut_point,
	markdown_item **left_segment, markdown_item **right_segment) {
	markdown_item *L = chain_from, *R = NULL;
	if ((chain_from) && (Markdown__somewhere(cut_point))) {
		markdown_item *md, *md_prev = NULL;
		for (md = chain_from; (md) && (Markdown__is_in(cut_point, md) == FALSE);
			md_prev = md, md = md->next) ;
		if (md) {
			if (cut_point.at <= md->from) {
				if (md_prev) md_prev->next = NULL; else L = NULL;
				R = md;
			} else {
				int old_to = md->to;
				md->to = cut_point.at - 1;
				markdown_item *splinter =
					Markdown__new_slice(md->type, md->sliced_from, cut_point.at, old_to);
				splinter->next = md->next;
				md->next = NULL;
				R = splinter;
			}
		}
	}
	if (left_segment) *left_segment = L;
	if (right_segment) *right_segment = R;
}

#line 1006 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__cut_to_just_at(markdown_item *chain_from, md_charpos cut_point,
	markdown_item **left_segment, markdown_item **right_segment) {
	markdown_item *L = chain_from, *R = NULL;
	if ((chain_from) && (Markdown__somewhere(cut_point))) {
		markdown_item *md, *md_prev = NULL;
		for (md = chain_from; (md) && (Markdown__is_in(cut_point, md) == FALSE);
			md_prev = md, md = md->next) ;
		if (md) {
			if (cut_point.at >= md->to) {
				R = md->next;
				md->next = NULL;
			} else {
				int old_to = md->to;
				md->to = cut_point.at;
				markdown_item *splinter =
					Markdown__new_slice(md->type, md->sliced_from, cut_point.at + 1, old_to);
				splinter->next = md->next;
				md->next = NULL;
				R = splinter;
			}
		}
	}
	if (left_segment) *left_segment = L;
	if (right_segment) *right_segment = R;
}

#line 1036 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__cut_interval(markdown_item *chain_from, md_charpos A, md_charpos B,
	markdown_item **left_segment, markdown_item **middle_segment, markdown_item **right_segment) {
	markdown_item *interstitial = NULL;
	Markdown__cut_to_just_before(chain_from, A, left_segment, &interstitial);
	Markdown__cut_to_just_at(interstitial, B, &interstitial, right_segment);
	if (middle_segment) *middle_segment = interstitial;
}

#line 1054 "inweb/foundation-module/Chapter 5/Markdown.w"

#line 1060 "inweb/foundation-module/Chapter 5/Markdown.w"

md_links_dictionary *Markdown__new_links_dictionary(void) {
	md_links_dictionary *dict = CREATE(md_links_dictionary);
	dict->dict = Dictionaries__new(32, FALSE); /* of |md_link_dictionary_entry| */
	return dict;
}

#line 1074 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__create(md_links_dictionary *dict, text_stream *label,
	text_stream *destination, text_stream *title) {
	if (dict) {
		Markdown__normalise_link_label(label);
		if (tracing_Markdown_parser) {
			PRINT("[%S] := %S", label, destination);
			if (Str__len(title) > 0) PRINT(" with title %S", title);
			PRINT("\n");
		}
		md_link_dictionary_entry *link_ref = CREATE(md_link_dictionary_entry);
		link_ref->destination = Str__duplicate(destination);
		link_ref->title = Str__duplicate(title);
		if (Dictionaries__find(dict->dict, label) == NULL) {
			dict_entry *de = Dictionaries__create(dict->dict, label);
			if (de) de->value = link_ref;
		}
	}
}

#line 1097 "inweb/foundation-module/Chapter 5/Markdown.w"
md_link_dictionary_entry *Markdown__look_up(md_links_dictionary *dict, text_stream *label) {
	if (dict == NULL) return NULL;
	if (Str__is_whitespace(label)) return NULL;
	if (Str__len(label) > 999) return NULL;
	if (tracing_Markdown_parser) PRINT("Looking up reference '%S' -> ", label);
	Markdown__normalise_link_label(label);
	if (tracing_Markdown_parser) PRINT("'%S'\n", label);
	dict_entry *de = Dictionaries__find(dict->dict, label);
	if (de) return (md_link_dictionary_entry *) Dictionaries__value_for_entry(de);
	return NULL;
}

#line 1118 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__normalise_link_label(text_stream *label) {
	TEMPORARY_TEXT(normal)
	for (int i=0, ws = FALSE; i<Str__len(label); i++) {
		inchar32_t c = Str__get_at(label, i);
		if ((c == ' ') || (c == '\t') || (c == '\n')) {
			ws = TRUE; continue;
		} else if (ws) {
			PUT_TO(normal, ' ');
		}
		ws = FALSE;
		inchar32_t F[4];
		Characters__full_Unicode_fold(c, F);
		for (int j=0; j<4; j++) if (F[j]) PUT_TO(normal, F[j]);
	}
	Str__clear(label); WRITE_TO(label, "%S", normal);
	DISCARD_TEXT(normal)
}

#line 1141 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__debug_char(OUTPUT_STREAM, inchar32_t c) {
	switch (c) {
		case 0:    WRITE("NULL"); break;
		case '\n': WRITE("NEWLINE"); break;
		case '\t': WRITE("TAB"); break;
		case ' ':  WRITE("SPACE"); break;
		case 0xA0: WRITE("NONBREAKING-SPACE"); break;
		default:   WRITE("'%c'", c); break;
	}
}

void Markdown__debug_char_briefly(OUTPUT_STREAM, inchar32_t c) {
	switch (c) {
		case 0:    WRITE("\\x0000"); break;
		case '\n': WRITE("\\n"); break;
		case '\t': WRITE("\\t"); break;
		case '\\': WRITE("\\\\"); break;
		default:   WRITE("%c", c); break;
	}
}

void Markdown__debug_pos(OUTPUT_STREAM, md_charpos A) {
	if (Markdown__somewhere(A) == FALSE) { WRITE("{nowhere}"); return; }
	WRITE("{");
	Markdown__debug_item(OUT, A.md);
	WRITE(" at %d = ", A.at);
	Markdown__debug_char(OUT, Markdown__get(A));
	WRITE("}");
}

void Markdown__debug_interval(OUTPUT_STREAM, md_charpos A, md_charpos B) {
	if (Markdown__somewhere(A) == FALSE) { WRITE("NONE\n"); return; }
	WRITE("[");
	Markdown__debug_pos(OUT, A);
	WRITE("...");
	Markdown__debug_pos(OUT, B);
	WRITE(" - ");
	for (md_charpos pos = A; Markdown__somewhere(pos); pos = Markdown__advance(pos)) {
		Markdown__debug_char(OUT, Markdown__get(pos));
		if (Markdown__pos_eq(pos, B)) break;
		WRITE(",");
	}
	WRITE("]\n");
}

void Markdown__debug_item(OUTPUT_STREAM, markdown_item *md) {
	if (md == NULL) { WRITE("<no-item>"); return; }
	if (md->open == TRUE) WRITE("*");
	if (md->open == FALSE) WRITE(".");
	WRITE("%S-", Markdown__item_type_name(md->type));
	WRITE("M%d", md->id);
	if (md->copied_from) WRITE("<-M%d", md->copied_from->id);
	if (md->sliced_from) {
		WRITE("(%d = '", md->from);
		for (int i = md->from; i <= md->to; i++) {
			Markdown__debug_char_briefly(OUT, Str__get_at(md->sliced_from, i));
		}
		WRITE("' = %d", md->to);
		WRITE(")");
	} else if (Str__len(md->stashed) > 0) {
		WRITE(" = (", md->from);
		for (int i=0; i<Str__len(md->stashed); i++)
			Markdown__debug_char_briefly(OUT, Str__get_at(md->stashed, i));
		WRITE(")");
	}
	if (md->type == TICKBOX_MIT) {
		if (Markdown__get_tick_state(md)) WRITE("-ticked");
		else WRITE("-unticked");
	}
	if (md->type == FILE_MIT) {
		WRITE(": %f", RETRIEVE_POINTER_filename(md->user_state));
	}
	if (md->type == GATE_MIT) {
		if (md->details) WRITE("-if-true");
		else WRITE("-if-false");
	}
	if (md->type == INLINE_HTML_MIT) {
		if (Markdown__get_filtered_state(md)) WRITE("-filtered");
	}
	if (md->whitespace_follows) WRITE("+ws");
}

#line 1229 "inweb/foundation-module/Chapter 5/Markdown.w"
int md_db_cycle_count = 1;

void Markdown__debug_subtree(OUTPUT_STREAM, markdown_item *md) {
	md_db_cycle_count++;
	Markdown__debug_item_r(OUT, md);
}

void Markdown__debug_chain(OUTPUT_STREAM, markdown_item *md) {
	Markdown__debug_chain_label(OUT, md, TL_IS_2330);
}

void Markdown__debug_chain_label(OUTPUT_STREAM, markdown_item *md, text_stream *label) {
	md_db_cycle_count++;
	WRITE("%S:\n", label);
	INDENT;
	if (md)
		for (; md; md = md->next) {
			WRITE(" -> ");
			Markdown__debug_item_r(OUT, md);
		}
	else
		WRITE("<none>\n");
	OUTDENT;
}

#line 1257 "inweb/foundation-module/Chapter 5/Markdown.w"
void Markdown__debug_item_r(OUTPUT_STREAM, markdown_item *md) {
	if (md) {
		Markdown__debug_item(OUT, md);
		if (md->cycle_count == md_db_cycle_count) {
			WRITE("AGAIN!\n");
		} else {
			md->cycle_count = md_db_cycle_count;
			WRITE("\n");
			INDENT;
			for (markdown_item *c = md->down; c; c = c->next)
				Markdown__debug_item_r(OUT, c);
			OUTDENT;
		}
	}
}

#line 76 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

md_doc_state *MDBlockParser__initialise(markdown_variation *variation,
	markdown_item *head, md_links_dictionary *dict) {
	md_doc_state *state = CREATE(md_doc_state);

	state->variation = variation;
	state->tree_head = head;
	state->link_references = dict;

	
{
#line 93 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	state->marker_sp = 0;
	for (int i=0; i < MAX_MARKDOWN_CONTAINER_DEPTH; i++)
		MDBlockParser__clear_marker(&(state->markers[i]));
	MDBlockParser__lift_marker_limit(state);

	state->container_sp = 1;
	for (int i=0; i < MAX_MARKDOWN_CONTAINER_DEPTH; i++) state->containers[i] = NULL;
	state->containers[0] = head;

}
#line 85 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 103 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	state->receiving_PARAGRAPH = NULL;
	state->receiving_CODE_ITEM = NULL;
	state->receiving_HTML = NULL;
	state->blank_matter_after_receiver = Str__new();

	MDBlockParser__clear_fencing_data(state);
	MDBlockParser__clear_HTML_data(state);

}
#line 86 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	MDBlockParser__open_block(state, head);
	return state;
}

#line 123 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
markdown_item *MDBlockParser__latest_paragraph(md_doc_state *state) {
	return state->receiving_PARAGRAPH;
}

markdown_item *MDBlockParser__latest_HTML_block(md_doc_state *state) {
	return state->receiving_HTML;
}

markdown_item *MDBlockParser__latest_code_block(md_doc_state *state) {
	return state->receiving_CODE_ITEM;
}
markdown_item *MDBlockParser__latest_receiver(md_doc_state *state, int type) {
	switch (type) {
		case PARAGRAPH_MIT: return state->receiving_PARAGRAPH;
		case CODE_BLOCK_MIT: return state->receiving_CODE_ITEM;
		case HTML_MIT: return state->receiving_HTML;
	}
	return NULL;
}

#line 146 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__make_receiver(md_doc_state *state, markdown_item *block) {
	if (block) {
		switch (block->type) {
			case PARAGRAPH_MIT:  state->receiving_PARAGRAPH = block; break;
			case CODE_BLOCK_MIT: state->receiving_CODE_ITEM = block; break;
			case HTML_MIT:       state->receiving_HTML = block; break;
		}
	}
	Str__clear(state->blank_matter_after_receiver);
}

void MDBlockParser__remove_receiver(md_doc_state *state, markdown_item *block) {
	if (block) {
		switch (block->type) {
			case PARAGRAPH_MIT:  state->receiving_PARAGRAPH = NULL; break;
			case CODE_BLOCK_MIT: state->receiving_CODE_ITEM = NULL; break;
			case HTML_MIT:       state->receiving_HTML = NULL; break;
		}
	}
}

#line 188 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

void MDBlockParser__clear_fencing_data(md_doc_state *state) {
	state->fencing.material = 0;
	state->fencing.width = 0;
	state->fencing.fenced_code = NULL;
	state->fencing.left_margin = -1; /* meaning "none" */
}

#line 200 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__clear_HTML_data(md_doc_state *state) {
	state->HTML_end_condition = 0;
}

#line 240 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

void MDBlockParser__clear_marker(positional_marker *marker) {
	marker->item_type = 0; /* which is not a valid item type: this will never be used */
	marker->width = 0;
	marker->indent = 0;
	marker->at = 0;
	marker->continues_from_earlier_line = FALSE;
	marker->list_item_value = 0;
	marker->list_item_flavour = 0;
	marker->blank_counts = 0;
}

#line 265 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__impose_marker_limit(md_doc_state *state, int limit) {
	state->temporary_marker_limit = limit;
}

void MDBlockParser__lift_marker_limit(md_doc_state *state) {
	state->temporary_marker_limit = 100000000;
}

#line 278 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
positional_marker *MDBlockParser__new_marker_at(md_doc_state *state, int position, int type) {
	if ((type != BLOCK_QUOTE_MIT) &&
		(type != UNORDERED_LIST_ITEM_MIT) && (type != ORDERED_LIST_ITEM_MIT))
		internal_error("bad type for marker stack");
	if ((position <= 0) || (position >= MAX_MARKDOWN_CONTAINER_DEPTH))
		internal_error("marker out of range");
	positional_marker *marker = &(state->markers[position]);
	MDBlockParser__clear_marker(marker);
	marker->item_type = type;
	return marker;
}

#line 293 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
positional_marker *MDBlockParser__marker_at(md_doc_state *state, int position) {
	if ((position <= 0) || (position >= MAX_MARKDOWN_CONTAINER_DEPTH)) return NULL;
	positional_marker *marker = &(state->markers[position]);
	if (marker->item_type == 0) return NULL;
	return marker;
}

#line 303 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__debug_positional_stack(OUTPUT_STREAM,
	md_doc_state *state) {
	for (int i=1; i<MAX_MARKDOWN_CONTAINER_DEPTH; i++) {
		if (i == state->marker_sp) WRITE("[top] ");
		if ((i > state->marker_sp) && (state->markers[i].item_type == 0)) break;
		MDBlockParser__debug_marker(OUT, &(state->markers[i]), (i == state->marker_sp-1)?TRUE:FALSE);
	}
	if (state->marker_sp == 0) WRITE("empty");
	WRITE("\n");
}

void MDBlockParser__debug_marker(OUTPUT_STREAM, positional_marker *marker, int in_full) {
	if (marker == NULL) { WRITE("<no-marker>"); return; }
	if (marker->continues_from_earlier_line) WRITE("continuing:");
	switch (marker->item_type) {
		case BLOCK_QUOTE_MIT:         WRITE("> "); break;
		case UNORDERED_LIST_ITEM_MIT: WRITE("(%c) ", marker->list_item_flavour); break;
		case ORDERED_LIST_ITEM_MIT:   WRITE("%d%c ",
										marker->list_item_value, marker->list_item_flavour);
									  break;
		default: WRITE("<invalid-marker>"); break;
	}
	if (in_full) {
		WRITE("[at=%d] ", marker->at);
		WRITE("[min-indent=%d] ", marker->indent);
		if (marker->blank_counts) WRITE("[blanks=%d] ", marker->blank_counts);
	}
}

#line 337 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
tabbed_string_iterator MDBlockParser__block_quote_marker(tabbed_string_iterator line_scanner) {
	if (TabbedStr__get_character(&line_scanner) != '>') return line_scanner;
	TabbedStr__advance(&line_scanner);
	return line_scanner;
}

#line 346 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
tabbed_string_iterator MDBlockParser__bullet_list_marker(tabbed_string_iterator line_scanner,
	inchar32_t *flavour) {
	tabbed_string_iterator old = line_scanner;
	if (MDBlockParser__thematic_marker(line_scanner.line, TabbedStr__get_index(&line_scanner))) return old;
	inchar32_t c = TabbedStr__get_character(&line_scanner);
	if ((c == '-') || (c == '+') || (c == '*')) {
		TabbedStr__advance(&line_scanner);
		*flavour = c;
	}
	return line_scanner;
}

#line 365 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
tabbed_string_iterator MDBlockParser__ordered_list_marker(tabbed_string_iterator line_scanner,
	int *v, inchar32_t *flavour) {
	tabbed_string_iterator old = line_scanner;
	if (MDBlockParser__thematic_marker(line_scanner.line,
		TabbedStr__get_index(&line_scanner))) return old;
	inchar32_t c = TabbedStr__get_character(&line_scanner);
	int dc = 0, val = 0;
	while (Characters__is_ASCII_digit(c)) {
		val = 10*val + (int) (c - '0');
		TabbedStr__advance(&line_scanner); dc++;
		c = TabbedStr__get_character(&line_scanner);
	}
	if ((dc < 1) || (dc > 9)) return old;
	c = TabbedStr__get_character(&line_scanner);
	if ((c == '.') || (c == ')')) {
		*flavour = c;
		*v = val;
		TabbedStr__advance(&line_scanner);
		return line_scanner;
	}
	return old;
}

#line 394 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__thematic_marker(text_stream *line, int index) {
	inchar32_t c = Str__get_at(line, index);
	if ((c == '-') || (c == '_') || (c == '*')) {
		int ornament_count = 1;
		for (int j=index+1; j<Str__len(line); j++) {
			inchar32_t d = Str__get_at(line, j);
			if (d == c) {
				if (ornament_count > 0) ornament_count++;
			} else {
				if ((d != ' ') && (d != '\t')) ornament_count = 0;
			}
		}
		if (ornament_count >= 3) return TRUE;
	}
	return FALSE;
}

#line 427 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__parse_positional_markers(md_doc_state *state, tabbed_string_iterator *line_scanner) {
	int sp = 1; /* next positional stack position to store into */

	int left_margin = TabbedStr__spaces_available(line_scanner);

	while (TRUE) {
		if (sp >= MAX_MARKDOWN_CONTAINER_DEPTH) break;
		if (sp >= state->temporary_marker_limit) break;

		tabbed_string_iterator rewind_point = *line_scanner;

		int interrupts_paragraph = FALSE;
		if (MDBlockParser__latest_paragraph(state)) interrupts_paragraph = TRUE;
		if ((sp < state->container_sp) &&
			((state->containers[sp]->type == UNORDERED_LIST_ITEM_MIT) ||
				(state->containers[sp]->type == ORDERED_LIST_ITEM_MIT)))
			interrupts_paragraph = FALSE;

		int available = TabbedStr__spaces_available(line_scanner);
		
{
#line 467 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	positional_marker *marker = MDBlockParser__marker_at(state, sp);
	if ((sp < state->marker_sp) && (marker) && (marker->item_type != BLOCK_QUOTE_MIT) &&
		((TabbedStr__blank_from_here(line_scanner)) || (available >= marker->indent))) {
			TabbedStr__eat_spaces(state->markers[sp].indent, line_scanner);
			marker->continues_from_earlier_line = TRUE;
			sp++;
			continue;
	}

}
#line 446 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		
{
#line 481 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (available < 4) {
		TabbedStr__eat_spaces(available, line_scanner);
		tabbed_string_iterator starts_at = *line_scanner;
		
{
#line 498 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MarkdownVariations__supports(state->variation, BLOCK_QUOTES_MARKDOWNFEATURE)) {
		tabbed_string_iterator adv = MDBlockParser__block_quote_marker(starts_at);
		int black_width = TabbedStr__get_position(&adv) - TabbedStr__get_position(line_scanner);
		if (black_width > 0) {
			TabbedStr__eat_space(&adv);
			int white_width = black_width;
			*line_scanner = adv;
			positional_marker *bq_m = MDBlockParser__new_marker_at(state, sp, BLOCK_QUOTE_MIT);
			bq_m->width = black_width;
			bq_m->at = TabbedStr__get_position(&starts_at);
			bq_m->indent = white_width + TabbedStr__spaces_available(line_scanner);
			if (sp == 1) bq_m->indent += left_margin;
			sp++;
			continue;
		}
	}

}
#line 484 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		
{
#line 523 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MarkdownVariations__supports(state->variation, UNORDERED_LISTS_MARKDOWNFEATURE)) {
		inchar32_t flavour = 0;
		tabbed_string_iterator adv = MDBlockParser__bullet_list_marker(starts_at, &flavour);
		int black_width = TabbedStr__get_position(&adv) - TabbedStr__get_position(line_scanner);
		if (black_width > 0) {
			inchar32_t next = TabbedStr__get_character(&adv);
			if ((next == ' ') || (next == 0)) {
				TabbedStr__eat_space(&adv);
				int white_width = TabbedStr__get_position(&adv) - TabbedStr__get_position(line_scanner);
				*line_scanner = adv;
				if ((TabbedStr__blank_from_here(line_scanner)) && (interrupts_paragraph)) {
					*line_scanner = rewind_point;
				} else {
					positional_marker *li_m =
						MDBlockParser__new_marker_at(state, sp, UNORDERED_LIST_ITEM_MIT);
					li_m->width = black_width;
					li_m->at = TabbedStr__get_position(&starts_at);
					li_m->indent = white_width + TabbedStr__spaces_available(line_scanner);
					if (sp == 1) li_m->indent += left_margin;
					li_m->list_item_flavour = flavour;
					sp++;
					continue;
				}
			}
		}
	}

}
#line 485 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		
{
#line 562 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MarkdownVariations__supports(state->variation, ORDERED_LISTS_MARKDOWNFEATURE)) {
		inchar32_t flavour = 0;
		int val = 0;
		tabbed_string_iterator adv = MDBlockParser__ordered_list_marker(starts_at, &val, &flavour);
		int black_width = TabbedStr__get_position(&adv) - TabbedStr__get_position(line_scanner);
		if (black_width > 0) {
			inchar32_t next = TabbedStr__get_character(&adv);
			if ((next == ' ') || (next == 0)) {
				TabbedStr__eat_space(&adv);
				int white_width = TabbedStr__get_position(&adv) - TabbedStr__get_position(line_scanner);
				*line_scanner = adv;
				if (((TabbedStr__blank_from_here(line_scanner)) || (val != 1)) && (interrupts_paragraph)) {
					*line_scanner = rewind_point;
				} else {
					positional_marker *li_m =
						MDBlockParser__new_marker_at(state, sp, ORDERED_LIST_ITEM_MIT);
					li_m->width = black_width;
					li_m->at = TabbedStr__get_position(&starts_at);
					li_m->indent = white_width + TabbedStr__spaces_available(line_scanner);
					if (sp == 1) li_m->indent += left_margin;
					li_m->list_item_flavour = flavour;
					li_m->list_item_value = val;
					sp++;
					continue;
				}
			}
		}
	}

}
#line 486 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		*line_scanner = rewind_point;
	}

}
#line 447 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		break;
	}
	return sp;
}

#line 595 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
positional_marker *MDBlockParser__innermost_marker(md_doc_state *state) {
	if (state->marker_sp == 1) return NULL;
	return MDBlockParser__marker_at(state, state->marker_sp - 1);
}

int MDBlockParser__marker_is_list_entry(positional_marker *marker) {
	if ((marker) &&
		((marker->item_type == ORDERED_LIST_ITEM_MIT) ||
			(marker->item_type == UNORDERED_LIST_ITEM_MIT)))
		return TRUE;
	return FALSE;
}

int MDBlockParser__marker_is_new_list_entry(positional_marker *marker) {
	if ((MDBlockParser__marker_is_list_entry(marker)) &&
		(marker->continues_from_earlier_line == FALSE))
		return TRUE;
	return FALSE;
}

#line 624 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__change_type(md_doc_state *state, markdown_item *block, int t) {
	if (block == NULL) internal_error("no block");
	if (tracing_Markdown_parser) {
		PRINT("Change type: "); Markdown__debug_item(STDOUT, block);
	}
	if ((state) && (block->open)) MDBlockParser__remove_receiver(state, block);
	block->type = t;
	if ((state) && (block->open)) MDBlockParser__make_receiver(state, block);
	if (tracing_Markdown_parser) {
		PRINT(" -> "); Markdown__debug_item(STDOUT, block); PRINT("\n");
	}
}

#line 642 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__mark_block_with_ws(md_doc_state *state, markdown_item *block) {
	if (block) {
		if (tracing_Markdown_parser) {
			PRINT("Mark as whitespace-following: "); Markdown__debug_item(STDOUT, block);
		}
		block->whitespace_follows = TRUE;
	}
}

#line 657 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__open_block(md_doc_state *state, markdown_item *block) {
	if (block->open == NOT_APPLICABLE) {
		block->open = TRUE;
		MDBlockParser__close_block(state, MDBlockParser__latest_receiver(state, block->type));
		MDBlockParser__make_receiver(state, block);
	}
}

void MDBlockParser__close_block(md_doc_state *state, markdown_item *at) {
	if (at == NULL) return;
	if (at->open != TRUE) return;
	if (tracing_Markdown_parser) {
		PRINT("Closing: "); Markdown__debug_item(STDOUT, at); PRINT("\n");
		STREAM_INDENT(STDOUT);
	}
	at->open = FALSE;
	for (markdown_item *ch = at->down; ch; ch = ch->next)
		MDBlockParser__close_block(state, ch);
	if (tracing_Markdown_parser) {
		STREAM_OUTDENT(STDOUT);
	}
	MDBlockParser__remove_receiver(state, at);
	MDBlockParser__remove_link_references(state, at);
}

#line 688 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__turn_over_a_new_leaf(md_doc_state *state, markdown_item *block) {
	MDBlockParser__open_block(state, block);
	Markdown__add_to(block, state->containers[state->container_sp-1]);
}

#line 699 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__container_will_change(md_doc_state *state) {
	if (state->marker_sp > state->container_sp) return TRUE;
	for (int sp = 1; sp<state->marker_sp; sp++) {
		positional_marker *marker = MDBlockParser__marker_at(state, sp);
		if (marker->item_type != state->containers[sp]->type) return TRUE;
		if (MDBlockParser__marker_is_new_list_entry(marker)) return TRUE;
	}
	return FALSE;
}

#line 729 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__add_to_document(md_doc_state *state, text_stream *line) {
	if (tracing_Markdown_parser) {
		PRINT("=======\nAdding '%S' to tree:\n", line);
		Markdown__debug_subtree(STDOUT, state->tree_head);
		PRINT("Positional stack carried over: ");
		MDBlockParser__debug_positional_stack(STDOUT, state);
		if (state->temporary_marker_limit < 100000000)
			PRINT("(Marker limit %d is in force)", state->temporary_marker_limit);
	}

	int marker_sp_left_over_from_last_line = state->marker_sp;

	tabbed_string_iterator line_scanner = TabbedStr__new(line, 4);
	
{
#line 758 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	state->marker_sp = MDBlockParser__parse_positional_markers(state, &line_scanner);

}
#line 742 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	int indentation = FALSE;
	
{
#line 761 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	ReparseIntervening: ;
	positional_marker *innermost = MDBlockParser__innermost_marker(state);
	
{
#line 796 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (TabbedStr__blank_from_here(&line_scanner))
		if ((innermost) && (innermost->continues_from_earlier_line))
			TabbedStr__seek(&line_scanner, innermost->at + innermost->indent);

}
#line 763 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	int intervening_space_width = TabbedStr__spaces_available(&line_scanner);

	if ((intervening_space_width >= 4) &&
		(MarkdownVariations__supports(state->variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE)))
		
{
#line 807 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	indentation = TRUE; intervening_space_width = 4;
	if (MDBlockParser__marker_is_new_list_entry(innermost)) {
		if (tracing_Markdown_parser) {
			PRINT("Opening line is code rule applies, and sets pos indent[%d] = %d\n",
				state->marker_sp, innermost->width + 1);
		}
		innermost->indent = innermost->width + 1;
	}

}
#line 769 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	if (TabbedStr__blank_from_here(&line_scanner)) {
		if (MDBlockParser__marker_is_new_list_entry(innermost))
			
{
#line 826 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (tracing_Markdown_parser) {
		PRINT("Opening line is empty rule applies, and sets pos indent[%d] = %d\n",
			state->marker_sp, innermost->width + 1);
	}
	innermost->indent = innermost->width + 1;
	innermost->blank_counts = 1;

}
#line 773 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

		else if (MDBlockParser__marker_is_list_entry(innermost))
			
{
#line 851 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (innermost->blank_counts > 0) {
		if (tracing_Markdown_parser) {
			PRINT("Blank after blank opening rule applies\n");
		}
		MDBlockParser__mark_block_with_ws(state, state->containers[state->marker_sp-1]);
		state->marker_sp--;
		goto ReparseIntervening;
	}

}
#line 775 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	}

	TabbedStr__eat_spaces(intervening_space_width, &line_scanner);

}
#line 745 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	if (tracing_Markdown_parser) {
		PRINT("Line '%S' ", line);
		PRINT("\n");
		PRINT("New positional stack: ");
		MDBlockParser__debug_positional_stack(STDOUT, state);
	}

	
{
#line 871 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int content_index = TabbedStr__get_index(&line_scanner);

	if (tracing_Markdown_parser) {
		if (indentation) PRINT("Indentation present. ");
		PRINT("Content: '");
		for (int i=content_index; i<Str__len(line); i++)
			Markdown__debug_char_briefly(STDOUT, Str__get_at(line, i));
		PRINT("'\n");
	}

	int interpretations[NO_MDINTERPRETATIONS], details[NO_MDINTERPRETATIONS];
	
{
#line 895 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	for (int which=0; which<NO_MDINTERPRETATIONS; which++)
		interpretations[which] =
			MDBlockParser__can_interpret_as(state, line, indentation, content_index,
				which, NULL, &(details[which]));
	
{
#line 967 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((MDBlockParser__latest_paragraph(state)) &&
		(MDBlockParser__container_will_change(state) == FALSE)) {
		int lazy = TRUE;
		if ((interpretations[SETEXT_UNDERLINE_MDINTERPRETATION]) &&
			(state->marker_sp == state->container_sp))
			interpretations[THEMATIC_MDINTERPRETATION] = FALSE;
		for (int which=0; which<NO_MDINTERPRETATIONS; which++)
			if (interpretations[which]) {
				if (which == SETEXT_UNDERLINE_MDINTERPRETATION) continue;
				if ((which == HTML_MDINTERPRETATION) &&
					(details[which] == MISCPAIR_MDHTMLC)) continue;
				lazy = FALSE;
			}
		interpretations[LAZY_CONTINUATION_MDINTERPRETATION] = lazy;
	}
	if (interpretations[LAZY_CONTINUATION_MDINTERPRETATION] == FALSE)
		interpretations[SETEXT_UNDERLINE_MDINTERPRETATION] = FALSE;

}
#line 899 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	if (tracing_Markdown_parser) {
		PRINT("interpretations: ");
		int c = 0;
		for (int which=0; which<NO_MDINTERPRETATIONS; which++) {
			if (interpretations[which]) {
				c++;
				switch (which) {
					case WHITESPACE_MDINTERPRETATION:        PRINT("white? "); break;
					case THEMATIC_MDINTERPRETATION:          PRINT("thematic? "); break;
					case ATX_HEADING_MDINTERPRETATION:       PRINT("atx? "); break;
					case SETEXT_UNDERLINE_MDINTERPRETATION:  PRINT("setext? "); break;
					case HTML_MDINTERPRETATION:              PRINT("html-open? "); break;
					case CODE_FENCE_OPEN_MDINTERPRETATION:   PRINT("fence-open? "); break;
					case CODE_FENCE_CLOSE_MDINTERPRETATION:  PRINT("fence-close? "); break;
					case CODE_BLOCK_MDINTERPRETATION:        PRINT("code? "); break;
					case FENCED_CODE_BLOCK_MDINTERPRETATION: PRINT("fenced-code? "); break;
					case LAZY_CONTINUATION_MDINTERPRETATION: PRINT("lazy-continuation? "); break;
					case HTML_CONTINUATION_MDINTERPRETATION: PRINT("html-continuation? "); break;
				}
			}
		}
		if (c == 0) PRINT("(none)");
		PRINT("\n");
		if (MDBlockParser__container_will_change(state)) PRINT("Container change coming\n");
	}

}
#line 882 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	if (interpretations[LAZY_CONTINUATION_MDINTERPRETATION])
		
{
#line 994 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int sp = state->marker_sp;
	state->marker_sp = marker_sp_left_over_from_last_line;

	if ((sp == state->container_sp) && (interpretations[SETEXT_UNDERLINE_MDINTERPRETATION]))
		
{
#line 1180 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	inchar32_t c = Str__get_at(line, content_index);
	markdown_item *headb = MDBlockParser__latest_paragraph(state);
	if (headb) {
		MDBlockParser__remove_link_references(state, headb);
		if (headb->type == EMPTY_MIT) 
{
#line 1475 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *parb = Markdown__new_item(PARAGRAPH_MIT);
	parb->stashed = Str__new();
	MDBlockParser__turn_over_a_new_leaf(state, parb);
	for (int i=content_index; i<Str__len(line); i++)
		PUT_TO(parb->stashed, Str__get_at(line, i));
	return;

}
#line 1184 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		MDBlockParser__change_type(state, headb, HEADING_MIT);
		if (c == '=') Markdown__set_heading_level(headb, 1);
		else Markdown__set_heading_level(headb, 2);
		Str__trim_white_space(headb->stashed);
	}
	return;

}
#line 998 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1195 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *parb = MDBlockParser__latest_paragraph(state);
	if ((parb) && (parb->type == PARAGRAPH_MIT)) {
		WRITE_TO(parb->stashed, "\n");
		for (int i = content_index; i<Str__len(line); i++) {
			inchar32_t c = Str__get_at(line, i);
			PUT_TO(parb->stashed, c);
		}
	} else internal_error("no paragraph is open after all");
	return;

}
#line 999 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

}
#line 885 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

	else
		
{
#line 1013 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MDBlockParser__latest_paragraph(state))
		MDBlockParser__close_block(state, MDBlockParser__latest_paragraph(state));
	if ((MDBlockParser__latest_code_block(state)) &&
		(interpretations[CODE_BLOCK_MDINTERPRETATION] == FALSE) &&
		(interpretations[WHITESPACE_MDINTERPRETATION] == FALSE))
		MDBlockParser__close_block(state, MDBlockParser__latest_code_block(state));

	
{
#line 1041 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int wipe_down_to_pos;
	
{
#line 1076 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int min_sp = state->marker_sp, max_sp = state->marker_sp;
	if (state->container_sp < min_sp) min_sp = state->container_sp;
	if (state->container_sp > max_sp) max_sp = state->container_sp;
	wipe_down_to_pos = min_sp;
	for (int sp = 1; sp<min_sp; sp++) {
		positional_marker *marker = MDBlockParser__marker_at(state, sp);
		if (MDBlockParser__marker_is_new_list_entry(marker) == TRUE) {
			wipe_down_to_pos = sp; break;
		}
	}
	if (tracing_Markdown_parser) {
		PRINT("Stacks compared: ");
		if (wipe_down_to_pos == 1) PRINT(" WIPE");
		for (int sp=1; (sp<state->container_sp) || (sp<state->marker_sp); sp++) {
			PRINT(" ");
			if (sp >= state->marker_sp) PRINT("--");
			else MDBlockParser__debug_marker(STDOUT, MDBlockParser__marker_at(state, sp), TRUE);
			PRINT(" vs ");
			if (sp >= state->container_sp) PRINT("--");
			else Markdown__debug_item(STDOUT, state->containers[sp]);
			if (sp+1 == wipe_down_to_pos) PRINT(" WIPE");
		}
		PRINT("\n");
	}

}
#line 1042 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1108 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	for (int sp = state->container_sp-1; sp >= wipe_down_to_pos; sp--) {
		MDBlockParser__close_block(state, state->containers[sp]);
		state->containers[sp] = NULL;
	}
	state->container_sp = wipe_down_to_pos;
	if (state->container_sp < state->temporary_marker_limit) {
		if (state->fencing.material != 0) {
			
{
#line 1258 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	MDBlockParser__clear_fencing_data(state);
	MDBlockParser__lift_marker_limit(state);

}
#line 1115 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
			interpretations[FENCED_CODE_BLOCK_MDINTERPRETATION] = FALSE;
		} else if (state->HTML_end_condition) {
			
{
#line 1440 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	MDBlockParser__clear_HTML_data(state);
	MDBlockParser__lift_marker_limit(state);
	if (latest) MDBlockParser__close_block(state, latest);

}
#line 1118 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
			interpretations[HTML_CONTINUATION_MDINTERPRETATION] = FALSE;
		}
		MDBlockParser__lift_marker_limit(state);
	}

}
#line 1043 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1128 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	for (int sp = wipe_down_to_pos; sp<state->marker_sp; sp++) {
		positional_marker *marker = MDBlockParser__marker_at(state, sp);
		markdown_item *newbq = Markdown__new_item(marker->item_type);
		Markdown__set_item_number_and_flavour(newbq,
			marker->list_item_value, marker->list_item_flavour);
		Markdown__add_to(newbq, state->containers[sp-1]);
		state->containers[state->container_sp++] = newbq;
		MDBlockParser__open_block(state, newbq);
	}

}
#line 1044 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (tracing_Markdown_parser) {
		PRINT("Container stack:");
		for (int sp = 0; sp<state->container_sp; sp++) {
			PRINT(" -> "); Markdown__debug_item(STDOUT, state->containers[sp]);
		}
		PRINT("\n");
	}

}
#line 1020 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	if (interpretations[HTML_CONTINUATION_MDINTERPRETATION]) 
{
#line 1212 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	if (latest == NULL) 
{
#line 1440 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	MDBlockParser__clear_HTML_data(state);
	MDBlockParser__lift_marker_limit(state);
	if (latest) MDBlockParser__close_block(state, latest);

}
#line 1213 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

	else {
		int ends = FALSE;
		
{
#line 1400 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MDBlockParser__latest_HTML_block(state) == NULL) {
		if (tracing_Markdown_parser) {
			PRINT("HTML forcibly ended by closure of container\n");
		}
	} else {
		if (tracing_Markdown_parser) {
			PRINT("test '%S' for HTML_end_condition = %d\n", line, state->HTML_end_condition);
		}
		switch (state->HTML_end_condition) {
			case PRE_MDHTMLC:
				if ((Str__includes_insensitive(line, TL_IS_2331)) ||
					(Str__includes_insensitive(line, TL_IS_2332)) ||
					(Str__includes_insensitive(line, TL_IS_2333)) ||
					(Str__includes_insensitive(line, TL_IS_2334)))
					ends = TRUE;
				break;
			case COMMENT_MDHTMLC:
				if (Str__includes(line, TL_IS_2335)) ends = TRUE;
				break;
			case QUERY_MDHTMLC:
				if (Str__includes(line, TL_IS_2336)) ends = TRUE;
				break;
			case PLING_MDHTMLC:
				if (Str__includes(line, TL_IS_2337)) ends = TRUE;
				break;
			case CDATA_MDHTMLC:
				if (Str__includes(line, TL_IS_2338)) ends = TRUE;
				break;
			case MISCSINGLE_MDHTMLC:
			case MISCPAIR_MDHTMLC:
				if (Str__is_whitespace(line)) ends = TRUE;
				break;
		}
	}

	if (tracing_Markdown_parser) {
		PRINT("test outcome: %s\n", (ends)?"yes":"no");
	}

}
#line 1216 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		if ((latest) && (!((ends) &&
			((state->HTML_end_condition == MISCSINGLE_MDHTMLC) ||
				(state->HTML_end_condition == MISCPAIR_MDHTMLC)))))
			
{
#line 1390 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	int from = content_index;
	if (state->temporary_marker_limit == 1) from = 0;
	for (int i = from; i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		PUT_TO(latest->stashed, c);
	}
	PUT_TO(latest->stashed, '\n');

}
#line 1220 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		if (ends) 
{
#line 1440 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	MDBlockParser__clear_HTML_data(state);
	MDBlockParser__lift_marker_limit(state);
	if (latest) MDBlockParser__close_block(state, latest);

}
#line 1221 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

		return;
	}

}
#line 1022 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[CODE_FENCE_OPEN_MDINTERPRETATION])   
{
#line 1232 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int post_count = details[CODE_FENCE_OPEN_MDINTERPRETATION];
	text_stream *info_string = Str__new();
	MDBlockParser__can_interpret_as(state, line, indentation, content_index,
		CODE_FENCE_OPEN_MDINTERPRETATION, info_string, NULL);
	inchar32_t c = Str__get_at(line, content_index);
	markdown_item *cb = Markdown__new_item(CODE_BLOCK_MIT);
	cb->stashed = Str__new();
	cb->info_string = info_string;
	MDBlockParser__turn_over_a_new_leaf(state, cb);
	state->fencing.left_margin = TabbedStr__get_position(&line_scanner);
	state->fencing.material = c;
	state->fencing.width = post_count;
	state->fencing.fenced_code = cb;
	MDBlockParser__make_receiver(state, cb);
	MDBlockParser__impose_marker_limit(state, state->container_sp);
	return;

}
#line 1023 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[CODE_FENCE_CLOSE_MDINTERPRETATION])  
{
#line 1254 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	
{
#line 1258 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	MDBlockParser__clear_fencing_data(state);
	MDBlockParser__lift_marker_limit(state);

}
#line 1254 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	return;

}
#line 1024 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[FENCED_CODE_BLOCK_MDINTERPRETATION]) 
{
#line 1270 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *code_block = state->fencing.fenced_code;
	if ((state->fencing.left_margin >= 0) &&
		(state->fencing.left_margin < TabbedStr__get_position(&line_scanner)))
		TabbedStr__seek(&line_scanner, state->fencing.left_margin);
	while (TabbedStr__at_whole_character(&line_scanner) == FALSE) {
		PUT_TO(code_block->stashed, ' ');
		TabbedStr__advance(&line_scanner);
	}
	for (int i = TabbedStr__get_index(&line_scanner); i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		PUT_TO(code_block->stashed, c);
	}
	PUT_TO(code_block->stashed, '\n');
	return;

}
#line 1025 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[WHITESPACE_MDINTERPRETATION])        
{
#line 1306 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int sp = state->container_sp-1;
	if (state->markers[sp].continues_from_earlier_line) {
		if (state->containers[sp]->down) {
			for (markdown_item *ch = state->containers[sp]->down; ch; ch = ch->next)
				if ((ch->next == NULL) && (ch->type != BLOCK_QUOTE_MIT))
					MDBlockParser__mark_block_with_ws(state, ch);
		} else {
			MDBlockParser__mark_block_with_ws(state, state->containers[sp]);
		}
	}

	if (indentation)
		for (int i=content_index; i<Str__len(line); i++) {
			inchar32_t c = Str__get_at(line, i);
			PUT_TO(state->blank_matter_after_receiver, c);
		}
	PUT_TO(state->blank_matter_after_receiver, '\n');
	return;

}
#line 1026 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[ATX_HEADING_MDINTERPRETATION])       
{
#line 1337 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int hash_count = details[ATX_HEADING_MDINTERPRETATION];
	markdown_item *headb = Markdown__new_item(HEADING_MIT);
	Markdown__set_heading_level(headb, hash_count);
	text_stream *H = Str__new();
	headb->stashed = H;
	for (int i=content_index+hash_count; i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		if ((Str__len(H) == 0) && ((c == ' ') || (c == '\t')))
			continue;
		PUT_TO(H, c);
	}
	while ((Str__get_last_char(H) == ' ') || (Str__get_last_char(H) == '\t'))
		Str__delete_last_character(H);
	for (int i=Str__len(H)-1; i>=0; i--) {
		if ((Str__get_at(H, i) == ' ') || (Str__get_at(H, i) == '\t')) {
			Str__truncate(H, i); break;
		}
		if (Str__get_at(H, i) != '#') break;
		if (i == 0) Str__clear(H);
	}
	while ((Str__get_last_char(H) == ' ') || (Str__get_last_char(H) == '\t'))
		Str__delete_last_character(H);
	MDBlockParser__turn_over_a_new_leaf(state, headb);
	return;

}
#line 1027 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[THEMATIC_MDINTERPRETATION])          
{
#line 1366 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *themb = Markdown__new_item(THEMATIC_MIT);
	MDBlockParser__turn_over_a_new_leaf(state, themb);
	return;

}
#line 1028 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[HTML_MDINTERPRETATION])              
{
#line 1375 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	state->HTML_end_condition = details[HTML_MDINTERPRETATION];
	if (tracing_Markdown_parser) {
		PRINT("enter HTML with end_condition = %d\n", state->HTML_end_condition);
	}
	markdown_item *htmlb = Markdown__new_item(HTML_MIT);
	htmlb->stashed = Str__new();
	MDBlockParser__turn_over_a_new_leaf(state, htmlb);
	MDBlockParser__impose_marker_limit(state, state->container_sp);
	
{
#line 1390 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	int from = content_index;
	if (state->temporary_marker_limit == 1) from = 0;
	for (int i = from; i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		PUT_TO(latest->stashed, c);
	}
	PUT_TO(latest->stashed, '\n');

}
#line 1383 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	int ends = FALSE;
	
{
#line 1400 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MDBlockParser__latest_HTML_block(state) == NULL) {
		if (tracing_Markdown_parser) {
			PRINT("HTML forcibly ended by closure of container\n");
		}
	} else {
		if (tracing_Markdown_parser) {
			PRINT("test '%S' for HTML_end_condition = %d\n", line, state->HTML_end_condition);
		}
		switch (state->HTML_end_condition) {
			case PRE_MDHTMLC:
				if ((Str__includes_insensitive(line, TL_IS_2331)) ||
					(Str__includes_insensitive(line, TL_IS_2332)) ||
					(Str__includes_insensitive(line, TL_IS_2333)) ||
					(Str__includes_insensitive(line, TL_IS_2334)))
					ends = TRUE;
				break;
			case COMMENT_MDHTMLC:
				if (Str__includes(line, TL_IS_2335)) ends = TRUE;
				break;
			case QUERY_MDHTMLC:
				if (Str__includes(line, TL_IS_2336)) ends = TRUE;
				break;
			case PLING_MDHTMLC:
				if (Str__includes(line, TL_IS_2337)) ends = TRUE;
				break;
			case CDATA_MDHTMLC:
				if (Str__includes(line, TL_IS_2338)) ends = TRUE;
				break;
			case MISCSINGLE_MDHTMLC:
			case MISCPAIR_MDHTMLC:
				if (Str__is_whitespace(line)) ends = TRUE;
				break;
		}
	}

	if (tracing_Markdown_parser) {
		PRINT("test outcome: %s\n", (ends)?"yes":"no");
	}

}
#line 1385 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (ends) 
{
#line 1440 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_HTML_block(state);
	MDBlockParser__clear_HTML_data(state);
	MDBlockParser__lift_marker_limit(state);
	if (latest) MDBlockParser__close_block(state, latest);

}
#line 1386 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	return;

}
#line 1029 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	if (interpretations[CODE_BLOCK_MDINTERPRETATION])        
{
#line 1449 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *latest = MDBlockParser__latest_code_block(state);
	if (latest) {
		WRITE_TO(latest->stashed, "%S", state->blank_matter_after_receiver);
		Str__clear(state->blank_matter_after_receiver);
	} else {
		markdown_item *cb = Markdown__new_item(CODE_BLOCK_MIT);
		cb->stashed = Str__new();
		state->fencing.left_margin = -1;
		MDBlockParser__turn_over_a_new_leaf(state, cb);
		latest = cb;
	}
	while (TabbedStr__at_whole_character(&line_scanner) == FALSE) {
		PUT_TO(latest->stashed, ' ');
		TabbedStr__advance(&line_scanner);
	}
	for (int i = TabbedStr__get_index(&line_scanner); i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		PUT_TO(latest->stashed, c);
	}
	PUT_TO(latest->stashed, '\n');
	return;

}
#line 1030 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1475 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	markdown_item *parb = Markdown__new_item(PARAGRAPH_MIT);
	parb->stashed = Str__new();
	MDBlockParser__turn_over_a_new_leaf(state, parb);
	for (int i=content_index; i<Str__len(line); i++)
		PUT_TO(parb->stashed, Str__get_at(line, i));
	return;

}
#line 1031 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

}
#line 887 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

}
#line 754 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
}

#line 1507 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__can_interpret_as(md_doc_state *state, text_stream *line,
	int indentation, int content_index, int which, text_stream *text_details, int *int_detail) {
	switch (which) {
		case WHITESPACE_MDINTERPRETATION:        
{
#line 1526 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	for (int i=content_index; i<Str__len(line); i++)
		if ((Str__get_at(line, i) != ' ') && (Str__get_at(line, i) != '\t'))
			return FALSE;
	return TRUE;

}
#line 1510 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case THEMATIC_MDINTERPRETATION:          
{
#line 1535 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((MarkdownVariations__supports(state->variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE))
		&& (indentation)) return FALSE;
	if (MarkdownVariations__supports(state->variation, THEMATIC_MARKERS_MARKDOWNFEATURE))
		return MDBlockParser__thematic_marker(line, content_index);
	return FALSE;

}
#line 1511 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case ATX_HEADING_MDINTERPRETATION:       
{
#line 1546 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((MarkdownVariations__supports(state->variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE))
		&& (indentation)) return FALSE;
	if (MarkdownVariations__supports(state->variation, ATX_HEADINGS_MARKDOWNFEATURE)) {
		int hash_count = 0;
		while (Str__get_at(line, content_index+hash_count) == '#') hash_count++;
		if ((hash_count >= 1) && (hash_count <= 6) &&
			((Str__get_at(line, content_index+hash_count) == ' ') ||
				(Str__get_at(line, content_index+hash_count) == '\t') ||
				(Str__get_at(line, content_index+hash_count) == 0))) {
			if (int_detail) *int_detail = hash_count;
			return TRUE;
		}
	}
	return FALSE;

}
#line 1512 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case SETEXT_UNDERLINE_MDINTERPRETATION:  
{
#line 1566 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MDBlockParser__latest_paragraph(state) == NULL) return FALSE;
	if ((MarkdownVariations__supports(state->variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE))
		&& (indentation)) return FALSE;
	if (MarkdownVariations__supports(state->variation, SETEXT_HEADINGS_MARKDOWNFEATURE)) {
		inchar32_t c = Str__get_at(line, content_index);
		if ((c == '-') || (c == '=')) {
			int ornament_count = 1, extraneous = 0;
			int j=content_index+1;
			for (; j<Str__len(line); j++) {
				inchar32_t d = Str__get_at(line, j);
				if (d == c) ornament_count++;
				else break;
			}
			for (; j<Str__len(line); j++) {
				inchar32_t d = Str__get_at(line, j);
				if ((d != ' ') && (d != '\t')) extraneous++;
			}
			if ((ornament_count > 0) && (extraneous == 0)) return TRUE;
		}
	}
	return FALSE;

}
#line 1513 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case CODE_FENCE_OPEN_MDINTERPRETATION:
		case CODE_FENCE_CLOSE_MDINTERPRETATION:  
{
#line 1604 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((MarkdownVariations__supports(state->variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE))
		&& (indentation)) return FALSE;
	if (MarkdownVariations__supports(state->variation, FENCED_CODE_BLOCKS_MARKDOWNFEATURE)) {
		if ((which == CODE_FENCE_OPEN_MDINTERPRETATION) && (state->fencing.material != 0))
			return FALSE;
		if ((which == CODE_FENCE_CLOSE_MDINTERPRETATION) && (state->fencing.material == 0))
			return FALSE;
		text_stream *info_string = text_details;
		inchar32_t c = Str__get_at(line, content_index);
		if ((which == CODE_FENCE_CLOSE_MDINTERPRETATION) && (state->fencing.material != c))
			return FALSE;
		if ((c == '`') || (c == '~')) {
			int post_count = 0;
			int j = content_index;
			for (; j<Str__len(line); j++) {
				inchar32_t d = Str__get_at(line, j);
				if (d == c) post_count++;
				else break;
			}
			if (post_count >= 3) {
				if ((which == CODE_FENCE_CLOSE_MDINTERPRETATION) &&
					(post_count < state->fencing.width)) return FALSE;
				
{
#line 1640 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int ambiguous = FALSE, count = 0, escaped = FALSE;
	for (; j<Str__len(line); j++) {
		inchar32_t d = Str__get_at(line, j);
		if ((escaped == FALSE) && (d == '\\') &&
			(Characters__is_ASCII_punctuation(Str__get_at(line, j+1))))
			escaped = TRUE;
		else {
			if ((escaped == FALSE) && (d == '`') && (c == d)) ambiguous = TRUE;
			PUT_TO(info_string, d); count++;
			escaped = FALSE;
		}
	}
	Str__trim_white_space(info_string);
	if ((which == CODE_FENCE_CLOSE_MDINTERPRETATION) && (count > 0)) return FALSE;
	if (ambiguous == FALSE) {
		if (int_detail) *int_detail = post_count;
		return TRUE;
	}

}
#line 1626 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
			}
		}
	}
	return FALSE;

}
#line 1515 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case HTML_MDINTERPRETATION:              
{
#line 1681 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((MarkdownVariations__supports(state->variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE))
		&& (indentation)) return FALSE;
	if (MarkdownVariations__supports(state->variation, HTML_BLOCKS_MARKDOWNFEATURE) == FALSE)
		return FALSE;
	inchar32_t c = Str__get_at(line, content_index);
	if (c != '<') return FALSE;

	int condition_type = 0; /* not a valid condition */

	int i = content_index+1; /* i.e., the index after the |<| */
	TEMPORARY_TEXT(tag)
	for (; i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		if ((c == ' ') || (c == '\t') || (c == '>')) break;
		PUT_TO(tag, c);
	}

	
{
#line 1728 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((Str__eq_insensitive(tag, TL_IS_2339)) ||
		(Str__eq_insensitive(tag, TL_IS_2340)) ||
		(Str__eq_insensitive(tag, TL_IS_2341)) ||
		(Str__eq_insensitive(tag, TL_IS_2342))) {
		condition_type = PRE_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1698 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1736 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (Str__begins_with(tag, TL_IS_2343)) {
		condition_type = COMMENT_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1699 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1741 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (Str__begins_with(tag, TL_IS_2344)) {
		condition_type = QUERY_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1700 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1746 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (Str__begins_with(tag, TL_IS_2345)) {
		condition_type = CDATA_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1701 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1751 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (Str__begins_with(tag, TL_IS_2346)) {
		condition_type = PLING_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1702 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	if (Str__get_first_char(tag) == '/') Str__delete_first_character(tag);
	for (int i=0; i<Str__len(tag); i++) {
		if (Str__get_at(tag, i) == '>') {
			Str__put_at(tag, i, 0); break;
		}
		if ((Str__get_at(tag, i) == '/') && (Str__get_at(tag, i+1) == '>')) {
			Str__put_at(tag, i, 0); break;
		}
	}

	
{
#line 1756 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((Str__eq_insensitive(tag, TL_IS_2347)) ||
		(Str__eq_insensitive(tag, TL_IS_2348)) ||
		(Str__eq_insensitive(tag, TL_IS_2349)) ||
		(Str__eq_insensitive(tag, TL_IS_2350)) ||
		(Str__eq_insensitive(tag, TL_IS_2351)) ||
		(Str__eq_insensitive(tag, TL_IS_2352)) ||
		(Str__eq_insensitive(tag, TL_IS_2353)) ||
		(Str__eq_insensitive(tag, TL_IS_2354)) ||
		(Str__eq_insensitive(tag, TL_IS_2355)) ||
		(Str__eq_insensitive(tag, TL_IS_2356)) ||
		(Str__eq_insensitive(tag, TL_IS_2357)) ||
		(Str__eq_insensitive(tag, TL_IS_2358)) ||
		(Str__eq_insensitive(tag, TL_IS_2359)) ||
		(Str__eq_insensitive(tag, TL_IS_2360)) ||
		(Str__eq_insensitive(tag, TL_IS_2361)) ||
		(Str__eq_insensitive(tag, TL_IS_2362)) ||
		(Str__eq_insensitive(tag, TL_IS_2363)) ||
		(Str__eq_insensitive(tag, TL_IS_2364)) ||
		(Str__eq_insensitive(tag, TL_IS_2365)) ||
		(Str__eq_insensitive(tag, TL_IS_2366)) ||
		(Str__eq_insensitive(tag, TL_IS_2367)) ||
		(Str__eq_insensitive(tag, TL_IS_2368)) ||
		(Str__eq_insensitive(tag, TL_IS_2369)) ||
		(Str__eq_insensitive(tag, TL_IS_2370)) ||
		(Str__eq_insensitive(tag, TL_IS_2371)) ||
		(Str__eq_insensitive(tag, TL_IS_2372)) ||
		(Str__eq_insensitive(tag, TL_IS_2373)) ||
		(Str__eq_insensitive(tag, TL_IS_2374)) ||
		(Str__eq_insensitive(tag, TL_IS_2375)) ||
		(Str__eq_insensitive(tag, TL_IS_2376)) ||
		(Str__eq_insensitive(tag, TL_IS_2377)) ||
		(Str__eq_insensitive(tag, TL_IS_2378)) ||
		(Str__eq_insensitive(tag, TL_IS_2379)) ||
		(Str__eq_insensitive(tag, TL_IS_2380)) ||
		(Str__eq_insensitive(tag, TL_IS_2381)) ||
		(Str__eq_insensitive(tag, TL_IS_2382)) ||
		(Str__eq_insensitive(tag, TL_IS_2383)) ||
		(Str__eq_insensitive(tag, TL_IS_2384)) ||
		(Str__eq_insensitive(tag, TL_IS_2385)) ||
		(Str__eq_insensitive(tag, TL_IS_2386)) ||
		(Str__eq_insensitive(tag, TL_IS_2387)) ||
		(Str__eq_insensitive(tag, TL_IS_2388)) ||
		(Str__eq_insensitive(tag, TL_IS_2389)) ||
		(Str__eq_insensitive(tag, TL_IS_2390)) ||
		(Str__eq_insensitive(tag, TL_IS_2391)) ||
		(Str__eq_insensitive(tag, TL_IS_2392)) ||
		(Str__eq_insensitive(tag, TL_IS_2393)) ||
		(Str__eq_insensitive(tag, TL_IS_2394)) ||
		(Str__eq_insensitive(tag, TL_IS_2395)) ||
		(Str__eq_insensitive(tag, TL_IS_2396)) ||
		(Str__eq_insensitive(tag, TL_IS_2397)) ||
		(Str__eq_insensitive(tag, TL_IS_2398)) ||
		(Str__eq_insensitive(tag, TL_IS_2399)) ||
		(Str__eq_insensitive(tag, TL_IS_2400)) ||
		(Str__eq_insensitive(tag, TL_IS_2401)) ||
		(Str__eq_insensitive(tag, TL_IS_2402)) ||
		(Str__eq_insensitive(tag, TL_IS_2403)) ||
		(Str__eq_insensitive(tag, TL_IS_2404)) ||
		(Str__eq_insensitive(tag, TL_IS_2405)) ||
		(Str__eq_insensitive(tag, TL_IS_2406)) ||
		(Str__eq_insensitive(tag, TL_IS_2407)) ||
		(Str__eq_insensitive(tag, TL_IS_2408))) {
		condition_type = MISCSINGLE_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1714 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	
{
#line 1827 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	Str__clear(tag);
	WRITE_TO(tag, "%S", line);
	Str__trim_white_space(tag);
	if (Str__get_first_char(tag) == '<') { Str__delete_first_character(tag); Str__trim_white_space(tag); }
	int valid = TRUE, closing = FALSE;
	if (Str__get_first_char(tag) == '/') { closing = TRUE; Str__delete_first_character(tag); }
	TEMPORARY_TEXT(tag_name)
	int i = 0;
	for (; i<Str__len(tag); i++) {
		inchar32_t c = Str__get_at(tag, i);
		if ((Characters__is_ASCII_letter(c)) ||
			((i > 0) && ((Characters__is_ASCII_digit(c)) || (c == '-'))))
			PUT_TO(tag_name, c);
		else break;
	}
	if (Str__len(tag_name) == 0) valid = FALSE;
	if ((Str__eq_insensitive(tag_name, TL_IS_2409)) ||
		(Str__eq_insensitive(tag_name, TL_IS_2410)) ||
		(Str__eq_insensitive(tag_name, TL_IS_2411)) ||
		(Str__eq_insensitive(tag_name, TL_IS_2412))) valid = FALSE;
	DISCARD_TEXT(tag_name)
	if (closing == FALSE) {
		while (TRUE) {
			inchar32_t c = Str__get_at(tag, i);
			if ((c != ' ') && (c != '\t')) break;
			i = MDBlockParser__advance_past_spacing(tag, i);
			c = Str__get_at(tag, i);
			if ((c == '_') || (c == ':') || (Characters__is_ASCII_letter(c))) {
				i++; c = Str__get_at(tag, i);
				while ((c == '_') || (c == ':') || (c == '.') || (c == '-') ||
					(Characters__is_ASCII_letter(c)) || (Characters__is_ASCII_digit(c))) {
					i++; c = Str__get_at(tag, i);
				}
				i = MDBlockParser__advance_past_spacing(tag, i);
				if (Str__get_at(tag, i) == '=') {
					i++;
					i = MDBlockParser__advance_past_spacing(tag, i);
					inchar32_t c = Str__get_at(tag, i);
					if (c == '\'') {
						i++; c = Str__get_at(tag, i);
						while ((c) && (c != '\'')) {
							i++; c = Str__get_at(tag, i);
						}
						if (c == 0) valid = FALSE;
						i++;
					} else if (c == '"') {
						i++; c = Str__get_at(tag, i);
						while ((c) && (c != '"')) {
							i++; c = Str__get_at(tag, i);
						}
						if (c == 0) valid = FALSE;
						i++;
					} else {
						int nc = 0;
						while ((c != 0) && (c != ' ') && (c != '\t') && (c != '\n') && (c != '"') &&
							(c != '\'') && (c != '=') && (c != '<') && (c != '>') && (c != '`')) {
							nc++; i++; c = Str__get_at(tag, i);
						}
						if (nc == 0) valid = FALSE;
						i++;
					}
					i = MDBlockParser__advance_past_spacing(tag, i);
				}
			} else break;
		}
	}
	if ((closing == FALSE) && (Str__get_at(tag, i) == '/')) i++;
	if (Str__get_at(tag, i) != '>') valid = FALSE; i++;
	i = MDBlockParser__advance_past_spacing(tag, i);
	if (Str__get_at(tag, i) != 0) valid = FALSE;
	if (valid) {
		condition_type = MISCPAIR_MDHTMLC; goto HTML_Start_Found;
	}

}
#line 1715 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

	HTML_Start_Found: ;

	DISCARD_TEXT(tag)

	if (condition_type != 0) {
		if (int_detail) *int_detail = condition_type;
		return TRUE;
	}
	return FALSE;

}
#line 1516 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case CODE_BLOCK_MDINTERPRETATION:        
{
#line 1905 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (MDBlockParser__latest_paragraph(state)) return FALSE;
	if (indentation) return TRUE;
	return FALSE;

}
#line 1517 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case FENCED_CODE_BLOCK_MDINTERPRETATION: 
{
#line 1910 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if (state->fencing.material != 0) return TRUE;
	return FALSE;

}
#line 1518 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case HTML_CONTINUATION_MDINTERPRETATION: 
{
#line 1914 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	if ((MDBlockParser__latest_HTML_block(state)) &&
		(state->HTML_end_condition != 0)) return TRUE;
	return FALSE;

}
#line 1519 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		case LAZY_CONTINUATION_MDINTERPRETATION: return FALSE;
		default: return FALSE;
	}
}

#line 1679 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"

#line 1922 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__advance_past_spacing(text_stream *tag, int i) {
	int newlines = 0;
	inchar32_t c = Str__get_at(tag, i);
	while ((c == ' ') || (c == '\t') || (c == '\n')) {
		if (c == '\n') {
			newlines++; if (newlines == 2) break;
		}
		i++; c = Str__get_at(tag, i);
	}
	return i;
}

#line 1940 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__remove_link_references(md_doc_state *state, markdown_item *at) {
	if (at->type == PARAGRAPH_MIT) {
		int matched_to = 0;
		while (matched_to >= 0) {
			matched_to = -1;
			text_stream *X = at->stashed;
			
{
#line 1962 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	int i = 0;
	while ((Str__get_at(X, i) == ' ') || (Str__get_at(X, i) == '\t')) i++;
	if (Str__get_at(X, i) == '[') {
		i++;
		int count = 0, ws_count = 0;
		TEMPORARY_TEXT(label)
		
{
#line 1990 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	for (; i<Str__len(X); i++) {
		inchar32_t c = Str__get_at(X, i);
		if ((c == '\\') && (Characters__is_ASCII_punctuation(Str__get_at(X, i+1)))) {
			i++; c = Str__get_at(X, i);
		} else if (c == ']') { i++; break; }
		else if (c == '[') { count = 0; break; }
		if ((c == ' ') || (c == '\t') || (c == '\n')) ws_count++;
		PUT_TO(label, c);
		count++;
	}

}
#line 1968 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
		if ((Str__get_at(X, i) == ':') && (count <= 999) && (ws_count < count)) {
			i++;
			i = MDBlockParser__advance_past_spacing(X, i);

			int valid = TRUE;

			TEMPORARY_TEXT(destination)
			TEMPORARY_TEXT(title)
			
{
#line 2002 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	inchar32_t c = Str__get_at(X, i);
	if (c == '<') {
		i++; c = Str__get_at(X, i);
		while ((c != 0) && (c != '\n')) {
			if ((c == '\\') && (Characters__is_ASCII_punctuation(Str__get_at(X, i+1)))) {
				i++; c = Str__get_at(X, i);
			} else if (c == '>') break;
			PUT_TO(destination, c);
			i++; c = Str__get_at(X, i);
		}
		if (Str__get_at(X, i) == '>') i++; else valid = FALSE;
	} else if ((c != 0) && (Characters__is_control_character(c) == FALSE)) {
		int bl = 0;
		while ((c != 0) && (c != ' ') && (Characters__is_control_character(c) == FALSE)) {
			if ((c == '\\') && (Characters__is_ASCII_punctuation(Str__get_at(X, i+1)))) {
				i++; c = Str__get_at(X, i);
			} else if (c == '(') bl++;
			else if (c == ')') { bl--; if (bl < 0) valid = FALSE; }
			PUT_TO(destination, c);
			i++; c = Str__get_at(X, i);
		}
		if (bl != 0) valid = FALSE;
	} else valid = FALSE;

	ws_count = i;
	while ((Str__get_at(X, i) == ' ') || (Str__get_at(X, i) == '\t')) i++;
	int stop_here = -1;
	if ((valid) && (Str__get_at(X, i) == '\n')) stop_here = i;
	i = MDBlockParser__advance_past_spacing(X, i);
	ws_count = i - ws_count;
	inchar32_t quot = 0;
	if (Str__get_at(X, i) == '"') quot = '"';
	if (Str__get_at(X, i) == '\'') quot = '\'';
	if ((ws_count > 0) && (quot)) {
		for (i++; i<Str__len(X); i++) {
			inchar32_t c = Str__get_at(X, i);
			if ((c == '\\') && (Characters__is_ASCII_punctuation(Str__get_at(X, i+1)))) {
				i++; c = Str__get_at(X, i);
			} else if (c == quot) break;
			PUT_TO(title, c);
		}
		if (Str__get_at(X, i) == quot) i++; else valid = FALSE;
	}
	while ((Str__get_at(X, i) == ' ') || (Str__get_at(X, i) == '\t')) i++;
	if ((Str__get_at(X, i) != 0) && (Str__get_at(X, i) != '\n')) valid = FALSE;
	i++;

	if ((valid == FALSE) && (stop_here >= 0)) { valid = TRUE; i = stop_here+1; }

}
#line 1977 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;

			if (valid) {
				Markdown__create(state->link_references, label, destination, title);
				matched_to = i;
			}
			DISCARD_TEXT(destination)
			DISCARD_TEXT(title)
		}
		DISCARD_TEXT(label)
	}

}
#line 1946 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
			if (matched_to > 0) {
				Str__delete_n_characters(at->stashed, matched_to);
				if (Str__len(at->stashed) == 0) {
					MDBlockParser__change_type(state, at, EMPTY_MIT);
					return TRUE;
				}
			}
		}
		if (MarkdownVariations__supports(state->variation, TABLES_MARKDOWNFEATURE))
			
{
#line 2068 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	text_stream *X = at->stashed;
	TEMPORARY_TEXT(line1)
	TEMPORARY_TEXT(line2)
	int remainder_at = -1;
	for (int i=0, counter=1; i<Str__len(X); i++) {
		inchar32_t c = Str__get_at(X, i);
		if (c == '\n') counter++;
		else if (counter == 1) PUT_TO(line1, c);
		else if (counter == 2) PUT_TO(line2, c);
		else if (counter == 3) { remainder_at = i; break; }
	}
	int cell_count1 = MDBlockParser__count_cells(line1, FALSE, NULL);
	int cell_count2 = MDBlockParser__count_cells(line2, TRUE, NULL);
	if (tracing_Markdown_parser) PRINT("Try as table: cells %d, %d\n", cell_count1, cell_count2);

	if ((cell_count1 == cell_count2) && (cell_count1 > 0)) {
		MDBlockParser__change_type(state, at, TABLE_MIT);
		Markdown__set_column_count(at, cell_count1);
		MDBlockParser__count_cells(line2, TRUE, at);
		MDBlockParser__count_cells(line1, FALSE, at);
		if (remainder_at > 0) {
			Str__clear(line1);
			for (int i=remainder_at; i<Str__len(X); i++) {
				inchar32_t c = Str__get_at(X, i);
				if (c == '\n') {
					MDBlockParser__count_cells(line1, FALSE, at);
					Str__clear(line1);
				} else {
					PUT_TO(line1, c);
				}
			}
			MDBlockParser__count_cells(line1, FALSE, at);
		}
	}
	DISCARD_TEXT(line1)
	DISCARD_TEXT(line2)

}
#line 1956 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	}
	return FALSE;
}

#line 2106 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
int MDBlockParser__count_cells(text_stream *line, int is_delimiter_row,
	markdown_item *table_item) {
	int col_count = 0;
	if ((table_item) && (is_delimiter_row == FALSE)) {
		for (markdown_item *md = table_item->down->down; md; md = md->next) col_count++;
	}
	markdown_item *row_item = NULL;
	if (table_item) {
		row_item = Markdown__new_item(TABLE_ROW_MIT);
		Markdown__add_to(row_item, table_item);
	}
	int i = 0, edge_pipes = 0;
	while ((Str__get_at(line, i) == ' ') || (Str__get_at(line, i) == '\t')) i++;
	if (Str__get_at(line, i) == '|') { edge_pipes++; i++; }
	int j = Str__len(line) - 1;
	while ((Str__get_at(line, j) == ' ') || (Str__get_at(line, j) == '\t')) j--;
	if (Str__get_at(line, j) == '|') { edge_pipes++; j--; }
	int cell_count = 0, escaped = FALSE, cell_number = 0;
	TEMPORARY_TEXT(cell)
	for (int k = i; k <= j; k++) {
		inchar32_t c = Str__get_at(line, k);
		if ((escaped == FALSE) && (c == '\\')) {
			escaped = TRUE;
		} else {
			if ((escaped == FALSE) && (c == '|')) {
				if (cell_count == 0) cell_count = 2;
				else cell_count++;
				
{
#line 2155 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	Str__trim_white_space(cell);
	int from = 0, to = Str__len(cell) - 1, alignment = 0;
	if (is_delimiter_row) {
		if (Str__get_at(cell, from) == ':') {
			from++; alignment = 1;
			if (Str__get_at(cell, to) == ':') {
				to--; alignment = 3;
			}
		} else if (Str__get_at(cell, to) == ':') {
			to--; alignment = 2;
		}
		for (int i=from; i<=to; i++)
			if (Str__get_at(cell, i) != '-')
				return 0;
		if (table_item) {
			markdown_item *tc = Markdown__new_item(TABLE_COLUMN_MIT);
			Markdown__set_alignment(tc, alignment);
			Markdown__add_to(tc, row_item);
		}
	} else if (table_item) {
		if (cell_number < col_count) {
			markdown_item *cell_item = Markdown__new_item(TABLE_COLUMN_MIT);
			cell_item->stashed = Str__duplicate(cell);
			Markdown__add_to(cell_item, row_item);
		}
	}
	cell_number++;

}
#line 2133 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
				Str__clear(cell);
			} else {
				PUT_TO(cell, c);
			}
			escaped = FALSE;
		}
	}
	
{
#line 2155 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
	Str__trim_white_space(cell);
	int from = 0, to = Str__len(cell) - 1, alignment = 0;
	if (is_delimiter_row) {
		if (Str__get_at(cell, from) == ':') {
			from++; alignment = 1;
			if (Str__get_at(cell, to) == ':') {
				to--; alignment = 3;
			}
		} else if (Str__get_at(cell, to) == ':') {
			to--; alignment = 2;
		}
		for (int i=from; i<=to; i++)
			if (Str__get_at(cell, i) != '-')
				return 0;
		if (table_item) {
			markdown_item *tc = Markdown__new_item(TABLE_COLUMN_MIT);
			Markdown__set_alignment(tc, alignment);
			Markdown__add_to(tc, row_item);
		}
	} else if (table_item) {
		if (cell_number < col_count) {
			markdown_item *cell_item = Markdown__new_item(TABLE_COLUMN_MIT);
			cell_item->stashed = Str__duplicate(cell);
			Markdown__add_to(cell_item, row_item);
		}
	}
	cell_number++;

}
#line 2141 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
;
	DISCARD_TEXT(cell)
	if ((cell_count == 0) && (edge_pipes == 2)) cell_count = 1;
	if ((table_item) && (is_delimiter_row == FALSE)) {
		for (; cell_number < col_count; cell_number++) {
			markdown_item *cell_item = Markdown__new_item(TABLE_COLUMN_MIT);
			cell_item->stashed = Str__new();
			Markdown__add_to(cell_item, row_item);
		}
	}
	return cell_count;
}

#line 2191 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__gather_lists(md_doc_state *state, markdown_item *at) {
	if (at == NULL) return;
	for (markdown_item *c = at->down; c; c = c->next)
		MDBlockParser__gather_lists(state, c);
	for (markdown_item *c = at->down, *d = NULL; c; d = c, c = c->next) {
		if (MDBlockParser__in_same_list(c, c)) {
			int type = ORDERED_LIST_MIT;
			if (c->type == UNORDERED_LIST_ITEM_MIT) type = UNORDERED_LIST_MIT;
			markdown_item *list = Markdown__new_item(type);
			if (d) d->next = list; else at->down = list;
			list->down = c;
			while (MDBlockParser__in_same_list(c, c->next)) c = c->next;
			list->next = c->next;
			c->next = NULL;
			c = list;
		}
	}
}

int MDBlockParser__in_same_list(markdown_item *A, markdown_item *B) {
	if ((A) && (B) &&
		(Markdown__get_item_flavour(A)) &&
		(Markdown__get_item_flavour(A) == Markdown__get_item_flavour(B)))
		return TRUE;
	return FALSE;
}

#line 2224 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__propagate_white_space_follows(md_doc_state *state, markdown_item *at) {
	if (at == NULL) return;
	for (markdown_item *c = at->down; c; c = c->next)
		MDBlockParser__propagate_white_space_follows(state, c);
	for (markdown_item *c = at->down; c; c = c->next)
		if ((c->next == NULL) && (c->whitespace_follows))
			MDBlockParser__mark_block_with_ws(state, at);
}

#line 2244 "inweb/foundation-module/Chapter 5/Markdown Phase I.w"
void MDBlockParser__task_list_items(md_doc_state *state, markdown_item *at) {
	if (at == NULL) return;
	if ((at->type == ORDERED_LIST_ITEM_MIT) || (at->type == UNORDERED_LIST_ITEM_MIT)) {
		if ((at->down) && (at->down->type == PARAGRAPH_MIT)) {
			text_stream *X = at->down->stashed;
			int i=0;
			while ((Str__get_at(X, i) == ' ') || (Str__get_at(X, i) == '\t')) i++;
			if ((Str__get_at(X, i) == '[') && (Str__get_at(X, i+2) == ']')) {
				inchar32_t middle = Str__get_at(X, i+1);
				int ticked = NOT_APPLICABLE;
				if ((middle == 'x') || (middle == 'X')) ticked = TRUE;
				if ((middle == ' ') || (middle == '\t')) ticked = FALSE;
				if (ticked != NOT_APPLICABLE) {
					markdown_item *tickbox = Markdown__new_item(TICKBOX_MIT);
					Markdown__set_tick_state(tickbox, ticked);
					at->down->down = tickbox;
					i+=3;
					while ((Str__get_at(X, i) == ' ') || (Str__get_at(X, i) == '\t')) i++;
					Str__delete_n_characters(X, i);
				}
			}
		}
	}
	for (markdown_item *c = at->down; c; c = c->next)
		MDBlockParser__task_list_items(state, c);
}

#line 14 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
void MDInlineParser__inline_recursion(markdown_variation *variation,
	md_links_dictionary *link_refs, markdown_item *at) {
	if (at == NULL) return;
	if ((at->type == PARAGRAPH_MIT) ||
		(at->type == HEADING_MIT) ||
		((at->type == TABLE_COLUMN_MIT) && (Str__len(at->stashed) > 0))) {
		markdown_item *matter = MDInlineParser__inline(variation, link_refs, at->stashed);
		Markdown__add_to(matter, at);
	}
	for (markdown_item *c = at->down; c; c = c->next)
		MDInlineParser__inline_recursion(variation, link_refs, c);
}

#line 53 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
markdown_item *MDInlineParser__inline(markdown_variation *variation,
	md_links_dictionary *link_refs, text_stream *text) {
	markdown_item *owner = Markdown__new_item(MATERIAL_MIT);
	MDInlineParser__make_inline_chain(variation, owner, text);
	MDInlineParser__links_and_images(variation, link_refs, owner, FALSE);
	int mask = 0;
	if (MarkdownVariations__supports(variation, ASTERISK_EMPHASIS_MARKDOWNFEATURE))
		mask += ASTERISK_EMPHASIS_BIT;
	if (MarkdownVariations__supports(variation, UNDERSCORE_EMPHASIS_MARKDOWNFEATURE))
		mask += UNDERSCORE_EMPHASIS_BIT;
	if (MarkdownVariations__supports(variation, STRIKETHROUGH_MARKDOWNFEATURE))
		mask += TILDE_STRIKETHROUGH_BIT;
	if (mask) MDInlineParser__emphasis(variation, owner, mask);
	return owner;
}

markdown_item *MDInlineParser__make_inline_chain(markdown_variation *variation,
	markdown_item *owner, text_stream *text) {
	int i = 0;
	while (Str__get_at(text, i) == ' ') i++;
	int from = i, escaped = FALSE;
	for (; i<Str__len(text); i++) {
		if ((escaped == FALSE) && (Str__get_at(text, i) == '\\') &&
			(Characters__is_ASCII_punctuation(Str__get_at(text, i+1)))) {
			escaped = TRUE;
		} else {
			if (escaped == FALSE) {
				
{
#line 116 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (MarkdownVariations__supports(variation, BACKTICKED_CODE_MARKDOWNFEATURE)) {
		int count = MDInlineParser__backtick_string(text, i);
		if (count > 0) {
			for (int j=i+count+1; j<Str__len(text); j++) {
				if (MDInlineParser__backtick_string(text, j) == count) {
					if (i-1 >= from) {
						markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
						Markdown__add_to(md, owner);
					}
					
{
#line 139 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int start = i+count, end = j-1;
	text_stream *codespan = Str__new();
	int all_spaces = TRUE;
	for (int k=start; k<=end; k++) {
		inchar32_t c = Str__get_at(text, k);
		if (c == '\n') c = ' ';
		if (c != ' ') all_spaces = FALSE;
		PUT_TO(codespan, c);
	}
	if ((all_spaces == FALSE) && (Str__get_first_char(codespan) == ' ')
		 && (Str__get_last_char(codespan) == ' ')) {
		markdown_item *md = Markdown__new_slice(CODE_MIT, codespan, 1, Str__len(codespan)-2);
		Markdown__set_backtick_count(md, count);
		Markdown__add_to(md, owner);
	} else {
		markdown_item *md = Markdown__new_slice(CODE_MIT, codespan, 0, Str__len(codespan)-1);
		Markdown__set_backtick_count(md, count);
		Markdown__add_to(md, owner);
	}

}
#line 125 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					i = j+count; from = j+count;
					goto ContinueOuter;
				}
			}
		}
	}

}
#line 80 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
				
{
#line 163 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (MarkdownVariations__supports(variation, INDEXING_MARKS_MARKDOWNFEATURE)) {
		if (Str__get_at(text, i) == '^') {
			int j = i+1, count = 1;
			if (Str__get_at(text, j) == '^') j++, count++;
			if (Str__get_at(text, j) == '^') j++, count++;
			if (Str__get_at(text, j) == '{') {
				TEMPORARY_TEXT(lemma)
				j++;
				int escaped = FALSE, end_found = FALSE;
				while (Str__get_at(text, j)) {
					if ((escaped == FALSE) && (Str__get_at(text, j) == '\\'))
						escaped = TRUE;
					else {
						if ((escaped == FALSE) && (Str__get_at(text, j) == '}')) {
							end_found = TRUE; break;
						}
						PUT_TO(lemma, Str__get_at(text, j));
						escaped = FALSE;
					}
					j++;
				}
				if (end_found) {
					if (i-1 >= from) {
						markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
						Markdown__add_to(md, owner);
					}
					
{
#line 199 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int name_inversion = FALSE;
	if (Str__get_first_char(lemma) == '@') {
		Str__delete_first_character(lemma);
		name_inversion = TRUE;
	}
	markdown_item *md = Markdown__new_item(INDEX_MARKER_MIT);
	md->stashed = Str__duplicate(lemma);
	md->details = count;
	if (name_inversion) {
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, md->stashed, U"(%c*) (%C+)")) {
			Str__clear(md->stashed);
			WRITE_TO(md->stashed, "%S, %S", mr.exp[1], mr.exp[0]);
		}
		Regexp__dispose_of(&mr);
	}
	Markdown__add_to(md, owner);
	if (count == 1) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, Str__duplicate(lemma), 0, Str__len(lemma)-1);
		Markdown__add_to(md, owner);
	}

}
#line 189 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					i = j; from = j+1;
				}
				DISCARD_TEXT(lemma)
				if (end_found) goto ContinueOuter;
			}
		}
	}

}
#line 81 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
				
{
#line 222 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (Str__get_at(text, i) == '<') {
		for (int j=i+1; j<Str__len(text); j++) {
			inchar32_t c = Str__get_at(text, j);
			if (c == '>') {
				int link_from = i+1, link_to = j-1, count = j-i+1;
				if (tracing_Markdown_parser) {
					text_stream *OUT = STDOUT;
					WRITE("Investigating potential autolink: ");
					for (int k=i; k<=j; k++) PUT(Str__get_at(text, k));
					WRITE("\n");
				}
				if (MarkdownVariations__supports(variation, WEB_AUTOLINKS_MARKDOWNFEATURE))
					
{
#line 264 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int colon_at = -1;
	for (int k=link_from; k<=link_to; k++) if (Str__get_at(text, k) == ':') { colon_at = k; break; }
	if (colon_at >= 0) {
		int scheme_valid = TRUE;
		
{
#line 291 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int scheme_length = colon_at - link_from;
	if ((scheme_length < 2) || (scheme_length > 32)) scheme_valid = FALSE;
	for (int i=link_from; i<colon_at; i++) {
		inchar32_t c = Str__get_at(text, i);
		if (!((Characters__is_ASCII_letter(c)) ||
			((i > link_from) &&
				((Characters__is_ASCII_digit(c)) || (c == '+') || (c == '-') || (c == '.')))))
			scheme_valid = FALSE;
	}

}
#line 268 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		int link_valid = TRUE;
		
{
#line 302 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	for (int i=colon_at+1; i<=link_to; i++) {
		inchar32_t c = Str__get_at(text, i);
		if ((c == '<') || (c == '>') || (c == ' ') ||
			(Characters__is_control_character(c)))
			link_valid = FALSE;
	}

}
#line 270 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		if ((scheme_valid) && (link_valid)) {
			if (i-1 >= from) {
				markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
				Markdown__add_to(md, owner);
			}
			markdown_item *md = Markdown__new_slice(URI_AUTOLINK_MIT,
				text, link_from, link_to);
			Markdown__add_to(md, owner);
			i = link_to+1; from = link_to+2;
			if (tracing_Markdown_parser) PRINT("Found URI from = %c\n", Markdown__get_at(md, from));
			goto ContinueOuter;
		} else if (tracing_Markdown_parser) {
			if (scheme_valid == FALSE) PRINT("Colon suggested URI but scheme invalid\n");
			if (link_valid == FALSE) PRINT("Colon suggested URI but link invalid\n");
		}
	} else {
		if (tracing_Markdown_parser) PRINT("Not a URI: no colon\n");
	}

}
#line 234 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
				if (MarkdownVariations__supports(variation, EMAIL_AUTOLINKS_MARKDOWNFEATURE))
					
{
#line 310 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int atsign_at = -1;
	for (int k=link_from; k<=link_to; k++) if (Str__get_at(text, k) == '@') { atsign_at = k; break; }
	if (atsign_at >= 0) {
		int username_valid = TRUE;
		
{
#line 342 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int username_length = atsign_at - link_from;
	if (username_length < 1) username_valid = FALSE;
	for (int i=link_from; i<atsign_at; i++) {
		inchar32_t c = Str__get_at(text, i);
		if (!((Characters__is_ASCII_letter(c)) ||
				(Characters__is_ASCII_digit(c)) ||
				(c == '.') ||
				(c == '!') ||
				(c == '#') ||
				(c == '$') ||
				(c == '%') ||
				(c == '&') ||
				(c == '\'') ||
				(c == '*') ||
				(c == '+') ||
				(c == '/') ||
				(c == '=') ||
				(c == '?') ||
				(c == '^') ||
				(c == '_') ||
				(c == '`') ||
				(c == '{') ||
				(c == '|') ||
				(c == '}') ||
				(c == '~') ||
				(c == '-')))
			username_valid = FALSE;
	}

}
#line 314 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		int domain_valid = TRUE;
		
{
#line 372 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int segment_length = 0;
	for (int i=atsign_at+1; i<=link_to; i++) {
		inchar32_t c = Str__get_at(text, i);
		if (segment_length == 0) {
			if (!((Characters__is_ASCII_letter(c)) || (Characters__is_ASCII_digit(c))))
				domain_valid = FALSE;
		} else {
			if (c == '.') { segment_length = 0; continue; }
			if (c == '-') {
				if ((Str__get_at(text, i+1) == 0) || (Str__get_at(text, i+1) == '.'))
					domain_valid = FALSE;
			} else if (!((Characters__is_ASCII_letter(c)) || (Characters__is_ASCII_digit(c))))
				domain_valid = FALSE;
		}
		segment_length++;
		if (segment_length >= 64) domain_valid = FALSE;
	}
	if (segment_length >= 64) domain_valid = FALSE;

}
#line 316 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		if ((username_valid) && (domain_valid)) {
			if (i-1 >= from) {
				markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
				Markdown__add_to(md, owner);
			}
			markdown_item *md = Markdown__new_slice(EMAIL_AUTOLINK_MIT,
				text, link_from, link_to);
			Markdown__set_add_protocol_state(md, TRUE);
			Markdown__add_to(md, owner);
			i = j+count; from = j+count;
			if (tracing_Markdown_parser) PRINT("Found email\n");
			goto ContinueOuter;
		} else if (tracing_Markdown_parser) {
			if (username_valid == FALSE) PRINT("At suggested email but username invalid\n");
			if (domain_valid == FALSE) PRINT("At suggested email but domain invalid\n");
		}
	} else {
		if (tracing_Markdown_parser) PRINT("Not an email: no at-sign\n");
	}

}
#line 236 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
				break;
			}
			if ((c == '<') ||
				(Characters__is_Unicode_whitespace(c)) ||
				(Characters__is_control_character(c)))
				break;
		}
	}
	if (MarkdownVariations__supports(variation, EXTENDED_AUTOLINKS_MARKDOWNFEATURE)) {
		if ((MDInlineParser__extended_autolink_domain_char(Str__get_at(text, i))) &&
			((i == 0) ||
				(Str__get_at(text, i-1) == '\n') ||
				(Str__get_at(text, i-1) == '*') ||
				(Str__get_at(text, i-1) == '_') ||
				(Str__get_at(text, i-1) == '~') ||
				((Str__get_at(text, i-1) == '(') && (Str__get_at(text, i-2) != ']')) ||
				(Characters__is_Unicode_whitespace(Str__get_at(text, i-1)))))
					
{
#line 398 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int domain_from = i, to = i;
	int add_protocol = FALSE, email_address = FALSE, email_required = FALSE, xmpp = FALSE;
	
{
#line 418 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if ((Str__get_at(text, domain_from) == 'w') &&
		(Str__get_at(text, domain_from+1) == 'w') &&
		(Str__get_at(text, domain_from+2) == 'w') &&
		(Str__get_at(text, domain_from+3) == '.') &&
		(MDInlineParser__extended_autolink_domain_char(Str__get_at(text, domain_from+4)))) {
		add_protocol = TRUE;
		to = domain_from+4;
	} else if ((Str__get_at(text, domain_from) == 'm') &&
		(Str__get_at(text, domain_from+1) == 'a') &&
		(Str__get_at(text, domain_from+2) == 'i') &&
		(Str__get_at(text, domain_from+3) == 'l') &&
		(Str__get_at(text, domain_from+4) == 't') &&
		(Str__get_at(text, domain_from+5) == 'o') &&
		(Str__get_at(text, domain_from+6) == ':') &&
		(MDInlineParser__extended_autolink_domain_char(Str__get_at(text, domain_from+7)))) {
		to = domain_from+7; email_required = TRUE;
	} else if ((Str__get_at(text, domain_from) == 'x') &&
		(Str__get_at(text, domain_from+1) == 'm') &&
		(Str__get_at(text, domain_from+2) == 'p') &&
		(Str__get_at(text, domain_from+3) == 'p') &&
		(Str__get_at(text, domain_from+4) == ':') &&
		(MDInlineParser__extended_autolink_domain_char(Str__get_at(text, domain_from+5)))) {
		to = domain_from+5; email_required = TRUE; xmpp = TRUE;
	} else if ((Str__get_at(text, domain_from) == 'h') &&
		(Str__get_at(text, domain_from+1) == 't') &&
		(Str__get_at(text, domain_from+2) == 't') &&
		(Str__get_at(text, domain_from+3) == 'p') &&
		(Str__get_at(text, domain_from+4) == ':') &&
		(Str__get_at(text, domain_from+5) == '/') &&
		(Str__get_at(text, domain_from+6) == '/') &&
		(MDInlineParser__extended_autolink_domain_char(Str__get_at(text, domain_from+7)))) {
		to = domain_from+7;
	} else if ((Str__get_at(text, domain_from) == 'h') &&
		(Str__get_at(text, domain_from+1) == 't') &&
		(Str__get_at(text, domain_from+2) == 't') &&
		(Str__get_at(text, domain_from+3) == 'p') &&
		(Str__get_at(text, domain_from+4) == 's') &&
		(Str__get_at(text, domain_from+5) == ':') &&
		(Str__get_at(text, domain_from+6) == '/') &&
		(Str__get_at(text, domain_from+7) == '/') &&
		(MDInlineParser__extended_autolink_domain_char(Str__get_at(text, domain_from+8)))) {
		to = domain_from+8;
	}

}
#line 400 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	if ((email_required) || (to == domain_from)) 
{
#line 463 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int j = to;
	while ((MDInlineParser__extended_autolink_email_char(Str__get_at(text, j))) ||
		(Str__get_at(text, j) == '+') ||
		(Str__get_at(text, j) == '.')) j++;
	if ((j > to) && (Str__get_at(text, j) == '@')) {
		to = j+1; email_address = TRUE;
		if (email_required == FALSE) add_protocol = TRUE;
	}

}
#line 401 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	if (((email_required == FALSE) || (email_address)) && (to > domain_from)) {
		if (tracing_Markdown_parser) {
			PRINT("Found valid extended autolink prefix: ");
			for (int j=domain_from; j<=to; j++) PUT_TO(STDOUT, Str__get_at(text, j));
			PRINT("\n");
		}
		
{
#line 473 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (email_address) {
		while (TRUE) {
			if (MDInlineParser__extended_autolink_email_char(Str__get_at(text, to+1))) to++;
			else if ((Str__get_at(text, to+1) == '.') && (Str__get_at(text, to) != '.')) to++;
			else break;
		}
	} else {
		while (TRUE) {
			if (MDInlineParser__extended_autolink_domain_char(Str__get_at(text, to+1))) to++;
			else if ((Str__get_at(text, to+1) == '.') && (Str__get_at(text, to) != '.')) to++;
			else break;
		}
	}
	if (Str__get_at(text, to) == '.') to--;

}
#line 408 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		int domain_name_invalid = FALSE;
		
{
#line 489 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int dot_count = 0;
	for (int j=domain_from; j<=to; j++) if (Str__get_at(text, j) == '.') dot_count++;
	if (dot_count == 0) domain_name_invalid = TRUE;
	if (email_address) {
		if ((Str__get_at(text, to) == '_') || (Str__get_at(text, to) == '-'))
			domain_name_invalid = TRUE;
	} else {
		for (int j=domain_from, dots_passed=0; j<=to; j++) {
			inchar32_t c = Str__get_at(text, j);
			if (c == '.') dots_passed++;
			if ((c == '_') && (dots_passed >= dot_count - 2)) domain_name_invalid = TRUE;
		}
	}

}
#line 410 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		if (domain_name_invalid == FALSE) {
			
{
#line 504 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int domain_to = to;
	if (email_address == FALSE) {
		while ((Str__get_at(text, to+1) != 0) && (Str__get_at(text, to+1) != '<') &&
			(Characters__is_Unicode_whitespace(Str__get_at(text, to+1)) == FALSE)) to++;
		while (MDInlineParser__extended_autolink_trailing_punctuation_char(Str__get_at(text, to))) to--;
	} else if (xmpp) {
		if (Str__get_at(text, to+1) == '/') {
			to++;
			while (MDInlineParser__extended_autolink_xmpp_resource_char(Str__get_at(text, to+1))) to++;
		}
	}
	while (TRUE) {
		int initial_to = to;
		if (Str__get_at(text, to) == ')') {
			int bl = 0;
			for (int j=domain_to+1; j<=to; j++) {
				if (Str__get_at(text, j) == '(') bl++;
				if (Str__get_at(text, j) == ')') bl--;
				if (bl < 0) { to = j-1; break; }
			}
		} else if (Str__get_at(text, to) == ';') {
			int b = to-1;
			while (Characters__isalnum(Str__get_at(text, b))) b--;
			if (Str__get_at(text, b) == '#') b--;
			if (Str__get_at(text, b) == '&') to = b-1;
		}
		if (to == initial_to) break;
	}

}
#line 412 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			
{
#line 534 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	int link_from = domain_from, link_to = to;
	i = link_to; from = link_to+1;
	int type = URI_AUTOLINK_MIT;
	if (email_address) type = EMAIL_AUTOLINK_MIT;
	if (xmpp) type = XMPP_AUTOLINK_MIT;
	markdown_item *md = Markdown__new_slice(type,
		text, link_from, link_to);
	Markdown__set_add_protocol_state(md, add_protocol);
	Markdown__add_to(md, owner);
	if (tracing_Markdown_parser) {
		PRINT("Found extended autolink ");
		for (int j=domain_from; j<=to; j++) PUT_TO(STDOUT, Str__get_at(text, j));
		PRINT("\n");
	}
	goto ContinueOuter;

}
#line 413 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		}
	}

}
#line 254 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	}

}
#line 82 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
				
{
#line 592 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (MarkdownVariations__supports(variation, INLINE_HTML_MARKDOWNFEATURE)) {
		int filter = NOT_APPLICABLE;
		if (Str__get_at(text, i) == '<') {
			switch (Str__get_at(text, i+1)) {
				case '?': 
{
#line 618 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	for (int j = i+3; j<Str__len(text); j++)
		if ((Str__get_at(text, j) == '?') && (Str__get_at(text, j+1) == '>')) {
			int tag_from = i, tag_to = j+1;
			
{
#line 765 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	markdown_item *md = Markdown__new_slice(INLINE_HTML_MIT, text, tag_from, tag_to);
	if (filter == TRUE) Markdown__set_filtered_state(md, TRUE);
	Markdown__add_to(md, owner);
	i = tag_to; from = tag_to + 1;
	if (tracing_Markdown_parser) PRINT("Found raw HTML\n");
	goto ContinueOuter;

}
#line 621 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		}

}
#line 596 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
; break;
				case '!':
					if ((Str__get_at(text, i+2) == '-') && (Str__get_at(text, i+3) == '-'))
						
{
#line 627 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int bad_start = FALSE;
	if (Str__get_at(text, i+4) == '>') bad_start = TRUE;
	if ((Str__get_at(text, i+4) == '-') && (Str__get_at(text, i+5) == '>')) bad_start = TRUE;
	if (bad_start == FALSE)
		for (int j = i+4; j<Str__len(text); j++)
			if ((Str__get_at(text, j) == '-') && (Str__get_at(text, j+1) == '-')) {
				if (Str__get_at(text, j+2) == '>') {
					int tag_from = i, tag_to = j+2;
					
{
#line 765 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	markdown_item *md = Markdown__new_slice(INLINE_HTML_MIT, text, tag_from, tag_to);
	if (filter == TRUE) Markdown__set_filtered_state(md, TRUE);
	Markdown__add_to(md, owner);
	i = tag_to; from = tag_to + 1;
	if (tracing_Markdown_parser) PRINT("Found raw HTML\n");
	goto ContinueOuter;

}
#line 635 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
				}
				break;
			}

}
#line 599 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					if ((Str__get_at(text, i+2) == '[') && (Str__get_at(text, i+3) == 'C') &&
						(Str__get_at(text, i+4) == 'D') && (Str__get_at(text, i+5) == 'A') &&
						(Str__get_at(text, i+6) == 'T') && (Str__get_at(text, i+7) == 'A') &&
						(Str__get_at(text, i+8) == '['))
						
{
#line 652 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	for (int j = i+10; j<Str__len(text); j++)
		if ((Str__get_at(text, j) == ']') && (Str__get_at(text, j+1) == ']') &&
			(Str__get_at(text, j+2) == '>')) {
			int tag_from = i, tag_to = j+2;
			
{
#line 765 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	markdown_item *md = Markdown__new_slice(INLINE_HTML_MIT, text, tag_from, tag_to);
	if (filter == TRUE) Markdown__set_filtered_state(md, TRUE);
	Markdown__add_to(md, owner);
	i = tag_to; from = tag_to + 1;
	if (tracing_Markdown_parser) PRINT("Found raw HTML\n");
	goto ContinueOuter;

}
#line 656 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		}

}
#line 604 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					if (Characters__is_ASCII_letter(Str__get_at(text, i+2)))
						
{
#line 643 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	for (int j = i+2; j<Str__len(text); j++)
		if (Str__get_at(text, j) == '>') {
			int tag_from = i, tag_to = j;
			
{
#line 765 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	markdown_item *md = Markdown__new_slice(INLINE_HTML_MIT, text, tag_from, tag_to);
	if (filter == TRUE) Markdown__set_filtered_state(md, TRUE);
	Markdown__add_to(md, owner);
	i = tag_to; from = tag_to + 1;
	if (tracing_Markdown_parser) PRINT("Found raw HTML\n");
	goto ContinueOuter;

}
#line 646 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		}

}
#line 606 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					break;
				case '/': 
{
#line 672 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int at = i+2;
	
{
#line 681 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	inchar32_t c = Str__get_at(text, at);
	if (Characters__is_ASCII_letter(c) == FALSE) goto NotATag;
	TEMPORARY_TEXT(tag)
	while ((c == '-') || (Characters__is_ASCII_letter(c)) || (Characters__is_ASCII_digit(c))) {
		PUT_TO(tag, c);
		c = Str__get_at(text, ++at);
	}
	if ((filter == FALSE) &&
		(MarkdownVariations__supports(variation, DISALLOWED_RAW_HTML_MARKDOWNFEATURE)) &&
		(Markdown__tag_should_be_filtered(tag))) filter = TRUE;
	DISCARD_TEXT(tag)

}
#line 673 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	
{
#line 753 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_ending_count = 0;
	while (TRUE) {
		inchar32_t c = Str__get_at(text, at++);
		if (c == '\n') {
			line_ending_count++;
			if (line_ending_count == 2) break;
		}
		if ((c != ' ') && (c != '\t') && (c != '\n')) break;
	}
	at--;

}
#line 674 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	if (Str__get_at(text, at) == '>') {
		int tag_from = i, tag_to = at;
		
{
#line 765 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	markdown_item *md = Markdown__new_slice(INLINE_HTML_MIT, text, tag_from, tag_to);
	if (filter == TRUE) Markdown__set_filtered_state(md, TRUE);
	Markdown__add_to(md, owner);
	i = tag_to; from = tag_to + 1;
	if (tracing_Markdown_parser) PRINT("Found raw HTML\n");
	goto ContinueOuter;

}
#line 677 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	}

}
#line 608 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
; break;
				default: 
{
#line 660 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int at = i+1;
	filter = FALSE;
	
{
#line 681 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	inchar32_t c = Str__get_at(text, at);
	if (Characters__is_ASCII_letter(c) == FALSE) goto NotATag;
	TEMPORARY_TEXT(tag)
	while ((c == '-') || (Characters__is_ASCII_letter(c)) || (Characters__is_ASCII_digit(c))) {
		PUT_TO(tag, c);
		c = Str__get_at(text, ++at);
	}
	if ((filter == FALSE) &&
		(MarkdownVariations__supports(variation, DISALLOWED_RAW_HTML_MARKDOWNFEATURE)) &&
		(Markdown__tag_should_be_filtered(tag))) filter = TRUE;
	DISCARD_TEXT(tag)

}
#line 662 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	
{
#line 694 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	while (TRUE) {
		int start_at = at;
		
{
#line 753 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_ending_count = 0;
	while (TRUE) {
		inchar32_t c = Str__get_at(text, at++);
		if (c == '\n') {
			line_ending_count++;
			if (line_ending_count == 2) break;
		}
		if ((c != ' ') && (c != '\t') && (c != '\n')) break;
	}
	at--;

}
#line 696 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		if (at == start_at) break;
		inchar32_t c = Str__get_at(text, at);
		if ((c == '_') || (c == ':') || (Characters__is_ASCII_letter(c))) {
			while ((c == '_') || (c == ':') || (c == '.') || (c == '-') ||
				(Characters__is_ASCII_letter(c)) || (Characters__is_ASCII_digit(c)))
				c = Str__get_at(text, ++at);
			int start_value_at = at;
			
{
#line 753 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_ending_count = 0;
	while (TRUE) {
		inchar32_t c = Str__get_at(text, at++);
		if (c == '\n') {
			line_ending_count++;
			if (line_ending_count == 2) break;
		}
		if ((c != ' ') && (c != '\t') && (c != '\n')) break;
	}
	at--;

}
#line 704 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			if (Str__get_at(text, at) != '=') {
				at = start_value_at; goto DoneValueSpecification;
			}
			at++;
			
{
#line 753 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_ending_count = 0;
	while (TRUE) {
		inchar32_t c = Str__get_at(text, at++);
		if (c == '\n') {
			line_ending_count++;
			if (line_ending_count == 2) break;
		}
		if ((c != ' ') && (c != '\t') && (c != '\n')) break;
	}
	at--;

}
#line 709 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			
{
#line 730 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (Str__get_at(text, at) == '\'') {
		int k = at + 1;
		while ((Str__get_at(text, k) != '\'') && (Str__get_at(text, k) != 0))
			k++;
		if (Str__get_at(text, k) == '\'') { at = k+1; goto DoneValueSpecification; }
		at = start_value_at; goto DoneValueSpecification;
	}

}
#line 710 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			
{
#line 739 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (Str__get_at(text, at) == '"') {
		int k = at + 1;
		while ((Str__get_at(text, k) != '"') && (Str__get_at(text, k) != 0))
			k++;
		if (Str__get_at(text, k) == '"') { at = k+1; goto DoneValueSpecification; }
		at = start_value_at; goto DoneValueSpecification;
	}

}
#line 711 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			
{
#line 718 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int k = at;
	while (TRUE) {
		inchar32_t c = Str__get_at(text, k);
		if ((c == ' ') || (c == '\t') || (c == '\n') || (c == '"') || (c == '\'') ||
			(c == '=') || (c == '<') || (c == '>') || (c == '`') || (c == 0))
			break;
		k++;
	}
	if (k == at) { at = start_value_at; goto DoneValueSpecification; }
	at = k; goto DoneValueSpecification;

}
#line 712 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			DoneValueSpecification: ;
		} else { at = start_at; break; }
	}

}
#line 663 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	
{
#line 753 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_ending_count = 0;
	while (TRUE) {
		inchar32_t c = Str__get_at(text, at++);
		if (c == '\n') {
			line_ending_count++;
			if (line_ending_count == 2) break;
		}
		if ((c != ' ') && (c != '\t') && (c != '\n')) break;
	}
	at--;

}
#line 664 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	if (Str__get_at(text, at) == '/') at++;
	if (Str__get_at(text, at) == '>') {
		int tag_from = i, tag_to = at;
		
{
#line 765 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (i-1 >= from) {
		markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-1);
		Markdown__add_to(md, owner);
	}
	markdown_item *md = Markdown__new_slice(INLINE_HTML_MIT, text, tag_from, tag_to);
	if (filter == TRUE) Markdown__set_filtered_state(md, TRUE);
	Markdown__add_to(md, owner);
	i = tag_to; from = tag_to + 1;
	if (tracing_Markdown_parser) PRINT("Found raw HTML\n");
	goto ContinueOuter;

}
#line 668 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	}

}
#line 609 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
; break;
			}
			NotATag: ;
		}
	}

}
#line 83 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			}
			
{
#line 777 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (Str__get_at(text, i) == '\n') {
		int soak = 0;
		if (Str__get_at(text, i-1) == '\\') soak = 2;
		int preceding_spaces = 0;
		while (Str__get_at(text, i-1-preceding_spaces) == ' ') preceding_spaces++;
		if (preceding_spaces >= 2) soak = preceding_spaces+1;
		if (soak > 0) {
			if (i-soak >= from) {
				markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-soak);
				Markdown__add_to(md, owner);
			}
			markdown_item *md = Markdown__new_slice(LINE_BREAK_MIT, TL_IS_2413, 0, 1);
			Markdown__add_to(md, owner);
		} else {
			if (i-preceding_spaces-1 >= from) {
				markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, i-preceding_spaces-1);
				Markdown__add_to(md, owner);
			}
			markdown_item *md = Markdown__new_slice(SOFT_BREAK_MIT, TL_IS_2414, 0, 0);
			Markdown__add_to(md, owner);
		}
		i++;
		while (Str__get_at(text, i) == ' ') i++;
		from = i;
		i--;
		if (tracing_Markdown_parser) PRINT("Found line break\n");
		goto ContinueOuter;
	}

}
#line 85 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			ContinueOuter: ;
			escaped = FALSE;
		}
	}
	if (from <= Str__len(text)-1) {
		int to = Str__len(text)-1;
		while (Str__get_at(text, to) == ' ') to--;
		if (to >= from) {
			markdown_item *md = Markdown__new_slice(PLAIN_MIT, text, from, to);
			Markdown__add_to(md, owner);
		}
	}
	return owner;
}

#line 107 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__backtick_string(text_stream *text, int at) {
	int count = 0;
	while (Str__get_at(text, at + count) == '`') count++;
	if (count == 0) return 0;
	if ((at > 0) && (Str__get_at(text, at - 1) == '`')) return 0;
	return count;
}

#line 559 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__extended_autolink_domain_char(inchar32_t c) {
	if ((Characters__isalnum(c)) || (c == '_') || (c == '-')) return TRUE;
	return FALSE;
}

#line 568 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__extended_autolink_email_char(inchar32_t c) {
	if ((Characters__isalnum(c)) || (c == '_') || (c == '-')) return TRUE;
	return FALSE;
}

#line 576 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__extended_autolink_xmpp_resource_char(inchar32_t c) {
	if ((Characters__isalnum(c)) || (c == '@') || (c == '.')) return TRUE;
	return FALSE;
}

#line 585 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__extended_autolink_trailing_punctuation_char(inchar32_t c) {
	if ((c == '?') || (c == '!') || (c == ',') || (c == '.') ||
		(c == ':') || (c == '*') || (c == '_') || (c == '~')) return TRUE;
	return FALSE;
}

#line 824 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
void MDInlineParser__links_and_images(markdown_variation *variation,
	md_links_dictionary *link_refs, markdown_item *owner, int images_only) {
	if (owner == NULL) return;
	if ((MarkdownVariations__supports(variation, LINKS_MARKDOWNFEATURE) == FALSE) &&
		(MarkdownVariations__supports(variation, IMAGES_MARKDOWNFEATURE) == FALSE))
		return;
	if (tracing_Markdown_parser) {
		PRINT("Beginning link/image pass:\n");
		Markdown__debug_subtree(STDOUT, owner);
	}
	md_charpos leftmost_pos = Markdown__left_edge_of(owner->down);
	while (TRUE) {
		if (tracing_Markdown_parser) {
			if (Markdown__somewhere(leftmost_pos)) {
				PRINT("Link/image notation scan from %c\n",
					Markdown__get(leftmost_pos));
				Markdown__debug_subtree(STDOUT, leftmost_pos.md);
			} else {
				PRINT("Link/image notation scan from start\n");
			}
		}
		md_link_parse found = MDInlineParser__first_valid_link(variation,
			link_refs, leftmost_pos, Markdown__nowhere(), images_only, FALSE);
		if (found.is_link == NOT_APPLICABLE) break;
		md_link_dictionary_entry *ref = found.link_reference;
		if (tracing_Markdown_parser) {
			PRINT("Link matter: ");
			if (found.link_text_empty) PRINT("EMPTY\n");
			else Markdown__debug_interval(STDOUT, found.link_text_from, found.link_text_to);
			if (ref) {
				PRINT("Link destination (reference): %S\n", ref->destination);
				PRINT("Link title (reference): %S\n", ref->title);
			} else {
				PRINT("Link destination: ");
				if (found.link_destination_empty) PRINT("EMPTY\n");
				else Markdown__debug_interval(STDOUT, found.link_destination_from, found.link_destination_to);
				PRINT("Link title: ");
				if (found.link_title_empty) PRINT("EMPTY\n");
				else Markdown__debug_interval(STDOUT, found.link_title_from, found.link_title_to);
			}
		}
		
{
#line 897 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	markdown_item *chain = owner->down, *found_text = NULL, *remainder = NULL;
	Markdown__cut_interval(chain, found.first, found.last, &chain, &found_text, &remainder);

	markdown_item *link_text = NULL;
	markdown_item *link_destination = NULL;
	markdown_item *link_title = NULL;
	if (found.link_text_empty == FALSE)
		Markdown__cut_interval(found_text, found.link_text_from, found.link_text_to,
			NULL, &link_text, &found_text);
	if ((Markdown__somewhere(found.link_destination_from)) &&
		(found.link_destination_empty == FALSE))
		Markdown__cut_interval(found_text, found.link_destination_from, found.link_destination_to,
			NULL, &link_destination, &found_text);
	if ((Markdown__somewhere(found.link_title_from)) && (found.link_title_empty == FALSE))
		Markdown__cut_interval(found_text, found.link_title_from, found.link_title_to,
			NULL, &link_title, &found_text);
	markdown_item *link_item = Markdown__new_item((found.is_link == TRUE)?LINK_MIT:IMAGE_MIT);
	markdown_item *matter = Markdown__new_item(MATERIAL_MIT);
	if (found.link_text_empty == FALSE) matter->down = link_text;
	Markdown__add_to(matter, link_item);
	if (found.is_link == TRUE) MDInlineParser__links_and_images(variation, link_refs, matter, TRUE);
	else MDInlineParser__links_and_images(variation, link_refs, matter, FALSE);
	if (ref) {
		if (Str__len(ref->destination) > 0) {
			markdown_item *dest_item = Markdown__new_item(LINK_DEST_MIT);
			dest_item->down = Markdown__new_slice(PLAIN_MIT, ref->destination, 0, Str__len(ref->destination)-1);
			Markdown__add_to(dest_item, link_item);
		}
		if (Str__len(ref->title) > 0) {
			markdown_item *title_item = Markdown__new_item(LINK_TITLE_MIT);
			title_item->down = Markdown__new_slice(PLAIN_MIT, ref->title, 0, Str__len(ref->title)-1);
			Markdown__add_to(title_item, link_item);
		}
	} else {
		if (link_destination) {
			markdown_item *dest_item = Markdown__new_item(LINK_DEST_MIT);
			if (found.link_destination_empty == FALSE) dest_item->down = link_destination;
			Markdown__add_to(dest_item, link_item);
		}
		if (link_title) {
			markdown_item *title_item = Markdown__new_item(LINK_TITLE_MIT);
			if (found.link_title_empty == FALSE) title_item->down = link_title;
			Markdown__add_to(title_item, link_item);
		}
	}
	if (chain) {
		owner->down = chain;
		while (chain->next) chain = chain->next; chain->next = link_item;
	} else {
		owner->down = link_item;
	}
	link_item->next = remainder;
	if (tracing_Markdown_parser) {
		PRINT("After link surgery:\n");
		Markdown__debug_subtree(STDOUT, owner);
	}
	leftmost_pos = Markdown__left_edge_of(remainder);

}
#line 865 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	}
}

#line 893 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"

#line 960 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
md_link_parse MDInlineParser__first_valid_link(markdown_variation *variation,
	md_links_dictionary *link_refs, md_charpos from, md_charpos to,
	int images_only, int links_only) {
	md_link_parse result;
	
{
#line 996 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	result.is_link = NOT_APPLICABLE;
	result.first = Markdown__nowhere();
	result.link_text_from = Markdown__nowhere();
	result.link_text_to = Markdown__nowhere();
	result.link_text_empty = NOT_APPLICABLE;
	result.link_destination_from = Markdown__nowhere();
	result.link_destination_to = Markdown__nowhere();
	result.link_destination_empty = NOT_APPLICABLE;
	result.link_title_from = Markdown__nowhere();
	result.link_title_to = Markdown__nowhere();
	result.link_title_empty = NOT_APPLICABLE;
	result.link_reference = FALSE;
	result.last = Markdown__nowhere();

}
#line 964 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	inchar32_t prev_c = 0;
	md_charpos prev_pos = Markdown__nowhere();
	int escaped = FALSE;
	for (md_charpos pos = from; Markdown__somewhere(pos); pos = Markdown__advance_up_to(pos, to)) {
		inchar32_t c = Markdown__get(pos);
		if ((c == '\\') && (escaped == FALSE)) escaped = TRUE;
		else {
			if ((c == '[') && (escaped == FALSE)) {
				md_charpos pass_pos = pos;
				for (int pass=1; pass<=2; pass++) {
					if (tracing_Markdown_parser) {
						PRINT("Pass %d: at ", pass);
						Markdown__debug_pos(STDOUT, pos);
						PRINT("\n");
					}
					if (pass == 2) pos = pass_pos;
					
{
#line 1017 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (((links_only == FALSE) || (prev_c != '!')) &&
		((images_only == FALSE) || (prev_c == '!'))) {
		int link_rather_than_image = TRUE, uses = LINKS_MARKDOWNFEATURE;
		result.first = pos;
		if ((prev_c == '!') && (links_only == FALSE)) {
			link_rather_than_image = FALSE;
			uses = IMAGES_MARKDOWNFEATURE;
			result.first = prev_pos;
		}
		if (MarkdownVariations__supports(variation, uses)) {
			if (link_rather_than_image) {
				if (tracing_Markdown_parser) PRINT("Potential link found\n");
			} else {
				if (tracing_Markdown_parser) PRINT("Potential image found\n");
			}
			md_charpos abandon_at = pos;
			
{
#line 1069 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	inchar32_t c = Markdown__get(pos);
	md_charpos prev_pos = pos;
	result.link_text_from = Markdown__advance_up_to(pos, to);
	inchar32_t prev_c = 0;
	int bl = 0, count = 0, escaped = FALSE;
	while (c != 0) {
		if ((c == '\\') && (escaped == FALSE)) {
			escaped = TRUE;
		} else {
			count++;
			if ((c == '[') && (escaped == FALSE)) bl++;
			if ((c == ']') && (escaped == FALSE)) { bl--; if (bl == 0) break; }
			escaped = FALSE;
		}
			prev_pos = pos;
			prev_c = c;
			pos = Markdown__advance_up_to(pos, to);
			c = Markdown__get(pos);
	}
	if (c == 0) { pos = abandon_at; ABANDON_LINK("no end to linked matter"); }
	result.link_text_empty = (count<=2)?TRUE:FALSE;
	result.link_text_to = prev_pos;
	if (link_rather_than_image) {
		md_link_parse nested =
			MDInlineParser__first_valid_link(variation, link_refs,
				result.link_text_from, result.link_text_to, FALSE, TRUE);
		if (nested.is_link != NOT_APPLICABLE) return nested;
	}
	pos = Markdown__advance_up_to_plainish_only(pos, to);

}
#line 1033 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			if (Markdown__get(pos) == '[') {
				
{
#line 1100 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	md_charpos prev_pos = pos;
	pos = Markdown__advance_up_to_plainish_only(pos, to);
	result.link_destination_from = pos;
	inchar32_t prev_c = 0;
	int bl = 1, escaping = FALSE;
	TEMPORARY_TEXT(label)
	inchar32_t c = Markdown__get(pos);
	while (c != 0) {
		if ((c == '\\') && (escaping == FALSE)) {
			escaping = TRUE;
		} else {
			if (escaping) {
				if ((c != '[') && (c != ']') && (c != '\\')) PUT_TO(label, '\\');
			} else {
				if (c == '[') bl++;
				if (c == ']') { bl--; if (bl == 0) break; }
			}
			PUT_TO(label, c);
			escaping = FALSE;
		}
		prev_pos = pos;
		prev_c = c;
		pos = Markdown__advance_up_to_plainish_only(pos, to);
		c = Markdown__get(pos);
	}
	if (c == 0) { pos = abandon_at; ABANDON_LINK("no end to reference"); }
	if (Str__len(label) == 0) {
		for (md_charpos pos = result.link_text_from; Markdown__somewhere(pos);
			pos = Markdown__advance(pos)) {
			PUT_TO(label, Markdown__get(pos));
			if (Markdown__pos_eq(pos, result.link_text_to)) break;
		}
	}
	md_link_dictionary_entry *ref = Markdown__look_up(link_refs, label);
	if (ref == NULL) ABANDON_LINK("unknown reference");
	result.link_reference = ref;

}
#line 1035 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			} else {
				if ((Markdown__get(pos) != '(') || (pass == 2)) {
					TEMPORARY_TEXT(label)
					for (md_charpos pos = result.link_text_from; Markdown__somewhere(pos);
						pos = Markdown__advance(pos)) {
						PUT_TO(label, Markdown__get(pos));
						if (Markdown__pos_eq(pos, result.link_text_to)) break;
					}
					
{
#line 1141 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	TEMPORARY_TEXT(to)
	for (int i=0; i<Str__len(label); i++) {
		if ((Str__get_at(label, i) == '\\') &&
			((Str__get_at(label, i+1) == '[') ||
				(Str__get_at(label, i+1) == '\\') ||
				(Str__get_at(label, i+1) == ']')))
			i++;
		PUT_TO(to, Str__get_at(label, i));
	}
	Str__clear(label); WRITE_TO(label, "%S", to);
	DISCARD_TEXT(to)

}
#line 1044 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					md_link_dictionary_entry *ref = Markdown__look_up(link_refs, label);
					if (ref == NULL) ABANDON_LINK("no '(' and not a valid reference");
					result.link_reference = ref;
					pos = result.link_text_to;
					pos = Markdown__advance_up_to(pos, to);
					DISCARD_TEXT(label)
				} else {
					pos = Markdown__advance_up_to_quasi_plainish_only(pos, to);
					
{
#line 1255 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_endings = 0;
	inchar32_t c = Markdown__get(pos);
	while ((c == ' ') || (c == '\t') || (c == '\n')) {
		if (c == '\n') { line_endings++; if (line_endings >= 2) break; }
		pos = Markdown__advance_up_to_quasi_plainish_only(pos, to);
		c = Markdown__get(pos);
	}

}
#line 1053 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					if (Markdown__get(pos) != ')') 
{
#line 1154 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (Markdown__get(pos) == '<') {
		pos = Markdown__advance_up_to_quasi_plainish_only(pos, to);
		result.link_destination_from = pos;
		int empty = TRUE;
		inchar32_t prev_c = 0;
		while ((Markdown__get(pos) != '>') || (prev_c == '\\')) {
			if (Markdown__get(pos) == 0) ABANDON_LINK("no end to destination in angles");
			if (Markdown__get(pos) == '<') ABANDON_LINK("'<' in destination in angles");
			if (Markdown__get(pos) == '\n') ABANDON_LINK("reference includes line end");
			prev_pos = pos; prev_c = Markdown__get(pos);
			pos = Markdown__advance_up_to_quasi_plainish_only(pos, to); empty = FALSE;
		}
		result.link_destination_empty = empty;
		result.link_destination_to = prev_pos;
		pos = Markdown__advance_up_to_quasi_plainish_only(pos, to);
		if ((Markdown__get(pos) == '"') || (Markdown__get(pos) == '\'') ||
			(Markdown__get(pos) == '(')) ABANDON_LINK("no gap between destination and title");
	} else {
		result.link_destination_from = pos;
		int bl = 1;
		inchar32_t prev_c = 0;
		md_charpos prev_pos = pos;
		int empty = TRUE;
		while ((Markdown__get(pos) != ' ') && (Markdown__get(pos) != '\n') &&
			(Markdown__get(pos) != '\t')) {
			inchar32_t c = Markdown__get(pos);
			if ((c == '(') && (prev_c != '\\')) bl++;
			if ((c == ')') && (prev_c != '\\')) { bl--; if (bl == 0) break; }
			if (c == 0) ABANDON_LINK("no end to destination");
			if (Characters__is_control_character(c)) ABANDON_LINK("control character in destination");
			prev_pos = pos;
			prev_c = c;
			pos = Markdown__advance_up_to_quasi_plainish_only(pos, to); empty = FALSE;
		}
		result.link_destination_empty = empty;
		result.link_destination_to = prev_pos;
		if ((Markdown__get(pos) == '"') || (Markdown__get(pos) == '\'') ||
			(Markdown__get(pos) == '(')) ABANDON_LINK("no gap between destination and title");
	}

}
#line 1054 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					
{
#line 1255 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_endings = 0;
	inchar32_t c = Markdown__get(pos);
	while ((c == ' ') || (c == '\t') || (c == '\n')) {
		if (c == '\n') { line_endings++; if (line_endings >= 2) break; }
		pos = Markdown__advance_up_to_quasi_plainish_only(pos, to);
		c = Markdown__get(pos);
	}

}
#line 1055 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					if (Markdown__get(pos) != ')') 
{
#line 1195 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (Markdown__get(pos) == '"') {
		pos = Markdown__advance_up_to_plainish_only(pos, to);
		result.link_title_from = pos;
		inchar32_t prev_c = 0;
		md_charpos prev_pos = pos;
		int empty = TRUE;
		inchar32_t c = Markdown__get(pos);
		while (c != 0) {
			inchar32_t c = Markdown__get(pos);
			if ((c == '"') && (prev_c != '\\')) break;
			prev_pos = pos;
			prev_c = c;
			pos = Markdown__advance_up_to_plainish_only(pos, to); empty = FALSE;
		}
		if (c == 0) ABANDON_LINK("no end to title");
		result.link_title_empty = empty;
		result.link_title_to = prev_pos;
		pos = Markdown__advance_up_to_plainish_only(pos, to);
	}
	else if (Markdown__get(pos) == '\'') {
		pos = Markdown__advance_up_to_plainish_only(pos, to);
		result.link_title_from = pos;
		inchar32_t prev_c = 0;
		md_charpos prev_pos = pos;
		int empty = TRUE;
		inchar32_t c = Markdown__get(pos);
		while (c != 0) {
			inchar32_t c = Markdown__get(pos);
			if ((c == '\'') && (prev_c != '\\')) break;
			prev_pos = pos;
			prev_c = c;
			pos = Markdown__advance_up_to_plainish_only(pos, to); empty = FALSE;
		}
		if (c == 0) ABANDON_LINK("no end to title");
		result.link_title_empty = empty;
		result.link_title_to = prev_pos;
		pos = Markdown__advance_up_to_plainish_only(pos, to);
	}
	else if (Markdown__get(pos) == '(') {
		pos = Markdown__advance_up_to(pos, to);
		result.link_title_from = pos;
		inchar32_t prev_c = 0;
		md_charpos prev_pos = pos;
		int empty = TRUE;
		inchar32_t c = Markdown__get(pos);
		while (c != 0) {
			inchar32_t c = Markdown__get(pos);
			if ((c == '(') && (prev_c != '\\')) ABANDON_LINK("unescaped '(' in title");
			if ((c == ')') && (prev_c != '\\')) break;
			prev_pos = pos;
			prev_c = c;
			pos = Markdown__advance_up_to(pos, to); empty = FALSE;
		}
		if (c == 0) ABANDON_LINK("no end to title");
		result.link_title_empty = empty;
		result.link_title_to = prev_pos;
		pos = Markdown__advance_up_to_plainish_only(pos, to);
	}

}
#line 1056 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					
{
#line 1255 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int line_endings = 0;
	inchar32_t c = Markdown__get(pos);
	while ((c == ' ') || (c == '\t') || (c == '\n')) {
		if (c == '\n') { line_endings++; if (line_endings >= 2) break; }
		pos = Markdown__advance_up_to_quasi_plainish_only(pos, to);
		c = Markdown__get(pos);
	}

}
#line 1057 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					if (Markdown__get(pos) != ')') ABANDON_LINK("no ')'");
				}
			}
			result.last = pos;
			result.is_link = link_rather_than_image;
			if (tracing_Markdown_parser) PRINT("Confirmed\n");
			return result;
		}
	}

}
#line 981 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
					AbandonHope: ;
				}
			}
			if (escaped == FALSE) {
				prev_c = c;
				prev_pos = pos;
			}
			escaped = FALSE;
		}
	}
	return result;
}

#line 1274 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
void MDInlineParser__emphasis(markdown_variation *variation, markdown_item *owner,
	int mask) {
	for (markdown_item *md = owner->down; md; md = md->next)
		if ((md->type == LINK_MIT) || (md->type == IMAGE_MIT))
			MDInlineParser__emphasis(variation, md->down, mask);
	text_stream *OUT = STDOUT;
	if (tracing_Markdown_parser) {
		WRITE("Seeking emphasis (%d) in:\n", mask);
		INDENT;
		Markdown__debug_subtree(STDOUT, owner);
	}
	
{
#line 1392 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int no_delimiters = 0;
	md_emphasis_delimiter delimiters[MAX_MD_EMPHASIS_DELIMITERS];
	
{
#line 1447 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int open_count[3] = { 0, 0, 0 }, close_count[3] = { 0, 0, 0 }, both_count[3] = { 0, 0, 0 };
	for (md_charpos pos = Markdown__left_edge_of(owner->down);
		Markdown__somewhere(pos); pos = Markdown__advance(pos)) {
		int run = MDInlineParser__delimiter_run(pos, mask);
		if (run != 0) {
			if (no_delimiters >= MAX_MD_EMPHASIS_DELIMITERS) break;
			int run_combined = run;
			if (run > 10000000) run_combined = run - 10000000;
			int can_open = MDInlineParser__can_open_emphasis(pos, run_combined);
			int can_close = MDInlineParser__can_close_emphasis(pos, run_combined);
			if ((no_delimiters == 0) && (can_open == FALSE)) continue;
			if ((can_open == FALSE) && (can_close == FALSE)) continue;
			md_emphasis_delimiter *P = &(delimiters[no_delimiters++]);
			P->pos = pos;
			P->width = (run_combined>0)?run_combined:(-run_combined);
			P->type = (run_combined>0)?1:-1;
			if (run > 10000000) P->type = 0;
			P->can_open = can_open;
			P->can_close = can_close;
			if (tracing_Markdown_parser) {
				WRITE("DR%d at ", no_delimiters);
				Markdown__debug_pos(OUT, pos);
				WRITE(" width %d type %d", P->width, P->type);
				if (MDInlineParser__left_flanking(pos, run_combined)) WRITE(", left-flanking");
				if (MDInlineParser__right_flanking(pos, run_combined)) WRITE(", right-flanking");
				if (P->can_open) WRITE(", can-open");
				if (P->can_close) WRITE(", can-close");
				WRITE(", preceded by ");
				Markdown__debug_char(OUT, Markdown__get_unescaped(P->pos, -1));
				WRITE(", followed by ");
				Markdown__debug_char(OUT, Markdown__get_unescaped(P->pos, P->width));
				WRITE("\n");
			}
			int x = (P->type>0)?0:1;
			if (P->type == 0) x = 2;
			if ((can_open) && (can_close == FALSE)) open_count[x] += P->width;
			if ((can_open == FALSE) && (can_close)) close_count[x] += P->width;
			if ((can_open) && (can_close)) both_count[x] += P->width;
			if ((both_count[0] == 0) && (open_count[0] == close_count[0]) &&
				(both_count[1] == 0) && (open_count[1] == close_count[1]) &&
				(both_count[2] == 0) && (open_count[2] == close_count[2])) break;
		}
	}

}
#line 1394 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;

	markdown_item *options[MAX_MD_EMPHASIS_DELIMITERS];
	int no_options = 0;
	for (int open_i = 0; open_i < no_delimiters; open_i++) {
		md_emphasis_delimiter *OD = &(delimiters[open_i]);
		if (OD->can_open == FALSE) continue;
		for (int close_i = open_i+1; close_i < no_delimiters; close_i++) {
			md_emphasis_delimiter *CD = &(delimiters[close_i]);
			if (CD->can_close == FALSE) continue;
			
{
#line 1503 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (CD->type != OD->type) continue;
	if ((CD->can_open) || (OD->can_close)) {
		int sum = OD->width + CD->width;
		if (sum % 3 == 0) {
			if (OD->width % 3 != 0) continue;
			if (CD->width % 3 != 0) continue;
		}
	}

}
#line 1404 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
			if (tracing_Markdown_parser) {
				WRITE("Option %d is to pair D%d with D%d\n", no_options, open_i, close_i);
			}
			
{
#line 1522 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	markdown_item *option = Markdown__deep_copy(owner);
	options[no_options++] = option;
	markdown_item *OI = NULL, *CI = NULL;
	for (markdown_item *md = option->down; md; md = md->next) {
		if (md->copied_from == OD->pos.md) OI = md;
		if (md->copied_from == CD->pos.md) CI = md;
	}
	if ((OI == NULL) || (CI == NULL)) internal_error("copy accident");

	int width; /* number of delimiter characters we will trim */
	md_charpos first_trimmed_char_left;
	md_charpos last_trimmed_char_left;
	md_charpos first_trimmed_char_right;
	md_charpos last_trimmed_char_right;
	
{
#line 1565 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int O_start = OD->pos.at, O_width = OD->width;
	if (O_start < OI->from) { O_width -= (OI->from - O_start); O_start = OI->from; }

	int C_start = CD->pos.at, C_width = CD->width;
	if (C_start + C_width - 1 > CI->to) { C_width = CI->to - C_start + 1; }

	width = O_width; if (width > C_width) width = C_width;

	first_trimmed_char_left = Markdown__pos(OI, O_start + O_width - width);
	last_trimmed_char_left = Markdown__pos(OI, O_start + O_width - 1);
	first_trimmed_char_right = Markdown__pos(CI, C_start);
	last_trimmed_char_right = Markdown__pos(CI, C_start + width - 1);

	if (tracing_Markdown_parser) {
		WRITE(" first left = "); Markdown__debug_pos(OUT, first_trimmed_char_left);
		WRITE("\n  last left = "); Markdown__debug_pos(OUT, last_trimmed_char_left);
		WRITE("\nfirst right = "); Markdown__debug_pos(OUT, first_trimmed_char_right);
		WRITE("\n last right = "); Markdown__debug_pos(OUT, last_trimmed_char_right);
		WRITE("\n");
	}

}
#line 1536 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;

	
{
#line 1587 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	for (int w=0; w<width; w++) {
		Markdown__put_offset(first_trimmed_char_left, w, ':');
		Markdown__put_offset(first_trimmed_char_right, w, ':');
	}

}
#line 1538 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;

	markdown_item *em_top, *em_bottom;
	
{
#line 1606 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	if (OD->type == 0) {
		em_top = Markdown__new_item(STRIKETHROUGH_MIT);
		em_bottom = em_top;
	} else {
		em_top = Markdown__new_item(((width%2) == 1)?EMPHASIS_MIT:STRONG_MIT);
		if ((width%2) == 1) width -= 1; else width -= 2;
		em_bottom = em_top;
		while (width > 0) {
			markdown_item *g = Markdown__new_item(STRONG_MIT); width -= 2;
			em_bottom->down = g; em_bottom = g;
		}
	}

}
#line 1541 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	
{
#line 1620 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	markdown_item *chain = option->down;
	if (tracing_Markdown_parser) {
		Markdown__debug_chain_label(OUT, chain, TL_IS_2415);
	}
	markdown_item *before_emphasis = NULL, *emphasis = NULL, *after_emphasis = NULL;
	Markdown__cut_to_just_before(chain, first_trimmed_char_left,
		&before_emphasis, &emphasis);
	Markdown__cut_to_just_at(emphasis, last_trimmed_char_left,
		NULL, &emphasis);
	Markdown__cut_to_just_before(emphasis, first_trimmed_char_right,
		&emphasis, &after_emphasis);
	Markdown__cut_to_just_at(after_emphasis, last_trimmed_char_right,
		NULL, &after_emphasis);

	if (tracing_Markdown_parser) {
		Markdown__debug_chain_label(OUT, before_emphasis, TL_IS_2416);
		Markdown__debug_chain_label(OUT, emphasis, TL_IS_2417);
		Markdown__debug_chain_label(OUT, after_emphasis, TL_IS_2418);
	}

	option->down = before_emphasis;
	if (option->down) {
		chain = option->down;
		while ((chain) && (chain->next)) chain = chain->next;
		chain->next = em_top;
	} else {
		option->down = em_top;
	}
	em_top->next = after_emphasis;
	em_bottom->down = emphasis;

}
#line 1542 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;

	MDInlineParser__emphasis(variation, em_bottom, mask);
	MDInlineParser__emphasis(variation, option, mask);

	if (tracing_Markdown_parser) {
		WRITE("Option %d is to fragment thus:\n", no_options);
		Markdown__debug_subtree(STDOUT, option);
		WRITE("Resulting in: ");
		Markdown__render_extended(STDOUT, option, variation);
		WRITE("\nWhich scores %d penalty points\n", MDInlineParser__penalty(option));
	}

}
#line 1408 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
		}
	}
	if (no_options > 0) 
{
#line 1652 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
	int best_is = 1, best_score = 100000000;
	for (int pair_i = 0; pair_i < no_options; pair_i++) {
		int score = MDInlineParser__penalty(options[pair_i]);
		if (score < best_score) { best_score = score; best_is = pair_i; }
	}
	if (tracing_Markdown_parser) {
		WRITE("Selected option %d with penalty %d\n", best_is, best_score);
	}
	owner->down = options[best_is]->down;

}
#line 1411 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;

}
#line 1285 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
;
	if (tracing_Markdown_parser) {
		OUTDENT;
		WRITE("Emphasis search complete\n");
	}
}

#line 1304 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__delimiter_run(md_charpos pos, int mask) {
	int count = 0;
	if (mask & ASTERISK_EMPHASIS_BIT) {
		count = Markdown__unescaped_run(pos, '*');
		if ((count > 0) && (Markdown__get_unescaped(pos, -1) != '*')) return count;
	}
	if (mask & UNDERSCORE_EMPHASIS_BIT) {
		count = Markdown__unescaped_run(pos, '_');
		if ((count > 0) && (Markdown__get_unescaped(pos, -1) != '_')) return -count;
	}
	if (mask & TILDE_STRIKETHROUGH_BIT) {
		count = Markdown__unescaped_run(pos, '~');
		if ((count >= 1) && (count <= 2) && (Markdown__get_unescaped(pos, -1) != '~'))
			return 10000000 + count;
	}
	return 0;
}

#line 1335 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__left_flanking(md_charpos pos, int count) {
	if (count == 0) return FALSE;
	if (count < 0) count = -count;
	inchar32_t followed_by = Markdown__get_unescaped(pos, count);
	if ((followed_by == 0) || (Characters__is_Unicode_whitespace(followed_by))) return FALSE;
	if (Characters__is_Unicode_punctuation(followed_by) == FALSE) return TRUE;
	inchar32_t preceded_by = Markdown__get_unescaped(pos, -1);
	if ((preceded_by == 0) || (Characters__is_Unicode_whitespace(preceded_by)) ||
		(Characters__is_Unicode_punctuation(preceded_by))) return TRUE;
	return FALSE;
}

int MDInlineParser__right_flanking(md_charpos pos, int count) {
	if (count == 0) return FALSE;
	if (count < 0) count = -count;
	inchar32_t preceded_by = Markdown__get_unescaped(pos, -1);
	if ((preceded_by == 0) || (Characters__is_Unicode_whitespace(preceded_by))) return FALSE;
	if (Characters__is_Unicode_punctuation(preceded_by) == FALSE) return TRUE;
	inchar32_t followed_by = Markdown__get_unescaped(pos, count);
	if ((followed_by == 0) || (Characters__is_Unicode_whitespace(followed_by)) ||
		(Characters__is_Unicode_punctuation(followed_by))) return TRUE;
	return FALSE;
}

#line 1362 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__can_open_emphasis(md_charpos pos, int count) {
	if (MDInlineParser__left_flanking(pos, count) == FALSE) return FALSE;
	if (count > 0) return TRUE;
	if (MDInlineParser__right_flanking(pos, count) == FALSE) return TRUE;
	inchar32_t preceded_by = Markdown__get_unescaped(pos, -1);
	if (Characters__is_Unicode_punctuation(preceded_by)) return TRUE;
	return FALSE;
}

int MDInlineParser__can_close_emphasis(md_charpos pos, int count) {
	if (MDInlineParser__right_flanking(pos, count) == FALSE) return FALSE;
	if (count > 0) return TRUE;
	if (MDInlineParser__left_flanking(pos, count) == FALSE) return TRUE;
	inchar32_t followed_by = Markdown__get_unescaped(pos, -count); /* count < 0 here */
	if (Characters__is_Unicode_punctuation(followed_by)) return TRUE;
	return FALSE;
}

#line 1445 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"

#line 1676 "inweb/foundation-module/Chapter 5/Markdown Phase II.w"
int MDInlineParser__penalty(markdown_item *md) {
	if (md) {
		int penalty = 0;
		if (md->type == PLAIN_MIT) {
			for (int i=md->from; i<=md->to; i++) {
				md_charpos pos = Markdown__pos(md, i);
				inchar32_t c = Markdown__get_unescaped(pos, 0);
				if ((c == '*') || (c == '_')) penalty += 100000;
			}
		}
		if ((md->type == EMPHASIS_MIT) || (md->type == STRONG_MIT))
			penalty += Markdown__width(md->down);
		for (markdown_item *c = md->down; c; c = c->next)
			penalty += MDInlineParser__penalty(c);
		return penalty;
	}
	return 0;
}

#line 25 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void MDRenderer__render_extended(OUTPUT_STREAM, markdown_item *md,
	markdown_variation *variation) {
	int default_mode = TAGS_MDRMODE | ESCAPES_MDRMODE;
	if (MarkdownVariations__supports(variation, ENTITIES_MARKDOWNFEATURE))
		default_mode = default_mode | ENTITIES_MDRMODE;
	MDRenderer__recurse(OUT, md, default_mode, variation);
}

void MDRenderer__recurse(OUTPUT_STREAM, markdown_item *md, int mode,
	markdown_variation *variation) {
	if (md == NULL) return;
	if (MarkdownVariations__intervene_in_rendering(variation, OUT, md, mode)) return;
	int old_mode = mode;
	switch (md->type) {
		case ORDERED_LIST_MIT:          
{
#line 112 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	if (mode & TAGS_MDRMODE) {
		int start = Markdown__get_item_number(md->down);
		if (start != 1) {
			HTML_OPEN_WITH("ol", "start=\"%d\"", start);
		} else {
			HTML_OPEN("ol");
		}
	}
	WRITE("\n");
	
{
#line 133 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	mode = mode & (~LOOSE_MDRMODE);
	for (markdown_item *ch = md->down; ch; ch = ch->next) {
		if ((ch->next) && (ch->whitespace_follows))
			mode = mode | LOOSE_MDRMODE;
		for (markdown_item *gch = ch->down; gch; gch = gch->next)
			if ((gch->next) && (gch->whitespace_follows))
				mode = mode | LOOSE_MDRMODE;
	}
	
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 141 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;

}
#line 121 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
	if (mode & TAGS_MDRMODE) HTML_CLOSE("ol");
	WRITE("\n");

}
#line 39 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case ORDERED_LIST_ITEM_MIT:     
{
#line 144 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	if (mode & TAGS_MDRMODE) HTML_OPEN("li");
	int nl_issued = FALSE;
	for (markdown_item *ch = md->down; ch; ch = ch->next)
		if (((mode & LOOSE_MDRMODE) == 0) && (ch->type == PARAGRAPH_MIT)) {
			for (markdown_item *gch = ch->down; gch; gch = gch->next)
				MDRenderer__recurse(OUT, gch, mode, variation);
		} else {
			if (nl_issued == FALSE) { nl_issued = TRUE; WRITE("\n"); }
			MDRenderer__recurse(OUT, ch, mode, variation);
		}
	if (mode & TAGS_MDRMODE) HTML_CLOSE("li");
	WRITE("\n");

}
#line 40 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case UNORDERED_LIST_MIT:        
{
#line 126 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	if (mode & TAGS_MDRMODE) HTML_OPEN("ul");
	WRITE("\n");
	
{
#line 133 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	mode = mode & (~LOOSE_MDRMODE);
	for (markdown_item *ch = md->down; ch; ch = ch->next) {
		if ((ch->next) && (ch->whitespace_follows))
			mode = mode | LOOSE_MDRMODE;
		for (markdown_item *gch = ch->down; gch; gch = gch->next)
			if ((gch->next) && (gch->whitespace_follows))
				mode = mode | LOOSE_MDRMODE;
	}
	
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 141 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;

}
#line 128 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
	if (mode & TAGS_MDRMODE) HTML_CLOSE("ul");
	WRITE("\n");

}
#line 41 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case UNORDERED_LIST_ITEM_MIT:   
{
#line 144 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	if (mode & TAGS_MDRMODE) HTML_OPEN("li");
	int nl_issued = FALSE;
	for (markdown_item *ch = md->down; ch; ch = ch->next)
		if (((mode & LOOSE_MDRMODE) == 0) && (ch->type == PARAGRAPH_MIT)) {
			for (markdown_item *gch = ch->down; gch; gch = gch->next)
				MDRenderer__recurse(OUT, gch, mode, variation);
		} else {
			if (nl_issued == FALSE) { nl_issued = TRUE; WRITE("\n"); }
			MDRenderer__recurse(OUT, ch, mode, variation);
		}
	if (mode & TAGS_MDRMODE) HTML_CLOSE("li");
	WRITE("\n");

}
#line 42 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;

		case BLOCK_QUOTE_MIT:           if (mode & TAGS_MDRMODE) HTML_OPEN("blockquote");
									    WRITE("\n");
									    
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 46 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
									    if (mode & TAGS_MDRMODE) HTML_CLOSE("blockquote");
								        break;

		case PARAGRAPH_MIT:             if (mode & TAGS_MDRMODE) HTML_OPEN("p");
								        
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 51 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
								        if (mode & TAGS_MDRMODE) HTML_CLOSE("p");
								        break;
		case TICKBOX_MIT:               
{
#line 158 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	if (mode & TAGS_MDRMODE) {
		if (Markdown__get_tick_state(md)) {
			WRITE("<input checked=\"\" disabled=\"\" type=\"checkbox\"> ");
		} else {
			WRITE("<input disabled=\"\" type=\"checkbox\"> ");
		}
	}

}
#line 54 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case HEADING_MIT:               
{
#line 167 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	char *h = "p";
	switch (Markdown__get_heading_level(md)) {
		case 1: h = "h1"; break;
		case 2: h = "h2"; break;
		case 3: h = "h3"; break;
		case 4: h = "h4"; break;
		case 5: h = "h5"; break;
		case 6: h = "h6"; break;
	}
	if (mode & TAGS_MDRMODE) HTML_OPEN(h);
	TEMPORARY_TEXT(anchor)
	text_stream *url = MarkdownVariations__URL_for_heading(md);
	for (int i=0; i<Str__len(url); i++)
		if (Str__get_at(url, i) == '#')
			for (i++; i<Str__len(url); i++)
				PUT_TO(anchor, Str__get_at(url, i));
	if (Str__len(anchor) > 0) {
		HTML_OPEN_WITH("span", "id=%S", anchor);
	}
	
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 186 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
	if (Str__len(anchor) > 0) {
		HTML_CLOSE("span");
	}
	DISCARD_TEXT(anchor)
	if (mode & TAGS_MDRMODE) HTML_CLOSE(h);
	WRITE("\n");

}
#line 55 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case CODE_BLOCK_MIT:            
{
#line 202 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	mode = mode & (~ESCAPES_MDRMODE) & (~ENTITIES_MDRMODE);
	if (mode & TAGS_MDRMODE) HTML_OPEN("pre");
	TEMPORARY_TEXT(language)
	for (int i=0; i<Str__len(md->info_string); i++) {
		inchar32_t c = Str__get_at(md->info_string, i);
		if ((c == ' ') || (c == '\t')) break;
		PUT_TO(language, c);
	}
	if (Str__len(language) > 0) {
		TEMPORARY_TEXT(language_rendered)
		md->sliced_from = language;
		md->from = 0; md->to = Str__len(language) - 1;
		if (MarkdownVariations__supports(variation, ENTITIES_MARKDOWNFEATURE))
			MDRenderer__slice(language_rendered, md, mode | ENTITIES_MDRMODE);
		else
			MDRenderer__slice(language_rendered, md, mode);
		if (mode & TAGS_MDRMODE)
			HTML_OPEN_WITH("code", "class=\"language-%S\"", language_rendered);
		DISCARD_TEXT(language_rendered)
	} else {
		if (mode & TAGS_MDRMODE) HTML_OPEN("code");
	}
	DISCARD_TEXT(language)
	md->sliced_from = md->stashed;
	md->from = 0; md->to = Str__len(md->sliced_from) - 1;
	MDRenderer__slice(OUT, md, mode);
	if (mode & TAGS_MDRMODE) HTML_CLOSE("code");
	if (mode & TAGS_MDRMODE) HTML_CLOSE("pre");
	WRITE("\n");

}
#line 56 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case HTML_MIT:                  
{
#line 233 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	if (MarkdownVariations__supports(variation, DISALLOWED_RAW_HTML_MARKDOWNFEATURE)) {
		for (int i=0; i<Str__len(md->stashed); i++)
			if (Str__get_at(md->stashed, i) == '<') {
				TEMPORARY_TEXT(tag)
				for (int j=i+1; j<Str__len(md->stashed); j++)
					if (Characters__is_ASCII_letter(Str__get_at(md->stashed, j)))
						PUT_TO(tag, Str__get_at(md->stashed, j));
					else
						break;
				if (Markdown__tag_should_be_filtered(tag)) WRITE("&lt;");
				else PUT('<');
				DISCARD_TEXT(tag)
			} else {
				PUT(Str__get_at(md->stashed, i));
			}
	} else {
		WRITE("%S", md->stashed);
	}

}
#line 57 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case THEMATIC_MIT:              if (mode & TAGS_MDRMODE) WRITE("<hr />\n");
		                                break;
		case TABLE_MIT:					
{
#line 253 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	markdown_item *alignment_markers = md->down;
	if (alignment_markers) {
		int row_count = 0;
		for (markdown_item *md = alignment_markers->next; md; md = md->next) row_count++;
		if (row_count > 0) {
			WRITE("<table>\n");
			WRITE("<thead>\n");
			markdown_item *row = alignment_markers->next;
			WRITE("<tr>\n");
			for (markdown_item *md = row->down, *top = alignment_markers->down;
				md; md = md->next, top = top->next) {
				switch (Markdown__get_alignment(top)) {
					case 0: WRITE("<th>"); break;
					case 1: WRITE("<th align=\"left\">"); break;
					case 2: WRITE("<th align=\"right\">"); break;
					case 3: WRITE("<th align=\"center\">"); break;
				}
				if (md->down) MDRenderer__recurse(OUT, md->down, mode, variation);
				WRITE("</th>\n");
			}
			WRITE("</tr>\n");
			row = row->next;
			WRITE("</thead>\n");
			if (row_count > 1) {
				WRITE("<tbody>\n");
				while (row) {
					WRITE("<tr>\n");
					for (markdown_item *md = row->down, *top = alignment_markers->down;
						md; md = md->next, top = top->next) {
						switch (Markdown__get_alignment(top)) {
							case 0: WRITE("<td>"); break;
							case 1: WRITE("<td align=\"left\">"); break;
							case 2: WRITE("<td align=\"right\">"); break;
							case 3: WRITE("<td align=\"center\">"); break;
						}
						if (md->down) MDRenderer__recurse(OUT, md->down, mode, variation);
						WRITE("</td>\n");
					}
					WRITE("</tr>\n");
					row = row->next;
				}
				WRITE("</tbody>\n");
			}
			WRITE("</table>\n");
		}
	}

}
#line 60 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case EMPTY_MIT:                 break;

		case PLAIN_MIT:    	            MDRenderer__slice(OUT, md, mode);
								        break;
		case LINE_BREAK_MIT:            if (mode & TAGS_MDRMODE) WRITE("<br />\n");
								        break;
		case SOFT_BREAK_MIT:            MDRenderer__char(OUT, '\n', mode);
								        break;
		case EMPHASIS_MIT: 	            if (mode & TAGS_MDRMODE) HTML_OPEN("em");
								        
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 70 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
								        if (mode & TAGS_MDRMODE) HTML_CLOSE("em");
								        break;
		case STRONG_MIT:   	            if (mode & TAGS_MDRMODE) HTML_OPEN("strong");
								        
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 74 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
								        if (mode & TAGS_MDRMODE) HTML_CLOSE("strong");
								        break;
		case STRIKETHROUGH_MIT:   	    if (mode & TAGS_MDRMODE) HTML_OPEN("del");
								        
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 78 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;
								        if (mode & TAGS_MDRMODE) HTML_CLOSE("del");
								        break;
		case CODE_MIT:                  if (mode & TAGS_MDRMODE) HTML_OPEN("code");
								       	mode = mode & (~ESCAPES_MDRMODE);
								       	mode = mode & (~ENTITIES_MDRMODE);
								        MDRenderer__slice(OUT, md, mode);
								        if (mode & TAGS_MDRMODE) HTML_CLOSE("code");
								        break;

		case EMAIL_AUTOLINK_MIT:        
{
#line 301 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	text_stream *supplied_scheme = NULL;
	if (Markdown__get_add_protocol_state(md)) {
		supplied_scheme = TL_IS_2419;
		if (md->type == XMPP_AUTOLINK_MIT) supplied_scheme = TL_IS_2420;
	}
	
{
#line 314 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	TEMPORARY_TEXT(address)
	MDRenderer__slice(address, md, (mode & (~ESCAPES_MDRMODE)) | URI_MDRMODE);
	if (mode & TAGS_MDRMODE) HTML_OPEN_WITH("a", "href=\"%S%S\"", supplied_scheme, address);
	MDRenderer__slice(OUT, md, mode & (~ESCAPES_MDRMODE));
	if (mode & TAGS_MDRMODE) HTML_CLOSE("a");
	DISCARD_TEXT(address)

}
#line 306 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;

}
#line 88 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case XMPP_AUTOLINK_MIT:         
{
#line 301 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	text_stream *supplied_scheme = NULL;
	if (Markdown__get_add_protocol_state(md)) {
		supplied_scheme = TL_IS_2419;
		if (md->type == XMPP_AUTOLINK_MIT) supplied_scheme = TL_IS_2420;
	}
	
{
#line 314 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	TEMPORARY_TEXT(address)
	MDRenderer__slice(address, md, (mode & (~ESCAPES_MDRMODE)) | URI_MDRMODE);
	if (mode & TAGS_MDRMODE) HTML_OPEN_WITH("a", "href=\"%S%S\"", supplied_scheme, address);
	MDRenderer__slice(OUT, md, mode & (~ESCAPES_MDRMODE));
	if (mode & TAGS_MDRMODE) HTML_CLOSE("a");
	DISCARD_TEXT(address)

}
#line 306 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;

}
#line 89 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case URI_AUTOLINK_MIT:          
{
#line 309 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	text_stream *supplied_scheme = NULL;
	if (Markdown__get_add_protocol_state(md)) supplied_scheme = TL_IS_2421;
	
{
#line 314 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	TEMPORARY_TEXT(address)
	MDRenderer__slice(address, md, (mode & (~ESCAPES_MDRMODE)) | URI_MDRMODE);
	if (mode & TAGS_MDRMODE) HTML_OPEN_WITH("a", "href=\"%S%S\"", supplied_scheme, address);
	MDRenderer__slice(OUT, md, mode & (~ESCAPES_MDRMODE));
	if (mode & TAGS_MDRMODE) HTML_CLOSE("a");
	DISCARD_TEXT(address)

}
#line 311 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
;

}
#line 90 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case INLINE_HTML_MIT:           mode = mode | RAW_MDRMODE;
										if (Markdown__get_filtered_state(md))
											mode = mode | FILTERED_MDRMODE;
								       	mode = mode & (~ESCAPES_MDRMODE);
								       	mode = mode & (~ENTITIES_MDRMODE);
								       	MDRenderer__slice(OUT, md, mode);
		                            	break;

		case LINK_MIT:                  
{
#line 322 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	TEMPORARY_TEXT(URI)
	TEMPORARY_TEXT(title)
	if (md->down->next) {
		if (md->down->next->type == LINK_DEST_MIT) {
			MDRenderer__recurse(URI, md->down->next, mode, variation);
			if ((md->down->next->next) && (md->down->next->next->type == LINK_TITLE_MIT))
				MDRenderer__recurse(title, md->down->next->next, mode, variation);
		} else if (md->down->next->type == LINK_TITLE_MIT) {
			MDRenderer__recurse(title, md->down->next, mode, variation);
		}
	}
	if (Str__len(title) > 0) {
		if (mode & TAGS_MDRMODE) HTML_OPEN_WITH("a", "href=\"%S\" title=\"%S\"", URI, title);
	} else {
		if (mode & TAGS_MDRMODE) HTML_OPEN_WITH("a", "href=\"%S\"", URI);
	}
	MDRenderer__recurse(OUT, md->down, mode, variation);
	if (mode & TAGS_MDRMODE) HTML_CLOSE("a");
	DISCARD_TEXT(URI)
	DISCARD_TEXT(title)

}
#line 99 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case IMAGE_MIT:                 
{
#line 344 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	TEMPORARY_TEXT(URI)
	TEMPORARY_TEXT(title)
	TEMPORARY_TEXT(alt)
	if (md->down->next) {
		if (md->down->next->type == LINK_DEST_MIT) {
			MDRenderer__recurse(URI, md->down->next, mode, variation);
			if ((md->down->next->next) && (md->down->next->next->type == LINK_TITLE_MIT))
				MDRenderer__recurse(title, md->down->next->next, mode, variation);
		} else if (md->down->next->type == LINK_TITLE_MIT) {
			MDRenderer__recurse(title, md->down->next, mode, variation);
		}
	}
	MDRenderer__recurse(alt, md->down, mode & (~TAGS_MDRMODE), variation);
	if (Str__len(title) > 0) {
		if (mode & TAGS_MDRMODE) {
			HTML_TAG_WITH("img", "src=\"%S\" alt=\"%S\" title=\"%S\" /", URI, alt, title);
		} else {
			WRITE("%S", alt);
		}
	} else {
		if (mode & TAGS_MDRMODE) {
			HTML_TAG_WITH("img", "src=\"%S\" alt=\"%S\" /", URI, alt);
		} else {
			WRITE("%S", alt);
		}
	}
	DISCARD_TEXT(URI)
	DISCARD_TEXT(title)
	DISCARD_TEXT(alt)

}
#line 100 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
		case LINK_DEST_MIT:             mode = mode | URI_MDRMODE;
								       	MDRenderer__slice(OUT, md->down, mode);
								       	break;
		case LINK_TITLE_MIT:            
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 104 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;

		default:                        
{
#line 377 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
	for (markdown_item *c = md->down; c; c = c->next)
		MDRenderer__recurse(OUT, c, mode, variation);

}
#line 106 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
; break;
	}
	mode = old_mode;
}

#line 388 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void MDRenderer__slice(OUTPUT_STREAM, markdown_item *md, int mode) {
	if (md) {
		int angles = 0;
		for (int i=md->from; i<=md->to; i++) {
			inchar32_t c = Markdown__get_at(md, i);
			if ((mode & ESCAPES_MDRMODE) && (c == '\\') && (i<md->to) &&
				(Characters__is_ASCII_punctuation(Markdown__get_at(md, i+1))))
				c = Markdown__get_at(md, ++i);
			else if ((mode & ENTITIES_MDRMODE) && (c == '&') && (i+2<=md->to)) {
				int at = i;
				TEMPORARY_TEXT(entity)
				inchar32_t d = c;
				while ((d != 0) && (d != ';')) {
					if (at > md->to) break;
					d = Markdown__get_at(md, at++);
					PUT_TO(entity, d);
				}
				if (d == ';') {
					inchar32_t A = 0, B = 0;
					int valid = HTMLEntities__parse(entity, &A, &B);
					DISCARD_TEXT(entity)
					if (valid) {
						if (A == 0) A = 0xFFFD;
						MDRenderer__char(OUT, A, mode);
						if (B) MDRenderer__char(OUT, B, mode);
						i = at - 1;
						continue;
					}
				}
			}
			if ((c == '<') && (angles++ == 0) && (mode & FILTERED_MDRMODE))
				MDRenderer__char(OUT, c, 0);
			else
				MDRenderer__char(OUT, c, mode);
		}
	}
}

#line 430 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void MDRenderer__char(OUTPUT_STREAM, inchar32_t c, int mode) {
	if (mode & TOLOWER_MDRMODE) c = Characters__tolower(c);
	if (mode & RAW_MDRMODE) {
		PUT(c);
	} else if (mode & URI_MDRMODE) {
		if (c >= 0x10000) {
			MARKDOWN_URI_HEX(0xF0 + (unsigned char) (c >> 18));
			MARKDOWN_URI_HEX(0x80 + (unsigned char) ((c >> 12) & 0x3f));
			MARKDOWN_URI_HEX( 0x80 + (unsigned char) ((c >> 6) & 0x3f));
			MARKDOWN_URI_HEX(0x80 + (unsigned char) (c & 0x3f));
		} else if (c >= 0x800) {
			MARKDOWN_URI_HEX(0xE0 + (unsigned char) (c >> 12));
			MARKDOWN_URI_HEX(0x80 + (unsigned char) ((c >> 6) & 0x3f));
			MARKDOWN_URI_HEX(0x80 + (unsigned char) (c & 0x3f));
		} else if (c >= 0x80) {
			MARKDOWN_URI_HEX(0xC0 + (unsigned char) (c >> 6));
			MARKDOWN_URI_HEX(0x80 + (unsigned char) (c & 0x3f));
		} else {
			switch (c) {
				case '<': WRITE("&lt;"); break;
				case '&': WRITE("&amp;"); break;
				case '>': WRITE("&gt;"); break;
				case '[': MARKDOWN_URI_HEX((unsigned char) c); break;
				case '\\':MARKDOWN_URI_HEX((unsigned char) c); break;
				case '\"':MARKDOWN_URI_HEX((unsigned char) c); break;
				case ']': MARKDOWN_URI_HEX((unsigned char) c); break;
				case '`': MARKDOWN_URI_HEX((unsigned char) c); break;
				case ' ': MARKDOWN_URI_HEX((unsigned char) c); break;
				default: PUT(c); break;
			}
		}
	} else {
		switch (c) {
			case '<': WRITE("&lt;"); break;
			case '&': WRITE("&amp;"); break;
			case '>': WRITE("&gt;"); break;
			case '"': WRITE("&quot;"); break;
			default: PUT(c); break;
		}
	}
}

#line 484 "inweb/foundation-module/Chapter 5/Markdown Rendering.w"
void MDRenderer__hex_digit(OUTPUT_STREAM, unsigned int x) {
	x = x%16;
	if (x<10) PUT('0'+x);
	else PUT('A'+(x-10));
}

#line 13 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_feature *markdown_feature_registry[MAX_MARKDOWNFEATURES];

void MarkdownVariations__start(void) {
	Markdown__create_item_types();
	for (int i=0; i<MAX_MARKDOWNFEATURES; i++) markdown_feature_registry[i] = NULL;
	MarkdownVariations__define_CommonMark();
	MarkdownVariations__define_GFM();
}

markdown_variation *CommonMark_variation = NULL, *GitHub_flavored_Markdown_variation = NULL;

markdown_variation *MarkdownVariations__CommonMark(void) {
	return CommonMark_variation;
}

markdown_variation *MarkdownVariations__GitHub_flavored_Markdown(void) {
	return GitHub_flavored_Markdown_variation;
}

#line 47 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

markdown_variation *MarkdownVariations__new(text_stream *name) {
	markdown_variation *variation = CREATE(markdown_variation);
	variation->name = Str__duplicate(name);
	variation->methods = Methods__new_set();
	for (int i=0; i<NO_DEFINED_MARKDOWNFEATURE_VALUES; i++)
		variation->active_built_in_features[i] = FALSE;
	MarkdownVariations__make_baseline_features_active(variation);
	return variation;
}

void MarkdownVariations__add_feature(markdown_variation *variation, int feature_id) {
	variation->active_built_in_features[feature_id] = TRUE;
}

void MarkdownVariations__remove_feature(markdown_variation *variation, int feature_id) {
	variation->active_built_in_features[feature_id] = FALSE;
}

void MarkdownVariations__copy_features_of(markdown_variation *to, markdown_variation *from) {
	for (int i=0; i<NO_DEFINED_MARKDOWNFEATURE_VALUES; i++)
		to->active_built_in_features[i] = from->active_built_in_features[i];
}

#line 81 "inweb/foundation-module/Chapter 5/Markdown Variations.w"


markdown_feature *MarkdownVariations__new_feature(text_stream *name, int id) {
	markdown_feature *feature = CREATE(markdown_feature);
	if (id >= MAX_MARKDOWNFEATURES) internal_error("too many Markdown features");
	feature->name = Str__duplicate(name);
	feature->feature_ID = id;
	feature->methods = Methods__new_set();
	if (markdown_feature_registry[id]) internal_error("Markdown feature ID clash");
	markdown_feature_registry[id] = feature;
	return feature;
}

#line 98 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
int MarkdownVariations__supports(markdown_variation *variation, int feature_id) {
	return variation->active_built_in_features[feature_id];
}

#line 114 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 123 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 125 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 127 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_feature *block_quotes_Markdown_feature = NULL;
markdown_feature *ordered_lists_Markdown_feature = NULL;
markdown_feature *unordered_lists_Markdown_feature = NULL;
markdown_feature *indented_code_blocks_Markdown_feature = NULL;
markdown_feature *fenced_code_blocks_Markdown_feature = NULL;
markdown_feature *HTML_blocks_Markdown_feature = NULL;
markdown_feature *thematic_markers_Markdown_feature = NULL;
markdown_feature *ATX_headings_Markdown_feature = NULL;
markdown_feature *setext_headings_Markdown_feature = NULL;

markdown_feature *web_autolinks_Markdown_feature = NULL;
markdown_feature *email_autolinks_Markdown_feature = NULL;
markdown_feature *inline_HTML_Markdown_feature = NULL;
markdown_feature *backticked_code_Markdown_feature = NULL;
markdown_feature *links_Markdown_feature = NULL;
markdown_feature *images_Markdown_feature = NULL;
markdown_feature *asterisk_emphasis_Markdown_feature = NULL;
markdown_feature *underscore_emphasis_Markdown_feature = NULL;

markdown_feature *entities_Markdown_feature = NULL;

void MarkdownVariations__define_CommonMark(void) {
	block_quotes_Markdown_feature =         MarkdownVariations__new_feature(TL_IS_2422,         BLOCK_QUOTES_MARKDOWNFEATURE);
	ordered_lists_Markdown_feature =        MarkdownVariations__new_feature(TL_IS_2423,        ORDERED_LISTS_MARKDOWNFEATURE);
	unordered_lists_Markdown_feature =      MarkdownVariations__new_feature(TL_IS_2424,      UNORDERED_LISTS_MARKDOWNFEATURE);
	indented_code_blocks_Markdown_feature = MarkdownVariations__new_feature(TL_IS_2425, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE);
	fenced_code_blocks_Markdown_feature =   MarkdownVariations__new_feature(TL_IS_2426,   FENCED_CODE_BLOCKS_MARKDOWNFEATURE);
	HTML_blocks_Markdown_feature =          MarkdownVariations__new_feature(TL_IS_2427,          HTML_BLOCKS_MARKDOWNFEATURE);
	thematic_markers_Markdown_feature =     MarkdownVariations__new_feature(TL_IS_2428,     THEMATIC_MARKERS_MARKDOWNFEATURE);
	ATX_headings_Markdown_feature =         MarkdownVariations__new_feature(TL_IS_2429,         ATX_HEADINGS_MARKDOWNFEATURE);
	setext_headings_Markdown_feature =      MarkdownVariations__new_feature(TL_IS_2430,      SETEXT_HEADINGS_MARKDOWNFEATURE);

	web_autolinks_Markdown_feature =        MarkdownVariations__new_feature(TL_IS_2431,        WEB_AUTOLINKS_MARKDOWNFEATURE);
	email_autolinks_Markdown_feature =      MarkdownVariations__new_feature(TL_IS_2432,      EMAIL_AUTOLINKS_MARKDOWNFEATURE);
	inline_HTML_Markdown_feature =          MarkdownVariations__new_feature(TL_IS_2433,          INLINE_HTML_MARKDOWNFEATURE);
	backticked_code_Markdown_feature =      MarkdownVariations__new_feature(TL_IS_2434,      BACKTICKED_CODE_MARKDOWNFEATURE);
	links_Markdown_feature =                MarkdownVariations__new_feature(TL_IS_2435,                LINKS_MARKDOWNFEATURE);
	images_Markdown_feature =               MarkdownVariations__new_feature(TL_IS_2436,               IMAGES_MARKDOWNFEATURE);
	asterisk_emphasis_Markdown_feature =    MarkdownVariations__new_feature(TL_IS_2437,             ASTERISK_EMPHASIS_MARKDOWNFEATURE);
	underscore_emphasis_Markdown_feature =  MarkdownVariations__new_feature(TL_IS_2438,             UNDERSCORE_EMPHASIS_MARKDOWNFEATURE);

	entities_Markdown_feature =             MarkdownVariations__new_feature(TL_IS_2439,             ENTITIES_MARKDOWNFEATURE);

	CommonMark_variation = MarkdownVariations__new(TL_IS_2440);
}

void MarkdownVariations__make_baseline_features_active(markdown_variation *variation) {
	MarkdownVariations__add_feature(variation, BLOCK_QUOTES_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, ORDERED_LISTS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, UNORDERED_LISTS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, INDENTED_CODE_BLOCKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, FENCED_CODE_BLOCKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, HTML_BLOCKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, THEMATIC_MARKERS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, ATX_HEADINGS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, SETEXT_HEADINGS_MARKDOWNFEATURE);

	MarkdownVariations__add_feature(variation, WEB_AUTOLINKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, EMAIL_AUTOLINKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, INLINE_HTML_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, BACKTICKED_CODE_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, LINKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, IMAGES_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, ASTERISK_EMPHASIS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, UNDERSCORE_EMPHASIS_MARKDOWNFEATURE);

	MarkdownVariations__add_feature(variation, ENTITIES_MARKDOWNFEATURE);
}

#line 206 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 208 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
markdown_feature *strikethrough_Markdown_feature = NULL;
markdown_feature *tables_Markdown_feature = NULL;
markdown_feature *task_list_items_Markdown_feature = NULL;
markdown_feature *extended_autolinks_Markdown_feature = NULL;
markdown_feature *disallowed_raw_HTML_Markdown_feature = NULL;

void MarkdownVariations__define_GFM(void) {
	strikethrough_Markdown_feature =       MarkdownVariations__new_feature(TL_IS_2441,       STRIKETHROUGH_MARKDOWNFEATURE);
	tables_Markdown_feature =              MarkdownVariations__new_feature(TL_IS_2442,              TABLES_MARKDOWNFEATURE);
	task_list_items_Markdown_feature =     MarkdownVariations__new_feature(TL_IS_2443,     TASK_LIST_ITEMS_MARKDOWNFEATURE);
	extended_autolinks_Markdown_feature =  MarkdownVariations__new_feature(TL_IS_2444,  EXTENDED_AUTOLINKS_MARKDOWNFEATURE);
	disallowed_raw_HTML_Markdown_feature = MarkdownVariations__new_feature(TL_IS_2445, DISALLOWED_RAW_HTML_MARKDOWNFEATURE);

	GitHub_flavored_Markdown_variation = MarkdownVariations__new(TL_IS_2446);
	MarkdownVariations__make_GitHub_features_active(GitHub_flavored_Markdown_variation);
}

void MarkdownVariations__make_GitHub_features_active(markdown_variation *variation) {
	MarkdownVariations__add_feature(variation, STRIKETHROUGH_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, TABLES_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, TASK_LIST_ITEMS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, EXTENDED_AUTOLINKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(variation, DISALLOWED_RAW_HTML_MARKDOWNFEATURE);
}

#line 240 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 242 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
INT_METHOD_TYPE(RENDER_MARKDOWN_MTID, markdown_feature *feature, text_stream *OUT,
	markdown_item *md, int mode)
int MarkdownVariations__intervene_in_rendering(markdown_variation *variation,
	text_stream *OUT, markdown_item *md, int mode) {
	markdown_feature *feature;
	LOOP_OVER(feature, markdown_feature) {
		if (MarkdownVariations__supports(variation, feature->feature_ID)) {
			int rv = FALSE;
			INT_METHOD_CALL(rv, feature, RENDER_MARKDOWN_MTID, OUT, md, mode);
			if (rv) return TRUE;
		}
	}
	return FALSE;
}

#line 262 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 264 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
VOID_METHOD_TYPE(POST_PHASE_I_MARKDOWN_MTID, markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references)
VOID_METHOD_TYPE(POST_PHASE_II_MARKDOWN_MTID, markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references)
void MarkdownVariations__intervene_after_Phase_I(markdown_variation *variation,
	markdown_item *tree, md_links_dictionary *link_references) {
	markdown_feature *feature;
	LOOP_OVER(feature, markdown_feature) {
		if (MarkdownVariations__supports(variation, feature->feature_ID)) {
			VOID_METHOD_CALL(feature, POST_PHASE_I_MARKDOWN_MTID, tree, link_references);
		}
	}
}
void MarkdownVariations__intervene_after_Phase_II(markdown_variation *variation,
	markdown_item *tree, md_links_dictionary *link_references) {
	markdown_feature *feature;
	LOOP_OVER(feature, markdown_feature) {
		if (MarkdownVariations__supports(variation, feature->feature_ID)) {
			VOID_METHOD_CALL(feature, POST_PHASE_II_MARKDOWN_MTID, tree, link_references);
		}
	}
}

#line 293 "inweb/foundation-module/Chapter 5/Markdown Variations.w"

#line 295 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
INT_METHOD_TYPE(MULTIFILE_MARKDOWN_MTID, markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references)
int MarkdownVariations__multifile_mode(markdown_variation *variation,
	markdown_item *tree, md_links_dictionary *link_references) {
	if (tree->down) {
		markdown_feature *feature;
		LOOP_OVER(feature, markdown_feature) {
			if (MarkdownVariations__supports(variation, feature->feature_ID)) {
				int rv = FALSE;
				INT_METHOD_CALL(rv, feature, MULTIFILE_MARKDOWN_MTID, tree, link_references);
				if (rv) {
					
{
#line 316 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
	if (tree->down->type != FILE_MIT) {
		markdown_item *index = Markdown__new_file_marker(Filenames__from_text(TL_IS_2447));
		index->next = tree->down; tree->down = index;
	}
	for (markdown_item *md = tree->down; md; md = md->next) {
		if (md->type == FILE_MIT) {
			md->down = md->next; md->next = NULL;
			markdown_item *ch = md->down, *prev_ch = NULL;
			while ((ch) && (ch->type != FILE_MIT)) { prev_ch = ch, ch = ch->next; }
			if (ch) { prev_ch->next = NULL; md->next = ch; }
		}
	}
	markdown_item *headings[7] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL };
	MarkdownVariations__multifile_r(tree->down, link_references, headings, NULL);

}
#line 306 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
;
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

#line 334 "inweb/foundation-module/Chapter 5/Markdown Variations.w"
void MarkdownVariations__multifile_r(markdown_item *md, md_links_dictionary *link_references,
	markdown_item *headings[7], markdown_item *file_item) {
	int non_heading_found = FALSE;
	for (; md; md = md->next) {
		if (md->type == HEADING_MIT) {
			int L = Markdown__get_heading_level(md);
			headings[L] = md;
			for (int i=L+1; i<=6; i++) headings[i] = NULL;
			text_stream *URL = Str__new();
			if (file_item) {
				WRITE_TO(URL, "%f", Markdown__get_filename(file_item));
			}
			TEMPORARY_TEXT(xref)
			TEMPORARY_TEXT(anchor)
			match_results mr = Regexp__create_mr();
			if (Regexp__match(&mr, md->stashed, U"Chapter (%d+): *(%c*)")) {
				WRITE_TO(xref, "%S", mr.exp[1]);
				WRITE_TO(anchor, "chapter%S", mr.exp[0]);
			} else if (Regexp__match(&mr, md->stashed, U"Chapter (%d+)")) {
				WRITE_TO(xref, "%S", md->stashed);
				WRITE_TO(anchor, "chapter%S", mr.exp[0]);
			} else if (Regexp__match(&mr, md->stashed, U"Section (%d+).(%d+): *(%c*)")) {
				WRITE_TO(xref, "%S", mr.exp[2]);
				WRITE_TO(anchor, "c%Ss%S", mr.exp[0], mr.exp[1]);
			} else if (Regexp__match(&mr, md->stashed, U"Section (%d+).(%d+)")) {
				WRITE_TO(xref, "%S", md->stashed);
				WRITE_TO(anchor, "c%Ss%S", mr.exp[0], mr.exp[1]);
			} else if (Regexp__match(&mr, md->stashed, U"Section (%d+): *(%c*)")) {
				WRITE_TO(xref, "%S", mr.exp[1]);
				WRITE_TO(anchor, "s%S", mr.exp[0]);
			} else if (Regexp__match(&mr, md->stashed, U"Section (%d+)")) {
				WRITE_TO(xref, "%S", md->stashed);
				WRITE_TO(anchor, "s%S", mr.exp[0]);
			} else {
				WRITE_TO(xref, "%S", md->stashed);
				WRITE_TO(anchor, "heading%d", md->id);
			}
			Regexp__dispose_of(&mr);
			if (non_heading_found) {
				WRITE_TO(URL, "#%S", anchor);
			}
			md->user_state = STORE_POINTER_text_stream(URL);
			Markdown__create(link_references, xref, URL, md->stashed);
			DISCARD_TEXT(xref)
			DISCARD_TEXT(anchor)
		} else {
			non_heading_found = TRUE;
		}
		MarkdownVariations__multifile_r(md->down, link_references, headings, (md->type == FILE_MIT)?md:NULL);
	}
}

text_stream *MarkdownVariations__URL_for_heading(markdown_item *md) {
	if ((md) && (md->type == HEADING_MIT) && (Markdown__get_heading_level(md) <= 2))
		if (GENERAL_POINTER_IS_NULL(md->user_state) == FALSE)
			return RETRIEVE_POINTER_text_stream(md->user_state);
	return NULL;
}

#line 10 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_variation *Inform_flavoured_Markdown = NULL;

markdown_variation *InformFlavouredMarkdown__variation(void) {
	if (Inform_flavoured_Markdown) return Inform_flavoured_Markdown;
	Inform_flavoured_Markdown = MarkdownVariations__new(TL_IS_2448);

	MarkdownVariations__copy_features_of(Inform_flavoured_Markdown,
		MarkdownVariations__GitHub_flavored_Markdown());

	MarkdownVariations__remove_feature(Inform_flavoured_Markdown, HTML_BLOCKS_MARKDOWNFEATURE);
	MarkdownVariations__remove_feature(Inform_flavoured_Markdown, INLINE_HTML_MARKDOWNFEATURE);

	
{
#line 45 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *fe = MarkdownVariations__new_feature(TL_IS_2449,
		FORMATTING_ERRORS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		FORMATTING_ERRORS_MARKDOWNFEATURE);
	METHOD_ADD(fe, RENDER_MARKDOWN_MTID, InformFlavouredMarkdown__render_errors);
	Markdown__new_leaf_block_type(INFORM_ERROR_MARKER_MIT, TL_IS_2450);

}
#line 22 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 86 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *he = MarkdownVariations__new_feature(TL_IS_2452,
		OLD_INDOC_HEADINGS_MARKDOWNFEATURE);
	METHOD_ADD(he, POST_PHASE_I_MARKDOWN_MTID,
		InformFlavouredMarkdown__OIH_intervene_after_Phase_I);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		OLD_INDOC_HEADINGS_MARKDOWNFEATURE);

}
#line 23 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 134 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *he = MarkdownVariations__new_feature(TL_IS_2453,
		DESCRIPTIVE_INFORM_HEADINGS_MARKDOWNFEATURE);
	METHOD_ADD(he, POST_PHASE_I_MARKDOWN_MTID,
		InformFlavouredMarkdown__Inform_headings_intervene_after_Phase_I);
	METHOD_ADD(he, RENDER_MARKDOWN_MTID, InformFlavouredMarkdown__render_descriptive_headings);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		DESCRIPTIVE_INFORM_HEADINGS_MARKDOWNFEATURE);

}
#line 24 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 303 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *ee =
		MarkdownVariations__new_feature(TL_IS_2454, EMBEDDED_EXAMPLES_MARKDOWNFEATURE);
	METHOD_ADD(ee, POST_PHASE_I_MARKDOWN_MTID, InformFlavouredMarkdown__EE_intervene_after_Phase_I);
	METHOD_ADD(ee, RENDER_MARKDOWN_MTID, InformFlavouredMarkdown__EE_render);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown, EMBEDDED_EXAMPLES_MARKDOWNFEATURE);
	Markdown__new_container_block_type(INFORM_EXAMPLE_HEADING_MIT, TL_IS_2455);

}
#line 25 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 515 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *pi = MarkdownVariations__new_feature(TL_IS_2461,
		PASTE_BUTTONS_MARKDOWNFEATURE);
	METHOD_ADD(pi, POST_PHASE_I_MARKDOWN_MTID,
		InformFlavouredMarkdown__paste_buttons_intervene_after_Phase_I);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown, PASTE_BUTTONS_MARKDOWNFEATURE);

}
#line 26 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 569 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *pd = MarkdownVariations__new_feature(TL_IS_2464,
		PHRASE_DEFN_BOXES_MARKDOWNFEATURE);
	METHOD_ADD(pd, RENDER_MARKDOWN_MTID, InformFlavouredMarkdown__PD_render);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown, PHRASE_DEFN_BOXES_MARKDOWNFEATURE);

}
#line 27 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 608 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	MarkdownVariations__new_feature(TL_IS_2465, INDEXING_MARKS_MARKDOWNFEATURE);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		INDEXING_MARKS_MARKDOWNFEATURE);
	Markdown__new_quasiplainish_inline_type(INDEX_MARKER_MIT, TL_IS_2466);

}
#line 28 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 622 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *he = MarkdownVariations__new_feature(TL_IS_2467,
		HEADING_MARKERS_MARKDOWNFEATURE);
	METHOD_ADD(he, POST_PHASE_I_MARKDOWN_MTID,
		InformFlavouredMarkdown__HM_intervene_after_Phase_I);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		HEADING_MARKERS_MARKDOWNFEATURE);
	Markdown__new_leaf_block_type(HEADING_MARKER_MIT, TL_IS_2468);

}
#line 29 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 658 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *pg = MarkdownVariations__new_feature(TL_IS_2469,
		PARAGRAPH_GATING_MARKDOWNFEATURE);
	METHOD_ADD(pg, POST_PHASE_I_MARKDOWN_MTID,
		InformFlavouredMarkdown__PG_intervene_after_Phase_I);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		PARAGRAPH_GATING_MARKDOWNFEATURE);
	METHOD_ADD(pg, RENDER_MARKDOWN_MTID, InformFlavouredMarkdown__PG_render);
	Markdown__new_container_block_type(GATE_MIT, TL_IS_2470);

}
#line 30 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 733 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *indoc_chaps =
		MarkdownVariations__new_feature(TL_IS_2471, INDOC_FILE_DIVISIONS_MARKDOWNFEATURE);
	METHOD_ADD(indoc_chaps, MULTIFILE_MARKDOWN_MTID, InformFlavouredMarkdown__IFD_multifile);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown, INDOC_FILE_DIVISIONS_MARKDOWNFEATURE);

}
#line 31 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	
{
#line 760 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	markdown_feature *sc =
		MarkdownVariations__new_feature(TL_IS_2472,
			INFORM_SYNTAX_COLOURING_MARKDOWNFEATURE);
	METHOD_ADD(sc, RENDER_MARKDOWN_MTID, InformFlavouredMarkdown__SC_render);
	MarkdownVariations__add_feature(Inform_flavoured_Markdown,
		INFORM_SYNTAX_COLOURING_MARKDOWNFEATURE);

}
#line 32 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;

	return Inform_flavoured_Markdown;
}

#line 43 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 53 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_item *InformFlavouredMarkdown__error_item(text_stream *text) {
	markdown_item *E = Markdown__new_item(INFORM_ERROR_MARKER_MIT);
	E->stashed = Str__duplicate(text);
	return E;
}

int InformFlavouredMarkdown__render_errors(markdown_feature *feature, text_stream *OUT,
	markdown_item *md, int mode) {
	if (md->type == INFORM_ERROR_MARKER_MIT) {
		HTML_OPEN_WITH("p", "class=\"documentationerrorbox\"");
		HTML__begin_span(OUT, TL_IS_2451);
		WRITE("Error: %S", md->stashed);
		HTML_CLOSE("span");
		HTML_CLOSE("p");
		return TRUE;
	}
	return FALSE;
}

#line 94 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__OIH_intervene_after_Phase_I(markdown_feature *feature,
	markdown_item *md, md_links_dictionary *link_references) {
	if (md->type == PARAGRAPH_MIT) {
		text_stream *line = md->stashed;
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, line, U"%[x%] *(%c+?)")) {
			MDBlockParser__change_type(NULL, md, HEADING_MIT);
			Markdown__set_heading_level(md, 2);
			Str__clear(line);
			WRITE_TO(line, "%S", mr.exp[0]);
		} else if (Regexp__match(&mr, line, U"%[Chapter: *(%c+)%] *(%c+?)")) {
			MDBlockParser__change_type(NULL, md, HEADING_MIT);
			Markdown__set_heading_level(md, 1);
			Str__clear(line);
			WRITE_TO(line, "%S", mr.exp[0]);
			markdown_item *sect = Markdown__new_item(HEADING_MIT);
			Markdown__set_heading_level(sect, 2);
			sect->stashed = Str__duplicate(mr.exp[1]);
			sect->next = md->next; md->next = sect;
		}
		Regexp__dispose_of(&mr);
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__OIH_intervene_after_Phase_I(feature, ch, link_references);
	}
}

#line 143 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__Inform_headings_intervene_after_Phase_I(markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references) {
	InformFlavouredMarkdown__Inform_headings_r(tree);
	int section_number = 0, chapter_number = 0;
	TEMPORARY_TEXT(latest)
	InformFlavouredMarkdown__number_headings_r(tree, &section_number, &chapter_number, latest, 0);
	DISCARD_TEXT(latest)
}

#line 155 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__Inform_headings_r(markdown_item *md) {
	if (md->type == PARAGRAPH_MIT) {
		text_stream *line = md->stashed;
		match_results mr = Regexp__create_mr();
		if ((Regexp__match(&mr, line, U"Section *: *(%c+?)")) ||
			(Regexp__match(&mr, line, U"Section *- *(%c+?)"))) {
			MDBlockParser__change_type(NULL, md, HEADING_MIT);
			Markdown__set_heading_level(md, 2);
			Str__clear(line);
			WRITE_TO(line, "%S", mr.exp[0]);
		} else if ((Regexp__match(&mr, line, U"Chapter *: *(%c+?)")) ||
			(Regexp__match(&mr, line, U"Chapter *- *(%c+?)"))) {
			MDBlockParser__change_type(NULL, md, HEADING_MIT);
			Markdown__set_heading_level(md, 1);
			Str__clear(line);
			WRITE_TO(line, "%S", mr.exp[0]);
		}
		Regexp__dispose_of(&mr);
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__Inform_headings_r(ch);
	}
}

#line 183 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__number_headings_r(markdown_item *md,
	int *section_number, int *chapter_number, text_stream *latest, int level) {
	if (md->type == HEADING_MIT) {
		switch (Markdown__get_heading_level(md)) {
			case 1: {
				if (level > 1) {
					MDBlockParser__change_type(NULL, md, PARAGRAPH_MIT);
				} else {
					md->user_state = STORE_POINTER_text_stream(md->stashed);
					(*chapter_number)++;
					(*section_number) = 0;
					Str__clear(latest);
					WRITE_TO(latest, "Chapter %d: %S", *chapter_number, md->stashed);
					md->stashed = Str__duplicate(latest);
				}
				break;
			}
			case 2: {
				if (level > 1) {
					MDBlockParser__change_type(NULL, md, PARAGRAPH_MIT);
				} else {
					md->user_state = STORE_POINTER_text_stream(md->stashed);
					(*section_number)++;
					Str__clear(latest);
					WRITE_TO(latest, "Section ");
					if (*chapter_number > 0) WRITE_TO(latest, "%d.", *chapter_number);
					WRITE_TO(latest, "%d: %S", *section_number, md->stashed);
					md->stashed = Str__duplicate(latest);
				}
				break;
			}
		}
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__number_headings_r(ch, section_number, chapter_number,
			latest, level + 1);
	}
}

#line 223 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_item *InformFlavouredMarkdown__find_section(markdown_item *tree, text_stream *name) {
	if (Str__len(name) == 0) return NULL;
	markdown_item *result = NULL;
	InformFlavouredMarkdown__find_s(tree, name, &result);
	return result;
}

void InformFlavouredMarkdown__find_s(markdown_item *md, text_stream *name, markdown_item **result) {
	if (md->type == HEADING_MIT) {
		switch (Markdown__get_heading_level(md)) {
			case 1:
			case 2: {
				int i=0;
				for (; i<Str__len(md->stashed); i++)
					if (Str__get_at(md->stashed, i) == ':') { i+=2; break; }
				if (i + Str__len(name) == Str__len(md->stashed)) {
					int fail = FALSE;
					for (int j=0; j<Str__len(name); j++, i++)
						if (Str__get_at(name, j) != Str__get_at(md->stashed, i)) { fail = TRUE; break; }
					if ((fail == FALSE) && (*result == NULL)) *result = md;
				}
				break;
			}
		}
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__find_s(ch, name, result);
	}
}

#line 254 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int InformFlavouredMarkdown__render_descriptive_headings(markdown_feature *feature,
	text_stream *OUT, markdown_item *md, int mode) {
	if (md->type == HEADING_MIT) {
		int L = Markdown__get_heading_level(md);
		switch (L) {
			case 1: HTML_OPEN("h2"); break;
			case 2: HTML_OPEN("h3"); break;
			case 3: HTML_OPEN("h4"); break;
			case 4: HTML_OPEN("h5"); break;
			default: HTML_OPEN("h6"); break;
		}
		TEMPORARY_TEXT(anchor)
		text_stream *url = MarkdownVariations__URL_for_heading(md);
		for (int i=0; i<Str__len(url); i++)
			if (Str__get_at(url, i) == '#')
				for (i++; i<Str__len(url); i++)
					PUT_TO(anchor, Str__get_at(url, i));
		if (Str__len(anchor) > 0) {
			HTML_OPEN_WITH("span", "id=%S", anchor);
		} else {
			HTML_OPEN("span");
		}
		DISCARD_TEXT(anchor)
		for (markdown_item *ch = md->down; ch; ch = ch->next)
			Markdown__render_extended(OUT, ch, InformFlavouredMarkdown__variation());
		HTML_CLOSE("span");
		switch (L) {
			case 1: HTML_CLOSE("h2"); break;
			case 2: HTML_CLOSE("h3"); break;
			case 3: HTML_CLOSE("h4"); break;
			case 4: HTML_CLOSE("h5"); break;
			default: HTML_CLOSE("h6"); break;
		}
		WRITE("\n");
		return TRUE;
	}
	return FALSE;
}

#line 301 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 317 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__EE_intervene_after_Phase_I(markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references) {
	int example_number = 0;
	InformFlavouredMarkdown__detect_embedded_examples_r(tree, &example_number);
	InformFlavouredMarkdown__regroup_examples_r(tree, &example_number);
}

void InformFlavouredMarkdown__detect_embedded_examples_r(markdown_item *md, int *example_number) {
	if (md->type == PARAGRAPH_MIT) {
		text_stream *line = md->stashed;
		match_results mr = Regexp__create_mr();
		if ((Regexp__match(&mr, line, U"Example *: *(%**) *(%c+?)")) ||
			(Regexp__match(&mr, line, U"Example *- *(%**) *(%c+?)"))) {
			MDBlockParser__change_type(NULL, md, INFORM_EXAMPLE_HEADING_MIT);
			int star_count = Str__len(mr.exp[0]);
			IFM_example *new_eg = InformFlavouredMarkdown__new_example(mr.exp[1], NULL,
				star_count, ++(*example_number));
			new_eg->cue = NULL;
			new_eg->header = md;
			if (star_count == 0) {
				markdown_item *E = InformFlavouredMarkdown__error_item(
					TL_IS_2456);
				E->next = md->next; md->next = E;
			}
			if (star_count > 4) {
				markdown_item *E = InformFlavouredMarkdown__error_item(
					TL_IS_2457);
				E->next = md->next; md->next = E;
			}
			md->user_state = STORE_POINTER_IFM_example(new_eg);
		}
		Regexp__dispose_of(&mr);
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__detect_embedded_examples_r(ch, example_number);
	}
}

#line 361 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__regroup_examples_r(markdown_item *md, int *example_number) {
	if (md->type == INFORM_EXAMPLE_HEADING_MIT) {
		if (md->down == NULL) {
			markdown_item *run_from = md->next;
			if (run_from) {
				markdown_item *run_to = run_from, *prev = NULL;
				while (run_to) {
					if (run_to->type == INFORM_EXAMPLE_HEADING_MIT) break;
					if ((run_to->type == HEADING_MIT) &&
						(Markdown__get_heading_level(run_to) <= 2)) break;
					prev = run_to;
					run_to = run_to->next;
				}
				if (prev) {
					md->down = run_from; md->next = run_to; prev->next = NULL;
				}
			}
		}
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__regroup_examples_r(ch, example_number);
	}
}

#line 388 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
markdown_item *InformFlavouredMarkdown__find_example(markdown_item *tree, int eg) {
	if (eg <= 0) return NULL;
	markdown_item *result = NULL;
	int counter = 0;
	InformFlavouredMarkdown__find_e(tree, eg, &result, &counter);
	return result;
}

void InformFlavouredMarkdown__find_e(markdown_item *md, int eg, markdown_item **result,
	int *counter) {
	if (md->type == INFORM_EXAMPLE_HEADING_MIT) {
		(*counter)++;
		if (*counter == eg) *result = md;
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__find_e(ch, eg, result, counter);
	}
}

#line 423 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

IFM_example *InformFlavouredMarkdown__new_example(text_stream *title, text_stream *desc,
	int star_count, int ecount) {
	IFM_example *E = CREATE(IFM_example);
	E->name = Str__duplicate(title);
	E->description = Str__duplicate(desc);
	E->header = NULL;
	E->cue = NULL;
	E->star_count = star_count;
	E->number = ecount;
	E->insignia = Str__new();
	E->ex_index = Str__new();
	E->ex_subtitle = Str__new();
	WRITE_TO(E->insignia, "e%d", ecount);
	return E;
}

#line 445 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int InformFlavouredMarkdown__EE_render(markdown_feature *feature,
	text_stream *OUT, markdown_item *md, int mode) {
	if (md->type == INFORM_EXAMPLE_HEADING_MIT) {
		IFM_example *E = RETRIEVE_POINTER_IFM_example(md->user_state);
		InformFlavouredMarkdown__render_example_heading(OUT, E, FALSE);
		return TRUE;
	}
	return FALSE;
}

void InformFlavouredMarkdown__render_example_heading(OUTPUT_STREAM, IFM_example *E,
	int in_stand_alone_file) {
	TEMPORARY_TEXT(link)
	if (E->cue) {
		if (in_stand_alone_file) {
			WRITE_TO(link, "style=\"text-decoration: none\" href=\"%S\"",
				MarkdownVariations__URL_for_heading(E->cue));
		} else {
			WRITE_TO(link, "style=\"text-decoration: none\" href=\"eg_%S.html\"",
				E->insignia);
		}
	}

	HTML_TAG("hr"); /* rule a line before the example heading */
	HTML_OPEN_WITH("div", "class=\"examplebox\"");

	/* Left hand cell: the oval icon */
	HTML_OPEN_WITH("div", "class=\"exampleleft\"");
	HTML_OPEN_WITH("span", "id=eg%S", E->insignia); /* provide the anchor point */
	if (Str__len(link) > 0) HTML_OPEN_WITH("a", "%S", link);
	HTML__begin_span(OUT, TL_IS_2458);
	WRITE("%S", E->insignia);
	HTML__end_span(OUT);
	if (Str__len(link) > 0) HTML_CLOSE("a");
	HTML_CLOSE("span"); /* end the textual link */
	HTML_CLOSE("div");

	/* Right hand cell: the asterisks and title, with rubric underneath */
	HTML_OPEN_WITH("div", "class=\"exampleright\"");
	if (Str__len(link) > 0) HTML_OPEN_WITH("a", "%S", link);
	for (int asterisk = 0; asterisk < E->star_count; asterisk++)
		PUT(0x2605); /* the Unicode for "black star" emoji */
	/* or 0x2B50 is the Unicode for "star" emoji */
	/* or again, could use the asterisk.png image in the app */
	WRITE("&nbsp; ");
	HTML_OPEN("b");
	HTML__begin_span(OUT, TL_IS_2459);
	WRITE("&nbsp;Example&nbsp;");
	HTML__end_span(OUT);
	HTML__begin_span(OUT, TL_IS_2460);
	InformFlavouredMarkdown__render_text(OUT, E->name);
	HTML_TAG("br");
	InformFlavouredMarkdown__render_text(OUT, E->description);
	HTML__end_span(OUT);
	HTML_CLOSE("b");
	if (Str__len(link) > 0) HTML_CLOSE("a");
	HTML_CLOSE("div");

	HTML_CLOSE("div");
	DISCARD_TEXT(link)
}

#line 513 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 522 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__paste_buttons_intervene_after_Phase_I(markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references) {
	InformFlavouredMarkdown__pbiapi_r(tree);
}

void InformFlavouredMarkdown__pbiapi_r(markdown_item *md) {
	markdown_item *current_sample = NULL;
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		if ((ch->type == CODE_BLOCK_MIT) && (Str__prefix_eq(ch->stashed, TL_IS_2462, 3))) {
			ch->user_state = STORE_POINTER_markdown_item(ch);
			current_sample = ch;
			Str__delete_first_character(ch->stashed);
			Str__delete_first_character(ch->stashed);
			Str__delete_first_character(ch->stashed);
		} else if ((ch->type == CODE_BLOCK_MIT) &&
			(Str__prefix_eq(ch->stashed, TL_IS_2463, 3)) && (current_sample)) {
			ch->user_state = STORE_POINTER_markdown_item(current_sample);
			Str__delete_first_character(ch->stashed);
			Str__delete_first_character(ch->stashed);
			Str__delete_first_character(ch->stashed);
			Str__delete_first_character(ch->stashed);
		}
		InformFlavouredMarkdown__pbiapi_r(ch);
		if (ch->type == CODE_BLOCK_MIT) {
			TEMPORARY_TEXT(detabbed)
			for (int i=0, margin=0; i<Str__len(ch->stashed); i++) {
				inchar32_t c = Str__get_at(ch->stashed, i);
				if (c == '\t') {
					PUT_TO(detabbed, ' '); margin++;
					while (margin % 4 != 0) { PUT_TO(detabbed, ' '); margin++; }
				} else {
					PUT_TO(detabbed, c); margin++;
					if (c == '\n') margin = 0;
				}
			}
			Str__clear(ch->stashed);
			WRITE_TO(ch->stashed, "%S", detabbed);
			DISCARD_TEXT(detabbed);
		}
	}
}

#line 567 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 575 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int InformFlavouredMarkdown__PD_render(markdown_feature *feature, text_stream *OUT,
	markdown_item *md, int mode) {
	if (md->type == BLOCK_QUOTE_MIT) {
		if ((md->down) && (md->down->type == PARAGRAPH_MIT)) {
			match_results mr = Regexp__create_mr();
			if ((Regexp__match(&mr, md->down->stashed, U"phrase: *{(%c*?)} *(%c+?)\n(%c*)")) ||
				(Regexp__match(&mr, md->down->stashed, U"(phrase): *(%c+?)\n(%c*)"))) {
				HTML_OPEN_WITH("div", "class=\"definition\"");
				HTML_OPEN_WITH("p", "class=\"defnprototype\"");
				WRITE("%S", mr.exp[1]);
				HTML_CLOSE("p");
				HTML_TAG("br");
				markdown_item *remainder =
					Markdown__parse_inline_extended(mr.exp[2], InformFlavouredMarkdown__variation());
				Markdown__render_extended(OUT, remainder, InformFlavouredMarkdown__variation());
				for (markdown_item *ch = md->down->next; ch; ch = ch->next)
					Markdown__render_extended(OUT, ch, InformFlavouredMarkdown__variation());
				HTML_CLOSE("div");
				Regexp__dispose_of(&mr);
				return TRUE;
			}
			Regexp__dispose_of(&mr);
		}
	}
	return FALSE;
}

#line 606 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 620 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 631 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__HM_intervene_after_Phase_I(markdown_feature *feature,
	markdown_item *md, md_links_dictionary *link_references) {
	if ((md->type == HEADING_MIT) && (Markdown__get_heading_level(md) <= 2)) {
		text_stream *line = md->stashed;
		match_results mr = Regexp__create_mr();
		while (Regexp__match(&mr, line, U"(%c*) %{(%C+)%} *")) {
			markdown_item *hm_item = Markdown__new_item(HEADING_MARKER_MIT);
			hm_item->stashed = Str__duplicate(mr.exp[1]);
			Str__clear(line); Str__copy(line, mr.exp[0]);
			Markdown__add_to(hm_item, md);
		}
		Regexp__dispose_of(&mr);
		Str__trim_white_space(line);
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__HM_intervene_after_Phase_I(feature, ch, link_references);
	}
}

#line 656 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 668 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__PG_intervene_after_Phase_I(markdown_feature *feature,
	markdown_item *md, md_links_dictionary *link_references) {
	if (md->type == PARAGRAPH_MIT) {
		text_stream *line = md->stashed;
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, line, U"%{(%C+?):%} *(%c*)")) {
			MDBlockParser__change_type(NULL, md, GATE_MIT);
			md->details = TRUE;
			Str__clear(line); Str__copy(line, mr.exp[0]);
			markdown_item *gated_item = Markdown__new_item(PARAGRAPH_MIT);
			gated_item->stashed = Str__duplicate(mr.exp[1]);
			gated_item->down = md->down;
			md->down = gated_item;
			InformFlavouredMarkdown__expand_gate(md);
		}
		Regexp__dispose_of(&mr);
	}
	for (markdown_item *ch = md->down; ch; ch=ch->next) {
		InformFlavouredMarkdown__PG_intervene_after_Phase_I(feature, ch, link_references);
	}
}

void InformFlavouredMarkdown__expand_gate(markdown_item *md) {
	if (Str__get_at(md->stashed, 0) == '^') {
		md->details = FALSE;
		Str__delete_first_character(md->stashed);
	}
	for (int i=0; i<Str__len(md->stashed); i++)
		if (Str__get_at(md->stashed, i) == ',') {
			markdown_item *subgate_item = Markdown__new_item(GATE_MIT);
			subgate_item->stashed = Str__new();
			for (int j=i+1; j<Str__len(md->stashed); j++)
				PUT_TO(subgate_item->stashed, Str__get_at(md->stashed, j));
			subgate_item->details = TRUE;
			Str__truncate(md->stashed, i);
			subgate_item->down = md->down; md->down = subgate_item;
			InformFlavouredMarkdown__expand_gate(subgate_item);
			break;
		}
}

int (*IFM_gatekeeper)(text_stream *) = NULL;

void InformFlavouredMarkdown__set_gatekeeper_function(int (gatekeeper)(text_stream *)) {
	IFM_gatekeeper = gatekeeper;
}

int InformFlavouredMarkdown__PG_render(markdown_feature *feature, text_stream *OUT,
	markdown_item *md, int mode) {
	if (md->type == GATE_MIT) {
		int decision = FALSE;
		if (IFM_gatekeeper) decision = IFM_gatekeeper(md->stashed);
		if (md->details == FALSE) decision = (decision)?FALSE:TRUE;
		if (decision)
			Markdown__render_extended(OUT, md->down, InformFlavouredMarkdown__variation());
		return TRUE;
	}
	return FALSE;
}

#line 731 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 739 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int InformFlavouredMarkdown__IFD_multifile(markdown_feature *feature,
	markdown_item *tree, md_links_dictionary *link_references) {
	int N = 1;
	for (markdown_item *prev_md = NULL, *md = tree->down; md; prev_md = md, md = md->next) {
		if ((md->type == HEADING_MIT) && (Markdown__get_heading_level(md) == 1)) {
			TEMPORARY_TEXT(leaf)
			WRITE_TO(leaf, "chapter%d.html", N++);
			markdown_item *file_marker = Markdown__new_file_marker(Filenames__from_text(leaf));
			DISCARD_TEXT(leaf)
			if (prev_md) prev_md->next = file_marker; else tree->down = file_marker;
			file_marker->next = md;
		}
	}
	return TRUE;
}

#line 758 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"

#line 768 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
int InformFlavouredMarkdown__SC_render(markdown_feature *feature, text_stream *OUT,
	markdown_item *md, int mode) {
	switch (md->type) {
		case CODE_MIT:       
{
#line 782 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	if (mode & TAGS_MDRMODE) {
		if (Markdown__get_backtick_count(md) == 1) {
			HTML_OPEN_WITH("code", "class=\"inlinesourcetext\"");
		} else if (Markdown__get_backtick_count(md) == 2) {
			HTML_OPEN_WITH("code", "class=\"inlinetranscript\"");
			mode = mode | TOLOWER_MDRMODE;
		} else {
			HTML_OPEN_WITH("code", "class=\"inlinecode\"");
		}
	}
	mode = mode & (~ESCAPES_MDRMODE);
	mode = mode & (~ENTITIES_MDRMODE);
	MDRenderer__slice(OUT, md, mode);
	if (mode & TAGS_MDRMODE) HTML_CLOSE("code");

}
#line 771 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
; return TRUE;
		case CODE_BLOCK_MIT: 
{
#line 801 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	TEMPORARY_TEXT(language_text)
	TEMPORARY_TEXT(language)
	for (int i=0; i<Str__len(md->info_string); i++) {
		inchar32_t c = Str__get_at(md->info_string, i);
		if ((c == ' ') || (c == '\t')) break;
		PUT_TO(language_text, c);
	}
	if (Str__len(language_text) > 0) {
		md->sliced_from = language_text;
		md->from = 0; md->to = Str__len(language_text) - 1;
		MDRenderer__slice(language, md, mode | ENTITIES_MDRMODE);
	}
	
{
#line 829 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	if (Str__len(language) == 0) {
		for (int i=0; i<Str__len(md->stashed); i++)
			if ((Str__get_at(md->stashed, i) == '>') &&
				((i==0) || (Str__get_at(md->stashed, i-1) == '\n'))) {
				Str__clear(language);
				WRITE_TO(language, "transcript");
			}
		if (Str__len(language) == 0) WRITE_TO(language, "inform");
	}

}
#line 813 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	if ((Str__eq_insensitive(language, TL_IS_2473)) ||
		(Str__eq_insensitive(language, TL_IS_2474))) {
		
{
#line 840 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML_OPEN("blockquote");
	if (GENERAL_POINTER_IS_NULL(md->user_state) == FALSE) {
		markdown_item *first = RETRIEVE_POINTER_markdown_item(md->user_state);
		TEMPORARY_TEXT(accumulated)
		for (markdown_item *ch = md; ch; ch = ch->next) {
			if (ch->type == CODE_BLOCK_MIT) {
				if (GENERAL_POINTER_IS_NULL(ch->user_state) == FALSE) {
					markdown_item *latest = RETRIEVE_POINTER_markdown_item(ch->user_state);
					if (first == latest) WRITE_TO(accumulated, "%S", ch->stashed);
				}
			}
		}
		#ifdef HTML_MODULE
		PasteButtons__paste_text_new_style(OUT, accumulated);
		#endif
		DISCARD_TEXT(accumulated)
	}
	TEMPORARY_TEXT(colouring)
	programming_language *default_language = Languages__find_by_name(TL_IS_2476, NULL, FALSE);

	programming_language *pl = default_language;
	if (pl) {
		Painter__reset_syntax_colouring(pl);
		Painter__syntax_colour(pl, NULL, md->stashed, colouring, FALSE);
		if (Str__eq(pl->language_name, TL_IS_2477)) {
			int ts = FALSE;
			for (int i=0; i<Str__len(colouring); i++) {
				if (Str__get_at(colouring, i) == STRING_COLOUR) {
					inchar32_t c = Str__get_at(md->stashed, i);
					if (c == '[') ts = TRUE;
					if (ts) Str__put_at(colouring, i, EXTRACT_COLOUR);
					if (c == ']') ts = FALSE;
				} else ts = FALSE;
			}
		}
	}
	HTML__begin_span(OUT, TL_IS_2478);
	int tabulating = FALSE, tabular = FALSE, line_count = 0;
	TEMPORARY_TEXT(line)
	TEMPORARY_TEXT(line_colouring)
	for (int k=0; k<Str__len(md->stashed); k++) {
		if (Str__get_at(md->stashed, k) == '\n') {
			
{
#line 898 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	line_count++;
	if (Str__is_whitespace(line)) tabular = FALSE;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"Table %c*")) tabular = TRUE;
	Regexp__dispose_of(&mr);
	if (tabular) {
		if (tabulating) {
			
{
#line 962 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__first_html_column(OUT, 0);

}
#line 905 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
		} else {
			
{
#line 946 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_span(OUT);
	HTML_TAG("br");
	HTML__begin_plain_html_table(OUT);
	HTML__first_html_column(OUT, 0);

}
#line 907 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
			tabulating = TRUE;
		}
		int cell_from = 0, cell_to = 0, i = 0;
		
{
#line 958 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	cell_from = i; cell_to = cell_from;
	HTML__begin_span(OUT, TL_IS_2479);

}
#line 911 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
		for (; i<Str__len(line); i++) {
			if (Str__get_at(line, i) == '\t') {
				
{
#line 952 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
		cell_from, cell_to, mode);
	HTML__end_span(OUT);
	HTML__next_html_column(OUT, 0);

}
#line 914 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
				while (Str__get_at(line, i) == '\t') i++;
				
{
#line 958 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	cell_from = i; cell_to = cell_from;
	HTML__begin_span(OUT, TL_IS_2479);

}
#line 916 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
				i--;
			} else {
				cell_to++;
			}
		}
		
{
#line 952 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
		cell_from, cell_to, mode);
	HTML__end_span(OUT);
	HTML__next_html_column(OUT, 0);

}
#line 922 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
		
{
#line 965 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_html_row(OUT);

}
#line 923 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	} else {
		if (line_count > 1) HTML_TAG("br");
		if (tabulating) {
			
{
#line 968 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_html_table(OUT);
	HTML__begin_span(OUT, TL_IS_2480);

}
#line 927 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
			tabulating = FALSE;
		}
		int indentation = 0;
		int z=0, spaces = 0;
		for (; z<Str__len(line); z++)
			if (Str__get_at(line, z) == ' ') { spaces++; if (spaces == 4) { indentation++; spaces = 0; } }
			else if (Str__get_at(line, z) == '\t') { indentation++; spaces = 0; }
			else break;
		for (int n=0; n<indentation; n++) WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
		InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
			z, Str__len(line), mode);
	}
	WRITE("\n");

}
#line 882 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
			Str__clear(line);
			Str__clear(line_colouring);
		} else {
			PUT_TO(line, Str__get_at(md->stashed, k));
			PUT_TO(line_colouring, Str__get_at(colouring, k));
		}
		if ((k == Str__len(md->stashed) - 1) && (Str__len(line) > 0)) 
{
#line 898 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	line_count++;
	if (Str__is_whitespace(line)) tabular = FALSE;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"Table %c*")) tabular = TRUE;
	Regexp__dispose_of(&mr);
	if (tabular) {
		if (tabulating) {
			
{
#line 962 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__first_html_column(OUT, 0);

}
#line 905 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
		} else {
			
{
#line 946 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_span(OUT);
	HTML_TAG("br");
	HTML__begin_plain_html_table(OUT);
	HTML__first_html_column(OUT, 0);

}
#line 907 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
			tabulating = TRUE;
		}
		int cell_from = 0, cell_to = 0, i = 0;
		
{
#line 958 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	cell_from = i; cell_to = cell_from;
	HTML__begin_span(OUT, TL_IS_2479);

}
#line 911 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
		for (; i<Str__len(line); i++) {
			if (Str__get_at(line, i) == '\t') {
				
{
#line 952 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
		cell_from, cell_to, mode);
	HTML__end_span(OUT);
	HTML__next_html_column(OUT, 0);

}
#line 914 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
				while (Str__get_at(line, i) == '\t') i++;
				
{
#line 958 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	cell_from = i; cell_to = cell_from;
	HTML__begin_span(OUT, TL_IS_2479);

}
#line 916 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
				i--;
			} else {
				cell_to++;
			}
		}
		
{
#line 952 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
		cell_from, cell_to, mode);
	HTML__end_span(OUT);
	HTML__next_html_column(OUT, 0);

}
#line 922 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
		
{
#line 965 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_html_row(OUT);

}
#line 923 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	} else {
		if (line_count > 1) HTML_TAG("br");
		if (tabulating) {
			
{
#line 968 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_html_table(OUT);
	HTML__begin_span(OUT, TL_IS_2480);

}
#line 927 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
			tabulating = FALSE;
		}
		int indentation = 0;
		int z=0, spaces = 0;
		for (; z<Str__len(line); z++)
			if (Str__get_at(line, z) == ' ') { spaces++; if (spaces == 4) { indentation++; spaces = 0; } }
			else if (Str__get_at(line, z) == '\t') { indentation++; spaces = 0; }
			else break;
		for (int n=0; n<indentation; n++) WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
		InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
			z, Str__len(line), mode);
	}
	WRITE("\n");

}
#line 889 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	}
	HTML_CLOSE("span");
	if (tabulating) 
{
#line 968 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	HTML__end_html_table(OUT);
	HTML__begin_span(OUT, TL_IS_2480);

}
#line 892 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	HTML_CLOSE("blockquote");
	DISCARD_TEXT(line)
	DISCARD_TEXT(line_colouring)

}
#line 816 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	} else if (Str__eq_insensitive(language, TL_IS_2475)) {
		
{
#line 972 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	if (mode & TAGS_MDRMODE)
		HTML_OPEN_WITH("div", "class=\"extract-problems\"");
	if (mode & TAGS_MDRMODE) HTML_OPEN("blockquote");
	for (int k=0; k<Str__len(md->stashed); k++)
		MDRenderer__char(OUT, Str__get_at(md->stashed, k), mode);
	if (mode & TAGS_MDRMODE) HTML_CLOSE("blockquote");
	if (mode & TAGS_MDRMODE) HTML_CLOSE("div");

}
#line 818 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	} else {
		
{
#line 981 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	programming_language *pl = NULL;
	if (Str__len(language) > 0) {
		if (mode & TAGS_MDRMODE)
			HTML_OPEN_WITH("div", "class=\"extract-%S\"", language);
	}
	if (mode & TAGS_MDRMODE) HTML_OPEN("pre");
	if (Str__len(language) > 0) {
		if (mode & TAGS_MDRMODE)
			HTML_OPEN_WITH("code", "class=\"language-%S\"", language);
		pl = Languages__find_by_name(language, NULL, FALSE);
		if (pl == NULL) LOG("Unable to find language <%S>\n", language);
	} else {
		if (mode & TAGS_MDRMODE) HTML_OPEN("code");
	}

	Painter__reset_syntax_colouring(pl);
	TEMPORARY_TEXT(line)
	TEMPORARY_TEXT(line_colouring)
	for (int k=0; k<Str__len(md->stashed); k++) {
		if (Str__get_at(md->stashed, k) == '\n') {
			
{
#line 1019 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	if (pl) Painter__syntax_colour(pl, NULL, line, line_colouring, FALSE);
	InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
		0, Str__len(line), mode);
	if (mode & TAGS_MDRMODE) WRITE("<br>"); else WRITE(" ");


}
#line 1001 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
			Str__clear(line);
			Str__clear(line_colouring);
		} else {
			PUT_TO(line, Str__get_at(md->stashed, k));
		}
		if ((k == Str__len(md->stashed) - 1) && (Str__len(line) > 0))
			
{
#line 1019 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
	if (pl) Painter__syntax_colour(pl, NULL, line, line_colouring, FALSE);
	InformFlavouredMarkdown__syntax_coloured_code(OUT, line, line_colouring,
		0, Str__len(line), mode);
	if (mode & TAGS_MDRMODE) WRITE("<br>"); else WRITE(" ");


}
#line 1008 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	}
	DISCARD_TEXT(line)
	DISCARD_TEXT(line_colouring)
	if (mode & TAGS_MDRMODE) HTML_CLOSE("code");
	if (mode & TAGS_MDRMODE) HTML_CLOSE("pre");
	if (Str__len(language) > 0) {
		if (mode & TAGS_MDRMODE) HTML_CLOSE("div");
	}

}
#line 820 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;
	}
	DISCARD_TEXT(language_text)
	DISCARD_TEXT(language)

}
#line 772 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
;   return TRUE;
	}
	return FALSE;
}

#line 1026 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__syntax_coloured_code(OUTPUT_STREAM, text_stream *text,
	text_stream *colouring, int from, int to, int mode) {
	inchar32_t current_col = 0;
	for (int i=from; i<to; i++) {
		inchar32_t c = Str__get_at(text, i);
		inchar32_t col = Str__get_at(colouring, i);
		if (col != current_col) {
			if (current_col) HTML_CLOSE("span");
			text_stream *span_class = NULL;
			switch (col) {
				case DEFINITION_COLOUR: span_class = TL_IS_2481; break;
				case FUNCTION_COLOUR:   span_class = TL_IS_2482; break;
				case RESERVED_COLOUR:   span_class = TL_IS_2483; break;
				case ELEMENT_COLOUR:    span_class = TL_IS_2484; break;
				case IDENTIFIER_COLOUR: span_class = TL_IS_2485; break;
				case CHARACTER_COLOUR:  span_class = TL_IS_2486; break;
				case CONSTANT_COLOUR:   span_class = TL_IS_2487; break;
				case STRING_COLOUR:     span_class = TL_IS_2488; break;
				case PLAIN_COLOUR:      span_class = TL_IS_2489; break;
				case EXTRACT_COLOUR:    span_class = TL_IS_2490; break;
				case COMMENT_COLOUR:    span_class = TL_IS_2491; break;
			}
			HTML_OPEN_WITH("span", "class=\"%S\"", span_class);
			current_col = col;
		}
		MDRenderer__char(OUT, c, mode);
	}
	if (current_col) HTML_CLOSE("span");
}

#line 1060 "inweb/foundation-module/Chapter 5/Inform-Flavoured Markdown.w"
void InformFlavouredMarkdown__render_text(OUTPUT_STREAM, text_stream *text) {
	markdown_item *md = Markdown__parse_inline(text);
	HTML_OPEN_WITH("span", "class=\"markdowncontent\"");
	Markdown__render_extended(OUT, md, InformFlavouredMarkdown__variation());
	HTML_CLOSE("span");
}

#line 42 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 53 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 63 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 72 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 90 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 96 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 102 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

#line 106 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
ebook *Epub__new(text_stream *title, char *prefix) {
	ebook *B = CREATE(ebook);
	B->metadata_list = NEW_LINKED_LIST(ebook_datum);
	B->OEBPS_path = NULL;
	B->ebook_page_list = NEW_LINKED_LIST(ebook_page);
	B->ebook_image_list = NEW_LINKED_LIST(ebook_image);
	B->ebook_volume_list = NEW_LINKED_LIST(ebook_volume);
	B->current_volume = NULL;
	B->ebook_chapter_list = NEW_LINKED_LIST(ebook_chapter);
	B->current_chapter = NULL;
	B->eventual_epub = NULL;
	B->prefix = prefix;
	Epub__attach_metadata(B, U"title", title);
	return B;
}

void Epub__use_CSS_throughout(ebook *B, filename *F) {
	B->CSS_file_throughout = F;
}

void Epub__use_CSS(ebook_volume *V, filename *F) {
	V->CSS_file = F;
}

text_stream *Epub__attach_metadata(ebook *B, inchar32_t *K, text_stream *V) {
	ebook_datum *D = NULL;
	LOOP_OVER_LINKED_LIST(D, ebook_datum, B->metadata_list)
		if (Str__eq_wide_string(D->key, K)) {
			Str__copy(D->value, V);
			return D->value;
		}
	D = CREATE(ebook_datum);
	D->key = Str__new_from_wide_string(K);
	D->value = Str__duplicate(V);
	ADD_TO_LINKED_LIST(D, ebook_datum, B->metadata_list);
	return D->value;
}

text_stream *Epub__get_metadata(ebook *B, inchar32_t *K) {
	ebook_datum *D = NULL;
	LOOP_OVER_LINKED_LIST(D, ebook_datum, B->metadata_list)
		if (Str__eq_wide_string(D->key, K))
			return D->value;
	return NULL;
}

text_stream *Epub__ensure_metadata(ebook *B, inchar32_t *K) {
	text_stream *S = Epub__get_metadata(B, K);
	if (S == NULL) S = Epub__attach_metadata(B, K, NULL);
	return S;
}

ebook_page *Epub__note_page(ebook *B, filename *F, text_stream *title, text_stream *type) {
	ebook_page *P = CREATE(ebook_page);
	P->relative_URL = F;
	P->nav_entry_written = FALSE;
	P->in_volume = B->current_volume;
	P->in_chapter = B->current_chapter;
	P->page_title = Str__duplicate(title);
	P->page_type = Str__duplicate(type);

	P->page_ID = Str__new();
	WRITE_TO(P->page_ID, B->prefix);
	Filenames__write_unextended_leafname(P->page_ID, F);
	LOOP_THROUGH_TEXT(pos, P->page_ID) {
		inchar32_t c = Str__get(pos);
		if ((c == '-') || (c == ' ')) Str__put(pos, '_');
	}
	ADD_TO_LINKED_LIST(P, ebook_page, B->ebook_page_list);
	return P;
}

void Epub__note_image(ebook *B, filename *F) {
	ebook_image *I = CREATE(ebook_image);
	I->relative_URL = F;
	I->image_ID = Str__new();
	Filenames__write_unextended_leafname(I->image_ID, F);
	ADD_TO_LINKED_LIST(I, ebook_image, B->ebook_image_list);
}

ebook_volume *Epub__starts_volume(ebook *B, ebook_page *P, text_stream *title) {
	ebook_volume *V = CREATE(ebook_volume);
	V->volume_starts = P;
	P->in_volume = V;
	V->volume_title = Str__duplicate(title);
	B->current_volume = V;
	V->CSS_file = NULL;
	ADD_TO_LINKED_LIST(V, ebook_volume, B->ebook_volume_list);
	return V;
}

ebook_chapter *Epub__starts_chapter(ebook *B, ebook_page *P, text_stream *title, text_stream *URL) {
	ebook_chapter *C = CREATE(ebook_chapter);
	C->chapter_starts = P;
	C->in_volume = B->current_volume;
	C->chapter_title = Str__duplicate(title);
	C->start_URL = Str__duplicate(URL);
	C->ebook_mark_list = NEW_LINKED_LIST(ebook_mark);
	ADD_TO_LINKED_LIST(C, ebook_chapter, B->ebook_chapter_list);
	B->current_chapter = C;
	P->in_chapter = C;
	return C;
}

void Epub__set_mark_in_chapter(ebook_chapter *C, text_stream *text, text_stream *URL) {
	ebook_mark *M = CREATE(ebook_mark);
	M->mark_text = Str__duplicate(text);
	M->mark_URL = Str__duplicate(URL);
	ADD_TO_LINKED_LIST(M, ebook_mark, C->ebook_mark_list);
}

#line 223 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
pathname *Epub__begin_construction(ebook *B, pathname *P, filename *cover_image) {
	if (Pathnames__create_in_file_system(P) == FALSE) return NULL;

	TEMPORARY_TEXT(TEMP)
	WRITE_TO(TEMP, "%S.epub", Epub__get_metadata(B, U"title"));
	B->eventual_epub = Filenames__in(P, TEMP);
	DISCARD_TEXT(TEMP)

	pathname *Holder = Pathnames__down(P, TL_IS_2492);
	if (Pathnames__create_in_file_system(Holder) == FALSE) return NULL;
	B->holder = Holder;

	
{
#line 245 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	filename *Mimetype = Filenames__in(Holder, TL_IS_2494);
	text_stream EM_struct; text_stream *OUT = &EM_struct;
	if (STREAM_OPEN_TO_FILE(OUT, Mimetype, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to open mimetype file for output: %f",
			Mimetype);
	WRITE("application/epub+zip"); /* EPUB requires there be no newline here */
	STREAM_CLOSE(OUT);

}
#line 235 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 254 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	pathname *META_INF = Pathnames__down(Holder, TL_IS_2495);
	if (Pathnames__create_in_file_system(META_INF) == FALSE) return NULL;
	filename *container = Filenames__in(META_INF, TL_IS_2496);
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, container, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to open container file for output: %f",
			container);
	WRITE("<?xml version=\"1.0\"?>\n");
	WRITE("<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n");
	INDENT;
	WRITE("<rootfiles>\n");
	INDENT;
	WRITE("<rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\" />\n");
	OUTDENT;
	WRITE("</rootfiles>\n");
	OUTDENT;
	WRITE("</container>\n");
	STREAM_CLOSE(OUT);

}
#line 236 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	pathname *OEBPS = Pathnames__down(Holder, TL_IS_2493);
	if (Pathnames__create_in_file_system(OEBPS) == FALSE) return NULL;
	if (cover_image) 
{
#line 280 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	filename *cover = Filenames__in(OEBPS, TL_IS_2497);
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, cover, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to open cover file for output: %f",
			cover);

	Epub__note_page(B, cover, TL_IS_2498, TL_IS_2499);

	HTML__declare_as_HTML(OUT, TRUE);
	HTML__begin_head(OUT, NULL);
	HTML_OPEN("title");
	WRITE("Cover");
	HTML_CLOSE("title");
	HTML_OPEN_WITH("style", "type=\"text/css\"");
	WRITE("img { max-width: 100%%; }\n");
	HTML_CLOSE("style");
	HTML__end_head(OUT);
	HTML__begin_body(OUT, NULL);
	HTML_OPEN_WITH("div", "id=\"cover-image\"");
	HTML_TAG_WITH("img", "src=\"%/f\" alt=\"%S\"", cover_image, Epub__get_metadata(B, U"title"));
	WRITE("\n");
	HTML_CLOSE("div");
	HTML__end_body(OUT);
	HTML__completed(OUT);
	STREAM_CLOSE(OUT);

}
#line 239 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	B->OEBPS_path = OEBPS;
	return OEBPS;
}

#line 307 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
void Epub__end_construction(ebook *B) {
	
{
#line 315 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	text_stream *datestamp = Epub__ensure_metadata(B, U"date");
	if (Str__len(datestamp) == 0) {
		WRITE_TO(datestamp, "%04d-%02d-%02d", the_present->tm_year + 1900,
			(the_present->tm_mon)+1, the_present->tm_mday);
	}

	TEMPORARY_TEXT(TEMP)
	WRITE_TO(TEMP, "urn:www.inform7.com:");
	text_stream *identifier = Epub__ensure_metadata(B, U"identifier");
	if (Str__len(identifier) == 0)
		WRITE_TO(TEMP, "%S", Epub__get_metadata(B, U"title"));
	else
		WRITE_TO(TEMP, "%S", identifier);
	Str__copy(identifier, TEMP);
	DISCARD_TEXT(TEMP)

	text_stream *lang = Epub__ensure_metadata(B, U"language");
	if (Str__len(lang) == 0) WRITE_TO(lang, "en-UK");

}
#line 308 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 335 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	filename *content = Filenames__in(B->OEBPS_path, TL_IS_2500);
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, content, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to open content file for output: %f",
			content);

	WRITE("<?xml version='1.0' encoding='utf-8'?>\n");
	WRITE("<package xmlns=\"http://www.idpf.org/2007/opf\"\n");
	WRITE("xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n");
	WRITE("unique-identifier=\"bookid\" version=\"2.0\">\n"); INDENT;
	
{
#line 357 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<metadata>\n"); INDENT;
	ebook_datum *D = NULL;
	LOOP_OVER_LINKED_LIST(D, ebook_datum, B->metadata_list) {
		WRITE("<dc:%S", D->key);
		if (Str__eq_wide_string(D->key, U"identifier")) WRITE(" id=\"bookid\"");
		WRITE(">");
		WRITE("%S</dc:%S>\n", D->value, D->key);
	}
	WRITE("<meta name=\"cover\" content=\"cover-image\" />\n");
	OUTDENT; WRITE("</metadata>\n");

}
#line 345 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 369 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<manifest>\n"); INDENT;
	WRITE("<item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>\n");
	
{
#line 377 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	int cssc = 1;
	if (B->CSS_file_throughout)
		WRITE("<item id=\"css%d\" href=\"%S\" media-type=\"text/css\"/>\n",
				cssc++, Filenames__get_leafname(B->CSS_file_throughout));
	ebook_volume *V;
	LOOP_OVER_LINKED_LIST(V, ebook_volume, B->ebook_volume_list)
		if (V->CSS_file)
			WRITE("<item id=\"css%d\" href=\"%S\" media-type=\"text/css\"/>\n",
				cssc++, Filenames__get_leafname(V->CSS_file));

}
#line 371 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 388 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_page *P;
	LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list)
		WRITE("<item id=\"%S\" href=\"%S\" media-type=\"application/xhtml+xml\"/>\n",
			P->page_ID, Filenames__get_leafname(P->relative_URL));

}
#line 372 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 394 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_image *I;
	LOOP_OVER_LINKED_LIST(I, ebook_image, B->ebook_image_list) {
		char *image_type = "";
		switch (Filenames__guess_format(I->relative_URL)) {
			case FORMAT_PERHAPS_PNG: image_type = "png"; break;
			case FORMAT_PERHAPS_JPEG: image_type = "jpeg"; break;
			case FORMAT_PERHAPS_SVG: image_type = "svg"; break;
			case FORMAT_PERHAPS_GIF: image_type = "gif"; break;
			default: Errors__nowhere("image not .gif, .png, .jpg or .svg"); break;
		}
		WRITE("<item id=\"%S\" href=\"%/f\" media-type=\"image/%s\"/>\n",
			I->image_ID, I->relative_URL, image_type);
	}

}
#line 373 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	OUTDENT; WRITE("</manifest>\n");

}
#line 346 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 409 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<spine toc=\"ncx\">\n"); INDENT;
	ebook_page *P;
	LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list) {
		WRITE("<itemref idref=\"%S\"", P->page_ID);
		if (Str__len(P->page_type) > 0) WRITE(" linear=\"no\"");
		WRITE("/>\n");
	}
	OUTDENT; WRITE("</spine>\n");

}
#line 347 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 419 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<guide>\n"); INDENT;
	ebook_page *P;
	LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list) {
		if (Str__len(P->page_type) > 0) {
			WRITE("<reference href=\"%S\" type=\"%S\" title=\"%S\"/>\n",
				Filenames__get_leafname(P->relative_URL), P->page_type, P->page_title);
		}
	}
	OUTDENT; WRITE("</guide>\n");

}
#line 348 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	OUTDENT; WRITE("</package>\n");

	STREAM_CLOSE(OUT);

}
#line 309 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 434 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	filename *toc = Filenames__in(B->OEBPS_path, TL_IS_2501);
	text_stream C_struct; text_stream *OUT = &C_struct;
	if (STREAM_OPEN_TO_FILE(OUT, toc, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to open ncx file for output: %f",
			toc);

	WRITE("<?xml version='1.0' encoding='utf-8'?>\n");
	WRITE("<!DOCTYPE ncx PUBLIC \"-//NISO//DTD ncx 2005-1//EN\"\n");
	WRITE("	\"http://www.daisy.org/z3986/2005/ncx-2005-1.dtd\">\n");
	WRITE("<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n");

	int depth = 1; /* there are surely at least sections */
	if (LinkedLists__len(B->ebook_chapter_list) > 0) depth = 2;
	if (LinkedLists__len(B->ebook_volume_list) > 0) depth = 3;

	
{
#line 456 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<head>\n"); INDENT;
	WRITE("<meta name=\"dtb:uid\" content=\"%S\"/>\n", Epub__get_metadata(B, U"identifier"));
	WRITE("<meta name=\"dtb:depth\" content=\"%d\"/>\n", depth);
	WRITE("<meta name=\"dtb:totalPageCount\" content=\"0\"/>\n");
	WRITE("<meta name=\"dtb:maxPageNumber\" content=\"0\"/>\n");
	OUTDENT; WRITE("</head>\n");
	WRITE("<docTitle>\n"); INDENT;
	WRITE("<text>%S</text>\n", Epub__get_metadata(B, U"title"));
	OUTDENT; WRITE("</docTitle>\n");

}
#line 449 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 467 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navMap>\n"); INDENT;
	int navpoint_count = 1;
	int navmap_depth = 1;
	int phase = 0;
	
{
#line 486 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_page *P;
	LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list) {
		int in_phase = 1;
		if ((Str__eq_wide_string(P->page_ID, U"cover")) ||
			(Str__eq_wide_string(P->page_ID, U"index")))
			in_phase = 0;
		if ((in_phase == phase) && (P->nav_entry_written == FALSE)) {
			
{
#line 540 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n",
		navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 493 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel> <content src=\"%S\"/>\n",
				P->page_title, Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 496 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
		}
	}

}
#line 471 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	ebook_volume *V = NULL;
	LOOP_OVER_LINKED_LIST(V, ebook_volume, B->ebook_volume_list) {
		
{
#line 540 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n",
		navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 474 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
		WRITE("<navLabel><text>%S</text></navLabel>", V->volume_title);
		WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(V->volume_starts->relative_URL));
		
{
#line 501 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_chapter *C = NULL;
	LOOP_OVER_LINKED_LIST(C, ebook_chapter, B->ebook_chapter_list)
		if (C->in_volume == V) {
			
{
#line 540 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n",
		navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 504 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", C->chapter_title);
			WRITE("<content src=\"%S\"/>\n", C->start_URL);
			if (C->ebook_mark_list)
				
{
#line 531 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_mark *M;
	LOOP_OVER_LINKED_LIST(M, ebook_mark, C->ebook_mark_list) {
		
{
#line 540 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n",
		navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 533 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
		WRITE("<navLabel><text>%S</text></navLabel>", M->mark_text);
		WRITE("<content src=\"%S\"/>\n", M->mark_URL);
		
{
#line 546 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 536 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	}

}
#line 508 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"

			else
				
{
#line 519 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_page *P;
	LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list) {
		if ((P->in_chapter == C) && (P->nav_entry_written == FALSE)) {
			
{
#line 540 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n",
		navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 522 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel>", P->page_title);
			WRITE("<content src=\"%S\"/>\n", Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 525 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
			P->nav_entry_written = TRUE;
		}
	}

}
#line 510 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
			ebook_page *P;
			LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list)
				if (P->in_chapter == C)
					P->nav_entry_written = TRUE;
			
{
#line 546 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 515 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
		}

}
#line 477 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
		
{
#line 546 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 478 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	}
	phase = 1;
	
{
#line 486 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	ebook_page *P;
	LOOP_OVER_LINKED_LIST(P, ebook_page, B->ebook_page_list) {
		int in_phase = 1;
		if ((Str__eq_wide_string(P->page_ID, U"cover")) ||
			(Str__eq_wide_string(P->page_ID, U"index")))
			in_phase = 0;
		if ((in_phase == phase) && (P->nav_entry_written == FALSE)) {
			
{
#line 540 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	WRITE("<navPoint id=\"navpoint-%d\" playOrder=\"%d\">\n",
		navpoint_count, navpoint_count);
	navpoint_count++;
	navmap_depth++; INDENT;

}
#line 493 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
			WRITE("<navLabel><text>%S</text></navLabel> <content src=\"%S\"/>\n",
				P->page_title, Filenames__get_leafname(P->relative_URL));
			
{
#line 546 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	navmap_depth--;
	if (navmap_depth < 1) internal_error("navMap numbering awry");
	OUTDENT; WRITE("</navPoint>\n");

}
#line 496 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
		}
	}

}
#line 481 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	OUTDENT; WRITE("</navMap>\n");
	if (navmap_depth != 1) internal_error("navMap numbering unbalanced");

}
#line 450 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	WRITE("</ncx>\n");

	STREAM_CLOSE(OUT);

}
#line 310 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 551 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	pathname *up = Pathnames__from_text(TL_IS_2502);
	filename *ePub_relative =
		Filenames__in(up, Filenames__get_leafname(B->eventual_epub));
	
{
#line 558 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, "cd ");
	Shell__quote_path(COMMAND, B->holder);
	Shell__plain(COMMAND, "; zip -0Xq ");
	Shell__quote_file(COMMAND, ePub_relative);
	Shell__plain(COMMAND, " mimetype");
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)

}
#line 554 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
	
{
#line 568 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
	TEMPORARY_TEXT(COMMAND)
	Shell__plain(COMMAND, "cd ");
	Shell__quote_path(COMMAND, B->holder);
	Shell__plain(COMMAND, "; zip -Xr9Dq ");
	Shell__quote_file(COMMAND, ePub_relative);
	Shell__plain(COMMAND, " *");
	Shell__run(COMMAND);
	DISCARD_TEXT(COMMAND)

}
#line 555 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;

}
#line 311 "inweb/foundation-module/Chapter 5/Epub Ebooks.w"
;
}

#line 10 "inweb/foundation-module/Chapter 6/Binary Files.w"
int BinaryFiles__read_int8(FILE *binary_file, unsigned int *result) {
    int c1 = getc(binary_file);
    if (c1 == EOF) return FALSE;

    *result = (unsigned int) c1;
    return TRUE;
}

int BinaryFiles__read_int16(FILE *binary_file, unsigned int *result) {
    int c1, c2;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    if (c1 == EOF || c2 == EOF) return FALSE;

    *result = (((unsigned int) c1) << 8) + ((unsigned int) c2);
    return TRUE;
}

int BinaryFiles__read_int32(FILE *binary_file, unsigned int *result) {
    int c1, c2, c3, c4;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    c3 = getc(binary_file);
    c4 = getc(binary_file);
    if (c1 == EOF || c2 == EOF || c3 == EOF || c4 == EOF) return FALSE;

    *result = (((unsigned int) c1) << 24) +
    			(((unsigned int) c2) << 16) +
    			(((unsigned int) c3) << 8) + ((unsigned int) c4);
    return TRUE;
}

int BinaryFiles__read_int64(FILE *binary_file, unsigned long long *result) {
    int c1, c2, c3, c4, c5, c6, c7, c8;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    c3 = getc(binary_file);
    c4 = getc(binary_file);
    c5 = getc(binary_file);
    c6 = getc(binary_file);
    c7 = getc(binary_file);
    c8 = getc(binary_file);
    if (c1 == EOF || c2 == EOF || c3 == EOF || c4 == EOF || c5 == EOF
    	|| c6 == EOF || c7 == EOF || c8 == EOF) return FALSE;

    *result = (((unsigned long long) c1) << 56) +
               (((unsigned long long) c2) << 48) +
               (((unsigned long long) c3) << 40) +
               (((unsigned long long) c4) << 32) +
               (((unsigned long long) c5) << 24) +
               (((unsigned long long) c6) << 16) +
               (((unsigned long long) c7) << 8) +
                ((unsigned long long) c8);
    return TRUE;
}

#line 70 "inweb/foundation-module/Chapter 6/Binary Files.w"
int BinaryFiles__write_int32(FILE *binary_file, unsigned int val) {
    int c1 = (int) ((val >> 24) & 0xFF);
    int c2 = (int) ((val >> 16) & 0xFF);
    int c3 = (int) ((val >> 8) & 0xFF);
    int c4 = (int) (val & 0xFF);
	if (putc(c1, binary_file) == EOF) return FALSE;
	if (putc(c2, binary_file) == EOF) return FALSE;
	if (putc(c3, binary_file) == EOF) return FALSE;
	if (putc(c4, binary_file) == EOF) return FALSE;

    return TRUE;
}

#line 87 "inweb/foundation-module/Chapter 6/Binary Files.w"
void BinaryFiles__swap_bytes32(unsigned int *value) {
    unsigned int result = (((*value & 0xff) << 24) +
                            ((*value & 0xff00) << 8) +
                            ((*value & 0xff0000) >> 8) +
                            ((*value & 0xff000000) >> 24 ) );
    *value = result;
}

void BinaryFiles__swap_bytes64(unsigned long long *value) {
    unsigned long long result = (((*value & 0xff) << 56) +
                                  ((*value & 0xff00) << 40) +
                                  ((*value & 0xff0000) << 24) +
                                  ((*value & 0xff000000) << 8) +
                                  ((*value >> 8)  & 0xff000000) +
                                  ((*value >> 24) & 0xff0000) +
                                  ((*value >> 40) & 0xff00) +
                                  ((*value >> 56) & 0xff) );
    *value = result;
}

#line 113 "inweb/foundation-module/Chapter 6/Binary Files.w"
int BinaryFiles__read_variable_length_integer(FILE *binary_file, unsigned int *result) {
    int c;

    *result = 0;
    do {
        c = getc(binary_file);
        if (c == EOF) return FALSE;
        *result = (*result << 7) + (((unsigned char) c) & 0x7F);
    } while  (((unsigned char) c) & 0x80);

    return TRUE;
}

#line 130 "inweb/foundation-module/Chapter 6/Binary Files.w"
int BinaryFiles__read_float80(FILE *binary_file, unsigned int *result) {
    int c1, c2, exp;
    unsigned int prev = 0, mantissa;

    c1 = getc(binary_file);
    c2 = getc(binary_file);
    if (c1 == EOF || c2 == EOF) return FALSE;
    if (!BinaryFiles__read_int32(binary_file, &mantissa)) return FALSE;

    exp = 30 - c2;
    while  (exp--) {
        prev = mantissa;
        mantissa >>= 1;
    }
    if (prev & 1) mantissa++;

    *result = (unsigned int) mantissa;
    return TRUE;
}

#line 155 "inweb/foundation-module/Chapter 6/Binary Files.w"
int BinaryFiles__read_string(FILE *binary_file, char *string, unsigned int length) {
    if (length > 0) {
        if (fread(string, 1, length, binary_file) != length) return FALSE;
    }
    string[length] = 0;

    return TRUE;
}

#line 167 "inweb/foundation-module/Chapter 6/Binary Files.w"
long int BinaryFiles__size(filename *F) {
	FILE *TEST_FILE = BinaryFiles__try_to_open_for_reading(F);
	if (TEST_FILE) {
		if (fseek(TEST_FILE, 0, SEEK_END) == 0) {
			long int file_size = ftell(TEST_FILE);
			if (file_size == -1L) Errors__fatal_with_file("ftell failed on linked file", F);
			BinaryFiles__close(TEST_FILE);
			return file_size;
		} else Errors__fatal_with_file("fseek failed on linked file", F);
		BinaryFiles__close(TEST_FILE);
	}
	return -1L;
}

#line 184 "inweb/foundation-module/Chapter 6/Binary Files.w"
FILE *BinaryFiles__open_for_reading(filename *F) {
	FILE *handle = Filenames__fopen(F, "rb");
	if (handle == NULL) Errors__fatal_with_file("unable to read file", F);
	return handle;
}

FILE *BinaryFiles__try_to_open_for_reading(filename *F) {
	return Filenames__fopen(F, "rb");
}

FILE *BinaryFiles__open_for_writing(filename *F) {
	FILE *handle = Filenames__fopen(F, "wb");
	if (handle == NULL) Errors__fatal_with_file("unable to write file", F);
	return handle;
}

FILE *BinaryFiles__try_to_open_for_writing(filename *F) {
	return Filenames__fopen(F, "wb");
}

void BinaryFiles__close(FILE *handle) {
	fclose(handle);
}

#line 213 "inweb/foundation-module/Chapter 6/Binary Files.w"
int BinaryFiles__copy(filename *from, filename *to, int suppress_error) {
	if ((from == NULL) || (to == NULL))
		Errors__fatal("files confused in copier");

	FILE *FROM = BinaryFiles__try_to_open_for_reading(from);
	if (FROM == NULL) {
		if (suppress_error == FALSE) Errors__fatal_with_file("unable to read file", from);
		return -1;
	}
	FILE *TO = BinaryFiles__try_to_open_for_writing(to);
	if (TO == NULL) {
		if (suppress_error == FALSE) Errors__fatal_with_file("unable to write to file", to);
		return -1;
	}

	int size = 0;
	while (TRUE) {
		int c = fgetc(FROM);
		if (c == EOF) break;
		size++;
		putc(c, TO);
	}

	BinaryFiles__close(FROM); BinaryFiles__close(TO);
	return size;
}

#line 259 "inweb/foundation-module/Chapter 6/Binary Files.w"
void BinaryFiles__md5(OUTPUT_STREAM, filename *F, int (*mask)(uint64_t)) {
	uint32_t s[64] = {
		7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
		5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
		4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
		6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 };
	uint32_t K[64] = {
		0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
		0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
		0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
		0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
		0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
		0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
		0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
		0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
		0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
		0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
		0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
		0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
		0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
		0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
		0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
		0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };

	uint32_t a0 = 0x67452301;
	uint32_t b0 = 0xefcdab89;
	uint32_t c0 = 0x98badcfe;
	uint32_t d0 = 0x10325476;

	unsigned int buffer[64];
	int bc = 0;

	FILE *bin = BinaryFiles__open_for_reading(F);
	if (bin == NULL) Errors__fatal_with_file("unable to open binary file", F);
	unsigned int b = 0;
	uint64_t L = 0;
	while (BinaryFiles__read_int8(bin, &b)) {
		if ((mask) && (mask(L))) b = 0;
		
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 297 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
		L++;
	}
	uint64_t original_length = L*8;

	b = 0x80;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 303 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	L++;
	while (L % 64 != 56) {
		b = 0;
		
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 307 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
		L++;
	}

	b = (original_length & 0x00000000000000FF) >> 0;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 312 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0x000000000000FF00) >> 8;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 314 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0x0000000000FF0000) >> 16;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 316 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0x00000000FF000000) >> 24;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 318 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0x000000FF00000000) >> 32;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 320 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0x0000FF0000000000) >> 40;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 322 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0x00FF000000000000) >> 48;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 324 "inweb/foundation-module/Chapter 6/Binary Files.w"
;
	b = (original_length & 0xFF00000000000000) >> 56;
	
{
#line 341 "inweb/foundation-module/Chapter 6/Binary Files.w"
	buffer[bc++] = (b % 0x100);
	if (bc == 64) {
		bc = 0;
		uint32_t M[16];
		for (uint32_t i=0; i<16; i++)
			M[i] = buffer[i*4+3]*0x1000000 + buffer[i*4+2]*0x10000 +
					buffer[i*4+1]*0x100 + buffer[i*4+0];
		uint32_t A = a0;
		uint32_t B = b0;
		uint32_t C = c0;
		uint32_t D = d0;
		for (uint32_t i=0; i<64; i++) {
       		uint32_t F, g;
			if (i < 16) {
				F = (B & C) | ((~ B) & D);
				g = i;
			} else if (i < 32) {
				F = (D & B) | ((~ D) & C);
				g = (5*i + 1) % 16;
			} else if (i < 48) {
				F = B ^ C ^ D;
				g = (3*i + 5) % 16;
			} else {
				F = C ^ (B | (~ D));
				g = (7*i) % 16;
			}
			F += A + K[i] + M[g];
			A = D;
			D = C;
			C = B;
			B = B + BinaryFiles__rotate(F, s[i]);
		}
   		a0 += A;
    	b0 += B;
    	c0 += C;
    	d0 += D;
	}

}
#line 326 "inweb/foundation-module/Chapter 6/Binary Files.w"
;

	WRITE("%02x%02x%02x%02x",
		a0 % 0x100, (a0 >> 8) % 0x100, (a0 >> 16) % 0x100, (a0 >> 24) % 0x100);
	WRITE("%02x%02x%02x%02x",
		b0 % 0x100, (b0 >> 8) % 0x100, (b0 >> 16) % 0x100, (b0 >> 24) % 0x100);
	WRITE("%02x%02x%02x%02x",
		c0 % 0x100, (c0 >> 8) % 0x100, (c0 >> 16) % 0x100, (c0 >> 24) % 0x100);
	WRITE("%02x%02x%02x%02x",
		d0 % 0x100, (d0 >> 8) % 0x100, (d0 >> 16) % 0x100, (d0 >> 24) % 0x100);

	BinaryFiles__close(bin);
}

#line 383 "inweb/foundation-module/Chapter 6/Binary Files.w"
uint32_t BinaryFiles__rotate(uint32_t value, uint32_t shift) {
    if ((shift &= sizeof(value)*8 - 1) == 0) return value;
    return (value << shift) | (value >> (sizeof(value)*8 - shift));
}

#line 24 "inweb/foundation-module/Chapter 6/Image Dimensions.w"
int ImageFiles__get_JPEG_dimensions(FILE *JPEG_file, unsigned int *width, unsigned int *height) {
    unsigned int sig, length;
    int marker;

    if (!BinaryFiles__read_int16(JPEG_file, &sig)) return FALSE;
    if (sig != 0xFFD8) return FALSE; /* |0xFF| (marker) then |0xD8| (SOI) */

    do {
        do {
            marker = getc(JPEG_file);
            if (marker == EOF) return FALSE;
        } while (marker != 0xff); /* skip to next |0xFF| byte */

        do {
            marker = getc(JPEG_file);
        } while (marker == 0xff); /* skip to next non |FF| byte */

        if (!BinaryFiles__read_int16(JPEG_file, &length)) return FALSE; /* length of marker */

        switch(marker) {
        	/* all variant forms of "start of frame": e.g., |0xC0| is a baseline DCT image */
            case 0xc0:
            case 0xc1: case 0xc2: case 0xc3:
            case 0xc5: case 0xc6: case 0xc7:
            case 0xc9: case 0xca: case 0xcb:
            case 0xcd: case 0xce: case 0xcf: {

 				/* fortunately these markers all then open with the same format */
                if (getc(JPEG_file) == EOF) return FALSE; /* skip 1 byte of data precision  */

                if (!BinaryFiles__read_int16(JPEG_file, height)) return FALSE;
                if (!BinaryFiles__read_int16(JPEG_file, width)) return FALSE;

                return TRUE;
            }
            default:
                if (fseek(JPEG_file, (long) (length - 2), SEEK_CUR) != 0) return FALSE; /* skip rest of marker */
        }
    }
    while (marker != EOF);

    return FALSE;
}

#line 77 "inweb/foundation-module/Chapter 6/Image Dimensions.w"
int ImageFiles__get_PNG_dimensions(FILE *PNG_file, unsigned int *width, unsigned int *height) {
    unsigned int sig1, sig2, length, type;

    /* Check PNG signature */
    if (!BinaryFiles__read_int32(PNG_file, &sig1)) return FALSE;
    if (!BinaryFiles__read_int32(PNG_file, &sig2)) return FALSE;
    if ((sig1 != 0x89504e47) || (sig2 != 0x0d0a1a0a)) return FALSE;

    /* Read first chunk */
    if (!BinaryFiles__read_int32(PNG_file, &length)) return FALSE;
    if (!BinaryFiles__read_int32(PNG_file, &type)) return FALSE;

    /* First chunk must be IHDR */
    if (type != 0x49484452) return FALSE;

    /* Width and height follow */
    if (!BinaryFiles__read_int32(PNG_file, width)) return FALSE;
    if (!BinaryFiles__read_int32(PNG_file, height)) return FALSE;
    return TRUE;
}

#line 12 "inweb/foundation-module/Chapter 6/Sound Durations.w"
int SoundFiles__get_AIFF_duration(FILE *pFile, unsigned int *pDuration,
	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) {
    unsigned int sig;
    unsigned int chunkID;
    unsigned int chunkLength;
    unsigned int numSampleFrames;
    unsigned int sampleSize;

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x464F524D) return FALSE; /* |"FORM"| indicating an IFF file */

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x41494646) return FALSE; /* |"AIFF"| indicating an AIFF file */

    /* Read chunks, skipping over those we are not interested in */
    while (TRUE) {
        if (!BinaryFiles__read_int32(pFile, &chunkID)) return FALSE;
        if (!BinaryFiles__read_int32(pFile, &chunkLength)) return FALSE;

        if (chunkID == 0x434F4D4D) { /* |"COMM"| indicates common AIFF data */
            if (chunkLength < 18) return FALSE; /* Check we have enough data to read */

            if (!BinaryFiles__read_int16(pFile, pChannels))          return FALSE;
            if (!BinaryFiles__read_int32(pFile, &numSampleFrames))  return FALSE;
            if (!BinaryFiles__read_int16(pFile, &sampleSize))       return FALSE;
            if (!BinaryFiles__read_float80(pFile, pSampleRate))      return FALSE;

            if (*pSampleRate == 0) return FALSE; /* Sanity check to avoid a divide by zero */

            /* Result is in centiseconds */
            *pDuration = (unsigned int) (((unsigned long long) numSampleFrames * 100) / *pSampleRate);
            *pBitsPerSecond = *pSampleRate * *pChannels * sampleSize;
            break;
        } else {
            /* Skip unwanted chunk */
            if (fseek(pFile, (long) chunkLength, SEEK_CUR) != 0) return FALSE;
        }
    }

	return TRUE;
}

#line 59 "inweb/foundation-module/Chapter 6/Sound Durations.w"
int SoundFiles__get_OggVorbis_duration(FILE *pFile, unsigned int *pDuration,
	unsigned int *pBitsPerSecond, unsigned int *pChannels, unsigned int *pSampleRate) {
    unsigned int sig;
    unsigned int version;
    unsigned int numSegments;
    unsigned int packetType;
    unsigned int vorbisSig1;
    unsigned int vorbisSig2;
    unsigned int seekPos;
    unsigned int fileLength, bytesToRead, lastSig, index;
    unsigned long long granulePosition;
    unsigned char buffer[256];

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x4F676753) return FALSE; /* |"OggS"| indicating an OGG file */

    /* Check OGG version is zero */
    if (!BinaryFiles__read_int8(pFile, &version)) return FALSE;
    if (version != 0) return FALSE;

    /* Skip header type, granule position, serial number, page sequence and CRC */
    if (fseek(pFile, 21, SEEK_CUR) != 0) return FALSE;

    /* Read number of page segments */
    if (!BinaryFiles__read_int8(pFile, &numSegments)) return FALSE;

    /* Skip segment table */
    if (fseek(pFile, (long) numSegments, SEEK_CUR) != 0) return FALSE;

    /* Vorbis Identification header */
    if (!BinaryFiles__read_int8(pFile, &packetType)) return FALSE;
    if (packetType != 1) return FALSE;

    if (!BinaryFiles__read_int32(pFile, &vorbisSig1)) return FALSE;
    if (vorbisSig1 != 0x766F7262) return FALSE;   /* |"VORB"| */

    if (!BinaryFiles__read_int16(pFile, &vorbisSig2)) return FALSE;
    if (vorbisSig2 != 0x6973) return FALSE;   /* |"IS"| */

    /* Check Vorbis version is zero */
    if (!BinaryFiles__read_int32(pFile, &version)) return FALSE;
    if (version != 0) return FALSE;

    /* Read number of channels */
    if (!BinaryFiles__read_int8(pFile, pChannels)) return FALSE;

    /* Read sample rate */
    if (!BinaryFiles__read_int32(pFile, pSampleRate)) return FALSE;
    BinaryFiles__swap_bytes32(pSampleRate);  /* Ogg Vorbis uses LSB first */

    /* Skip bitrate maximum */
    if (fseek(pFile, 4, SEEK_CUR) != 0) return FALSE;

    /* Read Nominal Bitrate */
    if (!BinaryFiles__read_int32(pFile, pBitsPerSecond)) return FALSE;
    BinaryFiles__swap_bytes32(pBitsPerSecond);  /* Ogg Vorbis uses LSB first */

    /* Encoders can be unhelpful and give no bitrate in the header */
    if (pBitsPerSecond == 0) return FALSE;

    /* Search for the final Ogg page (near the end of the file) to read duration, */
    /* i.e., read the last 4K of the file and look for the final |"OggS"| sig */
    if (fseek(pFile, 0, SEEK_END) != 0) return FALSE;
    fileLength = (unsigned int) ftell(pFile);
    if (fileLength < 4096) seekPos = 0;
    else seekPos = fileLength - 4096;

    lastSig = 0xFFFFFFFF;
    while (seekPos < fileLength) {
        if (fseek(pFile, (long) seekPos, SEEK_SET) != 0) return FALSE;
        bytesToRead = fileLength - seekPos;
        if (bytesToRead > 256) bytesToRead = 256;
        if (fread(buffer, 1, bytesToRead, pFile) != bytesToRead) return FALSE;

        for(index = 0; index < bytesToRead; index++) {
            if ((buffer[index] == 0x4F) &&
                (buffer[index + 1] == 0x67) &&
                (buffer[index + 2] == 0x67) &&
                (buffer[index + 3] == 0x53)) {
                lastSig = seekPos + index;
            }
        }

        /* Next place to read from is 256 bytes further on, but to catch */
        /* sigs that span between these blocks, read the last four bytes again */
        seekPos += 256 - 4;
    }

    if (lastSig == 0xFFFFFFFF) return FALSE;

    if (fseek(pFile, (long) lastSig, SEEK_SET) != 0) return FALSE;
    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    if (sig != 0x4F676753) return FALSE; /* |"OggS"| indicating an OGG file */

    /* Check OGG version is zero */
    if (!BinaryFiles__read_int8(pFile, &version)) return FALSE;
    if (version != 0) return FALSE;

    /* Skip header Type */
    if (fseek(pFile, 1, SEEK_CUR) != 0) return FALSE;

    if (!BinaryFiles__read_int64(pFile, &granulePosition)) return FALSE;
    BinaryFiles__swap_bytes64(&granulePosition);

    *pDuration = (unsigned int) ((granulePosition * 100) /
			    	(unsigned long long) *pSampleRate);

    return TRUE;
}

#line 181 "inweb/foundation-module/Chapter 6/Sound Durations.w"
int SoundFiles__get_MIDI_information(FILE *pFile, unsigned int *pType,
	unsigned int *pNumTracks) {
    unsigned int sig;
    unsigned int length;
    unsigned int pulses;
    unsigned int frames_per_second;
    unsigned int subframes_per_frame;
    unsigned int clocks_per_second;
    unsigned int start_of_chunk_data;
    unsigned int status;
    unsigned int clocks;
    unsigned int sysex_length;
    unsigned int non_midi_event_length;
    unsigned int start_of_non_midi_data;
    unsigned int non_midi_event;

    if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;

    /* |"RIFF"| indicating a RIFF file */
    if (sig == 0x52494646) {
        /* Skip the filesize and typeID */
        if (fseek(pFile, 8, SEEK_CUR) != 0) return FALSE;

        /* now read the real MIDI sig */
        if (!BinaryFiles__read_int32(pFile, &sig)) return FALSE;
    }

    /* |"MThd"| indicating a MIDI file */
    if (sig != 0x4D546864) return FALSE;

    /* Read length of chunk */
    if (!BinaryFiles__read_int32(pFile, &length)) return FALSE;

    /* Make sure we have enough data to read */
    if (length < 6) return FALSE;

    /* Read the MIDI type: 0,1 or 2 */
    /*   0 means one track containing up to 16 channels to make a single tune */
    /*   1 means one or more tracks, commonly each with a single channel, making up a single tune */
    /*   2 means one or more tracks, where each is a separate tune in it's own right */
    if (!BinaryFiles__read_int16(pFile, pType)) return FALSE;

    /* Read the number of tracks */
    if (!BinaryFiles__read_int16(pFile, pNumTracks)) return FALSE;

    /* Read "Pulses Per Quarter Note" (PPQN) */
    if (!BinaryFiles__read_int16(pFile, &pulses)) return FALSE;

    /* if top bit set, then number of subframes per second can be deduced */
    if (pulses >= 0x8000) {
        /* First byte is a negative number for the frames per second */
        /* Second byte is the number of subframes in each frame */
        frames_per_second    = (256 - (pulses & 0xff));
        subframes_per_frame  = (pulses >> 8);
        clocks_per_second    = frames_per_second * subframes_per_frame;

        /* Number of pulses per quarter note unknown */
        pulses = 0;
    } else {
        /* unknown values */
        frames_per_second    = 0;
        subframes_per_frame  = 0;
        clocks_per_second    = 0;
    }

    /* Skip any remaining bytes in the MThd chunk */
    if (fseek(pFile, (long) (length - 6), SEEK_CUR) != 0) return FALSE;

    /* Keep reading chunks, looking for |"MTrk"| */
    do {
        /* Read chunk signature and length */
        if (!BinaryFiles__read_int32(pFile, &sig)) {
            if (feof(pFile)) return TRUE;
            return FALSE;
        }
        if (!BinaryFiles__read_int32(pFile, &length)) return FALSE;

        start_of_chunk_data = (unsigned int) ftell(pFile);

        if (sig == 0x4D54726B) { /* |"MTrk"| */
            /* Read each event, looking for information before the real tune starts, e.g., tempo */
            do {
                /* Read the number of clocks since the previous event */
                if (!BinaryFiles__read_variable_length_integer(pFile, &clocks))
                	return FALSE;

                /* We bail out when the track starts */
                if (clocks > 0) break;

                /* Read the MIDI Status byte */
                if (!BinaryFiles__read_int8(pFile, &status)) return FALSE;

                /* Start or continuation of system exclusive data */
                if ((status == 0xF0) || (status == 0xF7)) {
                    /* Read length of system exclusive event data */
                    if (!BinaryFiles__read_variable_length_integer(pFile, &sysex_length)) return FALSE;

                    /* Skip sysex event */
                    if (fseek(pFile, (long) sysex_length, SEEK_CUR) != 0) return FALSE;
                } else if (status == 0xFF) { /* Non-MIDI event */
                    /* Read the Non-MIDI event type and length */
                    if (!BinaryFiles__read_int8(pFile, &non_midi_event)) return FALSE;
                    if (!BinaryFiles__read_variable_length_integer(pFile, &non_midi_event_length))
                    	return FALSE;

                    start_of_non_midi_data = (unsigned int) ftell(pFile);

                    switch(non_midi_event) {
                        case 0x01: /* Comment text */
                        case 0x02: /* Copyright text */
                        case 0x03: /* Track name */
                        case 0x04: { /* Instrument name */
                            char text[257];
                            if (!BinaryFiles__read_string(pFile, text, non_midi_event_length))
                            	return FALSE;
                            break;
                        }

                        case 0x51: /* Tempo change */
                        case 0x58: /* Time signature */
                        case 0x59: /* Key signature */
							break;
                    }

                    /* Skip non-midi event */
                    if (fseek(pFile,
                    	(long) (start_of_non_midi_data + non_midi_event_length), SEEK_SET) != 0)
                    	return FALSE;
                } else {
                    /* Real MIDI data found: we've read all we can so bail out at this point */
                    break;
                }
            }
            while (TRUE);
        }

        /* Seek to start of next chunk */
        if (fseek(pFile, (long) (start_of_chunk_data + length), SEEK_SET) != 0) return FALSE;

        /* Reached end of file */
        if (feof(pFile)) return TRUE;

        /* Did we try to seek beyond the end of the file? */
        unsigned int position_in_file = (unsigned int) ftell(pFile);
        if (position_in_file < (start_of_chunk_data + length)) return TRUE;
    }
    while (TRUE);

    return TRUE;
}

#line 65 "inweb/foundation-module/Chapter 7/Version Numbers.w"

#line 70 "inweb/foundation-module/Chapter 7/Version Numbers.w"

#line 77 "inweb/foundation-module/Chapter 7/Version Numbers.w"
semantic_version_number VersionNumbers__null(void) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
	semantic_version_number V;
	for (int i=0; i<SEMVER_NUMBER_DEPTH; i++) V.version_numbers[i] = -1;
	V.prerelease_segments = NULL;
	V.build_metadata = NULL;
	return V;
#pragma clang diagnostic pop
}

int VersionNumbers__is_null(semantic_version_number V) {
	for (int i=0, allow=TRUE; i<SEMVER_NUMBER_DEPTH; i++) {
		if (V.version_numbers[i] < -1) return TRUE; /* should never happen */
		if (V.version_numbers[i] == -1) allow = FALSE;
		else if (allow == FALSE) return TRUE; /* should never happen */
	}
	if (V.version_numbers[0] < 0) return TRUE;
	return FALSE;
}

#line 102 "inweb/foundation-module/Chapter 7/Version Numbers.w"
void VersionNumbers__to_text(OUTPUT_STREAM, semantic_version_number V) {
	if (VersionNumbers__is_null(V)) { WRITE("null"); return; }
	for (int i=0; (i<SEMVER_NUMBER_DEPTH) && (V.version_numbers[i] >= 0); i++) {
		if (i>0) WRITE(".");
		WRITE("%d", V.version_numbers[i]);
	}
	if (V.prerelease_segments) {
		int c = 0;
		text_stream *T;
		LOOP_OVER_LINKED_LIST(T, text_stream, V.prerelease_segments) {
			if (c++ == 0) WRITE("-"); else WRITE(".");
			WRITE("%S", T);
		}
	}
	if (V.build_metadata) WRITE("+%S", V.build_metadata);
}

#line 125 "inweb/foundation-module/Chapter 7/Version Numbers.w"
void VersionNumbers__writer(OUTPUT_STREAM, char *format_string, void *vE) {
	semantic_version_number *V = (semantic_version_number *) vE;
	VersionNumbers__to_text(OUT, *V);
}

#line 141 "inweb/foundation-module/Chapter 7/Version Numbers.w"

#line 143 "inweb/foundation-module/Chapter 7/Version Numbers.w"
semantic_version_number VersionNumbers__from_text(text_stream *T) {
	semantic_version_number V = VersionNumbers__null();
	int component = 0, val = -1, dots_used = 0, slashes_used = 0, count = 0;
	int part = MMP_SEMVERPART;
	TEMPORARY_TEXT(prerelease)
	LOOP_THROUGH_TEXT(pos, T) {
		inchar32_t c = Str__get(pos);
		switch (part) {
			case MMP_SEMVERPART:
				if (c == '.') dots_used++;
				if (c == '/') slashes_used++;
				if ((c == '.') || (c == '/') || (c == '-') || (c == '+')) {
					if (val == -1) return VersionNumbers__null();
					if (component >= SEMVER_NUMBER_DEPTH) return VersionNumbers__null();
					V.version_numbers[component] = val;
					component++; val = -1; count = 0;
					if (c == '-') part = PRE_SEMVERPART;
					if (c == '+') part = BM_SEMVERPART;
				} else if (Characters__isdigit(c)) {
					int digit = (int) (c - '0');
					if ((val == 0) && (slashes_used == 0))
						return VersionNumbers__null();
					if (val < 0) val = digit; else val = 10*val + digit;
					count++;
				} else return VersionNumbers__null();
				break;
			case PRE_SEMVERPART:
				if (c == '.') {
					
{
#line 202 "inweb/foundation-module/Chapter 7/Version Numbers.w"
	if (Str__len(prerelease) == 0) return VersionNumbers__null();
	if (V.prerelease_segments == NULL) V.prerelease_segments = NEW_LINKED_LIST(text_stream);
	ADD_TO_LINKED_LIST(Str__duplicate(prerelease), text_stream, V.prerelease_segments);
	Str__clear(prerelease);

}
#line 171 "inweb/foundation-module/Chapter 7/Version Numbers.w"
;
				} else if (c == '+') {
					
{
#line 202 "inweb/foundation-module/Chapter 7/Version Numbers.w"
	if (Str__len(prerelease) == 0) return VersionNumbers__null();
	if (V.prerelease_segments == NULL) V.prerelease_segments = NEW_LINKED_LIST(text_stream);
	ADD_TO_LINKED_LIST(Str__duplicate(prerelease), text_stream, V.prerelease_segments);
	Str__clear(prerelease);

}
#line 173 "inweb/foundation-module/Chapter 7/Version Numbers.w"
; part = BM_SEMVERPART;
				} else {
					PUT_TO(prerelease, c);
				}
				break;
			case BM_SEMVERPART:
				if (V.build_metadata == NULL) V.build_metadata = Str__new();
				PUT_TO(V.build_metadata, c);
				break;
		}
	}
	if ((part == PRE_SEMVERPART) && (Str__len(prerelease) > 0)) 
{
#line 202 "inweb/foundation-module/Chapter 7/Version Numbers.w"
	if (Str__len(prerelease) == 0) return VersionNumbers__null();
	if (V.prerelease_segments == NULL) V.prerelease_segments = NEW_LINKED_LIST(text_stream);
	ADD_TO_LINKED_LIST(Str__duplicate(prerelease), text_stream, V.prerelease_segments);
	Str__clear(prerelease);

}
#line 184 "inweb/foundation-module/Chapter 7/Version Numbers.w"
;
	DISCARD_TEXT(prerelease)
	if ((dots_used > 0) && (slashes_used > 0)) return VersionNumbers__null();
	if (slashes_used > 0) {
		if (component > 1) return VersionNumbers__null();
		if (count != 6) return VersionNumbers__null();
		V.version_numbers[1] = 0;
		component = 2;
	}
	if (part == MMP_SEMVERPART) {
		if (val == -1) return VersionNumbers__null();
		if (component >= SEMVER_NUMBER_DEPTH) return VersionNumbers__null();
		V.version_numbers[component] = val;
	}
	return V;
}

#line 218 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int VersionNumbers__le(semantic_version_number V1, semantic_version_number V2) {
	for (int i=0; i<SEMVER_NUMBER_DEPTH; i++) {
		int N1 = VersionNumbers__floor(V1.version_numbers[i]);
		int N2 = VersionNumbers__floor(V2.version_numbers[i]);
		if (N1 > N2) return FALSE;
		if (N1 < N2) return TRUE;
	}
	linked_list_item *I1 = (V1.prerelease_segments)?(LinkedLists__first(V1.prerelease_segments)):NULL;
	linked_list_item *I2 = (V2.prerelease_segments)?(LinkedLists__first(V2.prerelease_segments)):NULL;
	if ((I1 == NULL) && (I2)) return FALSE;
	if ((I1) && (I2 == NULL)) return TRUE;
	do {
		text_stream *T1 = (text_stream *) LinkedLists__content(I1);
		text_stream *T2 = (text_stream *) LinkedLists__content(I2);
		int N1 = VersionNumbers__strict_atoi(T1);
		int N2 = VersionNumbers__strict_atoi(T2);
		if ((N1 >= 0) && (N2 >= 0)) {
			if (N1 < N2) return TRUE;
			if (N1 > N2) return FALSE;
		} else {
			if (Str__ne(T1, T2)) {
				int c = Str__cmp(T1, T2);
				if (c < 0) return TRUE;
				if (c > 0) return FALSE;
			}
		}
		I1 = LinkedLists__next(I1);
		I2 = LinkedLists__next(I2);
	} while ((I1) && (I2));
	if ((I1 == NULL) && (I2)) return TRUE;
	if ((I1) && (I2 == NULL)) return FALSE;
	return TRUE;
}

#line 256 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int VersionNumbers__floor(int N) {
	if (N < 0) return 0;
	return N;
}

#line 266 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int VersionNumbers__strict_atoi(text_stream *T) {
	LOOP_THROUGH_TEXT(pos, T)
		if (Characters__isdigit(Str__get(pos)) == FALSE)
			return -1;
	inchar32_t c = Str__get_first_char(T);
	if ((c == '0') && (Str__len(T) > 1)) return -1;
	return Str__atoi(T, 0);
}

#line 282 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int VersionNumbers__eq(semantic_version_number V1, semantic_version_number V2) {
	if ((VersionNumbers__le(V1, V2)) && (VersionNumbers__le(V2, V1)))
		return TRUE;
	return FALSE;
}

int VersionNumbers__ne(semantic_version_number V1, semantic_version_number V2) {
	return (VersionNumbers__eq(V1, V2))?FALSE:TRUE;
}

int VersionNumbers__gt(semantic_version_number V1, semantic_version_number V2) {
	return (VersionNumbers__le(V1, V2))?FALSE:TRUE;
}

int VersionNumbers__ge(semantic_version_number V1, semantic_version_number V2) {
	return VersionNumbers__le(V2, V1);
}

int VersionNumbers__lt(semantic_version_number V1, semantic_version_number V2) {
	return (VersionNumbers__ge(V1, V2))?FALSE:TRUE;
}

#line 307 "inweb/foundation-module/Chapter 7/Version Numbers.w"
int VersionNumbers__cmp(semantic_version_number V1, semantic_version_number V2) {
	if (VersionNumbers__eq(V1, V2)) return 0;
	if (VersionNumbers__gt(V1, V2)) return 1;
	return -1;
}

#line 28 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"

#line 34 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"

#line 39 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
void VersionNumberRanges__write_range(OUTPUT_STREAM, semver_range *R) {
	if (R == NULL) internal_error("no range");
	switch(R->lower.end_type) {
		case CLOSED_RANGE_END: WRITE("[%v,", &(R->lower.end_value)); break;
		case OPEN_RANGE_END: WRITE("(%v,", &(R->lower.end_value)); break;
		case INFINITE_RANGE_END: WRITE("(-infty,"); break;
		case EMPTY_RANGE_END: WRITE("empty"); break;
	}
	switch(R->upper.end_type) {
		case CLOSED_RANGE_END: WRITE("%v]", &(R->upper.end_value)); break;
		case OPEN_RANGE_END: WRITE("%v)", &(R->upper.end_value)); break;
		case INFINITE_RANGE_END: WRITE("infty)"); break;
	}
}

#line 58 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range *VersionNumberRanges__any_range(void) {
	semver_range *R = CREATE(semver_range);
	R->lower.end_type = INFINITE_RANGE_END;
	R->lower.end_value = VersionNumbers__null();
	R->upper.end_type = INFINITE_RANGE_END;
	R->upper.end_value = VersionNumbers__null();
	return R;
}

int VersionNumberRanges__is_any_range(semver_range *R) {
	if (R == NULL) return TRUE;
	if ((R->lower.end_type == INFINITE_RANGE_END) && (R->upper.end_type == INFINITE_RANGE_END))
		return TRUE;
	return FALSE;
}

#line 87 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range *VersionNumberRanges__compatibility_range(semantic_version_number V) {
	semver_range *R = VersionNumberRanges__any_range();
	if (VersionNumbers__is_null(V) == FALSE) {
		R->lower.end_type = CLOSED_RANGE_END;
		R->lower.end_value = V;
		R->upper.end_type = OPEN_RANGE_END;
		semantic_version_number W = VersionNumbers__null();
		W.version_numbers[0] = V.version_numbers[0] + 1;
		W.prerelease_segments = NEW_LINKED_LIST(text_stream);
		ADD_TO_LINKED_LIST(TL_IS_2503, text_stream, W.prerelease_segments);
		R->upper.end_value = W;
	}
	return R;
}

#line 106 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
semver_range *VersionNumberRanges__at_least_range(semantic_version_number V) {
	semver_range *R = VersionNumberRanges__any_range();
	R->lower.end_type = CLOSED_RANGE_END;
	R->lower.end_value = V;
	return R;
}

semver_range *VersionNumberRanges__at_most_range(semantic_version_number V) {
	semver_range *R = VersionNumberRanges__any_range();
	R->upper.end_type = CLOSED_RANGE_END;
	R->upper.end_value = V;
	return R;
}

#line 123 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int VersionNumberRanges__version_ge_end(semantic_version_number V, range_end E) {
	switch (E.end_type) {
		case CLOSED_RANGE_END:
			if (VersionNumbers__is_null(V)) return FALSE;
			if (VersionNumbers__ge(V, E.end_value)) return TRUE;
			break;
		case OPEN_RANGE_END:
			if (VersionNumbers__is_null(V)) return FALSE;
			if (VersionNumbers__gt(V, E.end_value)) return TRUE;
			break;
		case INFINITE_RANGE_END: return TRUE;
		case EMPTY_RANGE_END: return FALSE;
	}
	return FALSE;
}

int VersionNumberRanges__version_le_end(semantic_version_number V, range_end E) {
	switch (E.end_type) {
		case CLOSED_RANGE_END:
			if (VersionNumbers__is_null(V)) return FALSE;
			if (VersionNumbers__le(V, E.end_value)) return TRUE;
			break;
		case OPEN_RANGE_END:
			if (VersionNumbers__is_null(V)) return FALSE;
			if (VersionNumbers__lt(V, E.end_value)) return TRUE;
			break;
		case INFINITE_RANGE_END: return TRUE;
		case EMPTY_RANGE_END: return FALSE;
	}
	return FALSE;
}

#line 158 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int VersionNumberRanges__in_range(semantic_version_number V, semver_range *R) {
	if (R == NULL) return TRUE;
	if ((VersionNumberRanges__version_ge_end(V, R->lower)) &&
		(VersionNumberRanges__version_le_end(V, R->upper))) return TRUE;
	return FALSE;
}

#line 178 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int VersionNumberRanges__stricter(range_end E1, range_end E2, int lower) {
	if ((E1.end_type == EMPTY_RANGE_END) && (E2.end_type == EMPTY_RANGE_END)) return 0;
	if (E1.end_type == EMPTY_RANGE_END) return 1;
	if (E2.end_type == EMPTY_RANGE_END) return -1;
	if ((E1.end_type == INFINITE_RANGE_END) && (E2.end_type == INFINITE_RANGE_END)) return 0;
	if (E1.end_type == INFINITE_RANGE_END) return -1;
	if (E2.end_type == INFINITE_RANGE_END) return 1;
	int c = VersionNumbers__cmp(E1.end_value, E2.end_value);
	if (c != 0) {
		if (lower) return c; else return -c;
	}
	if (E1.end_type == E2.end_type) return 0;
	if (E1.end_type == CLOSED_RANGE_END) return -1;
	return 1;
}

#line 202 "inweb/foundation-module/Chapter 7/Version Number Ranges.w"
int VersionNumberRanges__intersect_range(semver_range *R1, semver_range *R2) {
	int lc = VersionNumberRanges__stricter(R1->lower, R2->lower, TRUE);
	int uc = VersionNumberRanges__stricter(R1->upper, R2->upper, FALSE);
	if ((lc >= 0) && (uc >= 0)) return FALSE;
	if (lc < 0) R1->lower = R2->lower;
	if (uc < 0) R1->upper = R2->upper;
	if (R1->lower.end_type == EMPTY_RANGE_END) R1->upper.end_type = EMPTY_RANGE_END;
	else if (R1->upper.end_type == EMPTY_RANGE_END) R1->lower.end_type = EMPTY_RANGE_END;
	else if ((R1->lower.end_type != INFINITE_RANGE_END) && (R1->upper.end_type != INFINITE_RANGE_END)) {
		int c = VersionNumbers__cmp(R1->lower.end_value, R1->upper.end_value);
		if ((c > 0) ||
			((c == 0) && ((R1->lower.end_type == OPEN_RANGE_END) ||
				(R1->upper.end_type == OPEN_RANGE_END)))) {
			R1->lower.end_type = EMPTY_RANGE_END; R1->upper.end_type = EMPTY_RANGE_END;
		}
	}
	return TRUE;
}

#line 46 "inweb/foundation-module/Chapter 8/Web Structure.w"

#line 64 "inweb/foundation-module/Chapter 8/Web Structure.w"

#line 84 "inweb/foundation-module/Chapter 8/Web Structure.w"

#line 92 "inweb/foundation-module/Chapter 8/Web Structure.w"
web_md *WebMetadata__get_without_modules(pathname *P, filename *alt_F) {
	return WebMetadata__get(P, alt_F, V2_SYNTAX, NULL, FALSE, FALSE, NULL);
}

web_md *WebMetadata__get(pathname *P, filename *alt_F, int syntax_version,
	module_search *I, int verbosely, int including_modules, pathname *path_to_inweb) {
	if ((including_modules) && (I == NULL)) I = WebModules__make_search_path(NULL);
	web_md *Wm = CREATE(web_md);
	
{
#line 110 "inweb/foundation-module/Chapter 8/Web Structure.w"
	Wm->bibliographic_data = NEW_LINKED_LIST(web_bibliographic_datum);
	Bibliographic__initialise_data(Wm);

}
#line 100 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	
{
#line 114 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (P) {
		Wm->path_to_web = P;
		Wm->single_file = NULL;
		Wm->contents_filename = WebMetadata__contents_filename(P);
	} else {
		Wm->path_to_web = Filenames__up(alt_F);
		Wm->single_file = alt_F;
		Wm->contents_filename = NULL;
	}
	Wm->version_number = VersionNumbers__null();
	Wm->default_syntax = syntax_version;
	Wm->chaptered = FALSE;
	Wm->sections_md = NEW_LINKED_LIST(sections_md);
	Wm->chapters_md = NEW_LINKED_LIST(chapter_md);
	Wm->tangle_target_names = NEW_LINKED_LIST(text_stream);
	Wm->main_language_name = Str__new();
	Wm->header_filenames = NEW_LINKED_LIST(filename);
	Wm->as_module = WebModules__create_main_module(Wm);

}
#line 101 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	WebMetadata__read_contents_page(Wm, Wm->as_module, I, verbosely,
		including_modules, NULL, path_to_inweb);
	
{
#line 134 "inweb/foundation-module/Chapter 8/Web Structure.w"
	Bibliographic__check_required_data(Wm);
	BuildFiles__set_bibliographic_data_for(Wm);
	BuildFiles__deduce_semver(Wm);

}
#line 104 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	
{
#line 141 "inweb/foundation-module/Chapter 8/Web Structure.w"
	int sequential = FALSE; /* are we numbering sections sequentially? */
	if (Str__eq(Bibliographic__get_datum(Wm, TL_IS_2504), TL_IS_2505))
		sequential = TRUE;
	chapter_md *Cm;
	section_md *Sm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, Wm->chapters_md) {
		int section_counter = 1;
		LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md) {
			if (Str__len(Sm->sect_range) == 0)
				
{
#line 156 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (sequential) {
		WRITE_TO(Sm->sect_range, "%S/", Cm->ch_range);
		WRITE_TO(Sm->sect_range, "s%d", section_counter);
	} else {
		text_stream *from = Sm->sect_title;
		int letters_from_each_word = 5;
		do {
			Str__clear(Sm->sect_range);
			WRITE_TO(Sm->sect_range, "%S/", Cm->ch_range);
			
{
#line 176 "inweb/foundation-module/Chapter 8/Web Structure.w"
	int sn = 0, sw = Str__len(Sm->sect_range);
	if (Platform__is_folder_separator(Str__get_at(from, sn))) sn++;
	int letters_from_current_word = 0;
	while ((Str__get_at(from, sn)) && (Str__get_at(from, sn) != '.')) {
		if (Str__get_at(from, sn) == ' ') letters_from_current_word = 0;
		else {
			if (letters_from_current_word < letters_from_each_word) {
				if (Str__get_at(from, sn) != '-') {
					inchar32_t l = Characters__tolower(Str__get_at(from, sn));
					if ((letters_from_current_word == 0) ||
						((l != 'a') && (l != 'e') && (l != 'i') &&
							(l != 'o') && (l != 'u'))) {
						Str__put_at(Sm->sect_range, sw++, l);
						Str__put_at(Sm->sect_range, sw, 0);
						letters_from_current_word++;
					}
				}
			}
		}
		sn++;
	}

}
#line 165 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
			if (--letters_from_each_word == 0) break;
		} while (Str__len(Sm->sect_range) > 5);

		
{
#line 201 "inweb/foundation-module/Chapter 8/Web Structure.w"
	TEMPORARY_TEXT(original_range)
	Str__copy(original_range, Sm->sect_range);
	int disnum = 0, collision = FALSE;
	do {
		if (disnum++ > 0) {
			int ldn = 4;
			if (disnum >= 1000) ldn = 3;
			else if (disnum >= 100) ldn = 2;
			else if (disnum >= 10) ldn = 1;
			else ldn = 0;
			Str__clear(Sm->sect_range);
			WRITE_TO(Sm->sect_range, "%S", original_range);
			Str__truncate(Sm->sect_range, Str__len(Sm->sect_range) - ldn);
			WRITE_TO(Sm->sect_range, "%d", disnum);
		}
		collision = FALSE;
		chapter_md *Cm2;
		section_md *Sm2;
		LOOP_OVER_LINKED_LIST(Cm2, chapter_md, Wm->chapters_md)
			LOOP_OVER_LINKED_LIST(Sm2, section_md, Cm2->sections_md)
				if ((Sm2 != Sm) && (Str__eq(Sm2->sect_range, Sm->sect_range))) {
					collision = TRUE; break;
				}
	} while (collision);
	DISCARD_TEXT(original_range)

}
#line 169 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	}

}
#line 150 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
			section_counter++;
		}
	}

}
#line 105 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	return Wm;
}

#line 266 "inweb/foundation-module/Chapter 8/Web Structure.w"

void WebMetadata__read_contents_page(web_md *Wm, module *of_module,
	module_search *import_path, int verbosely,
	int including_modules, pathname *path, pathname *X) {
	reader_state RS;
	
{
#line 286 "inweb/foundation-module/Chapter 8/Web Structure.w"
	RS.Wm = Wm;
	RS.reading_from = of_module;
	RS.in_biblio = TRUE;
	RS.in_purpose = FALSE;
	RS.chapter_being_scanned = NULL;
	RS.chapter_dir_name = Str__new();
	RS.titling_line_to_insert = Str__new();
	RS.scan_verbosely = verbosely;
	RS.including_modules = including_modules;
	RS.path_to = path;
	RS.import_from = import_path;
	RS.halted = FALSE;
	RS.path_to_inweb = X;

	if (path == NULL) {
		path = Wm->path_to_web;
		RS.main_web_not_module = TRUE;
	} else {
		RS.main_web_not_module = FALSE;
	}

	if (Wm->single_file) {
		RS.contents_filename = Wm->single_file;
		RS.halt_at_at = TRUE;
	} else {
		RS.contents_filename = WebMetadata__contents_filename(path);
		RS.halt_at_at = FALSE;
	}
	RS.section_count = 0;
	RS.last_section = NULL;

}
#line 271 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

	int cl = TextFiles__read(RS.contents_filename, FALSE, "can't open contents file",
		TRUE, WebMetadata__read_contents_line, NULL, &RS);
	if (verbosely) {
		if (Wm->single_file) {
			PRINT("Read %d lines of contents part at top of file\n", cl);
		} else {
			PRINT("Read contents section (%d lines)\n", cl);
		}
	}
	if (RS.section_count == 1) RS.last_section->is_a_singleton = TRUE;
}

#line 322 "inweb/foundation-module/Chapter 8/Web Structure.w"
void WebMetadata__read_contents_line(text_stream *line, text_file_position *tfp, void *X) {
	reader_state *RS = (reader_state *) X;
	if (RS->halted) return;

	int begins_with_white_space = FALSE;
	if (Characters__is_whitespace(Str__get_first_char(line)))
		begins_with_white_space = TRUE;
	Str__trim_white_space(line);

	
{
#line 346 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (Str__eq(line, TL_IS_2506))
		RS->Wm->default_syntax = V1_SYNTAX;
	else if (Str__eq(line, TL_IS_2507))
		RS->Wm->default_syntax = V2_SYNTAX;

}
#line 331 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	int syntax = RS->Wm->default_syntax;

	filename *filename_of_single_file_web = NULL;
	if ((RS->halt_at_at) && (Str__get_at(line, 0) == '@'))
		
{
#line 357 "inweb/foundation-module/Chapter 8/Web Structure.w"
	RS->halted = TRUE;
	text_stream *new_chapter_range = TL_IS_2508;
	text_stream *language_name = NULL;
	line = TL_IS_2509;
	
{
#line 560 "inweb/foundation-module/Chapter 8/Web Structure.w"
	chapter_md *Cm = CREATE(chapter_md);
	Cm->ch_range = Str__duplicate(new_chapter_range);
	if (line == NULL) PRINT("Nullity!\n");
	Cm->ch_title = Str__duplicate(line);
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, Cm->ch_title, U"(%c*?): *(%c*)")) {
		Cm->ch_basic_title = Str__duplicate(mr.exp[0]);
		Cm->ch_decorated_title = Str__duplicate(mr.exp[1]);
	} else {
		Cm->ch_basic_title = Str__duplicate(Cm->ch_title);
		Cm->ch_decorated_title = Str__new();
	}
	Regexp__dispose_of(&mr);
	Cm->rubric = Str__new();
	Cm->ch_language_name = language_name;
	Cm->imported = TRUE;
	Cm->sections_md = NEW_LINKED_LIST(section_md);
	if (RS->main_web_not_module) Cm->imported = FALSE;

	ADD_TO_LINKED_LIST(Cm, chapter_md, RS->Wm->chapters_md);
	ADD_TO_LINKED_LIST(Cm, chapter_md, RS->reading_from->chapters_md);
	RS->chapter_being_scanned = Cm;

}
#line 361 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	line = TL_IS_2510;
	filename_of_single_file_web = tfp->text_file_filename;
	
{
#line 588 "inweb/foundation-module/Chapter 8/Web Structure.w"
	section_md *Sm = CREATE(section_md);
	
{
#line 597 "inweb/foundation-module/Chapter 8/Web Structure.w"
	Sm->source_file_for_section = filename_of_single_file_web;
	Sm->using_syntax = syntax;
	Sm->is_a_singleton = FALSE;
	Sm->titling_line_to_insert = Str__duplicate(RS->titling_line_to_insert);
	Sm->sect_range = Str__new();
	Str__clear(RS->titling_line_to_insert);

	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c+) %^\"(%c+)\" *")) {
		Sm->sect_title = Str__duplicate(mr.exp[0]);
		Sm->tag_name = Str__duplicate(mr.exp[1]);
	} else {
		Sm->sect_title = Str__duplicate(line);
		Sm->tag_name = NULL;
	}
	Regexp__dispose_of(&mr);
	Sm->owning_module = RS->reading_from;

}
#line 589 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	
{
#line 616 "inweb/foundation-module/Chapter 8/Web Structure.w"
	chapter_md *Cm = RS->chapter_being_scanned;
	RS->section_count++;
	RS->last_section = Sm;
	ADD_TO_LINKED_LIST(Sm, section_md, Cm->sections_md);
	ADD_TO_LINKED_LIST(Sm, section_md, RS->Wm->sections_md);
	ADD_TO_LINKED_LIST(Sm, section_md, RS->reading_from->sections_md);

}
#line 590 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	
{
#line 624 "inweb/foundation-module/Chapter 8/Web Structure.w"
	Sm->sect_language_name = RS->chapter_being_scanned->ch_language_name; /* by default */
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c*%C) %(Independent (%c*) *%)")) {
		text_stream *title_alone = mr.exp[0];
		text_stream *language_name = mr.exp[1];
		
{
#line 635 "inweb/foundation-module/Chapter 8/Web Structure.w"
	text_stream *p = language_name;
	if (Str__len(p) == 0) p = Bibliographic__get_datum(RS->Wm, TL_IS_2514);
	Sm->sect_independent_language = Str__duplicate(p);

}
#line 629 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
		Str__copy(Sm->sect_title, title_alone);
	}
	Regexp__dispose_of(&mr);

}
#line 591 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

	if (Sm->source_file_for_section == NULL)
		
{
#line 645 "inweb/foundation-module/Chapter 8/Web Structure.w"
	TEMPORARY_TEXT(leafname_to_use)
	WRITE_TO(leafname_to_use, "%S.i6t", Sm->sect_title);
	pathname *P = RS->path_to;
	if (P == NULL) P = RS->Wm->path_to_web;
	if (Str__len(RS->chapter_dir_name) > 0)
		P = Pathnames__down(P, RS->chapter_dir_name);
	Sm->source_file_for_section = Filenames__in(P, leafname_to_use);
	if (TextFiles__exists(Sm->source_file_for_section) == FALSE) {
		Str__clear(leafname_to_use);
		WRITE_TO(leafname_to_use, "%S.w", Sm->sect_title);
		Sm->source_file_for_section = Filenames__in(P, leafname_to_use);
	}
	DISCARD_TEXT(leafname_to_use)

}
#line 594 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

}
#line 364 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	return;

}
#line 336 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

	
{
#line 373 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (Str__len(line) == 0) 
{
#line 381 "inweb/foundation-module/Chapter 8/Web Structure.w"
	RS->in_biblio = FALSE;

}
#line 373 "inweb/foundation-module/Chapter 8/Web Structure.w"

	else if (RS->in_biblio) 
{
#line 387 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (RS->main_web_not_module) {
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, line, U"(%c+?): (%c+?) *")) {
			TEMPORARY_TEXT(key)
			Str__copy(key, mr.exp[0]);
			TEMPORARY_TEXT(value)
			Str__copy(value, mr.exp[1]);
			
{
#line 407 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (Bibliographic__datum_can_be_declared(RS->Wm, key)) {
		if (Bibliographic__datum_on_or_off(RS->Wm, key)) {
			if ((Str__ne_wide_string(value, U"On")) && (Str__ne_wide_string(value, U"Off"))) {
				TEMPORARY_TEXT(err)
				WRITE_TO(err, "this setting must be 'On' or 'Off': %S", key);
				Errors__in_text_file_S(err, tfp);
				DISCARD_TEXT(err)
				Str__clear(value);
				WRITE_TO(value, "Off");
			}
		}
		Bibliographic__set_datum(RS->Wm, key, value);
	} else {
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "no such bibliographic datum: %S", key);
		Errors__in_text_file_S(err, tfp);
		DISCARD_TEXT(err)
	}

}
#line 394 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
			DISCARD_TEXT(key)
			DISCARD_TEXT(value)
		} else {
			TEMPORARY_TEXT(err)
			WRITE_TO(err, "expected 'Setting: Value' but found '%S'", line);
			Errors__in_text_file_S(err, tfp);
			DISCARD_TEXT(err)
		}
		Regexp__dispose_of(&mr);
	}

}
#line 374 "inweb/foundation-module/Chapter 8/Web Structure.w"

	else 
{
#line 430 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if (begins_with_white_space == FALSE) {
		if (Str__get_first_char(line) == '"') {
			RS->in_purpose = TRUE; Str__delete_first_character(line);
		}
		if (RS->in_purpose == TRUE) 
{
#line 443 "inweb/foundation-module/Chapter 8/Web Structure.w"
	if ((Str__len(line) > 0) && (Str__get_last_char(line) == '"')) {
		Str__truncate(line, Str__len(line)-1); RS->in_purpose = FALSE;
	}
	if (RS->chapter_being_scanned) {
		text_stream *r = RS->chapter_being_scanned->rubric;
		if (Str__len(r) > 0) WRITE_TO(r, " ");
		WRITE_TO(r, "%S", line);
	}

}
#line 434 "inweb/foundation-module/Chapter 8/Web Structure.w"

		else 
{
#line 455 "inweb/foundation-module/Chapter 8/Web Structure.w"
	TEMPORARY_TEXT(new_chapter_range) /* e.g., S, P, 1, 2, 3, A, B, ... */
	TEMPORARY_TEXT(pdf_leafname)
	text_stream *language_name = NULL;

	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c*%C) %(Independent(%c*)%)")) {
		text_stream *title_alone = mr.exp[0];
		language_name = mr.exp[1];
		
{
#line 552 "inweb/foundation-module/Chapter 8/Web Structure.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, language_name, U" *"))
		language_name = Bibliographic__get_datum(RS->Wm, TL_IS_2513);
	else if (Regexp__match(&mr, language_name, U" *(%c*?) *"))
		language_name = mr.exp[0];
	Regexp__dispose_of(&mr);

}
#line 463 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
		Str__copy(line, title_alone);
	}
	int this_is_a_chapter = TRUE;
	Str__clear(RS->chapter_dir_name);
	if (Str__eq_wide_string(line, U"Sections")) {
		WRITE_TO(new_chapter_range, "S");
		WRITE_TO(RS->chapter_dir_name, "Sections");
		WRITE_TO(pdf_leafname, "Sections.pdf");
		RS->Wm->chaptered = FALSE;
		Str__clear(RS->titling_line_to_insert);
	} else if (Str__eq_wide_string(line, U"Preliminaries")) {
		WRITE_TO(new_chapter_range, "P");
		WRITE_TO(RS->chapter_dir_name, "Preliminaries");
		Str__clear(RS->titling_line_to_insert);
		WRITE_TO(RS->titling_line_to_insert, "%S.", line);
		WRITE_TO(pdf_leafname, "Preliminaries.pdf");
		RS->Wm->chaptered = TRUE;
	} else if (Str__eq_wide_string(line, U"Manual")) {
		WRITE_TO(new_chapter_range, "M");
		WRITE_TO(RS->chapter_dir_name, "Manual");
		Str__clear(RS->titling_line_to_insert);
		WRITE_TO(RS->titling_line_to_insert, "%S.", line);
		WRITE_TO(pdf_leafname, "Manual.pdf");
		RS->Wm->chaptered = TRUE;
	} else if (Regexp__match(&mr, line, U"Header: (%c+)")) {
		pathname *P = RS->path_to;
		if (P == NULL) P = RS->Wm->path_to_web;
		P = Pathnames__down(P, TL_IS_2511);
		filename *HF = Filenames__in(P, mr.exp[0]);
		ADD_TO_LINKED_LIST(HF, filename, RS->Wm->header_filenames);
		this_is_a_chapter = FALSE;
	} else if (Regexp__match(&mr, line, U"Import: (%c+)")) {
		if (RS->halt_at_at)
			Errors__in_text_file_S(TL_IS_2512, tfp);
		else if (RS->import_from) {
			module *imported =
				WebModules__find(RS->Wm, RS->import_from, mr.exp[0], RS->path_to_inweb);
			if (imported == NULL) {
				TEMPORARY_TEXT(err)
				WRITE_TO(err, "unable to find module: %S", line);
				Errors__in_text_file_S(err, tfp);
				DISCARD_TEXT(err)
			} else {
				if (RS->including_modules) {
					int save_syntax = RS->Wm->default_syntax;
					WebMetadata__read_contents_page(RS->Wm, imported, RS->import_from,
						RS->scan_verbosely, RS->including_modules,
						imported->module_location, RS->path_to_inweb);
					RS->Wm->default_syntax = save_syntax;
				}
			}
		}
		this_is_a_chapter = FALSE;
	} else if (Regexp__match(&mr, line, U"Chapter (%d+): %c+")) {
		int n = Str__atoi(mr.exp[0], 0);
		WRITE_TO(new_chapter_range, "%d", n);
		WRITE_TO(RS->chapter_dir_name, "Chapter %d", n);
		Str__clear(RS->titling_line_to_insert);
		WRITE_TO(RS->titling_line_to_insert, "%S.", line);
		WRITE_TO(pdf_leafname, "Chapter-%d.pdf", n);
		RS->Wm->chaptered = TRUE;
	} else if (Regexp__match(&mr, line, U"Appendix (%c): %c+")) {
		text_stream *letter = mr.exp[0];
		Str__copy(new_chapter_range, letter);
		WRITE_TO(RS->chapter_dir_name, "Appendix %S", letter);
		Str__clear(RS->titling_line_to_insert);
		WRITE_TO(RS->titling_line_to_insert, "%S.", line);
		WRITE_TO(pdf_leafname, "Appendix-%S.pdf", letter);
		RS->Wm->chaptered = TRUE;
	} else {
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "segment not understood: %S", line);
		Errors__in_text_file_S(err, tfp);
		WRITE_TO(STDERR, "(Must be 'Chapter <number>: Title', "
			"'Appendix <letter A to O>: Title',\n");
		WRITE_TO(STDERR, "'Manual', 'Preliminaries' or 'Sections')\n");
		DISCARD_TEXT(err)
	}

	if (this_is_a_chapter) 
{
#line 560 "inweb/foundation-module/Chapter 8/Web Structure.w"
	chapter_md *Cm = CREATE(chapter_md);
	Cm->ch_range = Str__duplicate(new_chapter_range);
	if (line == NULL) PRINT("Nullity!\n");
	Cm->ch_title = Str__duplicate(line);
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, Cm->ch_title, U"(%c*?): *(%c*)")) {
		Cm->ch_basic_title = Str__duplicate(mr.exp[0]);
		Cm->ch_decorated_title = Str__duplicate(mr.exp[1]);
	} else {
		Cm->ch_basic_title = Str__duplicate(Cm->ch_title);
		Cm->ch_decorated_title = Str__new();
	}
	Regexp__dispose_of(&mr);
	Cm->rubric = Str__new();
	Cm->ch_language_name = language_name;
	Cm->imported = TRUE;
	Cm->sections_md = NEW_LINKED_LIST(section_md);
	if (RS->main_web_not_module) Cm->imported = FALSE;

	ADD_TO_LINKED_LIST(Cm, chapter_md, RS->Wm->chapters_md);
	ADD_TO_LINKED_LIST(Cm, chapter_md, RS->reading_from->chapters_md);
	RS->chapter_being_scanned = Cm;

}
#line 543 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	DISCARD_TEXT(new_chapter_range)
	DISCARD_TEXT(pdf_leafname)
	Regexp__dispose_of(&mr);

}
#line 435 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	} else 
{
#line 588 "inweb/foundation-module/Chapter 8/Web Structure.w"
	section_md *Sm = CREATE(section_md);
	
{
#line 597 "inweb/foundation-module/Chapter 8/Web Structure.w"
	Sm->source_file_for_section = filename_of_single_file_web;
	Sm->using_syntax = syntax;
	Sm->is_a_singleton = FALSE;
	Sm->titling_line_to_insert = Str__duplicate(RS->titling_line_to_insert);
	Sm->sect_range = Str__new();
	Str__clear(RS->titling_line_to_insert);

	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c+) %^\"(%c+)\" *")) {
		Sm->sect_title = Str__duplicate(mr.exp[0]);
		Sm->tag_name = Str__duplicate(mr.exp[1]);
	} else {
		Sm->sect_title = Str__duplicate(line);
		Sm->tag_name = NULL;
	}
	Regexp__dispose_of(&mr);
	Sm->owning_module = RS->reading_from;

}
#line 589 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	
{
#line 616 "inweb/foundation-module/Chapter 8/Web Structure.w"
	chapter_md *Cm = RS->chapter_being_scanned;
	RS->section_count++;
	RS->last_section = Sm;
	ADD_TO_LINKED_LIST(Sm, section_md, Cm->sections_md);
	ADD_TO_LINKED_LIST(Sm, section_md, RS->Wm->sections_md);
	ADD_TO_LINKED_LIST(Sm, section_md, RS->reading_from->sections_md);

}
#line 590 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
	
{
#line 624 "inweb/foundation-module/Chapter 8/Web Structure.w"
	Sm->sect_language_name = RS->chapter_being_scanned->ch_language_name; /* by default */
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c*%C) %(Independent (%c*) *%)")) {
		text_stream *title_alone = mr.exp[0];
		text_stream *language_name = mr.exp[1];
		
{
#line 635 "inweb/foundation-module/Chapter 8/Web Structure.w"
	text_stream *p = language_name;
	if (Str__len(p) == 0) p = Bibliographic__get_datum(RS->Wm, TL_IS_2514);
	Sm->sect_independent_language = Str__duplicate(p);

}
#line 629 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
		Str__copy(Sm->sect_title, title_alone);
	}
	Regexp__dispose_of(&mr);

}
#line 591 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

	if (Sm->source_file_for_section == NULL)
		
{
#line 645 "inweb/foundation-module/Chapter 8/Web Structure.w"
	TEMPORARY_TEXT(leafname_to_use)
	WRITE_TO(leafname_to_use, "%S.i6t", Sm->sect_title);
	pathname *P = RS->path_to;
	if (P == NULL) P = RS->Wm->path_to_web;
	if (Str__len(RS->chapter_dir_name) > 0)
		P = Pathnames__down(P, RS->chapter_dir_name);
	Sm->source_file_for_section = Filenames__in(P, leafname_to_use);
	if (TextFiles__exists(Sm->source_file_for_section) == FALSE) {
		Str__clear(leafname_to_use);
		WRITE_TO(leafname_to_use, "%S.w", Sm->sect_title);
		Sm->source_file_for_section = Filenames__in(P, leafname_to_use);
	}
	DISCARD_TEXT(leafname_to_use)

}
#line 594 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

}
#line 436 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

}
#line 375 "inweb/foundation-module/Chapter 8/Web Structure.w"
;

}
#line 338 "inweb/foundation-module/Chapter 8/Web Structure.w"
;
}

#line 662 "inweb/foundation-module/Chapter 8/Web Structure.w"
int WebMetadata__directory_looks_like_a_web(pathname *P) {
	return TextFiles__exists(WebMetadata__contents_filename(P));
}

filename *WebMetadata__contents_filename(pathname *P) {
	return Filenames__in(P, TL_IS_2515);
}

#line 673 "inweb/foundation-module/Chapter 8/Web Structure.w"
int WebMetadata__chapter_count(web_md *Wm) {
	int n = 0;
	chapter_md *Cm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, Wm->chapters_md) n++;
	return n;
}
int WebMetadata__section_count(web_md *Wm) {
	int n = 0;
	chapter_md *Cm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, Wm->chapters_md) {
		section_md *Sm;
		LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md) n++;
	}
	return n;
}

#line 20 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"

#line 29 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
int Bibliographic__datum_can_be_declared(web_md *Wm, text_stream *key) {
	web_bibliographic_datum *bd = Bibliographic__look_up_datum(Wm, key);
	if (bd == NULL) return FALSE;
	return bd->declaration_permitted;
}

int Bibliographic__datum_on_or_off(web_md *Wm, text_stream *key) {
	web_bibliographic_datum *bd = Bibliographic__look_up_datum(Wm, key);
	if (bd == NULL) return FALSE;
	return bd->on_or_off;
}

#line 45 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
void Bibliographic__initialise_data(web_md *Wm) {
	web_bibliographic_datum *bd;

	bd = Bibliographic__set_datum(Wm, TL_IS_2516, NULL); bd->declaration_mandatory = TRUE;
	bd = Bibliographic__set_datum(Wm, TL_IS_2517, NULL); bd->declaration_mandatory = TRUE;
	bd = Bibliographic__set_datum(Wm, TL_IS_2518, TL_IS_2519);
	bd = Bibliographic__set_datum(Wm, TL_IS_2520, TL_IS_2521);

	bd = Bibliographic__set_datum(Wm, TL_IS_2522, NULL);
	bd->alias = Bibliographic__set_datum(Wm, TL_IS_2523, NULL); /* alias US to UK spelling */

	Bibliographic__set_datum(Wm, TL_IS_2524, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2525, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2526, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2527, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2528, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2529, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2530, TL_IS_2531);
	Bibliographic__set_datum(Wm, TL_IS_2532, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2533, NULL);
	Bibliographic__set_datum(Wm, TL_IS_2534, NULL);

	bd = Bibliographic__set_datum(Wm, TL_IS_2535, TL_IS_2536); bd->on_or_off = TRUE;
	bd = Bibliographic__set_datum(Wm, TL_IS_2537, TL_IS_2538); bd->on_or_off = TRUE;
	bd = Bibliographic__set_datum(Wm, TL_IS_2539, TL_IS_2540); bd->on_or_off = TRUE;
	bd = Bibliographic__set_datum(Wm, TL_IS_2541, TL_IS_2542); bd->on_or_off = TRUE;
	bd = Bibliographic__set_datum(Wm, TL_IS_2543, TL_IS_2544);
	bd = Bibliographic__set_datum(Wm, TL_IS_2545, TL_IS_2546);
	bd = Bibliographic__set_datum(Wm, TL_IS_2547, TL_IS_2548);
	bd = Bibliographic__set_datum(Wm, TL_IS_2549, TL_IS_2550);
	bd = Bibliographic__set_datum(Wm, TL_IS_2551, TL_IS_2552);
	bd = Bibliographic__set_datum(Wm, TL_IS_2553, TL_IS_2554);
	bd = Bibliographic__set_datum(Wm, TL_IS_2555, TL_IS_2556);
	bd = Bibliographic__set_datum(Wm, TL_IS_2557, NULL);
	bd = Bibliographic__set_datum(Wm, TL_IS_2558, TL_IS_2559);
}

#line 86 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
void Bibliographic__check_required_data(web_md *Wm) {
	web_bibliographic_datum *bd;
	LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, Wm)
		if ((bd->declaration_mandatory) &&
			(Str__len(bd->value) == 0))
				Errors__fatal_with_text(
					"The web does not specify '%S: ...'", bd->key);
}

#line 99 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
text_stream *Bibliographic__get_datum(web_md *Wm, text_stream *key) {
	web_bibliographic_datum *bd = Bibliographic__look_up_datum(Wm, key);
	if (bd) return bd->value;
	return NULL;
}

int Bibliographic__data_exists(web_md *Wm, text_stream *key) {
	web_bibliographic_datum *bd = Bibliographic__look_up_datum(Wm, key);
	if ((bd) && (Str__len(bd->value) > 0)) return TRUE;
	return FALSE;
}

web_bibliographic_datum *Bibliographic__look_up_datum(web_md *Wm, text_stream *key) {
	web_bibliographic_datum *bd;
	LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, Wm)
		if (Str__eq(key, bd->key)) {
			if (bd->alias) return bd->alias;
			return bd;
		}
	return NULL;
}

#line 126 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
web_bibliographic_datum *Bibliographic__set_datum(web_md *Wm, text_stream *key, text_stream *val) {
	web_bibliographic_datum *bd = Bibliographic__look_up_datum(Wm, key);
	if (bd == NULL) 
{
#line 135 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
	bd = CREATE(web_bibliographic_datum);
	bd->key = Str__duplicate(key);
	bd->value = Str__duplicate(val);
	bd->declaration_mandatory = FALSE;
	bd->declaration_permitted = TRUE;
	bd->on_or_off = FALSE;
	bd->alias = NULL;
	ADD_TO_LINKED_LIST(bd, web_bibliographic_datum, Wm->bibliographic_data);

}
#line 128 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"

	else Str__copy(bd->value, val);
	if (Str__eq_wide_string(key, U"Title")) 
{
#line 150 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
	TEMPORARY_TEXT(recapped)
	Str__copy(recapped, val);
	LOOP_THROUGH_TEXT(P, recapped)
		Str__put(P, Characters__toupper(Str__get(P)));
	Bibliographic__set_datum(Wm, TL_IS_2560, recapped);
	DISCARD_TEXT(recapped)

}
#line 130 "inweb/foundation-module/Chapter 8/Bibliographic Data for Webs.w"
;
	return bd;
}

#line 29 "inweb/foundation-module/Chapter 8/Web Modules.w"

#line 31 "inweb/foundation-module/Chapter 8/Web Modules.w"
module *WebModules__new(text_stream *name, pathname *at, int m) {
	module *M = CREATE(module);
	M->module_location = at;
	M->module_name = Str__duplicate(name);
	M->dependencies = NEW_LINKED_LIST(module);
	M->origin_marker = m;
	M->module_tag = TL_IS_2561;
	M->chapters_md = NEW_LINKED_LIST(chapter_md);
	M->sections_md = NEW_LINKED_LIST(section_md);
	return M;
}

#line 52 "inweb/foundation-module/Chapter 8/Web Modules.w"
module *WebModules__create_main_module(web_md *WS) {
	return WebModules__new(TL_IS_2562, WS->path_to_web, READING_WEB_MOM);
}

#line 63 "inweb/foundation-module/Chapter 8/Web Modules.w"
void WebModules__dependency(module *A, module *B) {
	if ((A == NULL) || (B == NULL)) internal_error("no module");
	ADD_TO_LINKED_LIST(B, module, A->dependencies);
}

#line 77 "inweb/foundation-module/Chapter 8/Web Modules.w"

#line 79 "inweb/foundation-module/Chapter 8/Web Modules.w"
module_search *WebModules__make_search_path(pathname *ext_path) {
	module_search *ms = CREATE(module_search);
	ms->path_to_search = ext_path;
	return ms;
}

#line 89 "inweb/foundation-module/Chapter 8/Web Modules.w"
module *WebModules__find(web_md *WS, module_search *ms, text_stream *name, pathname *X) {
	TEMPORARY_TEXT(T)
	WRITE_TO(T, "%S-module", name);
	pathname *tries[4];
	tries[0] = WS?(WS->path_to_web):NULL;
	tries[1] = tries[0]?(Pathnames__up(tries[0])):NULL;
	tries[2] = X;
	tries[3] = ms->path_to_search;
	int N = 4;
	for (int i=0; i<N; i++) {
		pathname *P = Pathnames__from_text_relative(tries[i], T);
		if ((P) && (WebModules__exists(P))) 
{
#line 110 "inweb/foundation-module/Chapter 8/Web Modules.w"
	pathname *Q = Pathnames__from_text(name);
	module *M = WebModules__new(Pathnames__directory_name(Q), P, READING_WEB_MOM);
	WebModules__dependency(WS->as_module, M);
	return M;

}
#line 100 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	}
	DISCARD_TEXT(T)
	return NULL;
}

#line 119 "inweb/foundation-module/Chapter 8/Web Modules.w"
int WebModules__exists(pathname *P) {
	return WebMetadata__directory_looks_like_a_web(P);
}

#line 142 "inweb/foundation-module/Chapter 8/Web Modules.w"
int WebModules__named_reference(module **return_M, section_md **return_Sm,
	int *named_as_module, text_stream *title, module *from_M, text_stream *text,
	int list, int sections_only) {
	*return_M = NULL; *return_Sm = NULL; *named_as_module = FALSE;
	module *M;
	int finds = 0;
	if (from_M == NULL) return 0;
	match_results mr = Regexp__create_mr();
	text_stream *seek = text;
	text_stream *seek_module = NULL;
	if (Regexp__match(&mr, text, U"(%C+?): *(%c+?) *")) {
		seek_module = mr.exp[0]; seek = mr.exp[1];
	} else {
		seek_module = from_M->module_name; seek = text;
	}
	LOOP_OVER_LINKED_LIST(M, module, from_M->dependencies) {
		if (Str__eq_insensitive(M->module_name, seek_module)) {
			
{
#line 178 "inweb/foundation-module/Chapter 8/Web Modules.w"
	if (M == NULL) internal_error("no module");
	if (Str__eq_insensitive(M->module_name, seek))
		
{
#line 195 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = FIRST_IN_LINKED_LIST(section_md, M->sections_md);
		*named_as_module = TRUE;
		WRITE_TO(title, "the %S module", M->module_name);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Module '%S'\n", finds, M->module_name);

}
#line 180 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	chapter_md *Cm;
	section_md *Sm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, M->chapters_md) {
		if ((sections_only == FALSE) &&
			((Str__eq_insensitive(Cm->ch_title, seek)) ||
			(Str__eq_insensitive(Cm->ch_basic_title, seek)) ||
			(Str__eq_insensitive(Cm->ch_decorated_title, seek))))
			
{
#line 204 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = FIRST_IN_LINKED_LIST(section_md, Cm->sections_md);
		WRITE_TO(title, "%S", Cm->ch_title);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Chapter '%S' of module '%S'\n",
		finds, Cm->ch_title, M->module_name);

}
#line 188 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
		LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md)
			if (Str__eq_insensitive(Sm->sect_title, seek))
				
{
#line 213 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = Sm;
		WRITE_TO(title, "%S", Sm->sect_title);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Section '%S' in chapter '%S' of module '%S'\n",
		finds, Sm->sect_title, Cm->ch_title, M->module_name);

}
#line 191 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	}

}
#line 159 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
		}
	}
	Regexp__dispose_of(&mr);
	seek = text;
	for (int stage = 1; ((finds == 0) && (stage <= 2)); stage++) {
		if (stage == 1) {
			M = from_M;
			
{
#line 178 "inweb/foundation-module/Chapter 8/Web Modules.w"
	if (M == NULL) internal_error("no module");
	if (Str__eq_insensitive(M->module_name, seek))
		
{
#line 195 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = FIRST_IN_LINKED_LIST(section_md, M->sections_md);
		*named_as_module = TRUE;
		WRITE_TO(title, "the %S module", M->module_name);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Module '%S'\n", finds, M->module_name);

}
#line 180 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	chapter_md *Cm;
	section_md *Sm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, M->chapters_md) {
		if ((sections_only == FALSE) &&
			((Str__eq_insensitive(Cm->ch_title, seek)) ||
			(Str__eq_insensitive(Cm->ch_basic_title, seek)) ||
			(Str__eq_insensitive(Cm->ch_decorated_title, seek))))
			
{
#line 204 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = FIRST_IN_LINKED_LIST(section_md, Cm->sections_md);
		WRITE_TO(title, "%S", Cm->ch_title);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Chapter '%S' of module '%S'\n",
		finds, Cm->ch_title, M->module_name);

}
#line 188 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
		LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md)
			if (Str__eq_insensitive(Sm->sect_title, seek))
				
{
#line 213 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = Sm;
		WRITE_TO(title, "%S", Sm->sect_title);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Section '%S' in chapter '%S' of module '%S'\n",
		finds, Sm->sect_title, Cm->ch_title, M->module_name);

}
#line 191 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	}

}
#line 167 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
		}
		if (stage == 2) {
			LOOP_OVER_LINKED_LIST(M, module, from_M->dependencies)
				
{
#line 178 "inweb/foundation-module/Chapter 8/Web Modules.w"
	if (M == NULL) internal_error("no module");
	if (Str__eq_insensitive(M->module_name, seek))
		
{
#line 195 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = FIRST_IN_LINKED_LIST(section_md, M->sections_md);
		*named_as_module = TRUE;
		WRITE_TO(title, "the %S module", M->module_name);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Module '%S'\n", finds, M->module_name);

}
#line 180 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	chapter_md *Cm;
	section_md *Sm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, M->chapters_md) {
		if ((sections_only == FALSE) &&
			((Str__eq_insensitive(Cm->ch_title, seek)) ||
			(Str__eq_insensitive(Cm->ch_basic_title, seek)) ||
			(Str__eq_insensitive(Cm->ch_decorated_title, seek))))
			
{
#line 204 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = FIRST_IN_LINKED_LIST(section_md, Cm->sections_md);
		WRITE_TO(title, "%S", Cm->ch_title);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Chapter '%S' of module '%S'\n",
		finds, Cm->ch_title, M->module_name);

}
#line 188 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
		LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md)
			if (Str__eq_insensitive(Sm->sect_title, seek))
				
{
#line 213 "inweb/foundation-module/Chapter 8/Web Modules.w"
	finds++;
	if (finds == 1) {
		*return_M = M; *return_Sm = Sm;
		WRITE_TO(title, "%S", Sm->sect_title);
	}
	if (list) WRITE_TO(STDERR, "(%d)  Section '%S' in chapter '%S' of module '%S'\n",
		finds, Sm->sect_title, Cm->ch_title, M->module_name);

}
#line 191 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
	}

}
#line 171 "inweb/foundation-module/Chapter 8/Web Modules.w"
;
		}
	}
	return finds;
}

#line 10 "inweb/foundation-module/Chapter 8/Build Files.w"
filename *BuildFiles__build_file_for_web(web_md *WS) {
	filename *F = Filenames__in(WS->path_to_web, TL_IS_2563);
	if (TextFiles__exists(F)) return F;
	F = Filenames__in(NULL, TL_IS_2564);
	if (TextFiles__exists(F)) return F;
	return NULL;
}

#line 26 "inweb/foundation-module/Chapter 8/Build Files.w"

#line 30 "inweb/foundation-module/Chapter 8/Build Files.w"
build_file_data BuildFiles__read(filename *F) {
	build_file_data bfd;
	bfd.prerelease_text = Str__new();
	bfd.build_code = Str__new();
	bfd.build_date = Str__new();
	TextFiles__read(F, FALSE, "unable to read build file", TRUE,
		&BuildFiles__build_file_helper, NULL, (void *) &bfd);
	return bfd;
}

void BuildFiles__build_file_helper(text_stream *text, text_file_position *tfp, void *state) {
	build_file_data *bfd = (build_file_data *) state;
	if (Str__len(text) == 0) return;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, text, U"Build Date: *(%c*)")) {
		bfd->build_date = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, text, U"Build Number: *(%c*)")) {
		bfd->build_code = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, text, U"Prerelease: *(%c*)")) {
		bfd->prerelease_text = Str__duplicate(mr.exp[0]);
	} else {
		Errors__in_text_file("can't parse build file line", tfp);
	}
	Regexp__dispose_of(&mr);
}

#line 59 "inweb/foundation-module/Chapter 8/Build Files.w"
void BuildFiles__write(build_file_data bfd, filename *F) {
	text_stream vr_stream;
	text_stream *OUT = &vr_stream;
	if (Streams__open_to_file(OUT, F, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("can't write build file", F);
	if (Str__len(bfd.prerelease_text) > 0)
		WRITE("Prerelease: %S\n", bfd.prerelease_text);
	WRITE("Build Date: %S\n", bfd.build_date);
	if (Str__len(bfd.build_code) > 0)
		WRITE("Build Number: %S\n", bfd.build_code);
	Streams__close(OUT);
}

#line 77 "inweb/foundation-module/Chapter 8/Build Files.w"
void BuildFiles__set_bibliographic_data_for(web_md *WS) {
	filename *F = BuildFiles__build_file_for_web(WS);
	if (F) {
		build_file_data bfd = BuildFiles__read(F);
		if (Str__len(bfd.prerelease_text) > 0)
			Bibliographic__set_datum(WS, TL_IS_2565, bfd.prerelease_text);
		if (Str__len(bfd.build_code) > 0)
			Bibliographic__set_datum(WS, TL_IS_2566, bfd.build_code);
		if (Str__len(bfd.build_date) > 0)
			Bibliographic__set_datum(WS, TL_IS_2567, bfd.build_date);
	}
}

#line 99 "inweb/foundation-module/Chapter 8/Build Files.w"
void BuildFiles__deduce_semver(web_md *WS) {
	TEMPORARY_TEXT(combined)
	text_stream *s = Bibliographic__get_datum(WS, TL_IS_2568);
	if (Str__len(s) > 0) WRITE_TO(combined, "%S", s);
	else {
		text_stream *v = Bibliographic__get_datum(WS, TL_IS_2569);
		if (Str__len(v) > 0) WRITE_TO(combined, "%S", v);
		text_stream *p = Bibliographic__get_datum(WS, TL_IS_2570);
		if (Str__len(p) > 0) WRITE_TO(combined, "-%S", p);
		text_stream *b = Bibliographic__get_datum(WS, TL_IS_2571);
		if (Str__len(b) > 0) WRITE_TO(combined, "+%S", b);
	}
	if (Str__len(combined) > 0) {
		WS->version_number = VersionNumbers__from_text(combined);
		if (VersionNumbers__is_null(WS->version_number)) {
			Errors__fatal_with_text(
				"Combined version '%S' does not comply with the semver standard",
				combined);
		} else {
			Bibliographic__set_datum(WS, TL_IS_2572, combined);
		}
	}
	DISCARD_TEXT(combined)
}

#line 129 "inweb/foundation-module/Chapter 8/Build Files.w"
void BuildFiles__advance_for_web(web_md *WS) {
	filename *F = BuildFiles__build_file_for_web(WS);
	if (F) BuildFiles__advance(F);
	else Errors__fatal("web has no build file");
}

void BuildFiles__advance(filename *F) {
	build_file_data bfd = BuildFiles__read(F);
	if (BuildFiles__dated_today(bfd.build_date) == FALSE) {
		BuildFiles__increment(bfd.build_code);
		BuildFiles__write(bfd, F);
	}
}

#line 148 "inweb/foundation-module/Chapter 8/Build Files.w"
int BuildFiles__dated_today(text_stream *dateline) {
	char *monthname[12] = { "January", "February", "March", "April", "May", "June",
		"July", "August", "September", "October", "November", "December" };
	TEMPORARY_TEXT(today)
	WRITE_TO(today, "%d %s %d",
		the_present->tm_mday, monthname[the_present->tm_mon], the_present->tm_year+1900);
	int rv = TRUE;
	if (Str__ne(dateline, today)) {
		rv = FALSE;
		Str__clear(dateline);
		Str__copy(dateline, today);
	}
	DISCARD_TEXT(today)
	return rv;
}

#line 174 "inweb/foundation-module/Chapter 8/Build Files.w"
void BuildFiles__increment(text_stream *T) {
	if (Str__len(T) != 4) Errors__with_text("build code malformed: %S", T);
	else {
		inchar32_t N = Str__get_at(T, 0) - '0';
		inchar32_t L = Str__get_at(T, 1);
		inchar32_t M1 = Str__get_at(T, 2) - '0';
		inchar32_t M2 = Str__get_at(T, 3) - '0';
		if ((N > 9) || (L < 'A') || (L > 'Z') || (M1 > 9) || (M2 > 9)) {
			Errors__with_text("build code malformed: %S", T);
		} else {
			M2++;
			if (M2 == 10) { M2 = 0; M1++; }
			if (M1 == 10) { M1 = 0; M2 = 1; L++; }
			if ((L == 'I') || (L == 'O')) L++;
			if (L > 'Z') { L = 'A'; N++; }
			if (N == 10) Errors__with_text("build code overflowed: %S", T);
			else {
				Str__clear(T);
				WRITE_TO(T, "%d%c%d%d", N, L, M1, M2);
				PRINT("Build code advanced to %S\n", T);
			}
		}
	}
}

#line 32 "inweb/foundation-module/Chapter 8/Simple Tangler.w"

#line 34 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
simple_tangle_docket SimpleTangler__new_docket(
	void (*A)(struct text_stream *, struct simple_tangle_docket *),
	void (*B)(struct text_stream *, struct text_stream *,
		struct text_stream *, struct simple_tangle_docket *),
	void (*C)(struct text_stream *, struct simple_tangle_docket *),
	void (*D)(struct text_stream *, struct simple_tangle_docket *),
	void (*E)(char *, struct text_stream *),
	pathname *web_path, void *initial_state) {
	simple_tangle_docket docket;
	docket.raw_callback = A;
	docket.command_callback = B;
	docket.bplus_callback = C;
	docket.source_marker_callback = D;
	docket.error_callback = E;
	docket.state = initial_state;
	docket.web_path = web_path;
	docket.current_filename = NULL;
	docket.current_start_line = 0;
	return docket;
}

#line 60 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void SimpleTangler__tangle_text(simple_tangle_docket *docket, text_stream *text) {
	SimpleTangler__tangle_L1(docket, text, NULL, NULL, FALSE);
}

void SimpleTangler__tangle_file(simple_tangle_docket *docket, filename *F) {
	SimpleTangler__tangle_L1(docket, NULL, F, NULL, FALSE);
}

void SimpleTangler__tangle_section(simple_tangle_docket *docket, text_stream *leafname) {
	SimpleTangler__tangle_L1(docket, NULL, NULL, leafname, FALSE);
}

void SimpleTangler__tangle_web(simple_tangle_docket *docket) {
	SimpleTangler__tangle_L1(docket, NULL, NULL, NULL, TRUE);
}

#line 77 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void SimpleTangler__tangle_L1(simple_tangle_docket *docket, text_stream *text,
	filename *F, text_stream *leafname, int whole_web) {
	TEMPORARY_TEXT(T)
	SimpleTangler__tangle_L2(T, text, F, leafname, docket, whole_web);
	(*(docket->raw_callback))(T, docket);
	DISCARD_TEXT(T)
}

#line 88 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void SimpleTangler__tangle_L2(OUTPUT_STREAM, text_stream *text, filename *F,
	text_stream *leafname, simple_tangle_docket *docket, int whole_web) {
	if (whole_web) {
		web_md *Wm = WebMetadata__get(docket->web_path, NULL, V2_SYNTAX, NULL, FALSE, TRUE, NULL);
		chapter_md *Cm;
		LOOP_OVER_LINKED_LIST(Cm, chapter_md, Wm->chapters_md) {
			section_md *Sm;
			LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md) {
				filename *SF = Sm->source_file_for_section;
				SimpleTangler__tangle_L3(OUT, text, Sm->sect_title, docket, SF);
			}
		}
	} else {
		SimpleTangler__tangle_L3(OUT, text, leafname, docket, F);
	}
}

#line 109 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
void SimpleTangler__tangle_L3(OUTPUT_STREAM, text_stream *text,
	text_stream *leafname, simple_tangle_docket *docket, filename *F) {
	int comment = FALSE;
	FILE *Input_File = NULL;
	if ((Str__len(leafname) > 0) || (F)) {
		
{
#line 125 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (F) {
		docket->current_filename = F;
		Input_File = Filenames__fopen(F, "r");
	} else if (Str__len(leafname) > 0) {
		pathname *P = Pathnames__down(docket->web_path, TL_IS_2573);
		docket->current_filename = Filenames__in(P, leafname);
		Input_File = Filenames__fopen(docket->current_filename, "r");
	}
	if (Input_File == NULL)
		(*(docket->error_callback))("unable to open the file '%S'", leafname);

}
#line 114 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		comment = TRUE;
	}
	
{
#line 137 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	TEMPORARY_TEXT(command)
	TEMPORARY_TEXT(argument)
	int skip_part = FALSE, extract = FALSE;
	int col = 1, line_count = 1, sfp = 0, final_newline = FALSE;
  inchar32_t cr = 0, prev_cr = 0;
	do {
		Str__clear(command);
		Str__clear(argument);
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 145 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		NewCharacter: if (cr == (inchar32_t) EOF) break;
		if (((cr == '@') || (cr == '=')) && (col == 1)) {
			int inweb_syntax = -1;
			if (cr == '=') 
{
#line 240 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	TEMPORARY_TEXT(equals_cmd)
	while (TRUE) {
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 242 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		if ((cr == 10) || (cr == 13)) break;
		PUT_TO(equals_cmd, cr);
	}
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, equals_cmd, U" %(text%c*%) *")) {
		inweb_syntax = INWEB_EXTRACT_SYNTAX;
	} else if (Regexp__match(&mr, equals_cmd, U" %(figure%c*%) *")) {
		inweb_syntax = INWEB_FIGURE_SYNTAX;
	} else if (Regexp__match(&mr, equals_cmd, U" %(%c*%) *")) {
		(*(docket->error_callback))(
			"unsupported '= (...)' marker at column 0", NULL);
	} else {
		inweb_syntax = INWEB_EQUALS_SYNTAX;
	}
	Regexp__dispose_of(&mr);
	DISCARD_TEXT(equals_cmd)

}
#line 149 "inweb/foundation-module/Chapter 8/Simple Tangler.w"

			else 
{
#line 198 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	TEMPORARY_TEXT(at_cmd)
	int committed = FALSE, unacceptable_character = FALSE;
	while (TRUE) {
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 201 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		if ((committed == FALSE) && ((cr == 10) || (cr == 13) || (cr == ' '))) {
			if (Str__eq_wide_string(at_cmd, U""))
				inweb_syntax = INWEB_PARAGRAPH_SYNTAX;
			else if (Str__eq_wide_string(at_cmd, U"p"))
				inweb_syntax = INWEB_PARAGRAPH_SYNTAX;
			else if (Str__eq_wide_string(at_cmd, U"h"))
				inweb_syntax = INWEB_PARAGRAPH_SYNTAX;
			else if (Str__eq_wide_string(at_cmd, U"c"))
				inweb_syntax = INWEB_CODE_SYNTAX;
			else if (Str__get_first_char(at_cmd) == '-')
				inweb_syntax = INWEB_DASH_SYNTAX;
			else if (Str__begins_with_wide_string(at_cmd, U"Purpose:"))
				inweb_syntax = INWEB_PURPOSE_SYNTAX;
			committed = TRUE;
			if (inweb_syntax == -1) {
				if (unacceptable_character == FALSE) {
					PUT_TO(OUT, '@');
					WRITE_TO(OUT, "%S", at_cmd);
					PUT_TO(OUT, cr);
					break;
				} else {
					LOG("heading begins: <%S>\n", at_cmd);
					(*(docket->error_callback))(
						"unknown '@...' marker at column 0: '%S'", at_cmd);
				}
			}
		}
		if (!(((cr >= 'A') && (cr <= 'Z')) || ((cr >= 'a') && (cr <= 'z'))
			|| ((cr >= '0') && (cr <= '9'))
			|| (cr == '-') || (cr == '>') || (cr == ':') || (cr == '_')))
			unacceptable_character = TRUE;
		if ((cr == 10) || (cr == 13)) break;
		PUT_TO(at_cmd, cr);
	}
	Str__copy(command, at_cmd);
	DISCARD_TEXT(at_cmd)

}
#line 150 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
			
{
#line 261 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	switch (inweb_syntax) {
		case INWEB_PARAGRAPH_SYNTAX: {
			TEMPORARY_TEXT(heading_name)
			Str__copy_tail(heading_name, command, 2);
			inchar32_t c;
			while (((c = Str__get_last_char(heading_name)) != 0) &&
				((c == ' ') || (c == '\t') || (c == '.')))
				Str__delete_last_character(heading_name);
			if (Str__len(heading_name) == 0)
				(*(docket->error_callback))("Empty heading name", NULL);
			DISCARD_TEXT(heading_name)
			extract = FALSE;
			comment = TRUE; skip_part = FALSE;
			break;
		}
		case INWEB_CODE_SYNTAX:
			
{
#line 295 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	extract = FALSE;
	if (skip_part == FALSE) {
		comment = FALSE;
		docket->current_start_line = line_count;
		(*(docket->source_marker_callback))(OUT, docket);
	}

}
#line 277 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
			break;
		case INWEB_EQUALS_SYNTAX:
			if (extract) {
				comment = TRUE; extract = FALSE;
			} else {
				
{
#line 295 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	extract = FALSE;
	if (skip_part == FALSE) {
		comment = FALSE;
		docket->current_start_line = line_count;
		(*(docket->source_marker_callback))(OUT, docket);
	}

}
#line 283 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
			}
			break;
		case INWEB_EXTRACT_SYNTAX:
			comment = TRUE; extract = TRUE;
			break;
		case INWEB_DASH_SYNTAX: break;
		case INWEB_PURPOSE_SYNTAX: break;
		case INWEB_FIGURE_SYNTAX: break;
	}

}
#line 151 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
			continue;
		}
		if (comment == FALSE) 
{
#line 303 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (cr == '{') {
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 304 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		if ((cr == '-') && (docket->command_callback)) {
			
{
#line 332 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	Str__clear(command);
	Str__clear(argument);
	int com_mode = TRUE;
	while (TRUE) {
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 336 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		if ((cr == '}') || (cr == (inchar32_t) EOF)) break;
		if ((cr == ':') && (com_mode)) { com_mode = FALSE; continue; }
		if (com_mode) PUT_TO(command, cr);
		else PUT_TO(argument, cr);
	}

}
#line 306 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
			if (Str__get_first_char(command) == '!') continue;
			(*(docket->command_callback))(OUT, command, argument, docket);
			continue;
		} else { /* otherwise the open brace was a literal */
			PUT_TO(OUT, '{');
			goto NewCharacter;
		}
	}
	if ((cr == '(') && (docket->bplus_callback)) {
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 316 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		if (cr == '+') {
			
{
#line 347 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	TEMPORARY_TEXT(material)
	while (TRUE) {
		
{
#line 166 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
	if (Input_File) {
		if (final_newline) {
			cr = (inchar32_t) EOF;
		} else {
			cr = (inchar32_t) fgetc(Input_File);
			if ((cr == (inchar32_t) EOF) && (prev_cr != 10) && (prev_cr != 13)) {
				final_newline = TRUE; cr = '\n';
			}
		}
	} else if (text) {
		cr = Str__get_at(text, sfp); if (cr == 0) cr = (inchar32_t) EOF; else sfp++;
	} else cr = (inchar32_t) EOF;
	col++;
	if ((cr == 10) || (cr == 13)) {
		col = 0;
		if ((cr == 10) && (prev_cr != 13)) line_count++;
		if ((cr == 13) && (prev_cr != 10)) line_count++;
	}
	prev_cr = cr;

}
#line 349 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
		if (cr == (inchar32_t) EOF) break;
		if ((cr == ')') && (Str__get_last_char(material) == '+')) {
			Str__delete_last_character(material); break; }
		PUT_TO(material, cr);
	}
	(*(docket->bplus_callback))(material, docket);
	DISCARD_TEXT(material)

}
#line 318 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
			continue;
		} else { /* otherwise the open bracket was a literal */
			PUT_TO(OUT, '(');
			goto NewCharacter;
		}
	}
	PUT_TO(OUT, cr);

}
#line 154 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
	} while (cr != (inchar32_t) EOF);
	DISCARD_TEXT(command)
	DISCARD_TEXT(argument)

}
#line 117 "inweb/foundation-module/Chapter 8/Simple Tangler.w"
;
	if (Input_File) fclose(Input_File);
}

#line 10 "inweb/foundation-module/Chapter 9/Programming Languages.w"
pathname *default_programming_language_path = NULL;

void Languages__set_default_directory(pathname *P) {
	default_programming_language_path = P;
}

programming_language *Languages__find_by_name(text_stream *lname, pathname *P,
	int error_if_not_found) {
	programming_language *pl;
	
{
#line 28 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	LOOP_OVER(pl, programming_language)
		if (Str__eq(lname, pl->language_name))
			return pl;

}
#line 19 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	
{
#line 33 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	filename *F = NULL;
	if (P) 
{
#line 46 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	if (F == NULL) {
		TEMPORARY_TEXT(leaf)
		WRITE_TO(leaf, "%S.ildf", lname);
		F = Filenames__in(P, leaf);
		DISCARD_TEXT(leaf)
		if (TextFiles__exists(F) == FALSE) F = NULL;
	}

}
#line 34 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	P = default_programming_language_path;
	if (P) 
{
#line 46 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	if (F == NULL) {
		TEMPORARY_TEXT(leaf)
		WRITE_TO(leaf, "%S.ildf", lname);
		F = Filenames__in(P, leaf);
		DISCARD_TEXT(leaf)
		if (TextFiles__exists(F) == FALSE) F = NULL;
	}

}
#line 36 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	if (F == NULL) {
		if (error_if_not_found)
			Errors__fatal_with_text(
				"unsupported programming language '%S'", lname);
		return NULL;
	}
	pl = Languages__read_definition(F);

}
#line 20 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	if (Str__ne(pl->language_name, lname))
		Errors__fatal_with_text(
			"definition of programming language '%S' is for something else", lname);
	return pl;
}

#line 57 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void Languages__show(OUTPUT_STREAM) {
	WRITE("I can see the following programming language definitions:\n\n");
	int N = NUMBER_CREATED(programming_language);
	programming_language **sorted_table =
		Memory__calloc(N, (int) sizeof(programming_language *), ARRAY_SORTING_MREASON);
	int i=0; programming_language *pl;
	LOOP_OVER(pl, programming_language) sorted_table[i++] = pl;
	qsort(sorted_table, (size_t) N, sizeof(programming_language *), Languages__compare_names);

	for (int i=0; i<N; i++) {
		programming_language *pl = sorted_table[i];
		WRITE("%S: %S\n", pl->language_name, pl->language_details);
	}
	Memory__I7_free(sorted_table, ARRAY_SORTING_MREASON, N*((int) sizeof(programming_language *)));
}

#line 74 "inweb/foundation-module/Chapter 9/Programming Languages.w"
int Languages__compare_names(const void *ent1, const void *ent2) {
	text_stream *tx1 = (*((const programming_language **) ent1))->language_name;
	text_stream *tx2 = (*((const programming_language **) ent2))->language_name;
	return Str__cmp_insensitive(tx1, tx2);
}

#line 83 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void Languages__read_definitions(pathname *P) {
	if (P == NULL) P = default_programming_language_path;
	if (P == NULL) internal_error("no path for definitions");
	scan_directory *D = Directories__open(P);
	TEMPORARY_TEXT(leafname)
	while (Directories__next(D, leafname)) {
		if (Platform__is_folder_separator(Str__get_last_char(leafname)) == FALSE) {
			filename *F = Filenames__in(P, leafname);
			Languages__read_definition(F);
		}
	}
	DISCARD_TEXT(leafname)
	Directories__close(D);
}

#line 144 "inweb/foundation-module/Chapter 9/Programming Languages.w"

#line 156 "inweb/foundation-module/Chapter 9/Programming Languages.w"

programming_language *Languages__read_definition(filename *F) {
	programming_language *pl = CREATE(programming_language);
	
{
#line 170 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	pl->language_name = NULL;
	pl->file_extension = NULL;
	pl->supports_namespaces = FALSE;
	pl->line_comment = NULL;
	pl->whole_line_comment = NULL;
	pl->multiline_comment_open = NULL;
	pl->multiline_comment_close = NULL;
	pl->string_literal = NULL;
	pl->string_literal_escape = NULL;
	pl->character_literal = NULL;
	pl->character_literal_escape = NULL;
	pl->binary_literal_prefix = NULL;
	pl->octal_literal_prefix = NULL;
	pl->hexadecimal_literal_prefix = NULL;
	pl->negative_literal_prefix = NULL;
	pl->shebang = NULL;
	pl->line_marker = NULL;
	pl->before_macro_expansion = NULL;
	pl->after_macro_expansion = NULL;
	pl->start_definition = NULL;
	pl->prolong_definition = NULL;
	pl->end_definition = NULL;
	pl->start_ifdef = NULL;
	pl->end_ifdef = NULL;
	pl->start_ifndef = NULL;
	pl->end_ifndef = NULL;
	pl->C_like = FALSE;
	pl->suppress_disclaimer = FALSE;
	pl->type_notation[0] = 0;
	pl->function_notation[0] = 0;

	pl->reserved_words = NEW_LINKED_LIST(reserved_word);
	ReservedWords__initialise_hash_table(&(pl->built_in_keywords));
	pl->program = NULL;
	pl->methods = Methods__new_set();

}
#line 159 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	language_reader_state lrs;
	lrs.defining = pl;
	lrs.current_block = NULL;
	TextFiles__read(F, FALSE, "can't open programming language definition file",
		TRUE, Languages__read_definition_line, NULL, (void *) &lrs);
	
{
#line 215 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	#ifdef THIS_IS_INWEB
	if (pl->C_like) CLike__make_c_like(pl);
	if (Str__eq(pl->language_name, TL_IS_2574)) InCSupport__add_features(pl);
	ACMESupport__add_fallbacks(pl);
	#endif

}
#line 165 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	return pl;
}

#line 224 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void Languages__read_definition_line(text_stream *line, text_file_position *tfp, void *v_state) {
	language_reader_state *state = (language_reader_state *) v_state;
	programming_language *pl = state->defining;

	Str__trim_white_space(line); /* ignore trailing space */
	if (Str__len(line) == 0) return; /* ignore blank lines */
	if (Str__get_first_char(line) == '#') return; /* lines opening with |#| are comments */

	match_results mr = Regexp__create_mr();
	if (state->current_block) 
{
#line 325 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	if (Str__eq(line, TL_IS_2606)) {
		state->current_block = state->current_block->parent;
	} else if (Regexp__match(&mr, line, U"characters {")) {
		colouring_rule *rule = Languages__new_rule(state->current_block);
		rule->execute_block =
			Languages__new_block(state->current_block, CHARACTERS_CRULE_RUN);
		state->current_block = rule->execute_block;
	} else if (Regexp__match(&mr, line, U"characters in (%c+) {")) {
		colouring_rule *rule = Languages__new_rule(state->current_block);
		rule->execute_block =
			Languages__new_block(state->current_block, CHARACTERS_IN_CRULE_RUN);
		rule->execute_block->char_set = Languages__text(mr.exp[0], tfp, FALSE);
		state->current_block = rule->execute_block;
	} else if (Regexp__match(&mr, line, U"runs of (%c+) {")) {
		colouring_rule *rule = Languages__new_rule(state->current_block);
		inchar32_t r = UNQUOTED_COLOUR;
		if (Str__ne(mr.exp[0], TL_IS_2607)) r = Languages__colour(mr.exp[0], tfp);
		rule->execute_block = Languages__new_block(state->current_block, (int) r);
		state->current_block = rule->execute_block;
	} else if (Regexp__match(&mr, line, U"instances of (%c+) {")) {
		colouring_rule *rule = Languages__new_rule(state->current_block);
		rule->execute_block = Languages__new_block(state->current_block, INSTANCES_CRULE_RUN);
		rule->execute_block->run_instance = Languages__text(mr.exp[0], tfp, FALSE);
		state->current_block = rule->execute_block;
	} else if (Regexp__match(&mr, line, U"matches of (%c+) {")) {
		colouring_rule *rule = Languages__new_rule(state->current_block);
		rule->execute_block = Languages__new_block(state->current_block, MATCHES_CRULE_RUN);
		Languages__regexp(rule->execute_block->match_regexp_text, mr.exp[0], tfp);
		state->current_block = rule->execute_block;
	} else if (Regexp__match(&mr, line, U"brackets in (%c+) {")) {
		colouring_rule *rule = Languages__new_rule(state->current_block);
		rule->execute_block = Languages__new_block(state->current_block, BRACKETS_CRULE_RUN);
		Languages__regexp(rule->execute_block->match_regexp_text, mr.exp[0], tfp);
		state->current_block = rule->execute_block;
	} else {
		int at = -1, quoted = FALSE;
		for (int i=0; i<Str__len(line)-1; i++) {
			if (Str__get_at(line, i) == '"') quoted = quoted?FALSE:TRUE;
			if ((quoted) && (Str__get_at(line, i) == '\\')) i++;
			if ((quoted == FALSE) &&
				(Str__get_at(line, i) == '=') && (Str__get_at(line, i+1) == '>')) at = i;
		}
		if (at >= 0) {
			TEMPORARY_TEXT(premiss)
			TEMPORARY_TEXT(conclusion)
			Str__substr(premiss, Str__start(line), Str__at(line, at));
			Str__substr(conclusion, Str__at(line, at+2), Str__end(line));
			Languages__parse_rule(state, premiss, conclusion, tfp);
			DISCARD_TEXT(conclusion)
			DISCARD_TEXT(premiss)
		} else {
			Errors__in_text_file("line in colouring block illegible", tfp);
		}
	}

}
#line 233 "inweb/foundation-module/Chapter 9/Programming Languages.w"

	else 
{
#line 242 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	if (Regexp__match(&mr, line, U"colouring {")) {
		if (pl->program) Errors__in_text_file("duplicate colouring program", tfp);
		pl->program = Languages__new_block(NULL, WHOLE_LINE_CRULE_RUN);
		state->current_block = pl->program;
	} else if (Regexp__match(&mr, line, U"keyword (%C+) of (%c+?)")) {
		Languages__reserved(pl, Languages__text(mr.exp[0], tfp, FALSE), Languages__colour(mr.exp[1], tfp), tfp);
	} else if (Regexp__match(&mr, line, U"keyword (%C+)")) {
		Languages__reserved(pl, Languages__text(mr.exp[0], tfp, FALSE), RESERVED_COLOUR, tfp);
	} else if (Regexp__match(&mr, line, U"(%c+) *: *(%c+?)")) {
		text_stream *key = mr.exp[0], *value = Str__duplicate(mr.exp[1]);
		if (Str__eq(key, TL_IS_2575)) pl->language_name = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2576))
			pl->language_details = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2577))
			pl->file_extension = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2578))
			pl->line_comment = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2579))
			pl->whole_line_comment = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2580))
			pl->multiline_comment_open = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2581))
			pl->multiline_comment_close = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2582))
			pl->string_literal = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2583))
			pl->string_literal_escape = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2584))
			pl->character_literal = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2585))
			pl->character_literal_escape = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2586))
			pl->binary_literal_prefix = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2587))
			pl->octal_literal_prefix = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2588))
			pl->hexadecimal_literal_prefix = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2589))
			pl->negative_literal_prefix = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2590))
			pl->shebang = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2591))
			pl->line_marker = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2592))
			pl->before_macro_expansion = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2593))
			pl->after_macro_expansion = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2594))
			pl->start_definition = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2595))
			pl->prolong_definition = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2596))
			pl->end_definition = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2597))
			pl->start_ifdef = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2598))
			pl->start_ifndef = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2599))
			pl->end_ifdef = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2600))
			pl->end_ifndef = Languages__text(value, tfp, TRUE);
		else if (Str__eq(key, TL_IS_2601))
			pl->C_like = Languages__boolean(value, tfp);
		else if (Str__eq(key, TL_IS_2602))
			pl->suppress_disclaimer = Languages__boolean(value, tfp);
		else if (Str__eq(key, TL_IS_2603))
			pl->supports_namespaces = Languages__boolean(value, tfp);
		else if (Str__eq(key, TL_IS_2604))
			Languages__regexp(pl->function_notation, value, tfp);
		else if (Str__eq(key, TL_IS_2605))
			Languages__regexp(pl->type_notation, value, tfp);
		else {
			Errors__in_text_file("unknown property name before ':'", tfp);
		}
	} else {
		Errors__in_text_file("line in language definition illegible", tfp);
	}

}
#line 234 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	Regexp__dispose_of(&mr);
}

#line 404 "inweb/foundation-module/Chapter 9/Programming Languages.w"

#line 406 "inweb/foundation-module/Chapter 9/Programming Languages.w"
colouring_language_block *Languages__new_block(colouring_language_block *within, int r) {
	colouring_language_block *block = CREATE(colouring_language_block);
	block->rules = NEW_LINKED_LIST(colouring_rule);
	block->parent = within;
	block->run = r;
	block->run_instance = NULL;
	block->char_set = NULL;
	block->match_regexp_text[0] = 0;
	block->mr = Regexp__create_mr();
	return block;
}

#line 458 "inweb/foundation-module/Chapter 9/Programming Languages.w"

#line 460 "inweb/foundation-module/Chapter 9/Programming Languages.w"
colouring_rule *Languages__new_rule(colouring_language_block *within) {
	if (within == NULL) internal_error("rule outside block");
	colouring_rule *rule = CREATE(colouring_rule);
	ADD_TO_LINKED_LIST(rule, colouring_rule, within->rules);
	rule->sense = TRUE;
	rule->match_colour = NOT_A_COLOUR;
	rule->match_text = NULL;
	rule->match_prefix = NOT_A_RULE_PREFIX;
	rule->match_keyword_of_colour = NOT_A_COLOUR;
	rule->match_regexp_text[0] = 0;
	rule->number = 0;
	rule->number_of = 0;

	rule->set_to_colour = NOT_A_COLOUR;
	rule->set_prefix_to_colour = NOT_A_COLOUR;
	rule->execute_block = NULL;
	rule->debug = FALSE;

	rule->fix_position = 0;
	rule->mr = Regexp__create_mr();
	return rule;
}

#line 484 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void Languages__parse_rule(language_reader_state *state, text_stream *premiss,
	text_stream *action, text_file_position *tfp) {
	match_results mr = Regexp__create_mr();
	colouring_rule *rule = Languages__new_rule(state->current_block);
	Str__trim_white_space(premiss); Str__trim_white_space(action);
	
{
#line 495 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	while (Regexp__match(&mr, premiss, U"not (%c+)")) {
		rule->sense = (rule->sense)?FALSE:TRUE;
		Str__clear(premiss); Str__copy(premiss, mr.exp[0]);
	}
	if (Regexp__match(&mr, premiss, U"number (%d+)")) {
		rule->number = Str__atoi(mr.exp[0], 0);
	} else if (Regexp__match(&mr, premiss, U"number (%d+) of (%d+)")) {
		rule->number = Str__atoi(mr.exp[0], 0);
		rule->number_of = Str__atoi(mr.exp[1], 0);
	} else if (Regexp__match(&mr, premiss, U"keyword of (%c+)")) {
		rule->match_keyword_of_colour = Languages__colour(mr.exp[0], tfp);
	} else if (Regexp__match(&mr, premiss, U"keyword")) {
		Errors__in_text_file("ambiguous: make it keyword of !reserved or \"keyword\"", tfp);
	} else if (Regexp__match(&mr, premiss, U"prefix (%c+)")) {
		rule->match_prefix = UNSPACED_RULE_PREFIX;
		rule->match_text = Languages__text(mr.exp[0], tfp, FALSE);
	} else if (Regexp__match(&mr, premiss, U"matching (%c+)")) {
		Languages__regexp(rule->match_regexp_text, mr.exp[0], tfp);
	} else if (Regexp__match(&mr, premiss, U"spaced prefix (%c+)")) {
		rule->match_prefix = SPACED_RULE_PREFIX;
		rule->match_text = Languages__text(mr.exp[0], tfp, FALSE);
	} else if (Regexp__match(&mr, premiss, U"optionally spaced prefix (%c+)")) {
		rule->match_prefix = OPTIONALLY_SPACED_RULE_PREFIX;
		rule->match_text = Languages__text(mr.exp[0], tfp, FALSE);
	} else if (Regexp__match(&mr, premiss, U"suffix (%c+)")) {
		rule->match_prefix = UNSPACED_RULE_SUFFIX;
		rule->match_text = Languages__text(mr.exp[0], tfp, FALSE);
	} else if (Regexp__match(&mr, premiss, U"spaced suffix (%c+)")) {
		rule->match_prefix = SPACED_RULE_SUFFIX;
		rule->match_text = Languages__text(mr.exp[0], tfp, FALSE);
	} else if (Regexp__match(&mr, premiss, U"optionally spaced suffix (%c+)")) {
		rule->match_prefix = OPTIONALLY_SPACED_RULE_SUFFIX;
		rule->match_text = Languages__text(mr.exp[0], tfp, FALSE);
	} else if (Regexp__match(&mr, premiss, U"coloured (%c+)")) {
		rule->match_colour = Languages__colour(mr.exp[0], tfp);
	} else if (Str__len(premiss) > 0) {
		rule->match_text = Languages__text(premiss, tfp, FALSE);
	}

}
#line 489 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	
{
#line 535 "inweb/foundation-module/Chapter 9/Programming Languages.w"
	if (Str__eq(action, TL_IS_2608)) {
		rule->execute_block =
			Languages__new_block(state->current_block, WHOLE_LINE_CRULE_RUN);
		state->current_block = rule->execute_block;
	} else if (Regexp__match(&mr, action, U"(!%c+) on prefix")) {
		rule->set_prefix_to_colour = Languages__colour(mr.exp[0], tfp);
	} else if (Regexp__match(&mr, action, U"(!%c+) on suffix")) {
		rule->set_prefix_to_colour = Languages__colour(mr.exp[0], tfp);
	} else if (Regexp__match(&mr, action, U"(!%c+) on both")) {
		rule->set_to_colour = Languages__colour(mr.exp[0], tfp);
		rule->set_prefix_to_colour = rule->set_to_colour;
	} else if (Str__get_first_char(action) == '!') {
		rule->set_to_colour = Languages__colour(action, tfp);
	} else if (Str__eq(action, TL_IS_2609)) {
		rule->debug = TRUE;
	} else {
		Errors__in_text_file("action after '=>' illegible", tfp);
	}

}
#line 490 "inweb/foundation-module/Chapter 9/Programming Languages.w"
;
	Regexp__dispose_of(&mr);
}

#line 563 "inweb/foundation-module/Chapter 9/Programming Languages.w"

reserved_word *Languages__reserved(programming_language *pl, text_stream *W, inchar32_t C,
	text_file_position *tfp) {
	reserved_word *rw;
	LOOP_OVER_LINKED_LIST(rw, reserved_word, pl->reserved_words)
		if (Str__eq(rw->word, W)) {
			Errors__in_text_file("duplicate reserved word", tfp);
		}
	rw = CREATE(reserved_word);
	rw->word = Str__duplicate(W);
	rw->colour = (int) C;
	ADD_TO_LINKED_LIST(rw, reserved_word, pl->reserved_words);
	ReservedWords__mark_reserved_word(&(pl->built_in_keywords), rw->word, (int) C);
	return rw;
}

#line 601 "inweb/foundation-module/Chapter 9/Programming Languages.w"
inchar32_t Languages__colour(text_stream *T, text_file_position *tfp) {
	if (Str__get_first_char(T) != '!') {
		Errors__in_text_file("colour names must begin with !", tfp);
		return PLAIN_COLOUR;
	}
	if (Str__eq(T, TL_IS_2610)) return STRING_COLOUR;
	else if (Str__eq(T, TL_IS_2611)) return FUNCTION_COLOUR;
	else if (Str__eq(T, TL_IS_2612)) return DEFINITION_COLOUR;
	else if (Str__eq(T, TL_IS_2613)) return RESERVED_COLOUR;
	else if (Str__eq(T, TL_IS_2614)) return ELEMENT_COLOUR;
	else if (Str__eq(T, TL_IS_2615)) return IDENTIFIER_COLOUR;
	else if (Str__eq(T, TL_IS_2616)) return CHARACTER_COLOUR;
	else if (Str__eq(T, TL_IS_2617)) return CONSTANT_COLOUR;
	else if (Str__eq(T, TL_IS_2618)) return PLAIN_COLOUR;
	else if (Str__eq(T, TL_IS_2619)) return EXTRACT_COLOUR;
	else if (Str__eq(T, TL_IS_2620)) return COMMENT_COLOUR;
	else {
		Errors__in_text_file("no such !colour", tfp);
		return PLAIN_COLOUR;
	}
}

#line 626 "inweb/foundation-module/Chapter 9/Programming Languages.w"
int Languages__boolean(text_stream *T, text_file_position *tfp) {
	if (Str__eq(T, TL_IS_2621)) return TRUE;
	else if (Str__eq(T, TL_IS_2622)) return FALSE;
	else {
		Errors__in_text_file("must be true or false", tfp);
		return FALSE;
	}
}

#line 640 "inweb/foundation-module/Chapter 9/Programming Languages.w"
text_stream *Languages__text(text_stream *T, text_file_position *tfp, int allow) {
	text_stream *V = Str__new();
	if (Str__len(T) > 0) {
		int bareword = TRUE, spaced = FALSE, from = 0, to = Str__len(T)-1;
		if ((to > from) &&
			(Str__get_at(T, from) == '"') && (Str__get_at(T, to) == '"')) {
			bareword = FALSE; from++; to--;
		}
		for (int i=from; i<=to; i++) {
			inchar32_t c = Str__get_at(T, i);
			if (c == ' ') spaced = TRUE;
			if ((c == '\\') && (Str__get_at(T, i+1) == 'n')) {
				PUT_TO(V, '\n');
				i++;
			} else if ((c == '\\') && (Str__get_at(T, i+1) == 's')) {
				PUT_TO(V, ' ');
				i++;
			} else if ((c == '\\') && (Str__get_at(T, i+1) == 't')) {
				PUT_TO(V, '\t');
				i++;
			} else if ((c == '\\') && (Str__get_at(T, i+1) == '\\')) {
				PUT_TO(V, '\\');
				i++;
			} else if ((bareword == FALSE) && (c == '\\') && (Str__get_at(T, i+1) == '"')) {
				PUT_TO(V, '"');
				i++;
			} else if ((bareword == FALSE) && (c == '"')) {
				Errors__in_text_file(
					"backslash needed before internal double-quotation mark", tfp);
			} else if ((bareword) && (c == '!') && (i == from)) {
				Errors__in_text_file(
					"a literal starting with ! must be in double-quotation marks", tfp);
			} else if ((bareword) && (c == '/')) {
				Errors__in_text_file(
					"forward slashes can only be used in quoted strings", tfp);
			} else if ((bareword) && (c == '"')) {
				Errors__in_text_file(
					"double-quotation marks can only be used in quoted strings", tfp);
			} else {
				PUT_TO(V, c);
			}
		}
		if ((bareword) && (spaced) && (allow == FALSE)) {
			TEMPORARY_TEXT(err)
			WRITE_TO(err, "'%S' seems to be literal text, but if so it needs double-quotation marks", T);
			Errors__in_text_file_S(err, tfp);
			DISCARD_TEXT(err)
		}
		if (bareword) {
			int rw = FALSE;
			if (Str__eq(V, TL_IS_2623)) rw = TRUE;
			if (Str__eq(V, TL_IS_2624)) rw = TRUE;
			if (Str__eq(V, TL_IS_2625)) rw = TRUE;
			if (Str__eq(V, TL_IS_2626)) rw = TRUE;
			if (Str__eq(V, TL_IS_2627)) rw = TRUE;
			if (Str__eq(V, TL_IS_2628)) rw = TRUE;
			if (Str__eq(V, TL_IS_2629)) rw = TRUE;
			if (Str__eq(V, TL_IS_2630)) rw = TRUE;
			if (Str__eq(V, TL_IS_2631)) rw = TRUE;
			if (Str__eq(V, TL_IS_2632)) rw = TRUE;
			if (Str__eq(V, TL_IS_2633)) rw = TRUE;
			if (Str__eq(V, TL_IS_2634)) rw = TRUE;
			if (Str__eq(V, TL_IS_2635)) rw = TRUE;
			if (Str__eq(V, TL_IS_2636)) rw = TRUE;
			if (Str__eq(V, TL_IS_2637)) rw = TRUE;
			if (Str__eq(V, TL_IS_2638)) rw = TRUE;
			if (Str__eq(V, TL_IS_2639)) rw = TRUE;
			if (Str__eq(V, TL_IS_2640)) rw = TRUE;
			if (Str__eq(V, TL_IS_2641)) rw = TRUE;
			if (Str__eq(V, TL_IS_2642)) rw = TRUE;
			if (Str__eq(V, TL_IS_2643)) rw = TRUE;
			if (Str__eq(V, TL_IS_2644)) rw = TRUE;

			if (rw) {
				TEMPORARY_TEXT(err)
				WRITE_TO(err, "'%S' is a reserved word, so you should put it in double-quotation marks", V);
				Errors__in_text_file_S(err, tfp);
				DISCARD_TEXT(err)
			}
		}
	}
	return V;
}

#line 727 "inweb/foundation-module/Chapter 9/Programming Languages.w"
void Languages__regexp(inchar32_t *write_to, text_stream *T, text_file_position *tfp) {
	if (write_to == NULL) internal_error("no buffer");
	write_to[0] = 0;
	if (Str__len(T) > 0) {
		int from = 0, to = Str__len(T)-1, x = 0;
		if ((to > from) &&
			(Str__get_at(T, from) == '/') && (Str__get_at(T, to) == '/')) {
			from++; to--;
			for (int i=from; i<=to; i++) {
				inchar32_t c = Str__get_at(T, i);
				if (c == '\\') {
					inchar32_t w = Str__get_at(T, i+1);
					if (w == '\\') {
						x = Languages__add_to_regexp(write_to, x, w);
					} else if (w == 'd') {
						x = Languages__add_escape_to_regexp(write_to, x, 'd');
					} else if (w == 't') {
						x = Languages__add_escape_to_regexp(write_to, x, 't');
					} else if (w == 's') {
						x = Languages__add_to_regexp(write_to, x, ' ');
					} else if (w == 'S') {
						x = Languages__add_escape_to_regexp(write_to, x, 'C');
					} else if (w == '"') {
						x = Languages__add_escape_to_regexp(write_to, x, 'q');
					} else {
						x = Languages__add_escape_to_regexp(write_to, x, w);
					}
					i++;
					continue;
				}
				if (c == '.') {
					x = Languages__add_escape_to_regexp(write_to, x, 'c');
					continue;
				}
				if (c == '%') {
					x = Languages__add_escape_to_regexp(write_to, x, '%');
					continue;
				}
				x = Languages__add_to_regexp(write_to, x, c);
			}
		} else {
			Errors__in_text_file(
				"the expression to match must be in slashes '/'", tfp);
		}
		if (x >= MAX_ILDF_REGEXP_LENGTH)
			Errors__in_text_file(
				"the expression to match is too long", tfp);
	}
}

int Languages__add_to_regexp(inchar32_t *write_to, int i, inchar32_t c) {
	if (i < MAX_ILDF_REGEXP_LENGTH) write_to[i++] = c;
	return i;
}

int Languages__add_escape_to_regexp(inchar32_t *write_to, int i, inchar32_t c) {
	i = Languages__add_to_regexp(write_to, i, '%');
	i = Languages__add_to_regexp(write_to, i, c);
	return i;
}

#line 17 "inweb/foundation-module/Chapter 9/Reserved Words.w"
int ReservedWords__hash_code_from_word(text_stream *text) {
    unsigned int hash_code = 0;
    string_position p = Str__start(text);
    switch(Str__get(p)) {
    	case '-': if (Str__len(text) == 1) break; /* an isolated minus sign is an ordinary word */
    		/* and otherwise fall through to... */
    	case '0': case '1': case '2': case '3': case '4':
    	case '5': case '6': case '7': case '8': case '9': {
    		int numeric = TRUE;
    		/* the first character may prove to be the start of a number: is this true? */
			for (p = Str__forward(p); Str__in_range(p); p = Str__forward(p))
				if (Characters__isdigit(Str__get(p)) == FALSE) numeric = FALSE;
			if (numeric) return NUMBER_HASH;
		}
    }
    for (p=Str__start(text); Str__in_range(p); p = Str__forward(p))
       hash_code = (hash_code*30011) + Str__get(p);
    return (int) (1+(hash_code % (HASH_TAB_SIZE-1))); /* result of X 30011, plus 1 */
}

#line 46 "inweb/foundation-module/Chapter 9/Reserved Words.w"

void ReservedWords__initialise_hash_table(hash_table *HT) {
	HT->safety_code = HASH_SAFETY_CODE;
	for (int i=0; i<HASH_TAB_SIZE; i++) HT->analysis_hash[i] = NULL;
}

#line 63 "inweb/foundation-module/Chapter 9/Reserved Words.w"

#line 70 "inweb/foundation-module/Chapter 9/Reserved Words.w"
hash_table_entry *ReservedWords__find_hash_entry(hash_table *HT, text_stream *text, int create) {
	int h = ReservedWords__hash_code_from_word(text);
	if (h == NUMBER_HASH) return NULL;
	if (HT == NULL) return NULL;
	if ((h<0) || (h>=HASH_TAB_SIZE)) internal_error("hash code out of range");
	if (HT->safety_code != HASH_SAFETY_CODE) internal_error("uninitialised HT");
	if (HT->analysis_hash[h] != NULL) {
		hash_table_entry *hte = NULL;
		LOOP_OVER_LINKED_LIST(hte, hash_table_entry, HT->analysis_hash[h]) {
			if (Str__eq(hte->hash_key, text))
				return hte;
		}
	}
	if (create) {
		hash_table_entry *hte = CREATE(hash_table_entry);
		hte->language_reserved_word = 0;
		hte->hash_key = Str__duplicate(text);
		hte->usages = NEW_LINKED_LIST(hash_table_entry_usage);
		hte->definition_line = NULL;
		hte->as_function = NULL;
		if (HT->analysis_hash[h] == NULL)
			HT->analysis_hash[h] = NEW_LINKED_LIST(hash_table_entry);
		ADD_TO_LINKED_LIST(hte, hash_table_entry, HT->analysis_hash[h]);
		return hte;
	}
	return NULL;
}

#line 101 "inweb/foundation-module/Chapter 9/Reserved Words.w"
hash_table_entry *ReservedWords__mark_reserved_word(hash_table *HT, text_stream *p, int e) {
	hash_table_entry *hte = ReservedWords__find_hash_entry(HT, p, TRUE);
	hte->language_reserved_word |= (1 << (e % 32));
	hte->definition_line = NULL;
	hte->as_function = NULL;
	return hte;
}

int ReservedWords__is_reserved_word(hash_table *HT, text_stream *p, int e) {
	hash_table_entry *hte = ReservedWords__find_hash_entry(HT, p, FALSE);
	if ((hte) && (hte->language_reserved_word & (1 << (e % 32)))) return TRUE;
	return FALSE;
}

#line 16 "inweb/foundation-module/Chapter 9/The Painter.w"
int colouring_state = PLAIN_COLOUR;
int painter_count = 1;
void Painter__reset_syntax_colouring(programming_language *pl) {
	colouring_state = PLAIN_COLOUR;
	painter_count = 1;
}

#line 39 "inweb/foundation-module/Chapter 9/The Painter.w"
int Painter__syntax_colour(programming_language *pl,
	hash_table *HT, text_stream *matter, text_stream *colouring, int with_comments) {
	int from = 0, to = Str__len(matter) - 1;
	if (with_comments) {
		TEMPORARY_TEXT(part_before_comment)
		TEMPORARY_TEXT(part_within_comment)
		int found = FALSE;
		#ifdef THIS_IS_INWEB
		found = LanguageMethods__parse_comment(pl,
			matter, part_before_comment, part_within_comment);
		#endif
		#ifndef THIS_IS_INWEB
		found = Painter__parse_comment(pl,
			matter, part_before_comment, part_within_comment);
		#endif
		if (found) {
			int N = Str__len(matter);
			for (int i=Str__len(part_before_comment); i<N; i++)
				Str__put_at(colouring, i, COMMENT_COLOUR);
			from = 0; to = Str__len(part_before_comment);
		}
		DISCARD_TEXT(part_before_comment)
		DISCARD_TEXT(part_within_comment)
	}
	Painter__syntax_colour_inner(pl, HT, matter, colouring, from, to);
	return FALSE;
}

void Painter__syntax_colour_inner(programming_language *pl,
	hash_table *HT, text_stream *matter, text_stream *colouring, int from, int to) {
	
{
#line 75 "inweb/foundation-module/Chapter 9/The Painter.w"
	inchar32_t squote = Str__get_first_char(pl->character_literal);
	inchar32_t squote_escape = Str__get_first_char(pl->character_literal_escape);
	inchar32_t dquote = Str__get_first_char(pl->string_literal);
	inchar32_t dquote_escape = Str__get_first_char(pl->string_literal_escape);
	for (int i=from; i <= to; i++) {
		inchar32_t skip = NOT_A_COLOUR;
		int one_off = -1, will_be = -1, glob = 1;
		switch (colouring_state) {
			case PLAIN_COLOUR: {
				inchar32_t c = Str__get_at(matter, i);
				if (c == dquote) {
					colouring_state = STRING_COLOUR;
					break;
				}
				if (c == squote) {
					colouring_state = CHARACTER_COLOUR;
					break;
				}
				if (Str__includes_at(matter, i, pl->multiline_comment_open)) {
					one_off = COMMENT_COLOUR; will_be = COMMENT_COLOUR;
					glob = Str__len(pl->multiline_comment_open);
				} else if (Str__includes_at(matter, i, pl->line_comment)) {
					one_off = COMMENT_COLOUR; will_be = PLAIN_COLOUR;
					glob = Str__len(matter) - i;
				} else if (Painter__identifier_at(pl, matter, colouring, i)) {
					one_off = IDENTIFIER_COLOUR;
				}
				break;
			}
			case COMMENT_COLOUR:
				if (Str__includes_at(matter, i, pl->multiline_comment_close)) {
					one_off = COMMENT_COLOUR; will_be = PLAIN_COLOUR;
					glob = Str__len(pl->multiline_comment_close);
				}
				break;
			case CHARACTER_COLOUR: {
				inchar32_t c = Str__get_at(matter, i);
				if (c == squote) will_be = PLAIN_COLOUR;
				if (c == squote_escape) skip = CHARACTER_COLOUR;
				break;
			}
			case STRING_COLOUR: {
				inchar32_t c = Str__get_at(matter, i);
				if (c == dquote) will_be = PLAIN_COLOUR;
				if (c == dquote_escape) skip = STRING_COLOUR;
				break;
			}
		}
		for (int j=0; j<glob; j++) {
			if (one_off >= 0) Str__put_at(colouring, i+j, (inchar32_t) one_off);
			else Str__put_at(colouring, i+j, (inchar32_t) colouring_state);
		}
		i += glob - 1;
		if (will_be >= 0) colouring_state = will_be;
		if ((skip != NOT_A_COLOUR) && (i<to)) {
			i++; Str__put_at(colouring, i, skip);
		}
	}

}
#line 69 "inweb/foundation-module/Chapter 9/The Painter.w"
;
	
{
#line 135 "inweb/foundation-module/Chapter 9/The Painter.w"
	int base = -1, dec_possible = TRUE;
	for (int i=from; i <= to; i++) {
		if ((Str__get_at(colouring, i) == PLAIN_COLOUR) ||
			(Str__get_at(colouring, i) == IDENTIFIER_COLOUR)) {
			inchar32_t c = Str__get_at(matter, i);
			if (Str__includes_at(matter, i, pl->binary_literal_prefix)) {
				base = 2;
				for (int j=0; j<Str__len(pl->binary_literal_prefix); j++)
					Str__put_at(colouring, i+j, (char) CONSTANT_COLOUR);
				dec_possible = TRUE;
				continue;
			} else if (Str__includes_at(matter, i, pl->octal_literal_prefix)) {
				base = 8;
				for (int j=0; j<Str__len(pl->octal_literal_prefix); j++)
					Str__put_at(colouring, i+j, (char) CONSTANT_COLOUR);
				dec_possible = TRUE;
				continue;
			} else if (Str__includes_at(matter, i, pl->hexadecimal_literal_prefix)) {
				base = 16;
				for (int j=0; j<Str__len(pl->hexadecimal_literal_prefix); j++)
					Str__put_at(colouring, i+j, (char) CONSTANT_COLOUR);
				dec_possible = TRUE;
				continue;
			}
			if ((Str__includes_at(matter, i, pl->negative_literal_prefix)) &&
				(dec_possible) && (base == 0)) {
				base = 10;
				Str__put_at(colouring, i, (char) CONSTANT_COLOUR);
				continue;
			}
			int pass = FALSE;
			switch (base) {
				case -1:
					if ((dec_possible) && (Characters__isdigit(c))) {
						base = 10; pass = TRUE;
					}
					break;
				case 2: if ((c == '0') || (c == '1')) pass = TRUE; break;
				case 10: if (Characters__isdigit(c)) pass = TRUE; break;
				case 16: if (Characters__isdigit(c)) pass = TRUE;
					inchar32_t d = Characters__tolower(c);
					if ((d == 'a') || (d == 'b') || (d == 'c') ||
						(d == 'd') || (d == 'e') || (d == 'f')) pass = TRUE;
					break;
			}
			if (pass) {
				Str__put_at(colouring, i, (char) CONSTANT_COLOUR);
			} else {
				if (Characters__is_whitespace(c)) dec_possible = TRUE;
				else dec_possible = FALSE;
				base = -1;
			}
		}
	}

}
#line 70 "inweb/foundation-module/Chapter 9/The Painter.w"
;
	
{
#line 220 "inweb/foundation-module/Chapter 9/The Painter.w"
	if (pl->program)
		Painter__execute(HT, pl->program, matter, colouring, from, to, painter_count++);

}
#line 71 "inweb/foundation-module/Chapter 9/The Painter.w"
;
}

#line 196 "inweb/foundation-module/Chapter 9/The Painter.w"
int Painter__identifier_at(programming_language *pl,
	text_stream *matter, text_stream *colouring, int i) {
	inchar32_t c = Str__get_at(matter, i);
	if ((i > 0) && (Str__get_at(colouring, i-1) == IDENTIFIER_COLOUR)) {
		if ((c == '_') ||
			((c >= 'A') && (c <= 'Z')) ||
			((c >= 'a') && (c <= 'z')) ||
			((c >= '0') && (c <= '9'))) return TRUE;
		if ((c == ':') && (pl->supports_namespaces)) return TRUE;
	} else {
		inchar32_t d = 0;
		if (i > 0) d = Str__get_at(matter, i);
		if ((d >= '0') && (d <= '9')) return FALSE;
		if ((c == '_') ||
			((c >= 'A') && (c <= 'Z')) ||
			((c >= 'a') && (c <= 'z'))) return TRUE;
	}
	return FALSE;
}

#line 229 "inweb/foundation-module/Chapter 9/The Painter.w"
void Painter__execute(hash_table *HT, colouring_language_block *block, text_stream *matter,
	text_stream *colouring, int from, int to, int N) {
	if (block == NULL) internal_error("no block");
	TEMPORARY_TEXT(colouring_at_start)
	Str__copy(colouring_at_start, colouring);
	colouring_rule *rule;
	LOOP_OVER_LINKED_LIST(rule, colouring_rule, block->rules) {
		switch (block->run) {
			case WHOLE_LINE_CRULE_RUN:
				Painter__execute_rule(HT, rule, matter, colouring, from, to,
					(N == 0)?1:N);
				break;
			case CHARACTERS_CRULE_RUN:
				for (int i=from; i<=to; i++)
					Painter__execute_rule(HT, rule, matter, colouring, i, i, i-from+1);
				break;
			case CHARACTERS_IN_CRULE_RUN:
				for (int count=1, i=from; i<=to; i++)
					for (int j=0; j<Str__len(block->char_set); j++)
						if (Str__get_at(matter, i) == Str__get_at(block->char_set, j) ) {
							Painter__execute_rule(HT, rule, matter, colouring, i, i, count++);
							break;
						}
				break;
			case INSTANCES_CRULE_RUN: {
				int L = Str__len(block->run_instance) - 1;
				if (L >= 0)
					for (int count=1, i=from; i<=to - L; i++)
						if (Str__includes_at(matter, i, block->run_instance)) {
							Painter__execute_rule(HT, rule, matter, colouring, i, i+L, count++);
							i += L;
						}
				break;
			}
			case MATCHES_CRULE_RUN:
				for (int count=1, i=from; i<=to; i++) {
					int L = Regexp__match_from(&(block->mr), matter, block->match_regexp_text, i, TRUE);
					if (L > 0) {
						Painter__execute_rule(HT, rule, matter, colouring, i, i+L-1, count++);
						i += L-1;
					}
				}
				break;
			case BRACKETS_CRULE_RUN:
				for (int i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++)
					if (block->mr.exp[i])
						Str__clear(block->mr.exp[i]);
				if (Regexp__match(&(block->mr), matter, block->match_regexp_text))
					for (int count=1, i=0; i<MAX_BRACKETED_SUBEXPRESSIONS; i++)
						if (block->mr.exp_at[i] >= 0)
							Painter__execute_rule(HT, rule, matter, colouring,
								block->mr.exp_at[i],
								block->mr.exp_at[i] + Str__len(block->mr.exp[i])-1,
								count++);
				break;
			default: {
				int ident_from = -1, count = 1;
				for (int i=from; i<=to; i++) {
					int col = (int) Str__get_at(colouring_at_start, i);
					if ((col == block->run) ||
						((block->run == UNQUOTED_COLOUR) &&
							((col != STRING_COLOUR) && (col != CHARACTER_COLOUR)))) {
						if (ident_from == -1) ident_from = i;
					} else {
						if (ident_from >= 0)
							Painter__execute_rule(HT, rule, matter, colouring, ident_from, i-1, count++);
						ident_from = -1;
					}
				}
				if (ident_from >= 0)
					Painter__execute_rule(HT, rule, matter, colouring, ident_from, to, count++);
				break;
			}
		}
	}
	DISCARD_TEXT(colouring_at_start)
}

#line 310 "inweb/foundation-module/Chapter 9/The Painter.w"
void Painter__execute_rule(hash_table *HT, colouring_rule *rule, text_stream *matter,
	text_stream *colouring, int from, int to, int N) {
	if (Painter__satisfies(HT, rule, matter, colouring, from, to, N) == rule->sense)
		Painter__follow(HT, rule, matter, colouring, from, to);
}

#line 326 "inweb/foundation-module/Chapter 9/The Painter.w"
int Painter__satisfies(hash_table *HT, colouring_rule *rule, text_stream *matter,
	text_stream *colouring, int from, int to, int N) {
	if (rule->number > 0) {
		if (rule->number_of > 0) {
			if (rule->number != ((N-1)%(rule->number_of)) + 1) return FALSE;
		} else {
			if (rule->number != N) return FALSE;
		}
	} else if (rule->match_regexp_text[0]) {
		TEMPORARY_TEXT(T)
		for (int j=from; j<=to; j++) PUT_TO(T, Str__get_at(matter, j));
		int rv = Regexp__match(&(rule->mr), T, rule->match_regexp_text);
		DISCARD_TEXT(T)
		if (rv == FALSE) return FALSE;
	} else if (Str__len(rule->match_text) > 0) {
		if ((rule->match_prefix == UNSPACED_RULE_PREFIX) ||
			(rule->match_prefix == SPACED_RULE_PREFIX) ||
			(rule->match_prefix == OPTIONALLY_SPACED_RULE_PREFIX)) {
			int pos = from;
			if (rule->match_prefix != UNSPACED_RULE_PREFIX) {
				while ((pos > 0) && (Characters__is_whitespace(pos-1))) pos--;
				if ((rule->match_prefix == SPACED_RULE_PREFIX) && (pos == from))
					return FALSE;
			}
			if (Str__includes_at(matter,
				pos-Str__len(rule->match_text), rule->match_text) == FALSE)
				return FALSE;
			rule->fix_position = pos-Str__len(rule->match_text);
		} else if ((rule->match_prefix == UNSPACED_RULE_SUFFIX) ||
			(rule->match_prefix == SPACED_RULE_SUFFIX) ||
			(rule->match_prefix == OPTIONALLY_SPACED_RULE_SUFFIX)) {
			int pos = to + 1;
			if (rule->match_prefix != UNSPACED_RULE_SUFFIX) {
				while ((pos < Str__len(rule->match_text)) && (Characters__is_whitespace(pos))) pos++;
				if ((rule->match_prefix == SPACED_RULE_SUFFIX) && (pos == from))
					return FALSE;
			}
			if (Str__includes_at(matter, pos, rule->match_text) == FALSE)
				return FALSE;
			rule->fix_position = pos;
		} else {
			if (Str__len(rule->match_text) != to-from+1)
				return FALSE;
			for (int i=from; i<=to; i++)
				if (Str__get_at(matter, i) != Str__get_at(rule->match_text, i-from))
					return FALSE;
		}
	} else if (rule->match_keyword_of_colour != NOT_A_COLOUR) {
		TEMPORARY_TEXT(id)
		Str__substr(id, Str__at(matter, from), Str__at(matter, to+1));
		int rw = ReservedWords__is_reserved_word(HT, id, (int) rule->match_keyword_of_colour);
		DISCARD_TEXT(id)
		if (rw == FALSE) return FALSE;
	} else if (rule->match_colour != NOT_A_COLOUR) {
		for (int i=from; i<=to; i++)
			if (Str__get_at(colouring, i) != rule->match_colour)
				return FALSE;
	}
	return TRUE;
}

#line 390 "inweb/foundation-module/Chapter 9/The Painter.w"
void Painter__follow(hash_table *HT, colouring_rule *rule, text_stream *matter,
	text_stream *colouring, int from, int to) {
	if (rule->execute_block)
		Painter__execute(HT, rule->execute_block, matter, colouring, from, to, 0);
	else if (rule->debug) 
{
#line 406 "inweb/foundation-module/Chapter 9/The Painter.w"
	PRINT("[%d, %d] text: ", from, to);
	for (int i=from; i<=to; i++)
		PUT_TO(STDOUT, Str__get_at(matter, i));
	PRINT("\n[%d, %d] cols: ", from, to);
	for (int i=from; i<=to; i++)
		PUT_TO(STDOUT, Str__get_at(colouring, i));
	PRINT("\n");

}
#line 394 "inweb/foundation-module/Chapter 9/The Painter.w"

	else {
		if (rule->set_to_colour != NOT_A_COLOUR)
			for (int i=from; i<=to; i++)
				Str__put_at(colouring, i, rule->set_to_colour);
		if (rule->set_prefix_to_colour != NOT_A_COLOUR)
			for (int i=rule->fix_position; i<rule->fix_position+Str__len(rule->match_text); i++)
				Str__put_at(colouring, i, rule->set_prefix_to_colour);
	}
}

#line 417 "inweb/foundation-module/Chapter 9/The Painter.w"
linked_list *Painter__lines(filename *F) {
	linked_list *L = NEW_LINKED_LIST(text_stream);
	TextFiles__read(F, FALSE, "unable to read file of textual extract", TRUE,
		&Painter__text_file_helper, NULL, L);
	int n = -1, c = 0;
	text_stream *T;
	LOOP_OVER_LINKED_LIST(T, text_stream, L) {
		c++;
		if (Str__is_whitespace(T) == FALSE)
			n = c;
	}
	if (n >= 0) {
		linked_list *R = NEW_LINKED_LIST(text_stream);
		c = 0;
		LOOP_OVER_LINKED_LIST(T, text_stream, L)
			if (++c <= n)
				ADD_TO_LINKED_LIST(T, text_stream, R);
		return R;
	}
	return L;
}

void Painter__text_file_helper(text_stream *text, text_file_position *tfp, void *state) {
	linked_list *L = (linked_list *) state;
	ADD_TO_LINKED_LIST(Str__duplicate(text), text_stream, L);
}

void Painter__colour_file(programming_language *pl, filename *F, text_stream *to, text_stream *coloured) {
	linked_list *L = Painter__lines(F);
	if (pl) Painter__reset_syntax_colouring(pl);
	int c = 1;
	text_stream *T;
	LOOP_OVER_LINKED_LIST(T, text_stream, L) {
		if (c++ > 1) { PUT_TO(to, '\n'); PUT_TO(coloured, NEWLINE_COLOUR); }
		Str__trim_white_space_at_end(T);
		TEMPORARY_TEXT(ST)
		TEMPORARY_TEXT(SC)
		LOOP_THROUGH_TEXT(pos, T)
			if (Str__get(pos) == '\t')
				WRITE_TO(ST, "    ");
			else
				PUT_TO(ST, Str__get(pos));
		if (pl) {
			Painter__syntax_colour(pl, (pl)?(&(pl->built_in_keywords)):NULL, ST, SC, TRUE);
		} else {
			LOOP_THROUGH_TEXT(pos, ST)
				PUT_TO(SC, PLAIN_COLOUR);
		}
		WRITE_TO(to, "%S", ST);
		WRITE_TO(coloured, "%S", SC);
	}
	if (c > 0) { PUT_TO(to, '\n'); PUT_TO(coloured, NEWLINE_COLOUR); }
}

#line 476 "inweb/foundation-module/Chapter 9/The Painter.w"
int Painter__parse_comment(programming_language *pl,
	text_stream *line, text_stream *part_before_comment, text_stream *part_within_comment) {
	int q_mode = 0, c_mode = 0, non_white_space = FALSE, c_position = -1, c_end = -1;
	for (int i=0; i<Str__len(line); i++) {
		inchar32_t c = Str__get_at(line, i);
		switch (c_mode) {
			case 0: 
{
#line 510 "inweb/foundation-module/Chapter 9/The Painter.w"
	switch (q_mode) {
		case 0: 
{
#line 517 "inweb/foundation-module/Chapter 9/The Painter.w"
	if (!(Characters__is_whitespace(c))) non_white_space = TRUE;
	if (c == Str__get_first_char(pl->string_literal)) q_mode = 2;
	else if (c == Str__get_first_char(pl->character_literal)) q_mode = 1;
	else if (Str__includes_at(line, i, pl->multiline_comment_open)) {
		c_mode = 2; c_position = i; non_white_space = FALSE;
		i += Str__len(pl->multiline_comment_open) - 1;
	} else if (Str__includes_at(line, i, pl->line_comment)) {
		c_mode = 1; c_position = i; c_end = Str__len(line); non_white_space = FALSE;
		i += Str__len(pl->line_comment) - 1;
	} else if (Str__includes_at(line, i, pl->whole_line_comment)) {
		int material_exists = FALSE;
		for (int j=0; j<i; j++)
			if (!(Characters__is_whitespace(Str__get_at(line, j))))
				material_exists = TRUE;
		if (material_exists == FALSE) {
			c_mode = 1; c_position = i; c_end = Str__len(line);
			non_white_space = FALSE;
			i += Str__len(pl->whole_line_comment) - 1;
		}
	}

}
#line 511 "inweb/foundation-module/Chapter 9/The Painter.w"
; break;
		case 1: 
{
#line 539 "inweb/foundation-module/Chapter 9/The Painter.w"
	if (!(Characters__is_whitespace(c))) non_white_space = TRUE;
	if (c == Str__get_first_char(pl->character_literal_escape)) i += 1;
	if (c == Str__get_first_char(pl->character_literal)) q_mode = 0;
	q_mode = 0;

}
#line 512 "inweb/foundation-module/Chapter 9/The Painter.w"
; break;
		case 2: 
{
#line 545 "inweb/foundation-module/Chapter 9/The Painter.w"
	if (!(Characters__is_whitespace(c))) non_white_space = TRUE;
	if (c == Str__get_first_char(pl->string_literal_escape)) i += 1;
	if (c == Str__get_first_char(pl->string_literal)) q_mode = 0;
	q_mode = 0;

}
#line 513 "inweb/foundation-module/Chapter 9/The Painter.w"
; break;
	}

}
#line 482 "inweb/foundation-module/Chapter 9/The Painter.w"
; break;
			case 1: 
{
#line 507 "inweb/foundation-module/Chapter 9/The Painter.w"
	;

}
#line 483 "inweb/foundation-module/Chapter 9/The Painter.w"
; break;
			case 2: 
{
#line 502 "inweb/foundation-module/Chapter 9/The Painter.w"
	if (Str__includes_at(line, i, pl->multiline_comment_close)) {
		c_mode = 0; c_end = i; i += Str__len(pl->multiline_comment_close) - 1;
	}

}
#line 484 "inweb/foundation-module/Chapter 9/The Painter.w"
; break;
		}
	}
	if (c_mode == 2) c_end = Str__len(line);
	if ((c_position >= 0) && (non_white_space == FALSE)) {
		Str__clear(part_before_comment);
		for (int i=0; i<c_position; i++)
			PUT_TO(part_before_comment, Str__get_at(line, i));
		Str__clear(part_within_comment);
		for (int i=c_position + 2; i<c_end; i++)
			PUT_TO(part_within_comment, Str__get_at(line, i));
		Str__trim_white_space_at_end(part_within_comment);
		return TRUE;
	}
	return FALSE;
}

#line 97 "inweb/Chapter 1/Basics.w"
DECLARE_CLASS_ALLOCATED_IN_ARRAYS(source_line, 1000)
DECLARE_CLASS(asset_rule)
DECLARE_CLASS(breadcrumb_request)
DECLARE_CLASS(chapter)
DECLARE_CLASS(colony)
DECLARE_CLASS(colony_member)
DECLARE_CLASS(colour_scheme)
DECLARE_CLASS(defined_constant)
DECLARE_CLASS(enumeration_set)
DECLARE_CLASS(footnote)
DECLARE_CLASS(hash_table_entry_usage)
DECLARE_CLASS(language_function)
DECLARE_CLASS(language_type)
DECLARE_CLASS(macro_usage)
DECLARE_CLASS(makefile_specifics)
DECLARE_CLASS(nonterminal_variable)
DECLARE_CLASS(para_macro)
DECLARE_CLASS(paragraph_tagging)
DECLARE_CLASS(paragraph)
DECLARE_CLASS(preform_nonterminal)
DECLARE_CLASS(section)
DECLARE_CLASS(structure_element)
DECLARE_CLASS(tangle_target)
DECLARE_CLASS(tex_results)
DECLARE_CLASS(text_literal)
DECLARE_CLASS(theme_tag)
DECLARE_CLASS(weave_format)
DECLARE_CLASS(weave_pattern)
DECLARE_CLASS(weave_plugin)
DECLARE_CLASS(weave_order)
DECLARE_CLASS(web)
DECLARE_CLASS(writeme_asset)

DECLARE_CLASS(weave_document_node)
DECLARE_CLASS(weave_head_node)
DECLARE_CLASS(weave_body_node)
DECLARE_CLASS(weave_tail_node)
DECLARE_CLASS(weave_section_header_node)
DECLARE_CLASS(weave_section_footer_node)
DECLARE_CLASS(weave_chapter_header_node)
DECLARE_CLASS(weave_chapter_footer_node)
DECLARE_CLASS(weave_verbatim_node)
DECLARE_CLASS(weave_section_purpose_node)
DECLARE_CLASS(weave_subheading_node)
DECLARE_CLASS(weave_bar_node)
DECLARE_CLASS(weave_linebreak_node)
DECLARE_CLASS(weave_pagebreak_node)
DECLARE_CLASS(weave_paragraph_heading_node)
DECLARE_CLASS(weave_endnote_node)
DECLARE_CLASS(weave_material_node)
DECLARE_CLASS(weave_figure_node)
DECLARE_CLASS(weave_extract_node)
DECLARE_CLASS(weave_audio_node)
DECLARE_CLASS(weave_video_node)
DECLARE_CLASS(weave_download_node)
DECLARE_CLASS(weave_embed_node)
DECLARE_CLASS(weave_pmac_node)
DECLARE_CLASS(weave_vskip_node)
DECLARE_CLASS(weave_chapter_node)
DECLARE_CLASS(weave_section_node)
DECLARE_CLASS(weave_code_line_node)
DECLARE_CLASS(weave_function_usage_node)
DECLARE_CLASS(weave_commentary_node)
DECLARE_CLASS(weave_carousel_slide_node)
DECLARE_CLASS(weave_toc_node)
DECLARE_CLASS(weave_toc_line_node)
DECLARE_CLASS(weave_chapter_title_page_node)
DECLARE_CLASS(weave_defn_node)
DECLARE_CLASS(weave_source_code_node)
DECLARE_CLASS(weave_url_node)
DECLARE_CLASS(weave_footnote_cue_node)
DECLARE_CLASS(weave_begin_footnote_text_node)
DECLARE_CLASS(weave_display_line_node)
DECLARE_CLASS(weave_item_node)
DECLARE_CLASS(weave_grammar_index_node)
DECLARE_CLASS(weave_inline_node)
DECLARE_CLASS(weave_locale_node)
DECLARE_CLASS(weave_maths_node)
DECLARE_CLASS(weave_function_defn_node)

#line 10 "inweb/Chapter 1/Program Control.w"
int default_inweb_syntax = V2_SYNTAX;

#line 22 "inweb/Chapter 1/Program Control.w"

#line 24 "inweb/Chapter 1/Program Control.w"
int fundamental_mode = NO_MODE;

#line 43 "inweb/Chapter 1/Program Control.w"

#line 51 "inweb/Chapter 1/Program Control.w"
pathname *path_to_inweb = NULL; /* where we are installed */
pathname *path_to_inweb_materials = NULL; /* the materials pathname */
pathname *path_to_inweb_patterns = NULL; /* where built-in patterns are stored */

#line 58 "inweb/Chapter 1/Program Control.w"
int no_inweb_errors = 0;
int verbose_mode = FALSE;

#line 64 "inweb/Chapter 1/Program Control.w"
int main(int argc, char **argv) {
	
{
#line 84 "inweb/Chapter 1/Program Control.w"
	Foundation__start(argc, argv);
	Formats__create_weave_formats();

}
#line 65 "inweb/Chapter 1/Program Control.w"
;
	inweb_instructions args = Configuration__read(argc, argv);
	verbose_mode = args.verbose_switch;
	fundamental_mode = args.inweb_mode;
	path_to_inweb = Pathnames__installation_path("INWEB_PATH", TL_IS_2645);
	if (verbose_mode) {
		PRINT("Installation path is %p\n", path_to_inweb);
		Locales__write_locales(STDOUT);
	}
	path_to_inweb_patterns = Pathnames__down(path_to_inweb, TL_IS_2646);
	path_to_inweb_materials = Pathnames__down(path_to_inweb, TL_IS_2647);
	Languages__set_default_directory(Pathnames__down(path_to_inweb, TL_IS_2648));

	Main__follow_instructions(&args);

	
{
#line 88 "inweb/Chapter 1/Program Control.w"
	Foundation__end();
	return (no_inweb_errors == 0)?0:1;

}
#line 80 "inweb/Chapter 1/Program Control.w"
;
}

#line 96 "inweb/Chapter 1/Program Control.w"
void Main__follow_instructions(inweb_instructions *ins) {
	web *W = NULL;
	if ((ins->chosen_web) || (ins->chosen_file)) {
		W = Reader__load_web(ins->chosen_web, ins->chosen_file,
			WebModules__make_search_path(ins->import_setting), TRUE);
		W->redirect_weaves_to = ins->weave_into_setting;
		Reader__read_web(W);
		Parser__parse_web(W, ins->inweb_mode);
	}
	if (no_inweb_errors == 0) {
		if (ins->inweb_mode == TRANSLATE_MODE) 
{
#line 116 "inweb/Chapter 1/Program Control.w"
	if ((ins->makefile_setting) && (ins->prototype_setting == NULL))
		ins->prototype_setting = Filenames__from_text(TL_IS_2649);
	if ((ins->gitignore_setting) && (ins->prototype_setting == NULL))
		ins->prototype_setting = Filenames__from_text(TL_IS_2650);
	if ((ins->writeme_setting) && (ins->prototype_setting == NULL))
		ins->prototype_setting = Filenames__from_text(TL_IS_2651);
	if (ins->makefile_setting)
		Makefiles__write(W, ins->prototype_setting, ins->makefile_setting,
			WebModules__make_search_path(ins->import_setting), ins->platform_setting);
	else if (ins->gitignore_setting)
		Git__write_gitignore(W, ins->prototype_setting, ins->gitignore_setting);
	else if (ins->advance_setting)
		BuildFiles__advance(ins->advance_setting);
	else if (ins->writeme_setting)
		Readme__write(ins->prototype_setting, ins->writeme_setting);

}
#line 106 "inweb/Chapter 1/Program Control.w"

		else if (ins->show_languages_switch) 
{
#line 135 "inweb/Chapter 1/Program Control.w"
	Languages__read_definitions(NULL);
	Languages__show(STDOUT);

}
#line 107 "inweb/Chapter 1/Program Control.w"

		else if ((ins->test_language_setting) || (ins->test_language_on_setting)) 
{
#line 141 "inweb/Chapter 1/Program Control.w"
	if ((ins->test_language_setting) && (ins->test_language_on_setting)) {
		TEMPORARY_TEXT(matter)
		TEMPORARY_TEXT(coloured)
		Painter__colour_file(ins->test_language_setting, ins->test_language_on_setting,
			matter, coloured);
		PRINT("Test of colouring for language %S:\n%S\n%S\n",
			ins->test_language_setting->language_name, matter, coloured);
		DISCARD_TEXT(matter)
		DISCARD_TEXT(coloured)
	} else {
		Errors__fatal("-test-language and -test-language-on must both be given");
	}

}
#line 108 "inweb/Chapter 1/Program Control.w"

		else if (ins->inweb_mode != NO_MODE) 
{
#line 157 "inweb/Chapter 1/Program Control.w"
	if (ins->inweb_mode != ANALYSE_MODE) Reader__print_web_statistics(W);
	if (ins->inweb_mode == ANALYSE_MODE) 
{
#line 165 "inweb/Chapter 1/Program Control.w"
	if (ins->swarm_mode != SWARM_OFF_SWM)
		Errors__fatal("only specific parts of the web can be analysed");
	if (ins->catalogue_switch)
		Analyser__catalogue_the_sections(W, ins->chosen_range, BASIC_SECTIONCAT);
	if (ins->functions_switch)
		Analyser__catalogue_the_sections(W, ins->chosen_range, FUNCTIONS_SECTIONCAT);
	if (ins->structures_switch)
		Analyser__catalogue_the_sections(W, ins->chosen_range, STRUCTURES_SECTIONCAT);
	if (ins->makefile_setting)
		Analyser__write_makefile(W, ins->makefile_setting,
			WebModules__make_search_path(ins->import_setting), ins->platform_setting);
	if (ins->gitignore_setting)
		Analyser__write_gitignore(W, ins->gitignore_setting);
	if (ins->advance_switch)
		BuildFiles__advance_for_web(W->md);
	if (ins->scan_switch)
		Analyser__scan_line_categories(W, ins->chosen_range);

}
#line 158 "inweb/Chapter 1/Program Control.w"
;
	if (ins->inweb_mode == TANGLE_MODE) 
{
#line 198 "inweb/Chapter 1/Program Control.w"
	TEMPORARY_TEXT(tangle_leaf)
	tangle_target *tn = NULL;
	if (Str__eq_wide_string(ins->chosen_range, U"0")) {
		
{
#line 222 "inweb/Chapter 1/Program Control.w"
	tn = NULL;
	if (Bibliographic__data_exists(W->md, TL_IS_2652))
		Str__copy(tangle_leaf, Bibliographic__get_datum(W->md, TL_IS_2653));
	else
		Str__copy(tangle_leaf, Bibliographic__get_datum(W->md, TL_IS_2654));
	Str__concatenate(tangle_leaf, W->main_language->file_extension);

}
#line 201 "inweb/Chapter 1/Program Control.w"
;
	} else if (Reader__get_section_for_range(W, ins->chosen_range)) {
		
{
#line 232 "inweb/Chapter 1/Program Control.w"
	section *S = Reader__get_section_for_range(W, ins->chosen_range);
	tn = S->sect_target;
	if (tn == NULL) Errors__fatal("section cannot be independently tangled");
	Str__copy(tangle_leaf, Filenames__get_leafname(S->md->source_file_for_section));

}
#line 203 "inweb/Chapter 1/Program Control.w"
;
	}
	if (Str__len(tangle_leaf) == 0) { Errors__fatal("no tangle destination known"); }

	filename *tangle_to = ins->tangle_setting;
	if (tangle_to == NULL) {
		pathname *P = Reader__tangled_folder(W);
		if (W->md->single_file) P = Filenames__up(W->md->single_file);
		tangle_to = Filenames__in(P, tangle_leaf);
	}
	if (tn == NULL) tn = Tangler__primary_target(W);
	Tangler__tangle(W, tn, tangle_to);
	if (ins->ctags_switch) Ctags__write(W, ins->ctags_setting);
	DISCARD_TEXT(tangle_leaf)

}
#line 159 "inweb/Chapter 1/Program Control.w"
;
	if (ins->inweb_mode == WEAVE_MODE) 
{
#line 240 "inweb/Chapter 1/Program Control.w"
	Numbering__number_web(W);

	theme_tag *tag = Tags__find_by_name(ins->tag_setting, FALSE);
	if ((Str__len(ins->tag_setting) > 0) && (tag == NULL))
		Errors__fatal_with_text("no such theme as '%S'", ins->tag_setting);

	weave_pattern *pattern = Patterns__find(W, ins->weave_pattern);
	if ((ins->chosen_range_actually_chosen == FALSE) && (ins->chosen_file == NULL))
		Configuration__set_range(ins, pattern->default_range);

	int r = Formats__begin_weaving(W, pattern);
	if (r != SWARM_OFF_SWM) ins->swarm_mode = r;
	
{
#line 265 "inweb/Chapter 1/Program Control.w"
	section *S; int k = 1;
	LOOP_OVER(S, section)
		if (Reader__range_within(S->md->sect_range, ins->chosen_range))
			S->printed_number = k++;

}
#line 252 "inweb/Chapter 1/Program Control.w"
;
	if (ins->swarm_mode == SWARM_OFF_SWM) {
		Swarm__weave_subset(W, ins->chosen_range, FALSE, tag, pattern,
			ins->weave_to_setting, ins->weave_into_setting,
			ins->breadcrumb_setting, ins->navigation_setting);
	} else {
		Swarm__weave(W, ins->chosen_range, ins->swarm_mode, tag, pattern,
			ins->weave_to_setting, ins->weave_into_setting,
			ins->breadcrumb_setting, ins->navigation_setting);
	}
	Formats__end_weaving(W, pattern);

}
#line 160 "inweb/Chapter 1/Program Control.w"
;

}
#line 109 "inweb/Chapter 1/Program Control.w"
;
	}
}

#line 276 "inweb/Chapter 1/Program Control.w"
void Main__error_in_web(text_stream *message, source_line *sl) {
	if (sl) {
		Errors__in_text_file_S(message, &(sl->source));
		WRITE_TO(STDERR, "%07d  %S\n", sl->source.line_count, sl->text);
	} else {
		Errors__in_text_file_S(message, NULL);
	}
	no_inweb_errors++;
}

#line 52 "inweb/Chapter 1/Configuration.w"

#line 59 "inweb/Chapter 1/Configuration.w"
inweb_instructions Configuration__read(int argc, char **argv) {
	inweb_instructions args;
	
{
#line 79 "inweb/Chapter 1/Configuration.w"
	args.inweb_mode = NO_MODE;
	args.swarm_mode = SWARM_OFF_SWM;
	args.show_languages_switch = FALSE;
	args.catalogue_switch = FALSE;
	args.functions_switch = FALSE;
	args.structures_switch = FALSE;
	args.advance_switch = FALSE;
	args.scan_switch = FALSE;
	args.verbose_switch = FALSE;
	args.ctags_switch = TRUE;
	args.chosen_web = NULL;
	args.chosen_file = NULL;
	args.chosen_range = Str__new();
	args.chosen_range_actually_chosen = FALSE;
	args.tangle_setting = NULL;
	args.ctags_setting = NULL;
	args.weave_to_setting = NULL;
	args.weave_into_setting = NULL;
	args.makefile_setting = NULL;
	args.gitignore_setting = NULL;
	args.advance_setting = NULL;
	args.writeme_setting = NULL;
	args.prototype_setting = NULL;
	args.navigation_setting = NULL;
	args.colony_setting = NULL;
	args.member_setting = NULL;
	args.breadcrumb_setting = NEW_LINKED_LIST(breadcrumb_request);
	args.platform_setting = NULL;
	args.tag_setting = Str__new();
	args.weave_pattern = Str__new();
	args.import_setting = NULL;
	args.targets = 0;
	args.test_language_setting = NULL;
	args.test_language_on_setting = NULL;

}
#line 61 "inweb/Chapter 1/Configuration.w"
;
	
{
#line 167 "inweb/Chapter 1/Configuration.w"
	CommandLine__declare_heading(U"inweb: a tool for literate programming\n\n"
		U"Usage: inweb WEB OPTIONS RANGE\n\n"
		U"WEB must be a directory holding a literate program (a 'web')\n\n"
		U"The legal RANGEs are:\n"
		U"   all: complete web (the default if no TARGETS set)\n"
		U"   P: all preliminaries\n"
		U"   1: Chapter 1 (and so on)\n"
		U"   A: Appendix A (and so on, up to Appendix O)\n"
		U"   3/eg: section with abbreviated name \"3/eg\" (and so on)\n"
		U"You can also, or instead, specify:\n"
		U"   index: to weave an HTML page indexing the project\n"
		U"   chapters: to weave all chapters as individual documents\n"
		U"   sections: ditto with sections\n");

	CommandLine__begin_group(LANGUAGES_CLSG,
		TL_IS_2656);
	CommandLine__declare_switch(LANGUAGE_CLSW, U"read-language", 2,
		U"read language definition from file X");
	CommandLine__declare_switch(LANGUAGES_CLSW, U"read-languages", 2,
		U"read all language definitions in path X");
	CommandLine__declare_switch(SHOW_LANGUAGES_CLSW, U"show-languages", 1,
		U"list programming languages supported by Inweb");
	CommandLine__declare_switch(TEST_LANGUAGE_CLSW, U"test-language", 2,
		U"test language X on...");
	CommandLine__declare_switch(TEST_LANGUAGE_ON_CLSW, U"test-language-on", 2,
		U"...the code in the file X");
	CommandLine__end_group();

	CommandLine__begin_group(ANALYSIS_CLSG,
		TL_IS_2657);
	CommandLine__declare_switch(CATALOGUE_CLSW, U"catalogue", 1,
		U"list the sections in the web");
	CommandLine__declare_switch(CATALOGUE_CLSW, U"catalog", 1,
		U"same as '-catalogue'");
	CommandLine__declare_switch(MAKEFILE_CLSW, U"makefile", 2,
		U"write a makefile for this web and store it in X");
	CommandLine__declare_switch(GITIGNORE_CLSW, U"gitignore", 2,
		U"write a .gitignore file for this web and store it in X");
	CommandLine__declare_switch(ADVANCE_FILE_CLSW, U"advance-build-file", 2,
		U"increment daily build code in file X");
	CommandLine__declare_switch(WRITEME_CLSW, U"write-me", 2,
		U"write a read-me file following instructions in file X");
	CommandLine__declare_switch(PLATFORM_CLSW, U"platform", 2,
		U"use platform X (e.g. 'windows') when making e.g. makefiles");
	CommandLine__declare_switch(PROTOTYPE_CLSW, U"prototype", 2,
		U"translate makefile from prototype X");
	CommandLine__declare_switch(FUNCTIONS_CLSW, U"functions", 1,
		U"catalogue the functions in the web");
	CommandLine__declare_switch(STRUCTURES_CLSW, U"structures", 1,
		U"catalogue the structures in the web");
	CommandLine__declare_switch(ADVANCE_CLSW, U"advance-build", 1,
		U"increment daily build code for the web");
	CommandLine__declare_switch(SCAN_CLSW, U"scan", 1,
		U"scan the web");
	CommandLine__end_group();

	CommandLine__begin_group(WEAVING_CLSG,
		TL_IS_2658);
	CommandLine__declare_switch(WEAVE_CLSW, U"weave", 1,
		U"weave the web into human-readable form");
	CommandLine__declare_switch(WEAVE_INTO_CLSW, U"weave-into", 2,
		U"weave, but into directory X");
	CommandLine__declare_switch(WEAVE_TO_CLSW, U"weave-to", 2,
		U"weave, but to filename X (for single files only)");
	CommandLine__declare_switch(OPEN_CLSW, U"open", 1,
		U"weave then open woven file");
	CommandLine__declare_switch(WEAVE_AS_CLSW, U"weave-as", 2,
		U"set weave pattern to X (default is 'HTML')");
	CommandLine__declare_switch(WEAVE_TAG_CLSW, U"weave-tag", 2,
		U"weave, but only using material tagged as X");
	CommandLine__declare_switch(BREADCRUMB_CLSW, U"breadcrumb", 2,
		U"use the text X as a breadcrumb in overhead navigation");
	CommandLine__declare_switch(NAVIGATION_CLSW, U"navigation", 2,
		U"use the file X as a column of navigation links");
	CommandLine__end_group();

	CommandLine__begin_group(TANGLING_CLSG,
		TL_IS_2659);
	CommandLine__declare_switch(TANGLE_CLSW, U"tangle", 1,
		U"tangle the web into machine-compilable form");
	CommandLine__declare_switch(TANGLE_TO_CLSW, U"tangle-to", 2,
		U"tangle, but to filename X");
	CommandLine__declare_switch(CTAGS_TO_CLSW, U"ctags-to", 2,
		U"tangle, but write Universal Ctags file to X not to 'tags'");
	CommandLine__declare_boolean_switch(CTAGS_CLSW, U"ctags", 1,
		U"write a Universal Ctags file when tangling", TRUE);
	CommandLine__end_group();

	CommandLine__begin_group(COLONIAL_CLSG,
		TL_IS_2660);
	CommandLine__declare_switch(COLONY_CLSW, U"colony", 2,
		U"use the file X as a list of webs in this colony");
	CommandLine__declare_switch(MEMBER_CLSW, U"member", 2,
		U"use member X from the colony as our web");
	CommandLine__end_group();

	CommandLine__declare_boolean_switch(VERBOSE_CLSW, U"verbose", 1,
		U"explain what inweb is doing", FALSE);
	CommandLine__declare_switch(IMPORT_FROM_CLSW, U"import-from", 2,
		U"specify that imported modules are at pathname X");

}
#line 62 "inweb/Chapter 1/Configuration.w"
;
	CommandLine__read(argc, argv, &args, &Configuration__switch, &Configuration__bareword);
	Configuration__member_and_colony(&args);
	if (Str__len(args.weave_pattern) == 0) WRITE_TO(args.weave_pattern, "HTML");
	if ((args.chosen_web == NULL) && (args.chosen_file == NULL)) {
		if ((args.makefile_setting) || (args.gitignore_setting))
			args.inweb_mode = TRANSLATE_MODE;
		if (args.inweb_mode != TRANSLATE_MODE)
			args.inweb_mode = NO_MODE;
	}
	if (Str__len(args.chosen_range) == 0) {
		Str__copy(args.chosen_range, TL_IS_2655);
	}
	return args;
}

#line 120 "inweb/Chapter 1/Configuration.w"

#line 122 "inweb/Chapter 1/Configuration.w"

#line 128 "inweb/Chapter 1/Configuration.w"

#line 130 "inweb/Chapter 1/Configuration.w"

#line 142 "inweb/Chapter 1/Configuration.w"

#line 144 "inweb/Chapter 1/Configuration.w"

#line 153 "inweb/Chapter 1/Configuration.w"

#line 155 "inweb/Chapter 1/Configuration.w"

#line 160 "inweb/Chapter 1/Configuration.w"

#line 162 "inweb/Chapter 1/Configuration.w"

#line 165 "inweb/Chapter 1/Configuration.w"

#line 271 "inweb/Chapter 1/Configuration.w"
void Configuration__switch(int id, int val, text_stream *arg, void *state) {
	inweb_instructions *args = (inweb_instructions *) state;
	switch (id) {
		/* Miscellaneous */
		case VERBOSE_CLSW: args->verbose_switch = TRUE; break;
		case IMPORT_FROM_CLSW: args->import_setting = Pathnames__from_text(arg); break;

		/* Analysis */
		case LANGUAGE_CLSW:
			Languages__read_definition(Filenames__from_text(arg)); break;
		case LANGUAGES_CLSW:
			Languages__read_definitions(Pathnames__from_text(arg)); break;
		case SHOW_LANGUAGES_CLSW:
			args->show_languages_switch = TRUE;
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case TEST_LANGUAGE_CLSW:
			args->test_language_setting =
				Languages__read_definition(Filenames__from_text(arg));
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case TEST_LANGUAGE_ON_CLSW:
			args->test_language_on_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case CATALOGUE_CLSW:
			args->catalogue_switch = TRUE;
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case FUNCTIONS_CLSW:
			args->functions_switch = TRUE;
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case STRUCTURES_CLSW:
			args->structures_switch = TRUE;
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case ADVANCE_CLSW:
			args->advance_switch = TRUE;
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;
		case MAKEFILE_CLSW:
			args->makefile_setting = Filenames__from_text(arg);
			if (args->inweb_mode != TRANSLATE_MODE)
				Configuration__set_fundamental_mode(args, ANALYSE_MODE);
			break;
		case GITIGNORE_CLSW:
			args->gitignore_setting = Filenames__from_text(arg);
			if (args->inweb_mode != TRANSLATE_MODE)
				Configuration__set_fundamental_mode(args, ANALYSE_MODE);
			break;
		case PLATFORM_CLSW:
			args->platform_setting = Str__duplicate(arg);
			break;
		case ADVANCE_FILE_CLSW:
			args->advance_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, TRANSLATE_MODE);
			break;
		case WRITEME_CLSW:
			args->writeme_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, TRANSLATE_MODE);
			break;
		case PROTOTYPE_CLSW:
			args->prototype_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, TRANSLATE_MODE); break;
		case SCAN_CLSW:
			args->scan_switch = TRUE;
			Configuration__set_fundamental_mode(args, ANALYSE_MODE); break;

		/* Weave-related */
		case WEAVE_CLSW:
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;
		case WEAVE_INTO_CLSW:
			args->weave_into_setting = Pathnames__from_text(arg);
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;
		case WEAVE_TO_CLSW:
			args->weave_to_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;
		case WEAVE_AS_CLSW:
			args->weave_pattern = Str__duplicate(arg);
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;
		case WEAVE_TAG_CLSW:
			args->tag_setting = Str__duplicate(arg);
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;
		case BREADCRUMB_CLSW:
			ADD_TO_LINKED_LIST(Colonies__request_breadcrumb(arg),
				breadcrumb_request, args->breadcrumb_setting);
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;
		case NAVIGATION_CLSW:
			args->navigation_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, WEAVE_MODE); break;

		/* Colonial */
		case COLONY_CLSW:
			args->colony_setting = Filenames__from_text(arg); break;
		case MEMBER_CLSW:
			args->member_setting = Str__duplicate(arg); break;

		/* Tangle-related */
		case TANGLE_CLSW:
			Configuration__set_fundamental_mode(args, TANGLE_MODE); break;
		case TANGLE_TO_CLSW:
			args->tangle_setting = Filenames__from_text(arg);
			Configuration__set_fundamental_mode(args, TANGLE_MODE); break;
		case CTAGS_TO_CLSW:
			args->ctags_setting = Filenames__from_text(arg);
			break;
		case CTAGS_CLSW:
			args->ctags_switch = val;
			break;

		default: internal_error("unimplemented switch");
	}
}

#line 383 "inweb/Chapter 1/Configuration.w"
void Configuration__member_and_colony(inweb_instructions *args) {
	if (args->colony_setting) Colonies__load(args->colony_setting);
	if (Str__len(args->member_setting) > 0) {
		if ((args->chosen_web == NULL) && (args->chosen_file == NULL)) {
			colony_member *CM = Colonies__find(args->member_setting);
			if (CM == NULL) Errors__fatal("the colony has no member of that name");
			Configuration__bareword(0, CM->path, args);
			if (Str__len(args->weave_pattern) == 0)
				args->weave_pattern = CM->default_weave_pattern;
			if (LinkedLists__len(args->breadcrumb_setting) == 0)
				args->breadcrumb_setting = CM->breadcrumb_tail;
			if (args->navigation_setting == NULL)
				args->navigation_setting = CM->navigation;
			if (args->weave_into_setting == NULL)
				args->weave_into_setting = CM->weave_path;
		} else {
			Errors__fatal("cannot specify a web and also use -member");
		}
	}
}

#line 409 "inweb/Chapter 1/Configuration.w"
void Configuration__bareword(int id, text_stream *opt, void *state) {
	inweb_instructions *args = (inweb_instructions *) state;
	if ((args->chosen_web == NULL) && (args->chosen_file == NULL)) {
		if (Str__suffix_eq(opt, TL_IS_2661, 6))
			args->chosen_file = Filenames__from_text(opt);
		else
			args->chosen_web = Pathnames__from_text(opt);
	} else Configuration__set_range(args, opt);
}

#line 424 "inweb/Chapter 1/Configuration.w"
void Configuration__set_range(inweb_instructions *args, text_stream *opt) {
	match_results mr = Regexp__create_mr();
	if (Str__eq_wide_string(opt, U"index")) {
		args->swarm_mode = SWARM_INDEX_SWM;
	} else if (Str__eq_wide_string(opt, U"chapters")) {
		args->swarm_mode = SWARM_CHAPTERS_SWM;
	} else if (Str__eq_wide_string(opt, U"sections")) {
		args->swarm_mode = SWARM_SECTIONS_SWM;
	} else {
		if (++args->targets > 1) Errors__fatal("at most one target may be given");
		if (Str__eq_wide_string(opt, U"all")) {
			Str__copy(args->chosen_range, TL_IS_2662);
		} else if (((Characters__isalnum(Str__get_first_char(opt))) && (Str__len(opt) == 1))
			|| (Regexp__match(&mr, opt, U"%i+/%i+"))) {
			Str__copy(args->chosen_range, opt);
			string_position P = Str__start(args->chosen_range);
			Str__put(P, Characters__toupper(Str__get(P)));
		} else {
			TEMPORARY_TEXT(ERM)
			WRITE_TO(ERM, "target not recognised (see -help for more): %S", opt);
			Main__error_in_web(ERM, NULL);
			DISCARD_TEXT(ERM)
			exit(1);
		}
	}
	args->chosen_range_actually_chosen = TRUE;
	Regexp__dispose_of(&mr);
}

#line 456 "inweb/Chapter 1/Configuration.w"
void Configuration__set_fundamental_mode(inweb_instructions *args, int new_material) {
	if ((args->inweb_mode != NO_MODE) && (args->inweb_mode != new_material))
		Errors__fatal("can only do one at a time - weaving, tangling or analysing");
	args->inweb_mode = new_material;
}

#line 18 "inweb/Chapter 1/The Swarm.w"
weave_order *swarm_leader = NULL; /* the most inclusive one we weave */

void Swarm__weave(web *W, text_stream *range, int swarm_mode, theme_tag *tag,
	weave_pattern *pattern, filename *to, pathname *into,
	linked_list *breadcrumbs, filename *navigation) {
	swarm_leader = NULL;
	chapter *C;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		if (C->md->imported == FALSE) {
			if (swarm_mode == SWARM_CHAPTERS_SWM)
				if ((W->md->chaptered == TRUE) && (Reader__range_within(C->md->ch_range, range))) {
					C->ch_weave = Swarm__weave_subset(W,
						C->md->ch_range, FALSE, tag, pattern, to, into,
						breadcrumbs, navigation);
					if (Str__len(range) > 0) swarm_leader = C->ch_weave;
				}
			if (swarm_mode == SWARM_SECTIONS_SWM)
				LOOP_OVER_LINKED_LIST(S, section, C->sections)
					if (Reader__range_within(S->md->sect_range, range))
						S->sect_weave = Swarm__weave_subset(W,
							S->md->sect_range, FALSE, tag, pattern, to, into,
							breadcrumbs, navigation);
		}

	Swarm__weave_index_templates(W, range, pattern, into, navigation, breadcrumbs);
}

#line 51 "inweb/Chapter 1/The Swarm.w"
weave_order *Swarm__weave_subset(web *W, text_stream *range, int open_afterwards,
	theme_tag *tag, weave_pattern *pattern, filename *to, pathname *into,
	linked_list *breadcrumbs, filename *navigation) {
	weave_order *wv = NULL;
	if (no_inweb_errors == 0) {
		Analyser__analyse_code(W);
		
{
#line 91 "inweb/Chapter 1/The Swarm.w"
	wv = CREATE(weave_order);
	wv->weave_web = W;
	wv->weave_range = Str__duplicate(range);
	wv->pattern = pattern;
	wv->theme_match = tag;
	wv->booklet_title = Str__new();
	wv->format = pattern->pattern_format;
	wv->post_processing_results = NULL;
	wv->self_contained = FALSE;
	wv->navigation = navigation;
	wv->breadcrumbs = breadcrumbs;
	wv->plugins = NEW_LINKED_LIST(weave_plugin);
	wv->colour_schemes = NEW_LINKED_LIST(colour_scheme);
	if (Reader__web_has_one_section(W)) wv->self_contained = TRUE;

	wv->current_weave_line = NULL;

	int has_content = FALSE;
	chapter *C;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		LOOP_OVER_LINKED_LIST(S, section, C->sections)
			if (Reader__range_within(S->md->sect_range, wv->weave_range))
				has_content = TRUE;
	if (has_content == FALSE)
		Errors__fatal("no sections match that range");

	TEMPORARY_TEXT(leafname)
	
{
#line 140 "inweb/Chapter 1/The Swarm.w"
	match_results mr = Regexp__create_mr();
	if (Str__eq_wide_string(range, U"0")) {
		if (W->md->single_file) {
			wv->booklet_title = Str__duplicate(Bibliographic__get_datum(W->md, TL_IS_2663));
			Filenames__write_unextended_leafname(leafname, W->md->single_file);
		} else {
			wv->booklet_title = Str__new_from_wide_string(U"Complete Program");
			WRITE_TO(leafname, "Complete");
		}
		if (wv->theme_match) 
{
#line 178 "inweb/Chapter 1/The Swarm.w"
	Str__clear(wv->booklet_title);
	WRITE_TO(wv->booklet_title, "Extracts: %S", wv->theme_match->tag_name);
	Str__copy(leafname, wv->theme_match->tag_name);

}
#line 149 "inweb/Chapter 1/The Swarm.w"
;
	} else if (Regexp__match(&mr, range, U"%d+")) {
		Str__clear(wv->booklet_title);
		WRITE_TO(wv->booklet_title, "Chapter %S", range);
		Str__copy(leafname, wv->booklet_title);
	} else if (Regexp__match(&mr, range, U"%[A-O]")) {
		Str__clear(wv->booklet_title);
		WRITE_TO(wv->booklet_title, "Appendix %S", range);
		Str__copy(leafname, wv->booklet_title);
	} else if (Str__eq_wide_string(range, U"P")) {
		wv->booklet_title = Str__new_from_wide_string(U"Preliminaries");
		Str__copy(leafname, wv->booklet_title);
	} else if (Str__eq_wide_string(range, U"M")) {
		wv->booklet_title = Str__new_from_wide_string(U"Manual");
		Str__copy(leafname, wv->booklet_title);
	} else {
		section *S = Reader__get_section_for_range(W, range);
		if (S) Str__copy(wv->booklet_title, S->md->sect_title);
		else Str__copy(wv->booklet_title, range);
		Str__copy(leafname, range);
	}
	Bibliographic__set_datum(W->md, TL_IS_2664, wv->booklet_title);
	LOOP_THROUGH_TEXT(P, leafname)
		if ((Str__get(P) == '/') || (Str__get(P) == ' '))
			Str__put(P, '-');
	WRITE_TO(leafname, "%S", Formats__file_extension(wv->format));
	Regexp__dispose_of(&mr);

}
#line 119 "inweb/Chapter 1/The Swarm.w"
;
	pathname *H = W->redirect_weaves_to;
	if (H == NULL) H = into;
	if (H == NULL) {
		if (W->md->single_file == NULL)
	 		H = Reader__woven_folder(W);
	 	else
	 		H = Filenames__up(W->md->single_file);
	}
	if (to) {
		wv->weave_to = to;
		wv->self_contained = TRUE;
	} else wv->weave_to = Filenames__in(H, leafname);
	if (Str__len(pattern->initial_extension) > 0)
		wv->weave_to = Filenames__set_extension(wv->weave_to, pattern->initial_extension);
	DISCARD_TEXT(leafname)

}
#line 57 "inweb/Chapter 1/The Swarm.w"
;
		if (Weaver__weave(wv) == 0) /* i.e., the number of lines woven was zero */
			Errors__fatal("empty weave request");
		Patterns__post_process(wv->pattern, wv);
		Formats__post_process_weave(wv, open_afterwards);
		
{
#line 185 "inweb/Chapter 1/The Swarm.w"
	PRINT("[%S: %S -> %f", wv->booklet_title, wv->format->format_name, wv->weave_to);
	Formats__report_on_post_processing(wv);
	PRINT("]\n");

}
#line 62 "inweb/Chapter 1/The Swarm.w"
;
	}
	return wv;
}

#line 89 "inweb/Chapter 1/The Swarm.w"

#line 190 "inweb/Chapter 1/The Swarm.w"
void Swarm__ensure_plugin(weave_order *wv, text_stream *name) {
	weave_plugin *existing;
	LOOP_OVER_LINKED_LIST(existing, weave_plugin, wv->plugins)
		if (Str__eq_insensitive(name, existing->plugin_name))
			return;
	weave_plugin *wp = Assets__new(name);
	ADD_TO_LINKED_LIST(wp, weave_plugin, wv->plugins);
}

colour_scheme *Swarm__ensure_colour_scheme(weave_order *wv, text_stream *name,
	text_stream *pre) {
	colour_scheme *existing;
	LOOP_OVER_LINKED_LIST(existing, colour_scheme, wv->colour_schemes)
		if (Str__eq_insensitive(name, existing->scheme_name))
			return existing;
	colour_scheme *cs = Assets__find_colour_scheme(wv->pattern, name, pre);
	if (cs == NULL) {
		if (Str__eq(name, TL_IS_2665)) {
			TEMPORARY_TEXT(err)
			WRITE_TO(err, "No CSS file for the colour scheme '%S' can be found", name);
			Main__error_in_web(err, NULL);
		} else {
			return Swarm__ensure_colour_scheme(wv, TL_IS_2666, TL_IS_2667);
		}
	}
	if (cs) ADD_TO_LINKED_LIST(cs, colour_scheme, wv->colour_schemes);
	return cs;
}

void Swarm__include_plugins(OUTPUT_STREAM, web *W, weave_order *wv, filename *from) {
	weave_plugin *wp;
	LOOP_OVER_LINKED_LIST(wp, weave_plugin, wv->plugins)
		Assets__include_plugin(OUT, W, wp, wv->pattern, from);
	colour_scheme *cs;
	LOOP_OVER_LINKED_LIST(cs, colour_scheme, wv->colour_schemes)
		Assets__include_colour_scheme(OUT, W, cs, wv->pattern, from);
}

#line 231 "inweb/Chapter 1/The Swarm.w"
void Swarm__weave_index_templates(web *W, text_stream *range, weave_pattern *pattern,
	pathname *into, filename *nav, linked_list *crumbs) {
	if (!(Bibliographic__data_exists(W->md, TL_IS_2668)))
		Bibliographic__set_datum(W->md, TL_IS_2669, TL_IS_2670);
	filename *INF = Patterns__find_template(pattern, TL_IS_2671);
	if (INF) {
		pathname *H = W->redirect_weaves_to;
		if (H == NULL) H = Reader__woven_folder(W);
		filename *Contents = Filenames__in(H, TL_IS_2672);
		text_stream TO_struct; text_stream *OUT = &TO_struct;
		if (STREAM_OPEN_TO_FILE(OUT, Contents, ISO_ENC) == FALSE)
			Errors__fatal_with_file("unable to write contents file", Contents);
		if (W->as_ebook)
			Epub__note_page(W->as_ebook, Contents, TL_IS_2673, TL_IS_2674);
		PRINT("[Index file: %f]\n", Contents);
		Collater__collate(OUT, W, range, INF, pattern, nav, crumbs, NULL, Contents);
		STREAM_CLOSE(OUT);
	}
}

#line 38 "inweb/Chapter 1/Patterns.w"

#line 42 "inweb/Chapter 1/Patterns.w"
weave_pattern *Patterns__find(web *W, text_stream *name) {
	filename *pattern_file = NULL;
	weave_pattern *wp = CREATE(weave_pattern);
	
{
#line 52 "inweb/Chapter 1/Patterns.w"
	wp->pattern_name = Str__duplicate(name);
	wp->pattern_location = NULL;
	wp->plugins = NEW_LINKED_LIST(weave_plugin);
	wp->colour_schemes = NEW_LINKED_LIST(colour_scheme);
	wp->based_on = NULL;
	wp->asset_rules = Assets__new_asset_rules_list();
	wp->patterned_for = W;
	wp->number_sections = FALSE;
	wp->footnotes_plugin = NULL;
	wp->mathematics_plugin = NULL;
	wp->default_range = Str__duplicate(TL_IS_2675);
	wp->initial_extension = NULL;
	wp->post_commands = NEW_LINKED_LIST(text_stream);
	wp->blocked_templates = NEW_LINKED_LIST(text_stream);
	wp->commands = 0;
	wp->name_command_given = FALSE;

}
#line 45 "inweb/Chapter 1/Patterns.w"
;
	
{
#line 70 "inweb/Chapter 1/Patterns.w"
	wp->pattern_location = NULL;
	pathname *CP = Colonies__patterns_path();
	if (CP) {
		wp->pattern_location = Pathnames__down(CP, name);
		pattern_file = Filenames__in(wp->pattern_location, TL_IS_2676);
		if (TextFiles__exists(pattern_file) == FALSE) wp->pattern_location = NULL;
	}
	if (wp->pattern_location == NULL) {
		wp->pattern_location = Pathnames__down(
			Pathnames__down(W->md->path_to_web, TL_IS_2677), name);
		pattern_file = Filenames__in(wp->pattern_location, TL_IS_2678);
		if (TextFiles__exists(pattern_file) == FALSE) wp->pattern_location = NULL;
	}
	if (wp->pattern_location == NULL) {
		wp->pattern_location = Pathnames__down(
			path_to_inweb_patterns, name);
		pattern_file = Filenames__in(wp->pattern_location, TL_IS_2679);
		if (TextFiles__exists(pattern_file) == FALSE) wp->pattern_location = NULL;
	}
	if (wp->pattern_location == NULL)
		Errors__fatal_with_text("no such weave pattern as '%S'", name);

}
#line 46 "inweb/Chapter 1/Patterns.w"
;
	
{
#line 93 "inweb/Chapter 1/Patterns.w"
	if (pattern_file)
		TextFiles__read(pattern_file, FALSE, "can't open pattern.txt file",
			TRUE, Patterns__scan_pattern_line, NULL, wp);
	if (wp->pattern_format == NULL)
		Errors__fatal_with_text("pattern did not specify a format", name);
	if (wp->name_command_given == FALSE)
		Errors__fatal_with_text("pattern did not name itself at the top", name);

}
#line 47 "inweb/Chapter 1/Patterns.w"
;
	return wp;
}

#line 106 "inweb/Chapter 1/Patterns.w"
void Patterns__scan_pattern_line(text_stream *line, text_file_position *tfp, void *X) {
	weave_pattern *wp = (weave_pattern *) X;

	Str__trim_white_space(line); /* ignore trailing space */
	if (Str__len(line) == 0) return; /* ignore blank lines */
	if (Str__get_first_char(line) == '#') return; /* lines opening with |#| are comments */

	wp->commands++;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c+) *: *(%c+?)")) {
		text_stream *key = mr.exp[0], *value = Str__duplicate(mr.exp[1]);
		if ((Str__eq_insensitive(key, TL_IS_2680)) && (wp->commands == 1)) {
			match_results mr2 = Regexp__create_mr();
			if (Regexp__match(&mr2, value, U"(%c+?) based on (%c+)")) {
				if (Str__ne_insensitive(mr2.exp[0], wp->pattern_name)) {
					Errors__in_text_file("wrong pattern name", tfp);
				}
				wp->based_on = Patterns__find(wp->patterned_for, mr2.exp[1]);
				wp->pattern_format = wp->based_on->pattern_format;
				wp->number_sections = wp->based_on->number_sections;
				wp->default_range = Str__duplicate(wp->based_on->default_range);
				wp->mathematics_plugin = Str__duplicate(wp->based_on->mathematics_plugin);
				wp->footnotes_plugin = Str__duplicate(wp->based_on->footnotes_plugin);
			} else {
				if (Str__ne_insensitive(value, wp->pattern_name)) {
					Errors__in_text_file("wrong pattern name", tfp);
				}
			}
			Regexp__dispose_of(&mr2);
			wp->name_command_given = TRUE;
		} else if (Str__eq_insensitive(key, TL_IS_2681)) {
			text_stream *name = Patterns__plugin_name(value, tfp);
			if (Str__len(name) > 0) {
				weave_plugin *plugin = Assets__new(name);
				ADD_TO_LINKED_LIST(plugin, weave_plugin, wp->plugins);
			}
		} else if (Str__eq_insensitive(key, TL_IS_2682)) {
			wp->pattern_format = Formats__find_by_name(value);
		} else if (Str__eq_insensitive(key, TL_IS_2683)) {
			wp->number_sections = Patterns__yes_or_no(value, tfp);
		} else if (Str__eq_insensitive(key, TL_IS_2684)) {
			wp->default_range = Str__duplicate(value);
		} else if (Str__eq_insensitive(key, TL_IS_2685)) {
			wp->initial_extension = Str__duplicate(value);
		} else if (Str__eq_insensitive(key, TL_IS_2686)) {
			wp->mathematics_plugin = Patterns__plugin_name(value, tfp);
		} else if (Str__eq_insensitive(key, TL_IS_2687)) {
			wp->footnotes_plugin = Patterns__plugin_name(value, tfp);
		} else if (Str__eq_insensitive(key, TL_IS_2688)) {
			ADD_TO_LINKED_LIST(Str__duplicate(value), text_stream, wp->blocked_templates);
		} else if (Str__eq_insensitive(key, TL_IS_2689)) {
			ADD_TO_LINKED_LIST(Str__duplicate(value), text_stream, wp->post_commands);
		} else if (Str__eq_insensitive(key, TL_IS_2690)) {
			match_results mr2 = Regexp__create_mr();
			if (Regexp__match(&mr2, value, U"(%c+?) = (%c+)")) {
				Bibliographic__set_datum(wp->patterned_for->md, mr2.exp[0], mr2.exp[1]);
			} else {
				Errors__in_text_file("syntax is 'bibliographic data: X = Y'", tfp);
			}
			Regexp__dispose_of(&mr2);
		} else if (Str__eq_insensitive(key, TL_IS_2691)) {
			match_results mr2 = Regexp__create_mr();
			if (Regexp__match(&mr2, value, U"(.%C+?) (%c+)")) {
				Assets__add_asset_rule(wp->asset_rules, mr2.exp[0], mr2.exp[1], tfp);
			} else {
				Errors__in_text_file("syntax is 'assets: .EXT COMMAND'", tfp);
			}
			Regexp__dispose_of(&mr2);
		} else {
			Errors__in_text_file("unrecognised pattern command", tfp);
		}
	} else {
		Errors__in_text_file("unrecognised pattern command", tfp);
	}
	Regexp__dispose_of(&mr);
}

#line 184 "inweb/Chapter 1/Patterns.w"
int Patterns__yes_or_no(text_stream *arg, text_file_position *tfp) {
	if (Str__eq(arg, TL_IS_2692)) return TRUE;
	if (Str__eq(arg, TL_IS_2693)) return FALSE;
	Errors__in_text_file("setting must be 'yes' or 'no'", tfp);
	return FALSE;
}

text_stream *Patterns__plugin_name(text_stream *arg, text_file_position *tfp) {
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, arg, U"(%i+)")) {
		if (Str__eq_insensitive(arg, TL_IS_2694)) return NULL;
	} else {
		Errors__in_text_file("plugin names must be single alphanumeric words", tfp);
		arg = NULL;
	}
	Regexp__dispose_of(&mr);
	return Str__duplicate(arg);
}

#line 208 "inweb/Chapter 1/Patterns.w"
void Patterns__post_process(weave_pattern *pattern, weave_order *wv) {
	text_stream *T;
	LOOP_OVER_LINKED_LIST(T, text_stream, pattern->post_commands) {
		filename *last_F = NULL;
		TEMPORARY_TEXT(cmd)
		for (int i=0; i<Str__len(T); i++) {
			if (Str__includes_at(T, i, TL_IS_2695)) {
				Shell__quote_path(cmd, Filenames__up(wv->weave_to));
				i += 8;
			} else if (Str__includes_at(T, i, TL_IS_2696)) {
				filename *W = wv->weave_to;
				i += 5;
				if (Str__get_at(T, i) == '.') {
					i++;
					TEMPORARY_TEXT(ext)
					while (Characters__isalpha(Str__get_at(T, i)))
						PUT_TO(ext,Str__get_at(T, i++));
					W = Filenames__set_extension(W, ext);
					DISCARD_TEXT(ext)
				}
				Shell__quote_file(cmd, W);
				last_F = W;
				i--;
			} else PUT_TO(cmd, Str__get_at(T, i));
		}
		if ((Str__includes_at(cmd, 0, TL_IS_2697)) && (last_F)) {
			TeXUtilities__post_process_weave(wv, last_F);
		} else {
			if (verbose_mode) PRINT("(%S)\n", cmd);
			int rv = Shell__run(cmd);
			if (rv != 0) Errors__fatal("post-processing command failed");
		}
		DISCARD_TEXT(cmd)
	}
}

#line 252 "inweb/Chapter 1/Patterns.w"
filename *Patterns__find_template(weave_pattern *pattern, text_stream *leafname) {
	for (weave_pattern *wp = pattern; wp; wp = wp->based_on) {
		text_stream *T;
		LOOP_OVER_LINKED_LIST(T, text_stream, pattern->blocked_templates)
			if (Str__eq_insensitive(T, leafname))
				return NULL;
		filename *F = Filenames__in(wp->pattern_location, leafname);
		if (TextFiles__exists(F)) return F;
	}
	return NULL;
}

#line 267 "inweb/Chapter 1/Patterns.w"
filename *Patterns__find_file_in_subdirectory(weave_pattern *pattern,
	text_stream *dirname, text_stream *leafname) {
	for (weave_pattern *wp = pattern; wp; wp = wp->based_on) {
		pathname *P = Pathnames__down(wp->pattern_location, dirname);
		filename *F = Filenames__in(P, leafname);
		if (TextFiles__exists(F)) return F;
	}
	return NULL;
}

#line 278 "inweb/Chapter 1/Patterns.w"
void Patterns__include_plugins(OUTPUT_STREAM, web *W, weave_pattern *pattern, filename *from) {
	for (weave_pattern *p = pattern; p; p = p->based_on) {
		weave_plugin *wp;
		LOOP_OVER_LINKED_LIST(wp, weave_plugin, p->plugins)
			Assets__include_plugin(OUT, W, wp, pattern, from);
		colour_scheme *cs;
		LOOP_OVER_LINKED_LIST(cs, colour_scheme, p->colour_schemes)
			Assets__include_colour_scheme(OUT, W, cs, pattern, from);
	}
}

#line 17 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"

#line 19 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
weave_plugin *Assets__new(text_stream *name) {
	weave_plugin *wp;
	LOOP_OVER(wp, weave_plugin)
		if (Str__eq_insensitive(wp->plugin_name, name))
			return wp;
	wp = CREATE(weave_plugin);
	wp->plugin_name = Str__duplicate(name);
	wp->last_included_in_round = 0;
	return wp;
}

#line 41 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"

#line 43 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
colour_scheme *Assets__find_colour_scheme(weave_pattern *pattern,
	text_stream *name, text_stream *pre) {
	colour_scheme *cs;
	LOOP_OVER(cs, colour_scheme)
		if (Str__eq_insensitive(cs->scheme_name, name))
			return cs;
	TEMPORARY_TEXT(css)
	WRITE_TO(css, "%S.css", name);
	filename *F = Patterns__find_file_in_subdirectory(pattern, TL_IS_2698, css);
	if (F == NULL) F = Patterns__find_file_in_subdirectory(pattern, TL_IS_2699, css);
	DISCARD_TEXT(css)
	if (F == NULL) return NULL;
	cs = CREATE(colour_scheme);
	cs->scheme_name = Str__duplicate(name);
	cs->at = F;
	cs->prefix = Str__duplicate(pre);
	cs->last_included_in_round = 0;
	if (Str__len(pre) > 0) WRITE_TO(cs->prefix, "-");
	return cs;
}

#line 70 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
int current_inclusion_round = 0;
void Assets__include_relevant_plugins(text_stream *OUT, weave_pattern *pattern,
	web *W, weave_order *wv, filename *from) {
	current_inclusion_round++;
	STREAM_INDENT(STDOUT);
	Patterns__include_plugins(OUT, W, pattern, from);
	if (wv) Swarm__include_plugins(OUT, W, wv, from);
	STREAM_OUTDENT(STDOUT);
}

#line 94 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void Assets__include_plugin(OUTPUT_STREAM, web *W, weave_plugin *wp,
	weave_pattern *pattern, filename *from) {
	if (wp->last_included_in_round == current_inclusion_round) return;
	wp->last_included_in_round = current_inclusion_round;
	if (verbose_mode) PRINT("Include plugin '%S'\n", wp->plugin_name);
	int finds = 0;
	dictionary *leaves_gathered = Dictionaries__new(128, TRUE);
	for (weave_pattern *p = pattern; p; p = p->based_on) {
		pathname *P = Pathnames__down(p->pattern_location, wp->plugin_name);
		scan_directory *D = Directories__open(P);
		if (D) {
			TEMPORARY_TEXT(leafname)
			while (Directories__next(D, leafname)) {
				if ((Platform__is_folder_separator(Str__get_last_char(leafname)) == FALSE) &&
					(Str__get_first_char(leafname) != '.')) {
					if (Dictionaries__find(leaves_gathered, leafname) == NULL) {
						WRITE_TO(Dictionaries__create_text(leaves_gathered, leafname), "y");
						filename *F = Filenames__in(P, leafname);
						Assets__include_asset(OUT, NULL, W, F, NULL, pattern, from);
						finds++;
					}
				}
			}
			DISCARD_TEXT(leafname)
			Directories__close(D);
		}
	}
	if (finds == 0) {
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "The plugin '%S' is not supported", wp->plugin_name);
		Main__error_in_web(err, NULL);
	}
}

#line 135 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void Assets__include_colour_scheme(OUTPUT_STREAM, web *W, colour_scheme *cs,
	weave_pattern *pattern, filename *from) {
	if (cs->last_included_in_round == current_inclusion_round) return;
	cs->last_included_in_round = current_inclusion_round;
	if (verbose_mode) PRINT("Include colour scheme '%S'\n", cs->scheme_name);
	TEMPORARY_TEXT(css)
	WRITE_TO(css, "%S.css", cs->scheme_name);
	filename *F = Patterns__find_file_in_subdirectory(pattern, TL_IS_2700, css);
	if (F == NULL) F = Patterns__find_file_in_subdirectory(pattern, TL_IS_2701, css);
	if (F == NULL) {
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "No CSS file for the colour scheme '%S' can be found",
			cs->scheme_name);
		Main__error_in_web(err, NULL);
		DISCARD_TEXT(err)
	} else {
		Assets__include_asset(OUT, NULL, W, F, cs->prefix, pattern, from);
	}
	DISCARD_TEXT(css)
}

#line 166 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"

#line 176 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"

#line 184 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
linked_list *Assets__new_asset_rules_list(void) {
	linked_list *L = NEW_LINKED_LIST(asset_rule);
	Assets__add_asset_rule(L, TL_IS_2702, TL_IS_2703, NULL);
	return L;
}

#line 194 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
void Assets__add_asset_rule(linked_list *L, text_stream *ext, text_stream *line,
	text_file_position *tfp) {
	asset_rule *R = Assets__new_rule(L, ext, line, tfp);
	ADD_TO_LINKED_LIST(R, asset_rule, L);
}

asset_rule *Assets__new_rule(linked_list *L, text_stream *ext, text_stream *line,
	text_file_position *tfp) {
	asset_rule *R;
	if (L)
		LOOP_OVER_LINKED_LIST(R, asset_rule, L)
			if (Str__eq_insensitive(R->applies_to, ext)) {
				
{
#line 223 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	text_stream *cmd = line;
	text_stream *detail = NULL;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c+?) *= *(%c*)")) {
		cmd = mr.exp[0];
		detail = mr.exp[1];
	}
	if (Str__eq(cmd, TL_IS_2704)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 231 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = COPY_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2705)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 233 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = PRIVATE_COPY_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2706)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 235 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = EMBED_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2707)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 237 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = COLLATE_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2708)) {
		R->pre = Str__duplicate(detail);
	} else if (Str__eq(cmd, TL_IS_2709)) {
		R->post = Str__duplicate(detail);
	} else if (Str__eq(cmd, TL_IS_2710)) {
		R->transform_names = TRUE;
	} else Errors__in_text_file("no such asset command", tfp);
	Regexp__dispose_of(&mr);

}
#line 206 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
;
				return R;
			}
	R = CREATE(asset_rule);
	R->applies_to = Str__duplicate(ext);
	
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 211 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
;
 	
{
#line 223 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	text_stream *cmd = line;
	text_stream *detail = NULL;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c+?) *= *(%c*)")) {
		cmd = mr.exp[0];
		detail = mr.exp[1];
	}
	if (Str__eq(cmd, TL_IS_2704)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 231 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = COPY_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2705)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 233 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = PRIVATE_COPY_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2706)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 235 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = EMBED_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2707)) {
		
{
#line 217 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	R->method = COPY_ASSET_METHOD;
 	R->pre = Str__new();
 	R->post = Str__new();
 	R->transform_names = FALSE;

}
#line 237 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; R->method = COLLATE_ASSET_METHOD;
	} else if (Str__eq(cmd, TL_IS_2708)) {
		R->pre = Str__duplicate(detail);
	} else if (Str__eq(cmd, TL_IS_2709)) {
		R->post = Str__duplicate(detail);
	} else if (Str__eq(cmd, TL_IS_2710)) {
		R->transform_names = TRUE;
	} else Errors__in_text_file("no such asset command", tfp);
	Regexp__dispose_of(&mr);

}
#line 212 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
;
 	return R;
}

#line 252 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
asset_rule *Assets__applicable_rule(weave_pattern *pattern, filename *F) {
	TEMPORARY_TEXT(ext)
	Filenames__write_extension(ext, F);
	for (weave_pattern *p = pattern; p; p = p->based_on) {
		asset_rule *R;
		LOOP_OVER_LINKED_LIST(R, asset_rule, p->asset_rules)
			if (Str__eq_insensitive(R->applies_to, ext))
				return R;
	}
	asset_rule *R;
	LOOP_OVER_LINKED_LIST(R, asset_rule, pattern->asset_rules)
		if (Str__eq_insensitive(R->applies_to, TL_IS_2711))
			return R;
	internal_error("no default asset rule");
	return NULL;
}

#line 274 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
pathname *Assets__include_asset(OUTPUT_STREAM, asset_rule *R, web *W, filename *F,
	text_stream *trans, weave_pattern *pattern, filename *from) {
	if (R == NULL) R = Assets__applicable_rule(pattern, F);
	TEMPORARY_TEXT(url)
	pathname *AP = Colonies__assets_path();
	if (AP) Pathnames__relative_URL(url, Filenames__up(from), AP);
	WRITE_TO(url, "%S", Filenames__get_leafname(F));
	if (R->transform_names == FALSE) trans = NULL;
	pathname *result = NULL;
	if (Str__len(R->pre) > 0) 
{
#line 296 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	for (int i=0; i<Str__len(R->pre); i++) {
		if (Str__includes_at(R->pre, i, TL_IS_2712)) {
			WRITE("%S", url);
			i += 2;
		} else PUT(Str__get_at(R->pre, i));
	}
	WRITE("\n");

}
#line 283 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
;
	switch (R->method) {
		case EMBED_ASSET_METHOD: 
{
#line 305 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	if (verbose_mode) PRINT("Embed asset %f\n", F);
	Assets__transform(OUT, F, trans);

}
#line 285 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; break;
		case COPY_ASSET_METHOD: 
{
#line 309 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	pathname *H = W->redirect_weaves_to;
	if (H == NULL) H = Reader__woven_folder(W);
	if ((AP) && (R->method != PRIVATE_COPY_ASSET_METHOD)) H = AP;
	if (verbose_mode) PRINT("Copy asset %f -> %p\n", F, H);
	if (Str__len(trans) > 0) {
		text_stream css_S;
		filename *G = Filenames__in(H, Filenames__get_leafname(F));
		if (STREAM_OPEN_TO_FILE(&css_S, G, ISO_ENC) == FALSE)
			Errors__fatal_with_file("unable to write tangled file", F);
		Assets__transform(&css_S, F, trans);
		STREAM_CLOSE(&css_S);
	} else {
		Shell__copy(F, H, "");
		result = H;
	}
	if (W->as_ebook) {
		filename *rel = Filenames__in(NULL, Filenames__get_leafname(F));
		Epub__note_image(W->as_ebook, rel);
	}

}
#line 286 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; break;
		case PRIVATE_COPY_ASSET_METHOD: 
{
#line 309 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	pathname *H = W->redirect_weaves_to;
	if (H == NULL) H = Reader__woven_folder(W);
	if ((AP) && (R->method != PRIVATE_COPY_ASSET_METHOD)) H = AP;
	if (verbose_mode) PRINT("Copy asset %f -> %p\n", F, H);
	if (Str__len(trans) > 0) {
		text_stream css_S;
		filename *G = Filenames__in(H, Filenames__get_leafname(F));
		if (STREAM_OPEN_TO_FILE(&css_S, G, ISO_ENC) == FALSE)
			Errors__fatal_with_file("unable to write tangled file", F);
		Assets__transform(&css_S, F, trans);
		STREAM_CLOSE(&css_S);
	} else {
		Shell__copy(F, H, "");
		result = H;
	}
	if (W->as_ebook) {
		filename *rel = Filenames__in(NULL, Filenames__get_leafname(F));
		Epub__note_image(W->as_ebook, rel);
	}

}
#line 287 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; break;
		case COLLATE_ASSET_METHOD: 
{
#line 330 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	if (verbose_mode) PRINT("Collate asset %f\n", F);
	Collater__for_web_and_pattern(OUT, W, pattern, F, from);

}
#line 288 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
; break;
	}
	if (Str__len(R->post) > 0) 
{
#line 334 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
	for (int i=0; i<Str__len(R->post); i++) {
		if (Str__includes_at(R->post, i, TL_IS_2713)) {
			WRITE("%S", url);
			i += 2;
		} else PUT(Str__get_at(R->post, i));
	}
	WRITE("\n");

}
#line 290 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"
;
	DISCARD_TEXT(url)
	return result;
}

#line 352 "inweb/Chapter 1/Assets, Plugins and Colour Schemes.w"

void Assets__transform(text_stream *OUT, filename *F, text_stream *trans) {
	css_file_transformation cft;
	cft.OUT = OUT;
	cft.trans = trans;
	TextFiles__read(F, FALSE, "can't open file", TRUE,
		Assets__transformer, NULL, (void *) &cft);
}

void Assets__transformer(text_stream *line, text_file_position *tfp, void *X) {
	css_file_transformation *cft = (css_file_transformation *) X;
	text_stream *OUT = cft->OUT;
	match_results mr = Regexp__create_mr();
	TEMPORARY_TEXT(spanned)
	while (Regexp__match(&mr, line, U"(%c*?span.)(%i+)(%c*?)")) {
		WRITE_TO(spanned, "%S%S%S", mr.exp[0], cft->trans, mr.exp[1]);
		Str__clear(line); Str__copy(line, mr.exp[2]);
	}
	WRITE_TO(spanned, "%S\n", line);
	while (Regexp__match(&mr, spanned, U"(%c*?pre.)(%i+)(%c*?)")) {
		WRITE("%S%S%S", mr.exp[0], cft->trans, mr.exp[1]);
		Str__clear(spanned); Str__copy(spanned, mr.exp[2]);
	}
	WRITE("%S", spanned);
	DISCARD_TEXT(spanned)
	Regexp__dispose_of(&mr);
}

#line 47 "inweb/Chapter 2/The Reader.w"

#line 61 "inweb/Chapter 2/The Reader.w"

#line 92 "inweb/Chapter 2/The Reader.w"

#line 97 "inweb/Chapter 2/The Reader.w"
web_md *Reader__load_web_md(pathname *P, filename *alt_F, module_search *I,
	int including_modules) {
	return WebMetadata__get(P, alt_F, default_inweb_syntax, I, verbose_mode,
		including_modules, path_to_inweb);
}

web *Reader__load_web(pathname *P, filename *alt_F, module_search *I,
	int including_modules) {

	web *W = CREATE(web);
	W->md = Reader__load_web_md(P, alt_F, I, including_modules);
	tangle_target *main_target = NULL;

	
{
#line 134 "inweb/Chapter 2/The Reader.w"
	TEMPORARY_TEXT(IB)
	WRITE_TO(IB, "7.2.1");
	web_bibliographic_datum *bd = Bibliographic__set_datum(W->md, TL_IS_2714, IB);
	bd->declaration_permitted = FALSE;
	DISCARD_TEXT(IB)

}
#line 110 "inweb/Chapter 2/The Reader.w"
;
	
{
#line 141 "inweb/Chapter 2/The Reader.w"
	W->chapters = NEW_LINKED_LIST(chapter);
	W->headers = NEW_LINKED_LIST(filename);
	W->language_types = NEW_LINKED_LIST(language_type);
	W->tangle_targets = NEW_LINKED_LIST(tangle_target);
	W->analysed = FALSE;
	W->as_ebook = NULL;
	W->redirect_weaves_to = NULL;
	W->main_language = Analyser__default_language(W);
	W->web_extent = 0; W->no_paragraphs = 0;
	text_stream *language_name = Bibliographic__get_datum(W->md, TL_IS_2715);
	if (Str__len(language_name) > 0)
		W->main_language = Analyser__find_by_name(language_name, W, TRUE);
	main_target = Reader__add_tangle_target(W, W->main_language);

}
#line 111 "inweb/Chapter 2/The Reader.w"
;
	chapter_md *Cm;
	LOOP_OVER_LINKED_LIST(Cm, chapter_md, W->md->chapters_md) {
		chapter *C = CREATE(chapter);
		C->md = Cm;
		C->owning_web = W;
		
{
#line 156 "inweb/Chapter 2/The Reader.w"
	C->ch_weave = NULL;
	C->titling_line_inserted = FALSE;
	C->sections = NEW_LINKED_LIST(section);
	C->ch_language = W->main_language;
	if (Str__len(Cm->ch_language_name) > 0)
		C->ch_language = Analyser__find_by_name(Cm->ch_language_name, W, TRUE);

}
#line 117 "inweb/Chapter 2/The Reader.w"
;
		ADD_TO_LINKED_LIST(C, chapter, W->chapters);
		section_md *Sm;
		LOOP_OVER_LINKED_LIST(Sm, section_md, Cm->sections_md) {
			section *S = CREATE(section);
			S->md = Sm;
			S->owning_chapter = C;
			S->owning_web = W;
			
{
#line 164 "inweb/Chapter 2/The Reader.w"
	S->sect_extent = 0;
	S->first_line = NULL; S->last_line = NULL;
	S->sect_paragraphs = 0;
	S->paragraphs = NEW_LINKED_LIST(paragraph);
	S->macros = NEW_LINKED_LIST(para_macro);

	S->scratch_flag = FALSE;
	S->barred = FALSE;
	S->printed_number = -1;
	S->sect_weave = NULL;
	S->sect_namespace = Str__new();
	S->owning_web = W;
	S->sect_language = C->ch_language;
	if (Str__len(S->md->sect_language_name) > 0)
		S->sect_language = Analyser__find_by_name(S->md->sect_language_name, W, TRUE);
	if (Str__len(S->md->sect_independent_language) > 0) {
		programming_language *pl =
			Analyser__find_by_name(S->md->sect_independent_language, W, TRUE);
		S->sect_language = pl;
		S->sect_target = Reader__add_tangle_target(W, pl);
	} else {
		S->sect_target = main_target;
	}
	S->tag_with = NULL;
	if (Str__len(Sm->tag_name) > 0)
		S->tag_with = Tags__add_by_name(NULL, Sm->tag_name);

}
#line 125 "inweb/Chapter 2/The Reader.w"
;
			ADD_TO_LINKED_LIST(S, section, C->sections);
		}
	}
	
{
#line 192 "inweb/Chapter 2/The Reader.w"
	filename *HF;
	LOOP_OVER_LINKED_LIST(HF, filename, W->md->header_filenames)
		Reader__add_imported_header(W, HF);

}
#line 129 "inweb/Chapter 2/The Reader.w"
;
	return W;
}

#line 205 "inweb/Chapter 2/The Reader.w"
void Reader__read_web(web *W) {
	chapter *C;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		LOOP_OVER_LINKED_LIST(S, section, C->sections)
			Reader__read_file(W, C,
				S->md->source_file_for_section,
				S->md->titling_line_to_insert, S,
				(W->md->single_file)?TRUE:FALSE);
}

#line 219 "inweb/Chapter 2/The Reader.w"
void Reader__read_file(web *W, chapter *C, filename *F, text_stream *titling_line,
	section *S, int disregard_top) {
	S->owning_chapter = C;
	if (disregard_top)
		S->paused_until_at = TRUE;
	else
		S->paused_until_at = FALSE;

	if ((titling_line) && (Str__len(titling_line) > 0) &&
		(S->owning_chapter->titling_line_inserted == FALSE))
		
{
#line 240 "inweb/Chapter 2/The Reader.w"
	S->owning_chapter->titling_line_inserted = TRUE;
	TEMPORARY_TEXT(line)
	text_file_position *tfp = NULL;
	WRITE_TO(line, "Chapter Heading");
	
{
#line 282 "inweb/Chapter 2/The Reader.w"
	source_line *sl = Lines__new_source_line_in(line, tfp, S);

	/* enter this in its section's linked list of lines: */
	if (S->first_line == NULL) S->first_line = sl;
	else S->last_line->next_line = sl;
	S->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

}
#line 244 "inweb/Chapter 2/The Reader.w"
;
	DISCARD_TEXT(line)

}
#line 229 "inweb/Chapter 2/The Reader.w"
;

	if (disregard_top)
		
{
#line 248 "inweb/Chapter 2/The Reader.w"
	TEMPORARY_TEXT(line)
	text_file_position *tfp = NULL;
	WRITE_TO(line, "Main.");
	
{
#line 282 "inweb/Chapter 2/The Reader.w"
	source_line *sl = Lines__new_source_line_in(line, tfp, S);

	/* enter this in its section's linked list of lines: */
	if (S->first_line == NULL) S->first_line = sl;
	else S->last_line->next_line = sl;
	S->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

}
#line 251 "inweb/Chapter 2/The Reader.w"
;
	Str__clear(line);
	
{
#line 282 "inweb/Chapter 2/The Reader.w"
	source_line *sl = Lines__new_source_line_in(line, tfp, S);

	/* enter this in its section's linked list of lines: */
	if (S->first_line == NULL) S->first_line = sl;
	else S->last_line->next_line = sl;
	S->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

}
#line 253 "inweb/Chapter 2/The Reader.w"
;
	text_stream *purpose = Bibliographic__get_datum(W->md, TL_IS_2716);
	if (Str__len(purpose) > 0) {
		Str__clear(line);
		WRITE_TO(line, "Implied Purpose: %S", purpose);
		
{
#line 282 "inweb/Chapter 2/The Reader.w"
	source_line *sl = Lines__new_source_line_in(line, tfp, S);

	/* enter this in its section's linked list of lines: */
	if (S->first_line == NULL) S->first_line = sl;
	else S->last_line->next_line = sl;
	S->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

}
#line 258 "inweb/Chapter 2/The Reader.w"
;
		Str__clear(line);
		
{
#line 282 "inweb/Chapter 2/The Reader.w"
	source_line *sl = Lines__new_source_line_in(line, tfp, S);

	/* enter this in its section's linked list of lines: */
	if (S->first_line == NULL) S->first_line = sl;
	else S->last_line->next_line = sl;
	S->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

}
#line 260 "inweb/Chapter 2/The Reader.w"
;
	}
	DISCARD_TEXT(line)

}
#line 232 "inweb/Chapter 2/The Reader.w"
;

	int cl = TextFiles__read(F, FALSE, "can't open section file", TRUE,
		Reader__scan_source_line, NULL, (void *) S);
	if (verbose_mode) PRINT("Read section: '%S' (%d lines)\n", S->md->sect_title, cl);
}

#line 269 "inweb/Chapter 2/The Reader.w"
void Reader__scan_source_line(text_stream *line, text_file_position *tfp, void *state) {
	section *S = (section *) state;
	int l = Str__len(line) - 1;
	while ((l>=0) && (Characters__is_space_or_tab(Str__get_at(line, l))))
		Str__truncate(line, l--);
	if (S->paused_until_at) {
		if (Str__get_at(line, 0) == '@') S->paused_until_at = FALSE;
		else return;
	}
	
{
#line 282 "inweb/Chapter 2/The Reader.w"
	source_line *sl = Lines__new_source_line_in(line, tfp, S);

	/* enter this in its section's linked list of lines: */
	if (S->first_line == NULL) S->first_line = sl;
	else S->last_line->next_line = sl;
	S->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

}
#line 278 "inweb/Chapter 2/The Reader.w"
;
}

#line 296 "inweb/Chapter 2/The Reader.w"
pathname *Reader__woven_folder(web *W) {
	pathname *P = Pathnames__down(W->md->path_to_web, TL_IS_2717);
	if (Pathnames__create_in_file_system(P) == FALSE)
		Errors__fatal_with_path("unable to create Woven subdirectory", P);
	return P;
}
pathname *Reader__tangled_folder(web *W) {
	pathname *P = Pathnames__down(W->md->path_to_web, TL_IS_2718);
	if (Pathnames__create_in_file_system(P) == FALSE)
		Errors__fatal_with_path("unable to create Tangled subdirectory", P);
	return P;
}

#line 317 "inweb/Chapter 2/The Reader.w"
chapter *Reader__get_chapter_for_range(web *W, text_stream *range) {
	chapter *C;
	if (W)
		LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
			if (Str__eq(C->md->ch_range, range))
				return C;
	return NULL;
}

section *Reader__get_section_for_range(web *W, text_stream *range) {
	chapter *C;
	section *S;
	if (W)
		LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
			LOOP_OVER_LINKED_LIST(S, section, C->sections)
				if (Str__eq(S->md->sect_range, range))
					return S;
	return NULL;
}

#line 340 "inweb/Chapter 2/The Reader.w"
section *Reader__section_by_filename(web *W, text_stream *filename) {
	chapter *C;
	section *S;
	if (W)
		LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
			LOOP_OVER_LINKED_LIST(S, section, C->sections) {
				TEMPORARY_TEXT(SFN)
				WRITE_TO(SFN, "%f", S->md->source_file_for_section);
				int rv = Str__eq(SFN, filename);
				DISCARD_TEXT(SFN)
				if (rv) return S;
			}
	return NULL;
}

#line 362 "inweb/Chapter 2/The Reader.w"
int Reader__range_within(text_stream *range1, text_stream *range2) {
	if (Str__eq_wide_string(range2, U"0")) return TRUE;
	if (Str__eq(range1, range2)) return TRUE;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, range2, U"%c+/%c+")) { Regexp__dispose_of(&mr); return FALSE; }
	if (Regexp__match(&mr, range1, U"(%c+)/%c+")) {
		if (Str__eq(mr.exp[0], range2)) { Regexp__dispose_of(&mr); return TRUE; }
	}
	return FALSE;
}

#line 389 "inweb/Chapter 2/The Reader.w"

#line 391 "inweb/Chapter 2/The Reader.w"
tangle_target *Reader__add_tangle_target(web *W, programming_language *language) {
	tangle_target *tt = CREATE(tangle_target);
	tt->tangle_language = language;
	ReservedWords__initialise_hash_table(&(tt->symbols));
	ADD_TO_LINKED_LIST(tt, tangle_target, W->tangle_targets);
	return tt;
}

#line 415 "inweb/Chapter 2/The Reader.w"
void Reader__add_imported_header(web *W, filename *HF) {
	ADD_TO_LINKED_LIST(HF, filename, W->headers);
}

#line 422 "inweb/Chapter 2/The Reader.w"
int Reader__web_has_one_section(web *W) {
	if (WebMetadata__section_count(W->md) == 1) return TRUE;
	return FALSE;
}

#line 430 "inweb/Chapter 2/The Reader.w"
void Reader__print_web_statistics(web *W) {
	PRINT("web \"%S\": ", Bibliographic__get_datum(W->md, TL_IS_2719));
	int c = WebMetadata__chapter_count(W->md);
	int s = WebMetadata__section_count(W->md);
	if (W->md->chaptered) PRINT("%d chapter%s : ",
		c, (c == 1)?"":"s");
	PRINT("%d section%s : %d paragraph%s : %d line%s\n",
		s, (s == 1)?"":"s",
		W->no_paragraphs, (W->no_paragraphs == 1)?"":"s",
		W->web_extent, (W->web_extent == 1)?"":"s");
}



#line 45 "inweb/Chapter 2/Line Categories.w"

#line 47 "inweb/Chapter 2/Line Categories.w"
source_line *Lines__new_source_line_in(text_stream *line, text_file_position *tfp,
	section *S) {
	source_line *sl = CREATE(source_line);
	sl->text = Str__duplicate(line);
	sl->text_operand = Str__new();
	sl->text_operand2 = Str__new();

	sl->category = NO_LCAT; /* that is, unknown category as yet */
	sl->command_code = NO_CMD;
	sl->default_defn = FALSE;
	sl->plainer = FALSE;
	sl->enable_hyperlinks = FALSE;
	sl->colour_as = NULL;
	sl->extract_to = NULL;
	sl->is_commentary = FALSE;
	sl->function_defined = NULL;
	sl->preform_nonterminal_defined = NULL;
	sl->suppress_tangling = FALSE;
	sl->interface_line_identified = FALSE;
	sl->footnote_text = NULL;

	if (tfp) sl->source = *tfp; else sl->source = TextFiles__nowhere();

	sl->owning_section = S;
	sl->owning_section->sect_extent++;
	sl->owning_section->owning_chapter->owning_web->web_extent++;

	sl->next_line = NULL;
	sl->owning_paragraph = NULL;
	return sl;
}

#line 87 "inweb/Chapter 2/Line Categories.w"

#line 113 "inweb/Chapter 2/Line Categories.w"

#line 118 "inweb/Chapter 2/Line Categories.w"
char *Lines__category_name(int cat) {
	switch (cat) {
		case NO_LCAT: return "(uncategorised)";

		case BAR_LCAT: return "BAR";
		case BEGIN_CODE_LCAT: return "BEGIN_CODE";
		case BEGIN_DEFINITION_LCAT: return "BEGIN_DEFINITION";
		case C_LIBRARY_INCLUDE_LCAT: return "C_LIBRARY_INCLUDE";
		case CHAPTER_HEADING_LCAT: return "CHAPTER_HEADING";
		case CODE_BODY_LCAT: return "CODE_BODY";
		case COMMAND_LCAT: return "COMMAND";
		case COMMENT_BODY_LCAT: return "COMMENT_BODY";
		case CONT_DEFINITION_LCAT: return "CONT_DEFINITION";
		case DEFINITIONS_LCAT: return "DEFINITIONS";
		case END_EXTRACT_LCAT: return "END_EXTRACT";
		case FOOTNOTE_TEXT_LCAT: return "FOOTNOTE_TEXT";
		case HEADING_START_LCAT: return "HEADING_START";
		case INTERFACE_BODY_LCAT: return "INTERFACE_BODY";
		case INTERFACE_LCAT: return "INTERFACE";
		case MACRO_DEFINITION_LCAT: return "MACRO_DEFINITION";
		case PARAGRAPH_START_LCAT: return "PARAGRAPH_START";
		case PREFORM_GRAMMAR_LCAT: return "PREFORM_GRAMMAR";
		case PREFORM_LCAT: return "PREFORM";
		case PURPOSE_BODY_LCAT: return "PURPOSE_BODY";
		case PURPOSE_LCAT: return "PURPOSE";
		case SECTION_HEADING_LCAT: return "SECTION_HEADING";
		case SOURCE_DISPLAY_LCAT: return "SOURCE_DISPLAY";
		case TEXT_EXTRACT_LCAT: return "TEXT_EXTRACT";
		case TYPEDEF_LCAT: return "TYPEDEF";
	}
	return "(?unknown)";
}

#line 170 "inweb/Chapter 2/Line Categories.w"

#line 17 "inweb/Chapter 2/The Parser.w"
void Parser__parse_web(web *W, int inweb_mode) {
	chapter *C;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		LOOP_OVER_LINKED_LIST(S, section, C->sections)
			
{
#line 34 "inweb/Chapter 2/The Parser.w"
	int comment_mode = TRUE, extract_mode = FALSE;
	int code_lcat_for_body = NO_LCAT,
		code_plainness_for_body = FALSE,
		hyperlink_body = FALSE;
	programming_language *code_pl_for_body = NULL;
	text_stream *code_destination = NULL;
	int before_bar = TRUE;
	int next_par_number = 1;
	paragraph *current_paragraph = NULL;
	TEMPORARY_TEXT(tag_list)
	for (source_line *L = S->first_line, *PL = NULL; L; PL = L, L = L->next_line) {
		
{
#line 80 "inweb/Chapter 2/The Parser.w"
	match_results mr = Regexp__create_mr();
	while (Regexp__match(&mr, tag_list, U" *%^\"(%c+?)\" *(%c*)")) {
		Tags__add_by_name(current_paragraph, mr.exp[0]);
		Str__copy(tag_list, mr.exp[1]);
	}
	Regexp__dispose_of(&mr);
	Str__clear(tag_list);

}
#line 45 "inweb/Chapter 2/The Parser.w"
;
		
{
#line 64 "inweb/Chapter 2/The Parser.w"
	if (Str__get_first_char(L->text) == '@') {
		match_results mr = Regexp__create_mr();
		while (Regexp__match(&mr, L->text, U"(%c*?)( *%^\"%c+?\")(%c*)")) {
			if (S->md->using_syntax < V2_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "tags written ^\"thus\"", V2_SYNTAX);
			Str__clear(L->text);
			WRITE_TO(tag_list, "%S", mr.exp[1]);
			Str__copy(L->text, mr.exp[0]); WRITE_TO(L->text, " %S", mr.exp[2]);
		}
		Regexp__dispose_of(&mr);
	}

}
#line 46 "inweb/Chapter 2/The Parser.w"
;
		
{
#line 121 "inweb/Chapter 2/The Parser.w"
	match_results mr = Regexp__create_mr();
	if ((PL) && (PL->category == CODE_BODY_LCAT) &&
		(Str__get_first_char(L->text) == '@') && (Str__get_at(L->text, 1) == '<') &&
		(Regexp__match(&mr, L->text, U"%c<(%c+)@> *= *")) &&
		(S->md->using_syntax >= V2_SYNTAX)) {
		
{
#line 141 "inweb/Chapter 2/The Parser.w"
	source_line *NL = Lines__new_source_line_in(TL_IS_2722, &(L->source), S);
	PL->next_line = NL;
	NL->next_line = L;
	L = PL;
	Regexp__dispose_of(&mr);
	continue;

}
#line 126 "inweb/Chapter 2/The Parser.w"
;
	}
	if ((PL) && (Regexp__match(&mr, L->text, U"@ *= *"))) {
		Str__clear(L->text);
		Str__copy(L->text, TL_IS_2721);
		if (S->md->using_syntax < V2_SYNTAX)
			Parser__wrong_version(S->md->using_syntax, L, "implied paragraph breaks", V2_SYNTAX);
		
{
#line 141 "inweb/Chapter 2/The Parser.w"
	source_line *NL = Lines__new_source_line_in(TL_IS_2722, &(L->source), S);
	PL->next_line = NL;
	NL->next_line = L;
	L = PL;
	Regexp__dispose_of(&mr);
	continue;

}
#line 133 "inweb/Chapter 2/The Parser.w"
;
	}
	Regexp__dispose_of(&mr);

}
#line 47 "inweb/Chapter 2/The Parser.w"
;
		
{
#line 153 "inweb/Chapter 2/The Parser.w"
	L->is_commentary = comment_mode;
	L->category = COMMENT_BODY_LCAT; /* until set otherwise down below */
	L->owning_paragraph = current_paragraph;

	if (L->source.line_count == 0) 
{
#line 180 "inweb/Chapter 2/The Parser.w"
	if (Str__eq_wide_string(L->text, U"Chapter Heading")) {
		comment_mode = TRUE;
		extract_mode = FALSE;
		L->is_commentary = TRUE;
		L->category = CHAPTER_HEADING_LCAT;
		L->owning_paragraph = NULL;
	}

}
#line 157 "inweb/Chapter 2/The Parser.w"
;
	if (L->source.line_count <= 1) 
{
#line 192 "inweb/Chapter 2/The Parser.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, L->text, U"Implied Purpose: (%c+)")) {
		S->sect_purpose = Str__duplicate(mr.exp[0]);
		if (Str__len(S->sect_purpose) > 0) {
			L->category = PURPOSE_LCAT;
			L->is_commentary = TRUE;
		}
	} else if (Regexp__match(&mr, L->text, U"%[(%C+)%] (%C+/%C+): (%c+).")) {
		if (S->md->using_syntax >= V2_SYNTAX)
			Parser__wrong_version(S->md->using_syntax, L,
			"section range in header line", V1_SYNTAX);
		S->sect_namespace = Str__duplicate(mr.exp[0]);
		S->md->sect_range = Str__duplicate(mr.exp[1]);
		S->md->sect_title = Str__duplicate(mr.exp[2]);
		L->text_operand = Str__duplicate(mr.exp[2]);
		L->category = SECTION_HEADING_LCAT;
		L->owning_paragraph = NULL;
	} else if (Regexp__match(&mr, L->text, U"(%C+/%C+): (%c+).")) {
		if (S->md->using_syntax >= V2_SYNTAX)
			Parser__wrong_version(S->md->using_syntax, L,
			"section range in header line", V1_SYNTAX);
		S->md->sect_range = Str__duplicate(mr.exp[0]);
		S->md->sect_title = Str__duplicate(mr.exp[1]);
		L->text_operand = Str__duplicate(mr.exp[1]);
		L->category = SECTION_HEADING_LCAT;
		L->owning_paragraph = NULL;
	} else if (Regexp__match(&mr, L->text, U"%[(%C+::)%] (%c+).")) {
		S->sect_namespace = Str__duplicate(mr.exp[0]);
		S->md->sect_title = Str__duplicate(mr.exp[1]);
		L->text_operand = Str__duplicate(mr.exp[1]);
		L->category = SECTION_HEADING_LCAT;
		L->owning_paragraph = NULL;
	} else if (Regexp__match(&mr, L->text, U"(%c+).")) {
		S->md->sect_title = Str__duplicate(mr.exp[0]);
		L->text_operand = Str__duplicate(mr.exp[0]);
		L->category = SECTION_HEADING_LCAT;
		L->owning_paragraph = NULL;
	}
	Regexp__dispose_of(&mr);

}
#line 158 "inweb/Chapter 2/The Parser.w"
;
	if (extract_mode == FALSE) {
		
{
#line 237 "inweb/Chapter 2/The Parser.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, L->text, U"%[%[(%c+)%]%]")) {
		TEMPORARY_TEXT(full_command)
		TEMPORARY_TEXT(command_text)
		Str__copy(full_command, mr.exp[0]);
		Str__copy(command_text, mr.exp[0]);
		L->category = COMMAND_LCAT;
		if (Regexp__match(&mr, command_text, U"(%c+?): *(%c+)")) {
			Str__copy(command_text, mr.exp[0]);
			L->text_operand = Str__duplicate(mr.exp[1]);
		}
		if (Str__eq_wide_string(command_text, U"Page Break")) {
			if (S->md->using_syntax > V1_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "[[Page Break]]", V1_SYNTAX);
			L->command_code = PAGEBREAK_CMD;
		} else if (Str__eq_wide_string(command_text, U"Grammar Index"))
			L->command_code = GRAMMAR_INDEX_CMD;
		else if (Str__eq_wide_string(command_text, U"Tag")) {
			if (S->md->using_syntax > V1_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "[[Tag...]]", V1_SYNTAX);
			Tags__add_by_name(L->owning_paragraph, L->text_operand);
			L->command_code = TAG_CMD;
		} else if (Str__eq_wide_string(command_text, U"Figure")) {
			if (S->md->using_syntax > V1_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "[[Figure...]]", V1_SYNTAX);
			Tags__add_by_name(L->owning_paragraph, TL_IS_2723);
			L->command_code = FIGURE_CMD;
		} else {
			Main__error_in_web(TL_IS_2724, L);
		}
		L->is_commentary = TRUE;
		DISCARD_TEXT(command_text)
		DISCARD_TEXT(full_command)
	}
	Regexp__dispose_of(&mr);

}
#line 160 "inweb/Chapter 2/The Parser.w"
;
		
{
#line 277 "inweb/Chapter 2/The Parser.w"
	match_results mr = Regexp__create_mr();
	if ((Str__get_first_char(L->text) == '@') && (Str__get_at(L->text, 1) == '<') &&
		(Regexp__match(&mr, L->text, U"%c<(%c+)@> *= *"))) {
		TEMPORARY_TEXT(para_macro_name)
		Str__copy(para_macro_name, mr.exp[0]);
		L->category = MACRO_DEFINITION_LCAT;
		if (current_paragraph == NULL)
			Main__error_in_web(TL_IS_2725, L);
		else Macros__create(S, current_paragraph, L, para_macro_name);
		comment_mode = FALSE; extract_mode = FALSE;
		L->is_commentary = FALSE;
		code_lcat_for_body = CODE_BODY_LCAT; /* code follows on subsequent lines */
		code_pl_for_body = NULL;
		code_plainness_for_body = FALSE;
		hyperlink_body = FALSE;
		DISCARD_TEXT(para_macro_name)
		continue;
	}
	Regexp__dispose_of(&mr);

}
#line 161 "inweb/Chapter 2/The Parser.w"
;
	}
	if (Str__get_first_char(L->text) == '=') {
		if (S->md->using_syntax < V2_SYNTAX)
			Parser__wrong_version(S->md->using_syntax, L, "column-1 '=' as code divider", V2_SYNTAX);
		if (extract_mode) 
{
#line 319 "inweb/Chapter 2/The Parser.w"
	L->category = END_EXTRACT_LCAT;
	comment_mode = TRUE;
	extract_mode = FALSE;

}
#line 166 "inweb/Chapter 2/The Parser.w"

		else 
{
#line 326 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_CODE_LCAT;
	L->plainer = FALSE;
	code_lcat_for_body = CODE_BODY_LCAT;
	code_destination = NULL;
	code_pl_for_body = NULL;
	comment_mode = FALSE;
	match_results mr = Regexp__create_mr();
	match_results mr2 = Regexp__create_mr();
	if (Regexp__match(&mr, L->text, U"= *(%c+) *")) {
		if ((current_paragraph) && (Str__eq(mr.exp[0], TL_IS_2726))) {
			current_paragraph->placed_very_early = TRUE;
		} else if ((current_paragraph) && (Str__eq(mr.exp[0], TL_IS_2727))) {
			current_paragraph->placed_early = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 341 "inweb/Chapter 2/The Parser.w"
;
			code_lcat_for_body = TEXT_EXTRACT_LCAT;
			code_destination = NULL;
			code_pl_for_body = NULL;
			extract_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text to *(%c+)%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 348 "inweb/Chapter 2/The Parser.w"
;
			code_lcat_for_body = TEXT_EXTRACT_LCAT;
			code_destination = Str__duplicate(mr2.exp[1]);
			code_pl_for_body = Analyser__find_by_name(TL_IS_2728, W, TRUE);
			extract_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text as code%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 355 "inweb/Chapter 2/The Parser.w"
;
			code_lcat_for_body = TEXT_EXTRACT_LCAT;
			code_destination = NULL;
			code_pl_for_body = S->sect_language;
			extract_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text as (%c+)%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 362 "inweb/Chapter 2/The Parser.w"
;
			code_lcat_for_body = TEXT_EXTRACT_LCAT;
			code_destination = NULL;
			code_pl_for_body = Analyser__find_by_name(mr2.exp[1], W, TRUE);
			extract_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text from (%c+) as code%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 369 "inweb/Chapter 2/The Parser.w"
;
			code_pl_for_body = S->sect_language;
			
{
#line 510 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_CODE_LCAT;
	pathname *P = W->md->path_to_web;
	if ((S->md->owning_module) && (S->md->owning_module->module_location))
		P = S->md->owning_module->module_location; /* references are relative to module */
	filename *F = Filenames__from_text_relative(P, mr2.exp[1]);
	linked_list *lines = Painter__lines(F);
	text_stream *T;
	source_line *latest = L;
	LOOP_OVER_LINKED_LIST(T, text_stream, lines) {
		source_line *TL = Lines__new_source_line_in(T, &(L->source), S);
		TL->next_line = latest->next_line;
		TL->plainer = L->plainer;
		latest->next_line = TL;
		latest = TL;
	}
	source_line *EEL = Lines__new_source_line_in(TL_IS_2746, &(L->source), S);
	EEL->next_line = latest->next_line;
	latest->next_line = EEL;
	code_lcat_for_body = TEXT_EXTRACT_LCAT;
	extract_mode = TRUE;

}
#line 371 "inweb/Chapter 2/The Parser.w"
;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text from (%c+) as (%c+)%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 374 "inweb/Chapter 2/The Parser.w"
;
			code_pl_for_body = Analyser__find_by_name(mr2.exp[2], W, TRUE);
			
{
#line 510 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_CODE_LCAT;
	pathname *P = W->md->path_to_web;
	if ((S->md->owning_module) && (S->md->owning_module->module_location))
		P = S->md->owning_module->module_location; /* references are relative to module */
	filename *F = Filenames__from_text_relative(P, mr2.exp[1]);
	linked_list *lines = Painter__lines(F);
	text_stream *T;
	source_line *latest = L;
	LOOP_OVER_LINKED_LIST(T, text_stream, lines) {
		source_line *TL = Lines__new_source_line_in(T, &(L->source), S);
		TL->next_line = latest->next_line;
		TL->plainer = L->plainer;
		latest->next_line = TL;
		latest = TL;
	}
	source_line *EEL = Lines__new_source_line_in(TL_IS_2746, &(L->source), S);
	EEL->next_line = latest->next_line;
	latest->next_line = EEL;
	code_lcat_for_body = TEXT_EXTRACT_LCAT;
	extract_mode = TRUE;

}
#line 376 "inweb/Chapter 2/The Parser.w"
;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%((%c*?) *text from (%c+)%)"))) {
			
{
#line 494 "inweb/Chapter 2/The Parser.w"
	match_results mr3 = Regexp__create_mr();
	while (TRUE) {
		if (Regexp__match(&mr3, mr2.exp[0], U" *(%C+) *(%c*?)")) {
			if (Str__eq(mr3.exp[0], TL_IS_2743)) L->plainer = TRUE;
			else if (Str__eq(mr3.exp[0], TL_IS_2744)) L->enable_hyperlinks = TRUE;
			else {
				Main__error_in_web(
					TL_IS_2745, L);
			}
		} else break;
		Str__clear(mr2.exp[0]);
		Str__copy(mr2.exp[0], mr3.exp[1]);
	}
	Regexp__dispose_of(&mr3);

}
#line 379 "inweb/Chapter 2/The Parser.w"
;
			code_pl_for_body = NULL;
			
{
#line 510 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_CODE_LCAT;
	pathname *P = W->md->path_to_web;
	if ((S->md->owning_module) && (S->md->owning_module->module_location))
		P = S->md->owning_module->module_location; /* references are relative to module */
	filename *F = Filenames__from_text_relative(P, mr2.exp[1]);
	linked_list *lines = Painter__lines(F);
	text_stream *T;
	source_line *latest = L;
	LOOP_OVER_LINKED_LIST(T, text_stream, lines) {
		source_line *TL = Lines__new_source_line_in(T, &(L->source), S);
		TL->next_line = latest->next_line;
		TL->plainer = L->plainer;
		latest->next_line = TL;
		latest = TL;
	}
	source_line *EEL = Lines__new_source_line_in(TL_IS_2746, &(L->source), S);
	EEL->next_line = latest->next_line;
	latest->next_line = EEL;
	code_lcat_for_body = TEXT_EXTRACT_LCAT;
	extract_mode = TRUE;

}
#line 381 "inweb/Chapter 2/The Parser.w"
;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(figure (%c+)%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2729);
			L->command_code = FIGURE_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(html (%c+)%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2730);
			L->command_code = HTML_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(audio (%c+)%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2731);
			L->command_code = AUDIO_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(video (%c+)%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2732);
			L->command_code = VIDEO_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(download (%c+) \"(%c*)\"%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2733);
			L->command_code = DOWNLOAD_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			L->text_operand2 = Str__duplicate(mr2.exp[1]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(download (%c+)%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2734);
			L->command_code = DOWNLOAD_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			L->text_operand2 = Str__new();
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(carousel%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2735);
			L->command_code = CAROUSEL_UNCAPTIONED_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__new();
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(carousel \"(%c+)\" below%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2736);
			L->command_code = CAROUSEL_BELOW_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(carousel \"(%c+)\" above%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2737);
			L->command_code = CAROUSEL_ABOVE_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(carousel \"(%c+)\"%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2738);
			L->command_code = CAROUSEL_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			(Regexp__match(&mr2, mr.exp[0], U"%(carousel end%)"))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2739);
			L->command_code = CAROUSEL_END_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			comment_mode = TRUE;
		} else if ((current_paragraph) &&
			((Regexp__match(&mr2, mr.exp[0], U"%(embedded (%C+) video (%c+)%)")) ||
				(Regexp__match(&mr2, mr.exp[0], U"%(embedded (%C+) audio (%c+)%)")))) {
			Tags__add_by_name(L->owning_paragraph, TL_IS_2740);
			L->command_code = EMBED_CMD;
			L->category = COMMAND_LCAT;
			code_lcat_for_body = COMMENT_BODY_LCAT;
			L->text_operand = Str__duplicate(mr2.exp[0]);
			L->text_operand2 = Str__duplicate(mr2.exp[1]);
			comment_mode = TRUE;
		} else {
			Main__error_in_web(TL_IS_2741, L);
		}
	} else if (Regexp__match(&mr, L->text, U"= *%C%c*")) {
		Main__error_in_web(TL_IS_2742, L);
	}
	code_plainness_for_body = L->plainer;
	hyperlink_body = L->enable_hyperlinks;
	Regexp__dispose_of(&mr);
	Regexp__dispose_of(&mr2);
	continue;

}
#line 167 "inweb/Chapter 2/The Parser.w"
;
	}
	if ((Str__get_first_char(L->text) == '@') &&
		(Str__get_at(L->text, 1) != '<') &&
		(L->category != MACRO_DEFINITION_LCAT))
		
{
#line 301 "inweb/Chapter 2/The Parser.w"
	TEMPORARY_TEXT(command_text)
	Str__copy(command_text, L->text);
	Str__delete_first_character(command_text); /* i.e., strip the at-sign from the front */
	TEMPORARY_TEXT(remainder)
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, command_text, U"(%C*) *(%c*?)")) {
		Str__copy(command_text, mr.exp[0]);
		Str__copy(remainder, mr.exp[1]);
	}
	
{
#line 538 "inweb/Chapter 2/The Parser.w"
	extract_mode = FALSE;
	if (Str__eq_wide_string(command_text, U"Purpose:")) 
{
#line 586 "inweb/Chapter 2/The Parser.w"
	if (before_bar == FALSE) Main__error_in_web(TL_IS_2748, L);
	if (S->md->using_syntax >= V2_SYNTAX)
		Parser__wrong_version(S->md->using_syntax, L, "'@Purpose'", V1_SYNTAX);
	L->category = PURPOSE_LCAT;
	L->is_commentary = TRUE;
	L->text_operand = Str__duplicate(remainder);
	S->sect_purpose = Parser__extract_purpose(remainder, L->next_line, L->owning_section, &L);

}
#line 539 "inweb/Chapter 2/The Parser.w"

	else if (Str__eq_wide_string(command_text, U"Interface:")) 
{
#line 595 "inweb/Chapter 2/The Parser.w"
	if (S->md->using_syntax >= V2_SYNTAX)
		Parser__wrong_version(S->md->using_syntax, L, "'@Interface'", V1_SYNTAX);
	if (before_bar == FALSE) Main__error_in_web(TL_IS_2749, L);
	L->category = INTERFACE_LCAT;
	L->owning_paragraph = NULL;
	L->is_commentary = TRUE;
	source_line *XL = L->next_line;
	while ((XL) && (XL->next_line) && (XL->owning_section == L->owning_section)) {
		if (Str__get_first_char(XL->text) == '@') break;
		XL->category = INTERFACE_BODY_LCAT;
		L = XL;
		XL = XL->next_line;
	}

}
#line 540 "inweb/Chapter 2/The Parser.w"

	else if (Str__eq_wide_string(command_text, U"Definitions:")) 
{
#line 610 "inweb/Chapter 2/The Parser.w"
	if (S->md->using_syntax >= V2_SYNTAX)
		Parser__wrong_version(S->md->using_syntax, L, "'@Definitions' headings", V1_SYNTAX);
	if (before_bar == FALSE) Main__error_in_web(TL_IS_2750, L);
	L->category = DEFINITIONS_LCAT;
	L->owning_paragraph = NULL;
	L->is_commentary = TRUE;
	before_bar = TRUE;
	next_par_number = 1;

}
#line 541 "inweb/Chapter 2/The Parser.w"

	else if (Regexp__match(&mr, command_text, U"----+")) 
{
#line 623 "inweb/Chapter 2/The Parser.w"
	if (S->md->using_syntax >= V2_SYNTAX)
		Parser__wrong_version(S->md->using_syntax, L, "the bar '----...'", V1_SYNTAX);
	if (before_bar == FALSE) Main__error_in_web(TL_IS_2751, L);
	L->category = BAR_LCAT;
	L->owning_paragraph = NULL;
	L->is_commentary = TRUE;
	comment_mode = TRUE;
	S->barred = TRUE;
	before_bar = FALSE;
	next_par_number = 1;

}
#line 542 "inweb/Chapter 2/The Parser.w"

	else if ((Str__eq_wide_string(command_text, U"c")) ||
			(Str__eq_wide_string(command_text, U"x")) ||
			((S->md->using_syntax == V1_SYNTAX) && (Str__eq_wide_string(command_text, U"e"))))
				
{
#line 641 "inweb/Chapter 2/The Parser.w"
	if (S->md->using_syntax > V1_SYNTAX)
		Parser__wrong_version(S->md->using_syntax, L, "'@c' and '@x'", V1_SYNTAX);
	L->category = BEGIN_CODE_LCAT;
	if ((Str__eq_wide_string(command_text, U"e")) && (current_paragraph))
		current_paragraph->placed_early = TRUE;
	if (Str__eq_wide_string(command_text, U"x")) code_lcat_for_body = TEXT_EXTRACT_LCAT;
	else code_lcat_for_body = CODE_BODY_LCAT;
	code_pl_for_body = NULL;
	comment_mode = FALSE;
	code_plainness_for_body = FALSE;
	hyperlink_body = FALSE;

}
#line 546 "inweb/Chapter 2/The Parser.w"

	else if (Str__eq_wide_string(command_text, U"d")) 
{
#line 657 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	code_lcat_for_body = CONT_DEFINITION_LCAT;
	code_pl_for_body = NULL;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, remainder, U"(%C+) (%c+)")) {
		L->text_operand = Str__duplicate(mr.exp[0]); /* name of term defined */
		L->text_operand2 = Str__duplicate(mr.exp[1]); /* Value */
	} else {
		L->text_operand = Str__duplicate(remainder); /* name of term defined */
		L->text_operand2 = Str__new(); /* no value given */
	}
	Analyser__mark_reserved_word_at_line(L, L->text_operand, CONSTANT_COLOUR);
	Ctags__note_defined_constant(L, L->text_operand);
	comment_mode = FALSE;
	L->is_commentary = FALSE;
	Regexp__dispose_of(&mr);

}
#line 547 "inweb/Chapter 2/The Parser.w"

	else if (Str__eq_wide_string(command_text, U"define")) {
		if (S->md->using_syntax < V2_SYNTAX)
			Parser__wrong_version(S->md->using_syntax, L, "'@define' for definitions (use '@d' instead)", V2_SYNTAX);
		
{
#line 657 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	code_lcat_for_body = CONT_DEFINITION_LCAT;
	code_pl_for_body = NULL;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, remainder, U"(%C+) (%c+)")) {
		L->text_operand = Str__duplicate(mr.exp[0]); /* name of term defined */
		L->text_operand2 = Str__duplicate(mr.exp[1]); /* Value */
	} else {
		L->text_operand = Str__duplicate(remainder); /* name of term defined */
		L->text_operand2 = Str__new(); /* no value given */
	}
	Analyser__mark_reserved_word_at_line(L, L->text_operand, CONSTANT_COLOUR);
	Ctags__note_defined_constant(L, L->text_operand);
	comment_mode = FALSE;
	L->is_commentary = FALSE;
	Regexp__dispose_of(&mr);

}
#line 551 "inweb/Chapter 2/The Parser.w"
;
	} else if (Str__eq_wide_string(command_text, U"default")) {
		if (S->md->using_syntax < V2_SYNTAX)
			Parser__wrong_version(S->md->using_syntax, L, "'@default' for definitions", V2_SYNTAX);
		L->default_defn = TRUE;
		
{
#line 657 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	code_lcat_for_body = CONT_DEFINITION_LCAT;
	code_pl_for_body = NULL;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, remainder, U"(%C+) (%c+)")) {
		L->text_operand = Str__duplicate(mr.exp[0]); /* name of term defined */
		L->text_operand2 = Str__duplicate(mr.exp[1]); /* Value */
	} else {
		L->text_operand = Str__duplicate(remainder); /* name of term defined */
		L->text_operand2 = Str__new(); /* no value given */
	}
	Analyser__mark_reserved_word_at_line(L, L->text_operand, CONSTANT_COLOUR);
	Ctags__note_defined_constant(L, L->text_operand);
	comment_mode = FALSE;
	L->is_commentary = FALSE;
	Regexp__dispose_of(&mr);

}
#line 556 "inweb/Chapter 2/The Parser.w"
;
	} else if (Str__eq_wide_string(command_text, U"enum")) 
{
#line 678 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	text_stream *from = NULL;
	match_results mr = Regexp__create_mr();
	L->text_operand = Str__duplicate(remainder); /* name of term defined */
	TEMPORARY_TEXT(before)
	TEMPORARY_TEXT(after)
	if (LanguageMethods__parse_comment(S->sect_language, L->text_operand,
		before, after)) {
		Str__copy(L->text_operand, before);
	}
	DISCARD_TEXT(before)
	DISCARD_TEXT(after)
	Str__trim_white_space(L->text_operand);
	if (Regexp__match(&mr, L->text_operand, U"(%C+) from (%c+)")) {
		from = mr.exp[1];
		Str__copy(L->text_operand, mr.exp[0]);
	} else if (Regexp__match(&mr, L->text_operand, U"(%C+) (%c+)")) {
		Main__error_in_web(TL_IS_2752, L);
	}
	L->text_operand2 = Str__new();
	if (inweb_mode == TANGLE_MODE)
		Enumerations__define(L->text_operand2, L->text_operand, from, L);
	Analyser__mark_reserved_word_at_line(L, L->text_operand, CONSTANT_COLOUR);
	Ctags__note_defined_constant(L, L->text_operand);
	comment_mode = FALSE;
	L->is_commentary = FALSE;
	Regexp__dispose_of(&mr);

}
#line 557 "inweb/Chapter 2/The Parser.w"

	else if ((Str__eq_wide_string(command_text, U"e")) && (S->md->using_syntax >= V2_SYNTAX))
		
{
#line 678 "inweb/Chapter 2/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	text_stream *from = NULL;
	match_results mr = Regexp__create_mr();
	L->text_operand = Str__duplicate(remainder); /* name of term defined */
	TEMPORARY_TEXT(before)
	TEMPORARY_TEXT(after)
	if (LanguageMethods__parse_comment(S->sect_language, L->text_operand,
		before, after)) {
		Str__copy(L->text_operand, before);
	}
	DISCARD_TEXT(before)
	DISCARD_TEXT(after)
	Str__trim_white_space(L->text_operand);
	if (Regexp__match(&mr, L->text_operand, U"(%C+) from (%c+)")) {
		from = mr.exp[1];
		Str__copy(L->text_operand, mr.exp[0]);
	} else if (Regexp__match(&mr, L->text_operand, U"(%C+) (%c+)")) {
		Main__error_in_web(TL_IS_2752, L);
	}
	L->text_operand2 = Str__new();
	if (inweb_mode == TANGLE_MODE)
		Enumerations__define(L->text_operand2, L->text_operand, from, L);
	Analyser__mark_reserved_word_at_line(L, L->text_operand, CONSTANT_COLOUR);
	Ctags__note_defined_constant(L, L->text_operand);
	comment_mode = FALSE;
	L->is_commentary = FALSE;
	Regexp__dispose_of(&mr);

}
#line 559 "inweb/Chapter 2/The Parser.w"

	else {
		int weight = -1, new_page = FALSE;
		if (Str__eq_wide_string(command_text, U"")) weight = ORDINARY_WEIGHT;
		if ((Str__eq_wide_string(command_text, U"h")) || (Str__eq_wide_string(command_text, U"heading"))) {
			if (S->md->using_syntax < V2_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "'@h' or '@heading' for headings (use '@p' instead)", V2_SYNTAX);
			weight = SUBHEADING_WEIGHT;
		}
		if (Str__eq_wide_string(command_text, U"p")) {
			if (S->md->using_syntax > V1_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "'@p' for headings (use '@h' instead)", V1_SYNTAX);
			weight = SUBHEADING_WEIGHT;
		}
		if (Str__eq_wide_string(command_text, U"pp")) {
			if (S->md->using_syntax > V1_SYNTAX)
				Parser__wrong_version(S->md->using_syntax, L, "'@pp' for super-headings", V1_SYNTAX);
			weight = SUBHEADING_WEIGHT; new_page = TRUE;
		}
		if (weight >= 0) 
{
#line 731 "inweb/Chapter 2/The Parser.w"
	comment_mode = TRUE;
	L->is_commentary = TRUE;
	L->category = PARAGRAPH_START_LCAT;
	if (weight == SUBHEADING_WEIGHT) L->category = HEADING_START_LCAT;
	L->text_operand = Str__new(); /* title */
	match_results mr = Regexp__create_mr();
	if ((weight == SUBHEADING_WEIGHT) && (Regexp__match(&mr, remainder, U"(%c+). (%c+)"))) {
		L->text_operand = Str__duplicate(mr.exp[0]);
		L->text_operand2 = Str__duplicate(mr.exp[1]);
	} else if ((weight == SUBHEADING_WEIGHT) && (Regexp__match(&mr, remainder, U"(%c+). *"))) {
		L->text_operand = Str__duplicate(mr.exp[0]);
		L->text_operand2 = Str__new();
	} else {
		L->text_operand = Str__new();
		L->text_operand2 = Str__duplicate(remainder);
	}
	
{
#line 781 "inweb/Chapter 2/The Parser.w"
	paragraph *P = CREATE(paragraph);
	if (S->md->using_syntax > V1_SYNTAX) {
		P->above_bar = FALSE;
		P->placed_early = FALSE;
		P->placed_very_early = FALSE;
	} else {
		P->above_bar = before_bar;
		P->placed_early = before_bar;
		P->placed_very_early = FALSE;
	}
	P->invisible = FALSE;
	if (Str__eq(Bibliographic__get_datum(W->md, TL_IS_2753), TL_IS_2754))
		P->invisible = TRUE;
	P->heading_text = Str__duplicate(L->text_operand);
	if ((S->md->using_syntax == V1_SYNTAX) && (before_bar))
		P->ornament = Str__duplicate(TL_IS_2755);
	else
		P->ornament = Str__duplicate(TL_IS_2756);
	WRITE_TO(P->paragraph_number, "%d", next_par_number++);
	P->parent_paragraph = NULL;
	P->next_child_number = 1;
	P->starts_on_new_page = FALSE;
	P->weight = weight;
	P->first_line_in_paragraph = L;
	P->defines_macro = NULL;
	P->functions = NEW_LINKED_LIST(function);
	P->structures = NEW_LINKED_LIST(language_type);
	P->taggings = NEW_LINKED_LIST(paragraph_tagging);
	P->footnotes = NEW_LINKED_LIST(footnote);

	P->under_section = S;
	S->sect_paragraphs++;
	ADD_TO_LINKED_LIST(P, paragraph, S->paragraphs);

	current_paragraph = P;

}
#line 747 "inweb/Chapter 2/The Parser.w"
;

	L->owning_paragraph = current_paragraph;
	W->no_paragraphs++;
	Regexp__dispose_of(&mr);

}
#line 578 "inweb/Chapter 2/The Parser.w"

		else Main__error_in_web(TL_IS_2747, L);
	}

}
#line 310 "inweb/Chapter 2/The Parser.w"
;
	DISCARD_TEXT(remainder)
	DISCARD_TEXT(command_text)
	Regexp__dispose_of(&mr);
	continue;

}
#line 172 "inweb/Chapter 2/The Parser.w"
;
	if (comment_mode) 
{
#line 820 "inweb/Chapter 2/The Parser.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, L->text, U">> (%c+)")) {
		L->category = SOURCE_DISPLAY_LCAT;
		L->text_operand = Str__duplicate(mr.exp[0]);
	}
	Regexp__dispose_of(&mr);

}
#line 173 "inweb/Chapter 2/The Parser.w"
;
	if (comment_mode == FALSE) 
{
#line 832 "inweb/Chapter 2/The Parser.w"
	if ((L->category != BEGIN_DEFINITION_LCAT) && (L->category != COMMAND_LCAT)) {
		L->category = code_lcat_for_body;
		L->plainer = code_plainness_for_body;
		L->enable_hyperlinks = hyperlink_body;
		if (L->category == TEXT_EXTRACT_LCAT) {
			L->colour_as = code_pl_for_body;
			if (code_destination) L->extract_to = Str__duplicate(code_destination);
		}
	}

	if ((L->category == CONT_DEFINITION_LCAT) && (Regexp__string_is_white_space(L->text))) {
		L->category = COMMENT_BODY_LCAT;
		L->is_commentary = TRUE;
		code_lcat_for_body = COMMENT_BODY_LCAT;
		comment_mode = TRUE;
	}

	LanguageMethods__subcategorise_line(S->sect_language, L);

}
#line 174 "inweb/Chapter 2/The Parser.w"
;

}
#line 48 "inweb/Chapter 2/The Parser.w"
;
	}
	DISCARD_TEXT(tag_list)
	
{
#line 107 "inweb/Chapter 2/The Parser.w"
	if (S->md->using_syntax >= V2_SYNTAX) {
		source_line *L = S->first_line;
		if ((L) && (L->category == CHAPTER_HEADING_LCAT)) L = L->next_line;
		if (Str__len(S->sect_purpose) == 0) {
			S->sect_purpose = Parser__extract_purpose(TL_IS_2720, L?L->next_line: NULL, S, NULL);
			if (Str__len(S->sect_purpose) > 0) L->next_line->category = PURPOSE_LCAT;
		}
	}

}
#line 51 "inweb/Chapter 2/The Parser.w"
;
	
{
#line 89 "inweb/Chapter 2/The Parser.w"
	paragraph *P;
	if (S->tag_with)
		LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
			Tags__add_to_paragraph(P, S->tag_with, NULL);

}
#line 52 "inweb/Chapter 2/The Parser.w"
;
	
{
#line 97 "inweb/Chapter 2/The Parser.w"
	int next_footnote = 1;
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		
{
#line 883 "inweb/Chapter 2/The Parser.w"
	int next_footnote_in_para = 1;
	footnote *current_text = NULL;
	TEMPORARY_TEXT(before)
	TEMPORARY_TEXT(cue)
	TEMPORARY_TEXT(after)
	for (source_line *L = P->first_line_in_paragraph;
		((L) && (L->owning_paragraph == P)); L = L->next_line)
		if (L->is_commentary) {
			Str__clear(before); Str__clear(cue); Str__clear(after);
			if (Parser__detect_footnote(W, L->text, before, cue, after)) {
				int this_is_a_cue = FALSE;
				LOOP_THROUGH_TEXT(pos, before)
					if (Characters__is_whitespace(Str__get(pos)) == FALSE)
						this_is_a_cue = TRUE;
				if (this_is_a_cue == FALSE)
					
{
#line 907 "inweb/Chapter 2/The Parser.w"
	L->category = FOOTNOTE_TEXT_LCAT;
	footnote *F = CREATE(footnote);
	F->footnote_cue_number = Str__atoi(cue, 0);
	if (F->footnote_cue_number != next_footnote_in_para) {
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "footnote should be numbered [%d], not [%d]",
			next_footnote_in_para, F->footnote_cue_number);
		Main__error_in_web(err, L);
		DISCARD_TEXT(err)
	}
	next_footnote_in_para++;
	F->footnote_text_number = next_footnote++;
	F->cue_text = Str__new();
	F->cued_already = FALSE;
	WRITE_TO(F->cue_text, "%d", F->footnote_text_number);
	ADD_TO_LINKED_LIST(F, footnote, P->footnotes);
	current_text = F;

}
#line 898 "inweb/Chapter 2/The Parser.w"
;
			}
			L->footnote_text = current_text;
		}
	DISCARD_TEXT(before)
	DISCARD_TEXT(cue)
	DISCARD_TEXT(after)

}
#line 100 "inweb/Chapter 2/The Parser.w"
;

}
#line 53 "inweb/Chapter 2/The Parser.w"
;

}
#line 22 "inweb/Chapter 2/The Parser.w"
;
	LanguageMethods__parse_types(W, W->main_language);
	LanguageMethods__parse_functions(W, W->main_language);
	LanguageMethods__further_parsing(W, W->main_language);
}

#line 779 "inweb/Chapter 2/The Parser.w"

#line 856 "inweb/Chapter 2/The Parser.w"
text_stream *Parser__extract_purpose(text_stream *prologue, source_line *XL, section *S, source_line **adjust) {
	text_stream *P = Str__duplicate(prologue);
	while ((XL) && (XL->next_line) && (XL->owning_section == S) &&
		(((adjust) && (Characters__isalnum(Str__get_first_char(XL->text)))) ||
		 ((!adjust) && (XL->category == COMMENT_BODY_LCAT)))) {
		WRITE_TO(P, " %S", XL->text);
		XL->category = PURPOSE_BODY_LCAT;
		XL->is_commentary = TRUE;
		if (adjust) *adjust = XL;
		XL = XL->next_line;
	}
	Str__trim_white_space(P);
	return P;
}

#line 881 "inweb/Chapter 2/The Parser.w"

#line 928 "inweb/Chapter 2/The Parser.w"
int Parser__detect_footnote(web *W, text_stream *matter, text_stream *before,
	text_stream *cue, text_stream *after) {
	text_stream *fn_on_notation =
		Bibliographic__get_datum(W->md, TL_IS_2757);
	text_stream *fn_off_notation =
		Bibliographic__get_datum(W->md, TL_IS_2758);
	if (Str__ne(fn_on_notation, TL_IS_2759)) {
		int N1 = Str__len(fn_on_notation);
		int N2 = Str__len(fn_off_notation);
		if ((N1 > 0) && (N2 > 0))
			for (int i=0; i < Str__len(matter); i++) {
				if (Str__includes_at(matter, i, fn_on_notation)) {
					int j = i + N1 + 1;
					while (j < Str__len(matter)) {
						if (Str__includes_at(matter, j, fn_off_notation)) {
							TEMPORARY_TEXT(b)
							TEMPORARY_TEXT(c)
							TEMPORARY_TEXT(a)
							Str__substr(b, Str__start(matter), Str__at(matter, i));
							Str__substr(c, Str__at(matter, i + N1), Str__at(matter, j));
							Str__substr(a, Str__at(matter, j + N2), Str__end(matter));
							int allow = TRUE;
							LOOP_THROUGH_TEXT(pos, c)
								if (Characters__isdigit(Str__get(pos)) == FALSE)
									allow = FALSE;
							if (allow) {
								Str__clear(before); Str__copy(before, b);
								Str__clear(cue); Str__copy(cue, c);
								Str__clear(after); Str__copy(after, a);
							}
							DISCARD_TEXT(b)
							DISCARD_TEXT(c)
							DISCARD_TEXT(a)
							if (allow) return TRUE;
						}
						j++;
					}
				}
			}
	}
	return FALSE;
}

footnote *Parser__find_footnote_in_para(paragraph *P, text_stream *cue) {
	int N = Str__atoi(cue, 0);
	footnote *F;
	if (P)
		LOOP_OVER_LINKED_LIST(F, footnote, P->footnotes)
			if (N == F->footnote_cue_number)
				return F;
	return NULL;
}

#line 988 "inweb/Chapter 2/The Parser.w"
text_stream *Parser__dimensions(text_stream *item, int *w, int *h, source_line *L) {
	int sv = L->owning_section->md->using_syntax;
	*w = -1; *h = -1;
	text_stream *use = item;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, item, U"(%c+) at (%d+) by (%d+)")) {
		if (sv < V2_SYNTAX)
			Parser__wrong_version(sv, L, "at X by Y", V2_SYNTAX);
		*w = Str__atoi(mr.exp[1], 0);
		*h = Str__atoi(mr.exp[2], 0);
		use = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, item, U"(%c+) at height (%d+)")) {
		if (sv < V2_SYNTAX)
			Parser__wrong_version(sv, L, "at height Y", V2_SYNTAX);
		*h = Str__atoi(mr.exp[1], 0);
		use = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, item, U"(%c+) at width (%d+)")) {
		if (sv < V2_SYNTAX)
			Parser__wrong_version(sv, L, "at width Y", V2_SYNTAX);
		*w = Str__atoi(mr.exp[1], 0);
		use = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, item, U"(%c+) at (%d+)cm by (%d+)cm")) {
		if (sv < V2_SYNTAX)
			Parser__wrong_version(sv, L, "at Xcm by Ycm", V2_SYNTAX);
		*w = POINTS_PER_CM*Str__atoi(mr.exp[1], 0);
		*h = POINTS_PER_CM*Str__atoi(mr.exp[2], 0);
		use = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, item, U"(%c+) at height (%d+)cm")) {
		if (sv < V2_SYNTAX)
			Parser__wrong_version(sv, L, "at height Ycm", V2_SYNTAX);
		*h = POINTS_PER_CM*Str__atoi(mr.exp[1], 0);
		use = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, item, U"(%c+) at width (%d+)cm")) {
		if (sv < V2_SYNTAX)
			Parser__wrong_version(sv, L, "at width Ycm", V2_SYNTAX);
		*w = POINTS_PER_CM*Str__atoi(mr.exp[1], 0);
		use = Str__duplicate(mr.exp[0]);
	}
	Regexp__dispose_of(&mr);
	return use;
}

#line 1036 "inweb/Chapter 2/The Parser.w"
void Parser__wrong_version(int using, source_line *L, char *feature, int need) {
	TEMPORARY_TEXT(warning)
	WRITE_TO(warning, "%s is a feature of version %d syntax (you're using v%d)",
		feature, need, using);
	Main__error_in_web(warning, L);
	DISCARD_TEXT(warning)
}

#line 15 "inweb/Chapter 2/Paragraph Macros.w"

#line 20 "inweb/Chapter 2/Paragraph Macros.w"
para_macro *Macros__create(section *S, paragraph *P, source_line *L, text_stream *name) {
	para_macro *pmac = CREATE(para_macro);
	pmac->macro_name = Str__duplicate(name);
	pmac->defining_paragraph = P;
	P->defines_macro = pmac;
	pmac->defn_start = L->next_line;
	pmac->macro_usages = NEW_LINKED_LIST(macro_usage);
	ADD_TO_LINKED_LIST(pmac, para_macro, S->macros);
	return pmac;
}

#line 38 "inweb/Chapter 2/Paragraph Macros.w"
para_macro *Macros__find_by_name(text_stream *name, section *scope) {
	para_macro *pmac;
	LOOP_OVER_LINKED_LIST(pmac, para_macro, scope->macros)
		if (Str__eq(name, pmac->macro_name))
			return pmac;
	return NULL;
}

#line 16 "inweb/Chapter 2/Tags.w"

#line 22 "inweb/Chapter 2/Tags.w"
theme_tag *Tags__find_by_name(text_stream *name, int creating_if_necessary) {
	theme_tag *tag;
	LOOP_OVER(tag, theme_tag)
		if (Str__eq(name, tag->tag_name))
			return tag;
	if (creating_if_necessary) {
		tag = CREATE(theme_tag);
		tag->tag_name = Str__duplicate(name);
		tag->ifdef_positive = NOT_APPLICABLE;
		tag->ifdef_symbol = Str__new();
		if (Str__prefix_eq(name, TL_IS_2760, 6)) {
			Str__substr(tag->ifdef_symbol, Str__at(name, 6), Str__end(name));
			tag->ifdef_positive = TRUE;
		} else if (Str__prefix_eq(name, TL_IS_2761, 7)) {
			Str__substr(tag->ifdef_symbol, Str__at(name, 7), Str__end(name));
			tag->ifdef_positive = FALSE;
		}
		LanguageMethods__new_tag_declared(tag);
		return tag;
	}
	return NULL;
}

#line 55 "inweb/Chapter 2/Tags.w"

void Tags__add_to_paragraph(paragraph *P, theme_tag *tag, text_stream *caption) {
	if (P) {
		paragraph_tagging *pt = CREATE(paragraph_tagging);
		pt->the_tag = tag;
		if (caption) pt->caption = Str__duplicate(caption);
		else pt->caption = Str__new();
		ADD_TO_LINKED_LIST(pt, paragraph_tagging, P->taggings);
	}
}

#line 71 "inweb/Chapter 2/Tags.w"
theme_tag *Tags__add_by_name(paragraph *P, text_stream *text) {
	if (Str__len(text) == 0) internal_error("empty tag name");
	TEMPORARY_TEXT(name) Str__copy(name, text);
	TEMPORARY_TEXT(caption)
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, name, U"(%c+?): (%c+)")) {
		Str__copy(name, mr.exp[0]);
		Str__copy(caption, mr.exp[1]);
	}
	theme_tag *tag = Tags__find_by_name(name, TRUE);
	if (P) Tags__add_to_paragraph(P, tag, caption);
	DISCARD_TEXT(name)
	DISCARD_TEXT(caption)
	Regexp__dispose_of(&mr);
	return tag;
}

#line 91 "inweb/Chapter 2/Tags.w"
text_stream *Tags__retrieve_caption(paragraph *P, theme_tag *tag) {
	if (tag == NULL) return NULL;
	if (P) {
		paragraph_tagging *pt;
		LOOP_OVER_LINKED_LIST(pt, paragraph_tagging, P->taggings)
			if (tag == pt->the_tag)
				return pt->caption;
	}
	return NULL;
}

#line 107 "inweb/Chapter 2/Tags.w"
int Tags__tagged_with(paragraph *P, theme_tag *tag) {
	if (tag == NULL) return TRUE;
	if (P) {
		paragraph_tagging *pt;
		LOOP_OVER_LINKED_LIST(pt, paragraph_tagging, P->taggings)
			if (tag == pt->the_tag)
				return TRUE;
	}
	return FALSE;
}

#line 119 "inweb/Chapter 2/Tags.w"
void Tags__open_ifdefs(OUTPUT_STREAM, paragraph *P) {
	paragraph_tagging *pt;
	LOOP_OVER_LINKED_LIST(pt, paragraph_tagging, P->taggings)
		if (Str__len(pt->the_tag->ifdef_symbol) > 0)
			LanguageMethods__open_ifdef(OUT,
				P->under_section->sect_language, pt->the_tag->ifdef_symbol, pt->the_tag->ifdef_positive);
}

void Tags__close_ifdefs(OUTPUT_STREAM, paragraph *P) {
	paragraph_tagging *pt;
	LOOP_OVER_LINKED_LIST(pt, paragraph_tagging, P->taggings)
		if (Str__len(pt->the_tag->ifdef_symbol) > 0)
			LanguageMethods__close_ifdef(OUT,
				P->under_section->sect_language, pt->the_tag->ifdef_symbol, pt->the_tag->ifdef_positive);
}

void Tags__show_endnote_on_ifdefs(heterogeneous_tree *tree, tree_node *ap, paragraph *P) {
	int d = 0, sense = TRUE;
	
{
#line 144 "inweb/Chapter 2/Tags.w"
	int c = 0;
	paragraph_tagging *pt;
	LOOP_OVER_LINKED_LIST(pt, paragraph_tagging, P->taggings)
		if (pt->the_tag->ifdef_positive == sense)
			if (Str__len(pt->the_tag->ifdef_symbol) > 0) {
				if (c++ == 0) {
					if (d++ == 0) {
						tree_node *E = WeaveTree__endnote(tree);
						Trees__make_child(E, ap); ap = E;
						TextWeaver__commentary_text(tree, ap, TL_IS_2763);
					} else {
						TextWeaver__commentary_text(tree, ap, TL_IS_2764);
					}
				} else {
					TextWeaver__commentary_text(tree, ap, TL_IS_2765);
				}
				TextWeaver__commentary_text(tree, ap, pt->the_tag->ifdef_symbol);
			}
	if (c > 0) {
		if (c == 1) TextWeaver__commentary_text(tree, ap, TL_IS_2766);
		else TextWeaver__commentary_text(tree, ap, TL_IS_2767);
		if (sense) TextWeaver__commentary_text(tree, ap, TL_IS_2768);
		else TextWeaver__commentary_text(tree, ap, TL_IS_2769);
	}

}
#line 137 "inweb/Chapter 2/Tags.w"
;
	sense = FALSE;
	
{
#line 144 "inweb/Chapter 2/Tags.w"
	int c = 0;
	paragraph_tagging *pt;
	LOOP_OVER_LINKED_LIST(pt, paragraph_tagging, P->taggings)
		if (pt->the_tag->ifdef_positive == sense)
			if (Str__len(pt->the_tag->ifdef_symbol) > 0) {
				if (c++ == 0) {
					if (d++ == 0) {
						tree_node *E = WeaveTree__endnote(tree);
						Trees__make_child(E, ap); ap = E;
						TextWeaver__commentary_text(tree, ap, TL_IS_2763);
					} else {
						TextWeaver__commentary_text(tree, ap, TL_IS_2764);
					}
				} else {
					TextWeaver__commentary_text(tree, ap, TL_IS_2765);
				}
				TextWeaver__commentary_text(tree, ap, pt->the_tag->ifdef_symbol);
			}
	if (c > 0) {
		if (c == 1) TextWeaver__commentary_text(tree, ap, TL_IS_2766);
		else TextWeaver__commentary_text(tree, ap, TL_IS_2767);
		if (sense) TextWeaver__commentary_text(tree, ap, TL_IS_2768);
		else TextWeaver__commentary_text(tree, ap, TL_IS_2769);
	}

}
#line 139 "inweb/Chapter 2/Tags.w"
;
	if (d > 0) TextWeaver__commentary_text(tree, ap, TL_IS_2762);
}

#line 22 "inweb/Chapter 2/Enumerated Constants.w"

#line 27 "inweb/Chapter 2/Enumerated Constants.w"
enumeration_set *Enumerations__find(text_stream *post) {
	enumeration_set *es = NULL;
	LOOP_OVER(es, enumeration_set)
		if (Str__eq(post, es->postfix))
			return es;
	return NULL;
}

#line 40 "inweb/Chapter 2/Enumerated Constants.w"
void Enumerations__define(OUTPUT_STREAM, text_stream *symbol,
	text_stream *from, source_line *L) {
	TEMPORARY_TEXT(pf)
	
{
#line 54 "inweb/Chapter 2/Enumerated Constants.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, symbol, U"%c*_(%C+?)")) Str__copy(pf, mr.exp[0]);
	else {
		Main__error_in_web(TL_IS_2770, L);
		WRITE_TO(pf, "BOGUS");
	}
	Regexp__dispose_of(&mr);

}
#line 43 "inweb/Chapter 2/Enumerated Constants.w"
;
	enumeration_set *es = Enumerations__find(pf);
	if (from == NULL) 
{
#line 63 "inweb/Chapter 2/Enumerated Constants.w"
	if (es) {
		if (es->stub) WRITE("(%S+", es->stub);
		WRITE("%d", es->next_free_value++);
		if (es->stub) WRITE(")");
	} else Main__error_in_web(TL_IS_2771, L);

}
#line 45 "inweb/Chapter 2/Enumerated Constants.w"

	else 
{
#line 70 "inweb/Chapter 2/Enumerated Constants.w"
	if (es) Main__error_in_web(TL_IS_2772, L);
	else {
		es = CREATE(enumeration_set);
		es->postfix = Str__duplicate(pf);
		es->stub = NULL;
		if ((Str__len(from) < 8) &&
			((Regexp__match(NULL, from, U"%d+")) ||
				(Regexp__match(NULL, from, U"-%d+")))) {
			es->first_value = Str__atoi(from, 0);
			es->next_free_value = es->first_value + 1;
		} else {
			es->stub = Str__duplicate(from);
			es->first_value = 0;
			es->next_free_value = 1;
		}
	}
	if (es->stub) WRITE("(%S+", es->stub);
	WRITE("%d", es->first_value);
	if (es->stub) WRITE(")");

}
#line 46 "inweb/Chapter 2/Enumerated Constants.w"
;
	DISCARD_TEXT(pf)
	if (es) es->last_observed_at = L;
}

#line 95 "inweb/Chapter 2/Enumerated Constants.w"
void Enumerations__define_extents(OUTPUT_STREAM, tangle_target *target, programming_language *lang) {
	enumeration_set *es;
	LOOP_OVER(es, enumeration_set) {
		TEMPORARY_TEXT(symbol)
		TEMPORARY_TEXT(value)
		WRITE_TO(symbol, "NO_DEFINED_%S_VALUES", es->postfix);
		WRITE_TO(value, "%d", es->next_free_value - es->first_value);
		LanguageMethods__start_definition(OUT, lang, symbol, value,
			es->last_observed_at->owning_section, es->last_observed_at);
		LanguageMethods__end_definition(OUT, lang,
			es->last_observed_at->owning_section, es->last_observed_at);
		DISCARD_TEXT(symbol)
		DISCARD_TEXT(value)
	}
}

#line 19 "inweb/Chapter 2/Paragraph Numbering.w"
void Numbering__number_web(web *W) {
	chapter *C;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters) {
		LOOP_OVER_LINKED_LIST(S, section, C->sections) {
			
{
#line 31 "inweb/Chapter 2/Paragraph Numbering.w"
	for (source_line *L = S->first_line; L; L = L->next_line) {
		TEMPORARY_TEXT(p)
		Str__copy(p, L->text);
		int mlen, mpos;
		while ((mpos = Regexp__find_expansion(p, '@', '<', '@', '>', &mlen)) != -1) {
			TEMPORARY_TEXT(found_macro)
			Str__substr(found_macro, Str__at(p, mpos+2), Str__at(p, mpos+mlen-2));
			TEMPORARY_TEXT(original_p)
			Str__copy(original_p, p);
			Str__clear(p);
			Str__substr(p, Str__at(original_p, mpos + mlen), Str__end(original_p));
			DISCARD_TEXT(original_p)
			para_macro *pmac = Macros__find_by_name(found_macro, S);
			if (pmac) 
{
#line 68 "inweb/Chapter 2/Paragraph Numbering.w"
	macro_usage *mu, *last = NULL;
	LOOP_OVER_LINKED_LIST(mu, macro_usage, pmac->macro_usages) {
		last = mu;
		if (mu->used_in_paragraph == L->owning_paragraph)
			break;
	}
	if (mu == NULL) {
		mu = CREATE(macro_usage);
		mu->used_in_paragraph = L->owning_paragraph;
		mu->multiplicity = 0;
		ADD_TO_LINKED_LIST(mu, macro_usage, pmac->macro_usages);
	}
	mu->multiplicity++;

}
#line 44 "inweb/Chapter 2/Paragraph Numbering.w"
;
			DISCARD_TEXT(found_macro)
		}
		DISCARD_TEXT(p)
	}

}
#line 24 "inweb/Chapter 2/Paragraph Numbering.w"
;
			
{
#line 88 "inweb/Chapter 2/Paragraph Numbering.w"
	
{
#line 95 "inweb/Chapter 2/Paragraph Numbering.w"
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if (P->defines_macro) {
			macro_usage *mu;
			LOOP_OVER_LINKED_LIST(mu, macro_usage, P->defines_macro->macro_usages)
				if (P != mu->used_in_paragraph) {
					Numbering__set_parent(P, mu->used_in_paragraph);
					break;
				}
		}

}
#line 88 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 107 "inweb/Chapter 2/Paragraph Numbering.w"
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if (P->parent_paragraph == NULL)
			for (linked_list_item *P2_item = P_item; P2_item; P2_item = NEXT_ITEM_IN_LINKED_LIST(P2_item, paragraph)) {
				paragraph *P2 = CONTENT_IN_ITEM(P2_item, paragraph);
				if (P2->parent_paragraph) {
					if (P2->parent_paragraph->allocation_id < P->allocation_id)
						Numbering__set_parent(P, P2->parent_paragraph);
					break;
				}
			}

}
#line 89 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 120 "inweb/Chapter 2/Paragraph Numbering.w"
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		P->paragraph_number = Str__new();

}
#line 90 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 129 "inweb/Chapter 2/Paragraph Numbering.w"
	int top_level = 1;
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if (P->parent_paragraph == NULL) {
			WRITE_TO(P->paragraph_number, "%d", top_level++);
			P->next_child_number = 1;
		} else
			Str__clear(P->paragraph_number);

}
#line 91 "inweb/Chapter 2/Paragraph Numbering.w"
;
	
{
#line 139 "inweb/Chapter 2/Paragraph Numbering.w"
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		Numbering__settle_paragraph_number(P);

}
#line 92 "inweb/Chapter 2/Paragraph Numbering.w"
;

}
#line 25 "inweb/Chapter 2/Paragraph Numbering.w"
;
		}
	}
}

#line 66 "inweb/Chapter 2/Paragraph Numbering.w"

#line 149 "inweb/Chapter 2/Paragraph Numbering.w"
void Numbering__settle_paragraph_number(paragraph *P) {
	if (Str__len(P->paragraph_number) > 0) return;
	WRITE_TO(P->paragraph_number, "X"); /* to prevent malformed sections hanging this */
	if (P->parent_paragraph) Numbering__settle_paragraph_number(P->parent_paragraph);
	if (P == P->parent_paragraph) internal_error("paragraph is its own parent");
	Str__clear(P->paragraph_number);
	WRITE_TO(P->paragraph_number, "%S.%d", P->parent_paragraph->paragraph_number,
			P->parent_paragraph->next_child_number++);
	P->next_child_number = 1;
}

void Numbering__set_parent(paragraph *of, paragraph *to) {
	if (of == NULL) internal_error("no paragraph");
	if (to == of) internal_error("paragraph parent set to itself");
	of->parent_paragraph = to;
}

#line 11 "inweb/Chapter 3/The Analyser.w"
void Analyser__scan_line_categories(web *W, text_stream *range) {
	PRINT("Scan of source lines for '%S'\n", range);
	int count = 1;
	chapter *C = Reader__get_chapter_for_range(W, range);
	if (C) {
		section *S;
		LOOP_OVER_LINKED_LIST(S, section, C->sections)
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 35 "inweb/Chapter 3/The Analyser.w"
	TEMPORARY_TEXT(C)
	WRITE_TO(C, "%s", Lines__category_name(L->category));
	while (Str__len(C) < 20) PUT_TO(C, '.');
	PRINT("%07d  %S  %S\n", count++, C, L->text);
	DISCARD_TEXT(C)

}
#line 19 "inweb/Chapter 3/The Analyser.w"
;
	} else {
		section *S = Reader__get_section_for_range(W, range);
		if (S) {
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 35 "inweb/Chapter 3/The Analyser.w"
	TEMPORARY_TEXT(C)
	WRITE_TO(C, "%s", Lines__category_name(L->category));
	while (Str__len(C) < 20) PUT_TO(C, '.');
	PRINT("%07d  %S  %S\n", count++, C, L->text);
	DISCARD_TEXT(C)

}
#line 24 "inweb/Chapter 3/The Analyser.w"

		} else {
			LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
				LOOP_OVER_LINKED_LIST(S, section, C->sections)
					for (source_line *L = S->first_line; L; L = L->next_line)
						
{
#line 35 "inweb/Chapter 3/The Analyser.w"
	TEMPORARY_TEXT(C)
	WRITE_TO(C, "%s", Lines__category_name(L->category));
	while (Str__len(C) < 20) PUT_TO(C, '.');
	PRINT("%07d  %S  %S\n", count++, C, L->text);
	DISCARD_TEXT(C)

}
#line 29 "inweb/Chapter 3/The Analyser.w"
;
		}
	}
}

#line 50 "inweb/Chapter 3/The Analyser.w"

#line 52 "inweb/Chapter 3/The Analyser.w"
void Analyser__catalogue_the_sections(web *W, text_stream *range, int form) {
	int max_width = 0, max_range_width = 0;
	chapter *C;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		LOOP_OVER_LINKED_LIST(S, section, C->sections) {
			if (max_range_width < Str__len(S->md->sect_range)) max_range_width = Str__len(S->md->sect_range);
			TEMPORARY_TEXT(main_title)
			WRITE_TO(main_title, "%S/%S", C->md->ch_basic_title, S->md->sect_title);
			if (max_width < Str__len(main_title)) max_width = Str__len(main_title);
			DISCARD_TEXT(main_title)
		}
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		if ((Str__eq_wide_string(range, U"0")) || (Str__eq(range, C->md->ch_range))) {
			PRINT("      -----\n");
			LOOP_OVER_LINKED_LIST(S, section, C->sections) {
				TEMPORARY_TEXT(main_title)
				WRITE_TO(main_title, "%S/%S", C->md->ch_basic_title, S->md->sect_title);
				PRINT("%4d  %S", S->sect_extent, S->md->sect_range);
				for (int i = Str__len(S->md->sect_range); i<max_range_width+2; i++) PRINT(" ");
				PRINT("%S", main_title);
				for (int i = Str__len(main_title); i<max_width+2; i++) PRINT(" ");
				if (form != BASIC_SECTIONCAT)
					Functions__catalogue(S, (form == FUNCTIONS_SECTIONCAT)?TRUE:FALSE);
				PRINT("\n");
				DISCARD_TEXT(main_title)
			}
		}
}

#line 106 "inweb/Chapter 3/The Analyser.w"
void Analyser__analyse_code(web *W) {
	if (W->analysed) return;

	
{
#line 141 "inweb/Chapter 3/The Analyser.w"
	LanguageMethods__early_preweave_analysis(W->main_language, W);

	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if ((L->category == INTERFACE_BODY_LCAT) &&
			(L->interface_line_identified == FALSE) &&
			(Regexp__string_is_white_space(L->text) == FALSE))
			Main__error_in_web(TL_IS_2773, L);

}
#line 109 "inweb/Chapter 3/The Analyser.w"
;

	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		switch (L->category) {
			case BEGIN_DEFINITION_LCAT:
				
{
#line 155 "inweb/Chapter 3/The Analyser.w"
	Analyser__analyse_as_code(W, L, L->text_operand2, ANY_USAGE, 0);
	while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
		L = L->next_line;
		Analyser__analyse_as_code(W, L, L->text, ANY_USAGE, 0);
	}

}
#line 116 "inweb/Chapter 3/The Analyser.w"
;
				break;
			case CODE_BODY_LCAT:
				
{
#line 152 "inweb/Chapter 3/The Analyser.w"
	Analyser__analyse_as_code(W, L, L->text, ANY_USAGE, 0);

}
#line 119 "inweb/Chapter 3/The Analyser.w"
;
				break;
			case PREFORM_GRAMMAR_LCAT:
				
{
#line 167 "inweb/Chapter 3/The Analyser.w"
	Analyser__analyse_as_code(W, L, L->text_operand2,
		ANY_USAGE, 0);
	Analyser__analyse_as_code(W, L, L->text_operand,
		PREFORM_IN_CODE_USAGE, PREFORM_IN_GRAMMAR_USAGE);

}
#line 122 "inweb/Chapter 3/The Analyser.w"
;
				break;
		}

	LanguageMethods__late_preweave_analysis(W->main_language, W);
	W->analysed = TRUE;
}

#line 185 "inweb/Chapter 3/The Analyser.w"
void Analyser__analyse_as_code(web *W, source_line *L, text_stream *text, int mask, int transf) {
	int start_at = -1, element_follows = FALSE;
	for (int i = 0; i < Str__len(text); i++) {
		if ((Regexp__identifier_char(Str__get_at(text, i))) ||
			((Str__get_at(text, i) == '-') && (Str__get_at(text, i+1) != '>'))) {
			if (start_at == -1) start_at = i;
		} else {
			if (start_at != -1) 
{
#line 206 "inweb/Chapter 3/The Analyser.w"
	int u = MISC_USAGE;
	if (element_follows) u = ELEMENT_ACCESS_USAGE;
	else if (Str__get_at(text, i) == '(') u = FCALL_USAGE;
	else if ((Str__get_at(text, i) == '>') && (start_at > 0) && (Str__get_at(text, start_at-1) == '<'))
		u = PREFORM_IN_CODE_USAGE;
	if (u & mask) {
		if (transf) u = transf;
		TEMPORARY_TEXT(identifier_found)
		for (int j = 0; start_at + j < i; j++)
			PUT_TO(identifier_found, Str__get_at(text, start_at + j));
		Analyser__analyse_find(W, L, identifier_found, u);
		DISCARD_TEXT(identifier_found)
	}
	start_at = -1; element_follows = FALSE;

}
#line 192 "inweb/Chapter 3/The Analyser.w"
;
			if (Str__get_at(text, i) == '.') element_follows = TRUE;
			else if ((Str__get_at(text, i) == '-') && (Str__get_at(text, i+1) == '>')) {
				element_follows = TRUE; i++;
			} else element_follows = FALSE;
		}
	}
	if (start_at != -1) {
		int i = Str__len(text);
		
{
#line 206 "inweb/Chapter 3/The Analyser.w"
	int u = MISC_USAGE;
	if (element_follows) u = ELEMENT_ACCESS_USAGE;
	else if (Str__get_at(text, i) == '(') u = FCALL_USAGE;
	else if ((Str__get_at(text, i) == '>') && (start_at > 0) && (Str__get_at(text, start_at-1) == '<'))
		u = PREFORM_IN_CODE_USAGE;
	if (u & mask) {
		if (transf) u = transf;
		TEMPORARY_TEXT(identifier_found)
		for (int j = 0; start_at + j < i; j++)
			PUT_TO(identifier_found, Str__get_at(text, start_at + j));
		Analyser__analyse_find(W, L, identifier_found, u);
		DISCARD_TEXT(identifier_found)
	}
	start_at = -1; element_follows = FALSE;

}
#line 201 "inweb/Chapter 3/The Analyser.w"
;
	}
}

#line 224 "inweb/Chapter 3/The Analyser.w"
hash_table_entry *Analyser__find_hash_entry_for_section(section *S, text_stream *text,
	int create) {
	return ReservedWords__find_hash_entry(&(S->sect_target->symbols), text, create);
}

void Analyser__mark_reserved_word_for_section(section *S, text_stream *p, int e) {
	ReservedWords__mark_reserved_word(&(S->sect_target->symbols), p, e);
}

hash_table_entry *Analyser__mark_reserved_word_at_line(source_line *L, text_stream *p, int e) {
	if (L == NULL) internal_error("no line for rw");
	hash_table_entry *hte =
		ReservedWords__mark_reserved_word(&(L->owning_section->sect_target->symbols), p, e);
	hte->definition_line = L;
	return hte;
}

int Analyser__is_reserved_word_for_section(section *S, text_stream *p, int e) {
	return ReservedWords__is_reserved_word(&(S->sect_target->symbols), p, e);
}

source_line *Analyser__get_defn_line(section *S, text_stream *p, int e) {
	hash_table_entry *hte = ReservedWords__find_hash_entry(&(S->sect_target->symbols), p, FALSE);
	if ((hte) && (hte->language_reserved_word & (1 << (e % 32)))) return hte->definition_line;
	return NULL;
}

language_function *Analyser__get_function(section *S, text_stream *p, int e) {
	hash_table_entry *hte = ReservedWords__find_hash_entry(&(S->sect_target->symbols), p, FALSE);
	if ((hte) && (hte->language_reserved_word & (1 << (e % 32)))) return hte->as_function;
	return NULL;
}

#line 270 "inweb/Chapter 3/The Analyser.w"

#line 274 "inweb/Chapter 3/The Analyser.w"
void Analyser__analyse_find(web *W, source_line *L, text_stream *identifier, int u) {
	hash_table_entry *hte =
		Analyser__find_hash_entry_for_section(L->owning_section, identifier, FALSE);
	if (hte == NULL) return;
	hash_table_entry_usage *hteu = NULL, *loop = NULL;
	LOOP_OVER_LINKED_LIST(loop, hash_table_entry_usage, hte->usages)
		if (L->owning_paragraph == loop->usage_recorded_at) {
			hteu = loop; break;
		}
	if (hteu == NULL) {
		hteu = CREATE(hash_table_entry_usage);
		hteu->form_of_usage = 0;
		hteu->usage_recorded_at = L->owning_paragraph;
		ADD_TO_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages);
	}
	hteu->form_of_usage |= u;
}

#line 297 "inweb/Chapter 3/The Analyser.w"
void Analyser__write_makefile(web *W, filename *F, module_search *I, text_stream *platform) {
	pathname *P = W->md->path_to_web;
	text_stream *short_name = Pathnames__directory_name(P);
	if ((Str__len(short_name) == 0) ||
		(Str__eq(short_name, TL_IS_2774)) || (Str__eq(short_name, TL_IS_2775)))
		short_name = TL_IS_2776;
	TEMPORARY_TEXT(leafname)
	WRITE_TO(leafname, "%S.mkscript", short_name);
	filename *prototype = Filenames__in(P, leafname);
	DISCARD_TEXT(leafname)
	if (!(TextFiles__exists(prototype)))
		prototype = Filenames__in(path_to_inweb_materials, TL_IS_2777);
	Makefiles__write(W, prototype, F, I, platform);
}

void Analyser__write_gitignore(web *W, filename *F) {
	pathname *P = W->md->path_to_web;
	text_stream *short_name = Pathnames__directory_name(P);
	if ((Str__len(short_name) == 0) ||
		(Str__eq(short_name, TL_IS_2778)) || (Str__eq(short_name, TL_IS_2779)))
		short_name = TL_IS_2780;
	TEMPORARY_TEXT(leafname)
	WRITE_TO(leafname, "%S.giscript", short_name);
	filename *prototype = Filenames__in(P, leafname);
	DISCARD_TEXT(leafname)
	if (!(TextFiles__exists(prototype)))
		prototype = Filenames__in(path_to_inweb_materials, TL_IS_2781);
	Git__write_gitignore(W, prototype, F);
}

#line 330 "inweb/Chapter 3/The Analyser.w"
programming_language *Analyser__default_language(web *W) {
	return Analyser__find_by_name(TL_IS_2782, W, TRUE);
}

programming_language *Analyser__find_by_name(text_stream *lname, web *W,
	int error_if_not_found) {
	pathname *P = Pathnames__down(W->md->path_to_web, TL_IS_2783);
	return Languages__find_by_name(lname, P, error_if_not_found);
}

#line 19 "inweb/Chapter 3/The Collater.w"
void Collater__for_web_and_pattern(text_stream *OUT, web *W,
	weave_pattern *pattern, filename *F, filename *into) {
	Collater__collate(OUT, W, TL_IS_2784, F, pattern, NULL, NULL, NULL, into);
}

void Collater__for_order(text_stream *OUT, weave_order *wv,
	filename *F, filename *into) {
	Collater__collate(OUT, wv->weave_web, wv->weave_range, F, wv->pattern,
		wv->navigation, wv->breadcrumbs, wv, into);
}

void Collater__collate(text_stream *OUT, web *W, text_stream *range,
	filename *template_filename, weave_pattern *pattern, filename *nav_file,
	linked_list *crumbs, weave_order *wv, filename *into) {
	collater_state actual_ies =
		Collater__initial_state(W, range, template_filename, pattern,
			nav_file, crumbs, wv, into);
	collater_state *ies = &actual_ies;
	Collater__process(OUT, ies);
}

#line 67 "inweb/Chapter 3/The Collater.w"

#line 73 "inweb/Chapter 3/The Collater.w"
collater_state Collater__initial_state(web *W, text_stream *range,
	filename *template_filename, weave_pattern *pattern, filename *nav_file,
	linked_list *crumbs, weave_order *wv, filename *into) {
	collater_state cls;
	cls.no_tlines = 0;
	cls.restrict_to_range = Str__duplicate(range);
	cls.sp = 0;
	cls.inside_navigation_submenu = FALSE;
	cls.for_web = W;
	cls.nav_pattern = pattern;
	cls.nav_file = nav_file;
	cls.crumbs = crumbs;
	cls.errors_at = template_filename;
	cls.wv = wv;
	cls.into_file = into;
	cls.modules = NEW_LINKED_LIST(module);
	if (W) {
		int c = LinkedLists__len(W->md->as_module->dependencies);
		if (c > 0) 
{
#line 98 "inweb/Chapter 3/The Collater.w"
	module **module_array =
		Memory__calloc(c, sizeof(module *), ARRAY_SORTING_MREASON);
	module *M; int d=0;
	LOOP_OVER_LINKED_LIST(M, module, W->md->as_module->dependencies)
		module_array[d++] = M;
	Collater__sort_web(W);
	qsort(module_array, (size_t) c, sizeof(module *), Collater__sort_comparison);
	for (int d=0; d<c; d++) ADD_TO_LINKED_LIST(module_array[d], module, cls.modules);
	Memory__I7_free(module_array, ARRAY_SORTING_MREASON, c*((int) sizeof(module *)));

}
#line 91 "inweb/Chapter 3/The Collater.w"
;
	}
	
{
#line 109 "inweb/Chapter 3/The Collater.w"
	TextFiles__read(template_filename, FALSE,
		"can't find contents template", TRUE, Collater__temp_line, NULL, &cls);
	if (TRACE_COLLATER_EXECUTION)
		PRINT("Read template <%f>: %d line(s)\n", template_filename, cls.no_tlines);
	if (cls.no_tlines >= MAX_TEMPLATE_LINES)
		PRINT("Warning: template <%f> truncated after %d line(s)\n",
			template_filename, cls.no_tlines);

}
#line 93 "inweb/Chapter 3/The Collater.w"
;
	return cls;
}

#line 118 "inweb/Chapter 3/The Collater.w"
void Collater__temp_line(text_stream *line, text_file_position *tfp, void *v_ies) {
	collater_state *cls = (collater_state *) v_ies;
	if (cls->no_tlines < MAX_TEMPLATE_LINES)
		cls->tlines[cls->no_tlines++] = Str__duplicate(line);
}

#line 127 "inweb/Chapter 3/The Collater.w"
void Collater__process(text_stream *OUT, collater_state *cls) {
	int lpos = 0; /* This is our program counter: a line number in the template */
	while (lpos < cls->no_tlines) {
		match_results mr = Regexp__create_mr();
		TEMPORARY_TEXT(tl)
		Str__copy(tl, cls->tlines[lpos++]); /* Fetch the line at the program counter and advance */
		
{
#line 144 "inweb/Chapter 3/The Collater.w"
	if (Regexp__match(&mr, tl, U"(%c*?) ")) Str__copy(tl, mr.exp[0]); /* Strip trailing spaces */
	if (TRACE_COLLATER_EXECUTION)
		
{
#line 166 "inweb/Chapter 3/The Collater.w"
	PRINT("%04d: %S\nStack:", lpos-1, tl);
	for (int j=0; j<cls->sp; j++) {
		if (cls->repeat_stack_level[j] == CHAPTER_LEVEL)
			PRINT(" %d: %S/%S",
				j, ((chapter *)
					CONTENT_IN_ITEM(cls->repeat_stack_variable[j], chapter))->md->ch_range,
				((chapter *)
					CONTENT_IN_ITEM(cls->repeat_stack_threshold[j], chapter))->md->ch_range);
		else if (cls->repeat_stack_level[j] == SECTION_LEVEL)
			PRINT(" %d: %S/%S",
				j, ((section *)
					CONTENT_IN_ITEM(cls->repeat_stack_variable[j], section))->md->sect_range,
				((section *)
					CONTENT_IN_ITEM(cls->repeat_stack_threshold[j], section))->md->sect_range);
	}
	PRINT("\n");

}
#line 146 "inweb/Chapter 3/The Collater.w"
;
	if ((Regexp__match(&mr, tl, U"%[%[(%c+)%]%]")) ||
		(Regexp__match(&mr, tl, U" %[%[(%c+)%]%]"))) {
		TEMPORARY_TEXT(command)
		Str__copy(command, mr.exp[0]);
		
{
#line 188 "inweb/Chapter 3/The Collater.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, command, U"Select (%c*)")) {
		chapter *C;
		section *S;
		LOOP_OVER_LINKED_LIST(C, chapter, cls->for_web->chapters)
			LOOP_OVER_LINKED_LIST(S, section, C->sections)
				if (Str__eq(S->md->sect_range, mr.exp[0])) {
					Collater__start_CI_loop(cls, SECTION_LEVEL, S_item, S_item, lpos);
					Regexp__dispose_of(&mr);
					goto CYCLE;
				}
		LOOP_OVER_LINKED_LIST(C, chapter, cls->for_web->chapters)
			if (Str__eq(C->md->ch_range, mr.exp[0])) {
				Collater__start_CI_loop(cls, CHAPTER_LEVEL, C_item, C_item, lpos);
				Regexp__dispose_of(&mr);
				goto CYCLE;
			}
		Errors__at_position("don't recognise the chapter or section abbreviation range",
			cls->errors_at, lpos);
		Regexp__dispose_of(&mr);
		goto CYCLE;
	}

}
#line 151 "inweb/Chapter 3/The Collater.w"
;
		
{
#line 214 "inweb/Chapter 3/The Collater.w"
	if (Regexp__match(&mr, command, U"If (%c*)")) {
		text_stream *condition = mr.exp[0];
		int level = IF_FALSE_LEVEL;
		if (Str__eq(condition, TL_IS_2785)) {
			if (cls->for_web->md->chaptered) level = IF_TRUE_LEVEL;
		} else if (Str__eq(condition, TL_IS_2786)) {
			if (LinkedLists__len(cls->modules) > 0)
				level = IF_TRUE_LEVEL;
		} else if (Str__eq(condition, TL_IS_2787)) {
			module *M = CONTENT_IN_ITEM(
				Collater__heading_topmost_on_stack(cls, MODULE_LEVEL), module);
			if ((M) && (Colonies__find(M->module_name)))
				level = IF_TRUE_LEVEL;
		} else if (Str__eq(condition, TL_IS_2788)) {
			module *M = CONTENT_IN_ITEM(
				Collater__heading_topmost_on_stack(cls, MODULE_LEVEL), module);
			if (M) {
				TEMPORARY_TEXT(url)
				TEMPORARY_TEXT(purpose)
				WRITE_TO(url, "%p", M->module_location);
				Readme__write_var(purpose, url, TL_IS_2789);
				if (Str__len(purpose) > 0) level = IF_TRUE_LEVEL;
				DISCARD_TEXT(url)
				DISCARD_TEXT(purpose)
			}
		} else if (Str__eq(condition, TL_IS_2790)) {
			chapter *C = CONTENT_IN_ITEM(
				Collater__heading_topmost_on_stack(cls, CHAPTER_LEVEL), chapter);
			if ((C) && (Str__len(C->md->rubric) > 0)) level = IF_TRUE_LEVEL;
		} else if (Str__eq(condition, TL_IS_2791)) {
			section *S = CONTENT_IN_ITEM(
				Collater__heading_topmost_on_stack(cls, SECTION_LEVEL), section);
			if ((S) && (Str__len(S->sect_purpose) > 0)) level = IF_TRUE_LEVEL;
		} else {
			Errors__at_position("don't recognise the condition",
				cls->errors_at, lpos);
		}
		Collater__start_CI_loop(cls, level, NULL, NULL, lpos);
		Regexp__dispose_of(&mr);
		goto CYCLE;
	}

}
#line 152 "inweb/Chapter 3/The Collater.w"
;
		
{
#line 257 "inweb/Chapter 3/The Collater.w"
	if (Regexp__match(&mr, command, U"Else")) {
		if (cls->sp <= 0) {
			Errors__at_position("Else without If",
				cls->errors_at, lpos);
			goto CYCLE;
		}
		switch (cls->repeat_stack_level[cls->sp-1]) {
			case SECTION_LEVEL:
			case CHAPTER_LEVEL:
				Errors__at_position("Else not matched with If",
					cls->errors_at, lpos);
				break;
			case IF_TRUE_LEVEL: cls->repeat_stack_level[cls->sp-1] = IF_FALSE_LEVEL; break;
			case IF_FALSE_LEVEL: cls->repeat_stack_level[cls->sp-1] = IF_TRUE_LEVEL; break;
		}
		Regexp__dispose_of(&mr);
		goto CYCLE;
	}

}
#line 153 "inweb/Chapter 3/The Collater.w"
;
		
{
#line 279 "inweb/Chapter 3/The Collater.w"
	int loop_level = 0;
	if (Regexp__match(&mr, command, U"Repeat Module")) loop_level = MODULE_LEVEL;
	if (Regexp__match(&mr, command, U"Repeat Chapter")) loop_level = CHAPTER_LEVEL;
	if (Regexp__match(&mr, command, U"Repeat Section")) loop_level = SECTION_LEVEL;
	if (loop_level != 0) {
		linked_list_item *from = NULL, *to = NULL;
		linked_list_item *CI = FIRST_ITEM_IN_LINKED_LIST(chapter, cls->for_web->chapters);
		while ((CI) && (CONTENT_IN_ITEM(CI, chapter)->md->imported))
			CI = NEXT_ITEM_IN_LINKED_LIST(CI, chapter);
		if (loop_level == MODULE_LEVEL) 
{
#line 296 "inweb/Chapter 3/The Collater.w"
	from = FIRST_ITEM_IN_LINKED_LIST(module, cls->modules);
	to = LAST_ITEM_IN_LINKED_LIST(module, cls->modules);

}
#line 288 "inweb/Chapter 3/The Collater.w"
;
		if (loop_level == CHAPTER_LEVEL) 
{
#line 300 "inweb/Chapter 3/The Collater.w"
	from = CI;
	to = LAST_ITEM_IN_LINKED_LIST(chapter, cls->for_web->chapters);
	if (Str__eq_wide_string(cls->restrict_to_range, U"0") == FALSE) {
		chapter *C;
		LOOP_OVER_LINKED_LIST(C, chapter, cls->for_web->chapters)
			if (Str__eq(C->md->ch_range, cls->restrict_to_range)) {
				from = C_item; to = from;
				break;
			}
	}

}
#line 289 "inweb/Chapter 3/The Collater.w"
;
		if (loop_level == SECTION_LEVEL) 
{
#line 312 "inweb/Chapter 3/The Collater.w"
	chapter *within_chapter =
		CONTENT_IN_ITEM(Collater__heading_topmost_on_stack(cls, CHAPTER_LEVEL),
			chapter);
	if (within_chapter == NULL) {
		if (CI) {
			chapter *C = CONTENT_IN_ITEM(CI, chapter);
			from = FIRST_ITEM_IN_LINKED_LIST(section, C->sections);
		}
		chapter *LC = LAST_IN_LINKED_LIST(chapter, cls->for_web->chapters);
		if (LC) to = LAST_ITEM_IN_LINKED_LIST(section, LC->sections);
	} else {
		from = FIRST_ITEM_IN_LINKED_LIST(section, within_chapter->sections);
		to = LAST_ITEM_IN_LINKED_LIST(section, within_chapter->sections);
	}

}
#line 290 "inweb/Chapter 3/The Collater.w"
;
		Collater__start_CI_loop(cls, loop_level, from, to, lpos);
		goto CYCLE;
	}

}
#line 154 "inweb/Chapter 3/The Collater.w"
;
		
{
#line 330 "inweb/Chapter 3/The Collater.w"
	int end_form = -1;
	if (Regexp__match(&mr, command, U"End Repeat")) end_form = 1;
	if (Regexp__match(&mr, command, U"End Select")) end_form = 2;
	if (Regexp__match(&mr, command, U"End If")) end_form = 3;
	if (end_form > 0) {
		if (cls->sp <= 0) {
			Errors__at_position("stack underflow on contents template",
				cls->errors_at, lpos);
			goto CYCLE;
		}
		switch (cls->repeat_stack_level[cls->sp-1]) {
			case MODULE_LEVEL:
			case CHAPTER_LEVEL:
			case SECTION_LEVEL:
				if (end_form == 3) {
					Errors__at_position("End If not matched with If",
						cls->errors_at, lpos);
					goto CYCLE;
				}
				break;
			case IF_TRUE_LEVEL:
			case IF_FALSE_LEVEL:
				if (end_form != 3) {
					Errors__at_position("If not matched with End If",
						cls->errors_at, lpos);
					goto CYCLE;
				}
				break;
		}
		switch (cls->repeat_stack_level[cls->sp-1]) {
			case MODULE_LEVEL: 
{
#line 370 "inweb/Chapter 3/The Collater.w"
	linked_list_item *CI = cls->repeat_stack_variable[cls->sp-1];
	if (CI == cls->repeat_stack_threshold[cls->sp-1])
		Collater__end_CI_loop(cls);
	else {
		cls->repeat_stack_variable[cls->sp-1] =
			NEXT_ITEM_IN_LINKED_LIST(CI, chapter);
		lpos = cls->repeat_stack_startpos[cls->sp-1]; /* Back round loop */
	}

}
#line 360 "inweb/Chapter 3/The Collater.w"
; break;
			case CHAPTER_LEVEL: 
{
#line 380 "inweb/Chapter 3/The Collater.w"
	linked_list_item *CI = cls->repeat_stack_variable[cls->sp-1];
	if (CI == cls->repeat_stack_threshold[cls->sp-1])
		Collater__end_CI_loop(cls);
	else {
		cls->repeat_stack_variable[cls->sp-1] =
			NEXT_ITEM_IN_LINKED_LIST(CI, chapter);
		lpos = cls->repeat_stack_startpos[cls->sp-1]; /* Back round loop */
	}

}
#line 361 "inweb/Chapter 3/The Collater.w"
; break;
			case SECTION_LEVEL: 
{
#line 390 "inweb/Chapter 3/The Collater.w"
	linked_list_item *SI = cls->repeat_stack_variable[cls->sp-1];
	if ((SI == cls->repeat_stack_threshold[cls->sp-1]) ||
		(NEXT_ITEM_IN_LINKED_LIST(SI, section) == NULL))
		Collater__end_CI_loop(cls);
	else {
		cls->repeat_stack_variable[cls->sp-1] =
			NEXT_ITEM_IN_LINKED_LIST(SI, section);
		lpos = cls->repeat_stack_startpos[cls->sp-1]; /* Back round loop */
	}

}
#line 362 "inweb/Chapter 3/The Collater.w"
; break;
			case IF_TRUE_LEVEL: 
{
#line 401 "inweb/Chapter 3/The Collater.w"
	Collater__end_CI_loop(cls);

}
#line 363 "inweb/Chapter 3/The Collater.w"
; break;
			case IF_FALSE_LEVEL: 
{
#line 401 "inweb/Chapter 3/The Collater.w"
	Collater__end_CI_loop(cls);

}
#line 364 "inweb/Chapter 3/The Collater.w"
; break;
		}
		goto CYCLE;
	}

}
#line 155 "inweb/Chapter 3/The Collater.w"
;
		DISCARD_TEXT(command)
	}
	
{
#line 415 "inweb/Chapter 3/The Collater.w"
	for (int j=cls->sp-1; j>=0; j--)
		if (cls->repeat_stack_level[j] == IF_FALSE_LEVEL)
			goto CYCLE;

}
#line 158 "inweb/Chapter 3/The Collater.w"
;
	
{
#line 406 "inweb/Chapter 3/The Collater.w"
	for (int rstl = cls->sp-1; rstl >= 0; rstl--)
		if (cls->repeat_stack_level[cls->sp-1] == SECTION_LEVEL) {
			linked_list_item *SI = cls->repeat_stack_threshold[cls->sp-1];
			if (NEXT_ITEM_IN_LINKED_LIST(SI, section) ==
				cls->repeat_stack_variable[cls->sp-1])
				goto CYCLE;
		}

}
#line 159 "inweb/Chapter 3/The Collater.w"
;
	
{
#line 465 "inweb/Chapter 3/The Collater.w"
	TEMPORARY_TEXT(rewritten)
	int slen, spos;
	while ((spos = Regexp__find_expansion(tl, '[', '[', ']', ']', &slen)) >= 0) {
		TEMPORARY_TEXT(varname)
		TEMPORARY_TEXT(substituted)
		TEMPORARY_TEXT(tail)
		Str__substr(rewritten, Str__start(tl), Str__at(tl, spos));
		Str__substr(varname, Str__at(tl, spos+2), Str__at(tl, spos+slen-2));
		Str__substr(tail, Str__at(tl, spos+slen), Str__end(tl));

		match_results mr = Regexp__create_mr();
		if (Bibliographic__data_exists(cls->for_web->md, varname)) {
			
{
#line 541 "inweb/Chapter 3/The Collater.w"
	WRITE_TO(substituted, "%S", Bibliographic__get_datum(cls->for_web->md, varname));

}
#line 477 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Navigation")) {
			
{
#line 547 "inweb/Chapter 3/The Collater.w"
	if (cls->nav_file) {
		if (TextFiles__exists(cls->nav_file))
			Collater__collate(substituted, cls->for_web, cls->restrict_to_range,
				cls->nav_file, cls->nav_pattern, NULL, NULL, cls->wv, cls->into_file);
		else
			Errors__fatal_with_file("unable to find navigation file", cls->nav_file);
	} else {
		PRINT("Warning: no sidebar links will be generated, as -navigation is unset");
	}

}
#line 479 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Breadcrumbs")) {
			
{
#line 560 "inweb/Chapter 3/The Collater.w"
	Colonies__drop_initial_breadcrumbs(substituted, cls->into_file,
		cls->crumbs);

}
#line 481 "inweb/Chapter 3/The Collater.w"
;
		} else if (Str__eq_wide_string(varname, U"Plugins")) {
			
{
#line 564 "inweb/Chapter 3/The Collater.w"
	Assets__include_relevant_plugins(OUT, cls->nav_pattern, cls->for_web,
		cls->wv, cls->into_file);

}
#line 483 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Complete (%c+)")) {
			text_stream *detail = mr.exp[0];
			
{
#line 570 "inweb/Chapter 3/The Collater.w"
	if (swarm_leader)
		if (Formats__substitute_post_processing_data(substituted,
			swarm_leader, detail, cls->nav_pattern) == FALSE)
			WRITE_TO(substituted, "%S for complete web", detail);

}
#line 486 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Module (%c+)")) {
			text_stream *detail = mr.exp[0];
			
{
#line 578 "inweb/Chapter 3/The Collater.w"
	module *M = CONTENT_IN_ITEM(
		Collater__heading_topmost_on_stack(cls, MODULE_LEVEL), module);
	if (M == NULL)
		Errors__at_position("no module is currently selected",
			cls->errors_at, lpos);
	else 
{
#line 586 "inweb/Chapter 3/The Collater.w"
	if (Str__eq_wide_string(detail, U"Title")) {
		text_stream *owner = Collater__module_owner(M, cls->for_web);
		if (Str__len(owner) > 0) WRITE_TO(substituted, "%S/", owner);
		WRITE_TO(substituted, "%S", M->module_name);
	} else if (Str__eq_wide_string(detail, U"Page")) {
		if (Colonies__find(M->module_name))
			Colonies__reference_URL(substituted, M->module_name, cls->into_file);
	} else if (Str__eq_wide_string(detail, U"Purpose")) {
		TEMPORARY_TEXT(url)
		WRITE_TO(url, "%p", M->module_location);
		Readme__write_var(substituted, url, TL_IS_2792);
		DISCARD_TEXT(url)
	} else {
		WRITE_TO(substituted, "%S for %S", varname, M->module_name);
	}

}
#line 583 "inweb/Chapter 3/The Collater.w"
;

}
#line 489 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Chapter (%c+)")) {
			text_stream *detail = mr.exp[0];
			
{
#line 605 "inweb/Chapter 3/The Collater.w"
	chapter *C = CONTENT_IN_ITEM(
		Collater__heading_topmost_on_stack(cls, CHAPTER_LEVEL), chapter);
	if (C == NULL)
		Errors__at_position("no chapter is currently selected",
			cls->errors_at, lpos);
	else 
{
#line 613 "inweb/Chapter 3/The Collater.w"
	if (Str__eq_wide_string(detail, U"Title")) {
		Str__copy(substituted, C->md->ch_title);
	} else if (Str__eq_wide_string(detail, U"Code")) {
		Str__copy(substituted, C->md->ch_range);
	} else if (Str__eq_wide_string(detail, U"Purpose")) {
		Str__copy(substituted, C->md->rubric);
	} else if (Formats__substitute_post_processing_data(substituted,
		C->ch_weave, detail, cls->nav_pattern)) {
		;
	} else {
		WRITE_TO(substituted, "%S for %S", varname, C->md->ch_title);
	}

}
#line 610 "inweb/Chapter 3/The Collater.w"
;

}
#line 492 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Section (%c+)")) {
			text_stream *detail = mr.exp[0];
			
{
#line 629 "inweb/Chapter 3/The Collater.w"
	section *S = CONTENT_IN_ITEM(
		Collater__heading_topmost_on_stack(cls, SECTION_LEVEL), section);
	if (S == NULL)
		Errors__at_position("no section is currently selected",
			cls->errors_at, lpos);
	else 
{
#line 637 "inweb/Chapter 3/The Collater.w"
	if (Str__eq_wide_string(detail, U"Title")) {
		Str__copy(substituted, S->md->sect_title);
	} else if (Str__eq_wide_string(detail, U"Purpose")) {
		Str__copy(substituted, S->sect_purpose);
	} else if (Str__eq_wide_string(detail, U"Code")) {
		Str__copy(substituted, S->md->sect_range);
	} else if (Str__eq_wide_string(detail, U"Lines")) {
		WRITE_TO(substituted, "%d", S->sect_extent);
	} else if (Str__eq_wide_string(detail, U"Source")) {
		WRITE_TO(substituted, "%f", S->md->source_file_for_section);
	} else if (Str__eq_wide_string(detail, U"Page")) {
		Colonies__section_URL(substituted, S->md);
	} else if (Str__eq_wide_string(detail, U"Paragraphs")) {
		WRITE_TO(substituted, "%d", S->sect_paragraphs);
	} else if (Str__eq_wide_string(detail, U"Mean")) {
		int denom = S->sect_paragraphs;
		if (denom == 0) denom = 1;
		WRITE_TO(substituted, "%d", S->sect_extent/denom);
	} else if (Formats__substitute_post_processing_data(substituted,
		S->sect_weave, detail, cls->nav_pattern)) {
		;
	} else {
		WRITE_TO(substituted, "%S for %S", varname, S->md->sect_title);
	}

}
#line 634 "inweb/Chapter 3/The Collater.w"
;

}
#line 495 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Docs")) {
			
{
#line 666 "inweb/Chapter 3/The Collater.w"
	Pathnames__relative_URL(substituted,
		Filenames__up(cls->into_file),
		Pathnames__from_text(Colonies__home()));

}
#line 497 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Assets")) {
			
{
#line 671 "inweb/Chapter 3/The Collater.w"
	pathname *P = Colonies__assets_path();
	if (P == NULL) P = Filenames__up(cls->into_file);
	Pathnames__relative_URL(substituted,
		Filenames__up(cls->into_file), P);

}
#line 499 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"URL \"(%c+)\"")) {
			text_stream *link_text = mr.exp[0];
			
{
#line 677 "inweb/Chapter 3/The Collater.w"
	Pathnames__relative_URL(substituted,
		Filenames__up(cls->into_file),
		Pathnames__from_text(link_text));

}
#line 502 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Link \"(%c+)\"")) {
			text_stream *link_text = mr.exp[0];
			
{
#line 682 "inweb/Chapter 3/The Collater.w"
	WRITE_TO(substituted, "<a href=\"");
	Colonies__reference_URL(substituted, link_text, cls->into_file);
	WRITE_TO(substituted, "\">");

}
#line 505 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Menu \"(%c+)\"")) {
			text_stream *menu_name = mr.exp[0];
			
{
#line 687 "inweb/Chapter 3/The Collater.w"
	if (cls->inside_navigation_submenu) WRITE_TO(substituted, "</ul>");
	WRITE_TO(substituted, "<h2>%S</h2><ul>", menu_name);
	cls->inside_navigation_submenu = TRUE;

}
#line 508 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Item \"(%c+)\"")) {
			text_stream *item_name = mr.exp[0];
			text_stream *icon_text = NULL;
			
{
#line 692 "inweb/Chapter 3/The Collater.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, item_name, U"<(%i+.%i+)> *(%c*)")) {
		icon_text = Str__duplicate(mr.exp[0]);
		item_name = Str__duplicate(mr.exp[1]);
	} else if (Regexp__match(&mr, item_name, U"(%c*?) *<(%i+.%i+)>")) {
		icon_text = Str__duplicate(mr.exp[1]);
		item_name = Str__duplicate(mr.exp[0]);
	}
	Regexp__dispose_of(&mr);

}
#line 512 "inweb/Chapter 3/The Collater.w"
;
			text_stream *link_text = item_name;
			
{
#line 703 "inweb/Chapter 3/The Collater.w"
	TEMPORARY_TEXT(url)
	Colonies__reference_URL(url, link_text, cls->into_file);
	
{
#line 715 "inweb/Chapter 3/The Collater.w"
	if (cls->inside_navigation_submenu == FALSE) WRITE_TO(substituted, "<ul>");
	cls->inside_navigation_submenu = TRUE;
	WRITE_TO(substituted, "<li>");
	if (Str__eq(url, Filenames__get_leafname(cls->into_file))) {
		WRITE_TO(substituted, "<span class=\"unlink\">");
		
{
#line 736 "inweb/Chapter 3/The Collater.w"
	if (Str__len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies__assets_path();
		if (I == NULL) I = Pathnames__from_text(Colonies__home());
		Pathnames__relative_URL(substituted,
			Filenames__up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=18> ", icon_text);
	}
	WRITE_TO(substituted, "%S", item_name);

}
#line 720 "inweb/Chapter 3/The Collater.w"
;
		WRITE_TO(substituted, "</span>");
	} else if (Str__eq(url, TL_IS_2793)) {
		WRITE_TO(substituted, "<a href=\"%S\">", url);
		WRITE_TO(substituted, "<span class=\"selectedlink\">");
		
{
#line 736 "inweb/Chapter 3/The Collater.w"
	if (Str__len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies__assets_path();
		if (I == NULL) I = Pathnames__from_text(Colonies__home());
		Pathnames__relative_URL(substituted,
			Filenames__up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=18> ", icon_text);
	}
	WRITE_TO(substituted, "%S", item_name);

}
#line 725 "inweb/Chapter 3/The Collater.w"
;
		WRITE_TO(substituted, "</span>");
		WRITE_TO(substituted, "</a>");
	} else {
		WRITE_TO(substituted, "<a href=\"%S\">", url);
		
{
#line 736 "inweb/Chapter 3/The Collater.w"
	if (Str__len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies__assets_path();
		if (I == NULL) I = Pathnames__from_text(Colonies__home());
		Pathnames__relative_URL(substituted,
			Filenames__up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=18> ", icon_text);
	}
	WRITE_TO(substituted, "%S", item_name);

}
#line 730 "inweb/Chapter 3/The Collater.w"
;
		WRITE_TO(substituted, "</a>");
	}
	WRITE_TO(substituted, "</li>");

}
#line 705 "inweb/Chapter 3/The Collater.w"
;
	DISCARD_TEXT(url)

}
#line 514 "inweb/Chapter 3/The Collater.w"
;
		} else if (Regexp__match(&mr, varname, U"Item \"(%c+)\" -> (%c+)")) {
			text_stream *item_name = mr.exp[0];
			text_stream *link_text = mr.exp[1];
			text_stream *icon_text = NULL;
			
{
#line 692 "inweb/Chapter 3/The Collater.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, item_name, U"<(%i+.%i+)> *(%c*)")) {
		icon_text = Str__duplicate(mr.exp[0]);
		item_name = Str__duplicate(mr.exp[1]);
	} else if (Regexp__match(&mr, item_name, U"(%c*?) *<(%i+.%i+)>")) {
		icon_text = Str__duplicate(mr.exp[1]);
		item_name = Str__duplicate(mr.exp[0]);
	}
	Regexp__dispose_of(&mr);

}
#line 519 "inweb/Chapter 3/The Collater.w"
;
			
{
#line 709 "inweb/Chapter 3/The Collater.w"
	TEMPORARY_TEXT(url)
	Colonies__link_URL(url, link_text, cls->into_file);
	
{
#line 715 "inweb/Chapter 3/The Collater.w"
	if (cls->inside_navigation_submenu == FALSE) WRITE_TO(substituted, "<ul>");
	cls->inside_navigation_submenu = TRUE;
	WRITE_TO(substituted, "<li>");
	if (Str__eq(url, Filenames__get_leafname(cls->into_file))) {
		WRITE_TO(substituted, "<span class=\"unlink\">");
		
{
#line 736 "inweb/Chapter 3/The Collater.w"
	if (Str__len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies__assets_path();
		if (I == NULL) I = Pathnames__from_text(Colonies__home());
		Pathnames__relative_URL(substituted,
			Filenames__up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=18> ", icon_text);
	}
	WRITE_TO(substituted, "%S", item_name);

}
#line 720 "inweb/Chapter 3/The Collater.w"
;
		WRITE_TO(substituted, "</span>");
	} else if (Str__eq(url, TL_IS_2793)) {
		WRITE_TO(substituted, "<a href=\"%S\">", url);
		WRITE_TO(substituted, "<span class=\"selectedlink\">");
		
{
#line 736 "inweb/Chapter 3/The Collater.w"
	if (Str__len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies__assets_path();
		if (I == NULL) I = Pathnames__from_text(Colonies__home());
		Pathnames__relative_URL(substituted,
			Filenames__up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=18> ", icon_text);
	}
	WRITE_TO(substituted, "%S", item_name);

}
#line 725 "inweb/Chapter 3/The Collater.w"
;
		WRITE_TO(substituted, "</span>");
		WRITE_TO(substituted, "</a>");
	} else {
		WRITE_TO(substituted, "<a href=\"%S\">", url);
		
{
#line 736 "inweb/Chapter 3/The Collater.w"
	if (Str__len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies__assets_path();
		if (I == NULL) I = Pathnames__from_text(Colonies__home());
		Pathnames__relative_URL(substituted,
			Filenames__up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=18> ", icon_text);
	}
	WRITE_TO(substituted, "%S", item_name);

}
#line 730 "inweb/Chapter 3/The Collater.w"
;
		WRITE_TO(substituted, "</a>");
	}
	WRITE_TO(substituted, "</li>");

}
#line 711 "inweb/Chapter 3/The Collater.w"
;
	DISCARD_TEXT(url)

}
#line 520 "inweb/Chapter 3/The Collater.w"
;
		} else {
			WRITE_TO(substituted, "%S", varname);
			if (Regexp__match(&mr, varname, U"%i+%c*"))
				PRINT("Warning: unable to resolve command '%S'\n", varname);
		}
		Regexp__dispose_of(&mr);
		Str__clear(tl);
		WRITE_TO(rewritten, "%S", substituted);
		WRITE_TO(tl, "%S", tail);
		DISCARD_TEXT(tail)
		DISCARD_TEXT(varname)
		DISCARD_TEXT(substituted)
	}
	WRITE_TO(rewritten, "%S", tl);
	Str__clear(tl); Str__copy(tl, rewritten);
	DISCARD_TEXT(rewritten)

}
#line 160 "inweb/Chapter 3/The Collater.w"
;

}
#line 133 "inweb/Chapter 3/The Collater.w"
;
		WRITE("%S\n", tl); /* Copy the now finished line to the output */
		DISCARD_TEXT(tl)
		CYCLE: ;
		Regexp__dispose_of(&mr);
	}
	if (cls->inside_navigation_submenu) WRITE("</ul>");
	cls->inside_navigation_submenu = FALSE;
}

#line 423 "inweb/Chapter 3/The Collater.w"
linked_list_item *Collater__heading_topmost_on_stack(collater_state *cls, int level) {
	for (int rstl = cls->sp-1; rstl >= 0; rstl--)
		if (cls->repeat_stack_level[rstl] == level)
			return cls->repeat_stack_variable[rstl];
	return NULL;
}

#line 440 "inweb/Chapter 3/The Collater.w"
void Collater__start_CI_loop(collater_state *cls, int level,
	linked_list_item *from, linked_list_item *to, int pos) {
	if (cls->sp < CI_STACK_CAPACITY) {
		cls->repeat_stack_level[cls->sp] = level;
		cls->repeat_stack_variable[cls->sp] = from;
		cls->repeat_stack_threshold[cls->sp] = to;
		cls->repeat_stack_startpos[cls->sp++] = pos;
	}
}

void Collater__end_CI_loop(collater_state *cls) {
	cls->sp--;
}

#line 750 "inweb/Chapter 3/The Collater.w"
text_stream *Collater__module_owner(const module *M, web *W) {
	text_stream *owner =
		Pathnames__directory_name(Pathnames__up(M->module_location));
	text_stream *me = NULL;
	if ((W) && (W->md->path_to_web))
		me = Pathnames__directory_name(W->md->path_to_web);
	if (Str__ne_insensitive(me, owner)) return owner;
	return NULL;
}

#line 765 "inweb/Chapter 3/The Collater.w"
web *sorting_web = NULL;
void Collater__sort_web(web *W) {
	sorting_web = W;
}
int Collater__sort_comparison(const void *ent1, const void *ent2) {
	const module *M1 = *((const module **) ent1);
	const module *M2 = *((const module **) ent2);
	text_stream *O1 = Collater__module_owner(M1, sorting_web);
	text_stream *O2 = Collater__module_owner(M2, sorting_web);
	int r = Collater__cmp_owners(O1, O2);
	if (r != 0) return r;
	return Str__cmp_insensitive(M1->module_name, M2->module_name);
}

int Collater__cmp_owners(text_stream *O1, text_stream *O2) {
	if (Str__len(O1) == 0) {
		if (Str__len(O2) > 0) return -1;
		return 0;
	}
	if (Str__len(O2) == 0) return 1;
	if (Str__eq_insensitive(O1, TL_IS_2794)) {
		if (Str__eq_insensitive(O2, TL_IS_2795) == FALSE) return 1;
		return 0;
	}
	if (Str__eq_insensitive(O2, TL_IS_2796)) return -1;
	return Str__cmp_insensitive(O1, O2);
}

#line 16 "inweb/Chapter 3/The Weaver.w"
int Weaver__weave(weave_order *wv) {
	heterogeneous_tree *tree = WeaveTree__new_tree(wv);
	TEMPORARY_TEXT(banner)
	WRITE_TO(banner, "Weave of '%S' generated by Inweb", wv->booklet_title);
	tree_node *H = WeaveTree__head(tree, banner);
	DISCARD_TEXT(banner)
	tree_node *B = WeaveTree__body(tree);
	tree_node *T = WeaveTree__tail(tree, TL_IS_2797);
	Trees__make_child(H, tree->root);
	Trees__make_child(B, tree->root);
	Trees__make_child(T, tree->root);

	int lines = Weaver__weave_inner(wv, tree, B);

	WeaveTree__prune(tree);

	text_stream TO_struct;
	text_stream *OUT = &TO_struct;
	if (STREAM_OPEN_TO_FILE(OUT, wv->weave_to, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to write woven file", wv->weave_to);
	Formats__render(OUT, tree, wv->weave_to);
	STREAM_CLOSE(OUT);
	return lines;
}

#line 42 "inweb/Chapter 3/The Weaver.w"
int Weaver__weave_inner(weave_order *wv, heterogeneous_tree *tree, tree_node *body) {
	web *W = wv->weave_web;
	int lines_woven = 0;
	weaver_state state_at; weaver_state *state = &state_at;
	
{
#line 129 "inweb/Chapter 3/The Weaver.w"
	state->kind_of_material = COMMENTARY_MATERIAL;
	state->line_break_pending = FALSE;
	state->next_heading_without_vertical_skip = FALSE;
	state->horizontal_rule_just_drawn = FALSE;
	state->last_extract_from = NULL;
	state->body_node = body;
	state->chapter_node = NULL;
	state->section_node = NULL;
	state->para_node = NULL;
	state->carousel_node = NULL;
	state->material_node = NULL;
	state->ap = body;

}
#line 46 "inweb/Chapter 3/The Weaver.w"
;
	chapter *C, *last_heading = NULL;
	section *S;
	LOOP_OVER_LINKED_LIST(C, chapter, W->chapters)
		if (C->md->imported == FALSE) {
			LOOP_OVER_LINKED_LIST(S, section, C->sections)
				if (Reader__range_within(S->md->sect_range, wv->weave_range)) {
					
{
#line 65 "inweb/Chapter 3/The Weaver.w"
	if (last_heading != C) {
		
{
#line 79 "inweb/Chapter 3/The Weaver.w"
	if (wv->theme_match == NULL) {
		if (last_heading != NULL) {
			tree_node *F = WeaveTree__chapter_footer(tree, last_heading);
			Trees__make_child(F, state->chapter_node);
		}
	}

}
#line 66 "inweb/Chapter 3/The Weaver.w"
;
		tree_node *CH = WeaveTree__chapter(tree, C);
		Trees__make_child(CH, state->body_node);
		state->chapter_node = CH;
		state->ap = CH;
		last_heading = C;
		if (wv->theme_match == NULL) {
			tree_node *H = WeaveTree__chapter_header(tree, C);
			Trees__make_child(H, state->chapter_node);
		}
	}

}
#line 53 "inweb/Chapter 3/The Weaver.w"
;
					
{
#line 87 "inweb/Chapter 3/The Weaver.w"
	tree_node *SH = WeaveTree__section(tree, S);
	Trees__make_child(SH, state->chapter_node);
	state->section_node = SH;
	state->ap = SH;
	if (wv->theme_match == NULL) {
		tree_node *H = WeaveTree__section_header(tree, S);
		Trees__make_child(H, state->section_node);
	}

}
#line 54 "inweb/Chapter 3/The Weaver.w"
;
					LanguageMethods__begin_weave(S, wv);
					
{
#line 145 "inweb/Chapter 3/The Weaver.w"
	paragraph *current_P = NULL;
	int toc_made = FALSE;
	for (source_line *LLL = S->first_line; LLL; LLL = LLL->next_line) {
		wv->current_weave_line = LLL;
		if (LLL->owning_paragraph == NULL)
			
{
#line 167 "inweb/Chapter 3/The Weaver.w"
	if (LLL->category == INTERFACE_BODY_LCAT) {
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}
	if (LLL->category == PURPOSE_BODY_LCAT)  {
		continue;
	}
	if (LLL->category == DEFINITIONS_LCAT) {
		Weaver__weave_subheading(tree, wv, state->ap, TL_IS_2798);
		state->next_heading_without_vertical_skip = TRUE;
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}
	if (LLL->category == BAR_LCAT) {
		state->kind_of_material = COMMENTARY_MATERIAL;
		state->next_heading_without_vertical_skip = TRUE;
		if (state->horizontal_rule_just_drawn == FALSE) {
			tree_node *B = WeaveTree__bar(tree);
			Trees__make_child(B, state->ap);
		}
		continue;
	}
	if ((LLL->category == CHAPTER_HEADING_LCAT) ||
		(LLL->category == SECTION_HEADING_LCAT))
		continue;

}
#line 150 "inweb/Chapter 3/The Weaver.w"

		else if (LLL->owning_paragraph != current_P) {
			if (toc_made == FALSE) {
				if (Str__len(S->sect_purpose) > 0) {
					tree_node *F = WeaveTree__purpose(tree, S->sect_purpose);
					Trees__make_child(F, state->ap);
				}
				Weaver__weave_table_of_contents(tree, state->ap, S);
				toc_made = TRUE;
			}
			current_P = LLL->owning_paragraph;
			if (Tags__tagged_with(current_P, wv->theme_match))
				
{
#line 194 "inweb/Chapter 3/The Weaver.w"
	if (current_P->starts_on_new_page)
		Trees__make_child(WeaveTree__pagebreak(tree), state->ap);
	source_line *L = LLL;
	if ((L->category != HEADING_START_LCAT) &&
		(L->category != PARAGRAPH_START_LCAT))
		Main__error_in_web(TL_IS_2799, L); /* should never happen */

	
{
#line 220 "inweb/Chapter 3/The Weaver.w"
	LanguageMethods__reset_syntax_colouring(S->sect_language);
	if (wv->theme_match) 
{
#line 233 "inweb/Chapter 3/The Weaver.w"
	text_stream *cap = Tags__retrieve_caption(L->owning_paragraph, wv->theme_match);
	if (Str__len(cap) > 0) {
		Weaver__weave_subheading(tree, wv, state->ap, C->md->ch_title);
	} else if (state->last_extract_from != S) {
		TEMPORARY_TEXT(extr)
		WRITE_TO(extr, "From %S: %S", C->md->ch_title, S->md->sect_title);
		Weaver__weave_subheading(tree, wv, state->ap, extr);
		DISCARD_TEXT(extr)
	}
	state->last_extract_from = S;

}
#line 221 "inweb/Chapter 3/The Weaver.w"
;
	state->para_node = WeaveTree__paragraph_heading(tree, current_P,
		state->next_heading_without_vertical_skip);
	Trees__make_child(state->para_node, state->section_node);
	Weaver__change_material_for_para(tree, state);
	state->kind_of_material = COMMENTARY_MATERIAL;
	state->next_heading_without_vertical_skip = FALSE;

}
#line 201 "inweb/Chapter 3/The Weaver.w"
;

	
{
#line 248 "inweb/Chapter 3/The Weaver.w"
	if (Str__len(L->text_operand2) > 0) {
		TEMPORARY_TEXT(matter)
		WRITE_TO(matter, "%S\n", L->text_operand2);
		Weaver__commentary_text(tree, wv, state->ap, matter);
		DISCARD_TEXT(matter)
	}

}
#line 203 "inweb/Chapter 3/The Weaver.w"
;
	L = L->next_line;
	for (; ((L) && (L->owning_paragraph == current_P)); L = L->next_line) {
		wv->current_weave_line = L;
		if (LanguageMethods__skip_in_weaving(S->sect_language, wv, L) == FALSE) {
			lines_woven++;
			
{
#line 276 "inweb/Chapter 3/The Weaver.w"
	if (L->category == COMMAND_LCAT) {
		if (L->command_code == PAGEBREAK_CMD)
			Trees__make_child(WeaveTree__pagebreak(tree), state->ap);
		if (L->command_code == GRAMMAR_INDEX_CMD)
			Trees__make_child(WeaveTree__grammar_index(tree), state->ap);
		if (L->command_code == FIGURE_CMD) 
{
#line 297 "inweb/Chapter 3/The Weaver.w"
	int w, h;
	text_stream *figname = Parser__dimensions(L->text_operand, &w, &h, L);
	Trees__make_child(WeaveTree__figure(tree, figname, w, h), state->ap);

}
#line 281 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == HTML_CMD) 
{
#line 302 "inweb/Chapter 3/The Weaver.w"
	Trees__make_child(WeaveTree__raw_extract(tree, L->text_operand),
		state->ap);

}
#line 282 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == AUDIO_CMD) 
{
#line 306 "inweb/Chapter 3/The Weaver.w"
	int w, h;
	text_stream *figname = Parser__dimensions(L->text_operand, &w, &h, L);
	Trees__make_child(WeaveTree__audio(tree, figname, w), state->ap);

}
#line 283 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == VIDEO_CMD) 
{
#line 311 "inweb/Chapter 3/The Weaver.w"
	int w, h;
	text_stream *figname = Parser__dimensions(L->text_operand, &w, &h, L);
	Trees__make_child(WeaveTree__video(tree, figname, w, h), state->ap);

}
#line 284 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == DOWNLOAD_CMD) 
{
#line 316 "inweb/Chapter 3/The Weaver.w"
	Trees__make_child(WeaveTree__download(tree, L->text_operand, L->text_operand2),
		state->ap);

}
#line 285 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == EMBED_CMD) 
{
#line 320 "inweb/Chapter 3/The Weaver.w"
	int w, h;
	text_stream *ID = Parser__dimensions(L->text_operand2, &w, &h, L);
	Trees__make_child(WeaveTree__embed(tree, L->text_operand, ID, w, h), state->ap);

}
#line 286 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == CAROUSEL_CMD) 
{
#line 325 "inweb/Chapter 3/The Weaver.w"
	tree_node *C = WeaveTree__carousel_slide(tree, L->text_operand, L->command_code);
	Trees__make_child(C, state->para_node);
	state->ap = C;
	state->carousel_node = C;

}
#line 287 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == CAROUSEL_ABOVE_CMD) 
{
#line 325 "inweb/Chapter 3/The Weaver.w"
	tree_node *C = WeaveTree__carousel_slide(tree, L->text_operand, L->command_code);
	Trees__make_child(C, state->para_node);
	state->ap = C;
	state->carousel_node = C;

}
#line 288 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == CAROUSEL_BELOW_CMD) 
{
#line 325 "inweb/Chapter 3/The Weaver.w"
	tree_node *C = WeaveTree__carousel_slide(tree, L->text_operand, L->command_code);
	Trees__make_child(C, state->para_node);
	state->ap = C;
	state->carousel_node = C;

}
#line 289 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == CAROUSEL_UNCAPTIONED_CMD) 
{
#line 325 "inweb/Chapter 3/The Weaver.w"
	tree_node *C = WeaveTree__carousel_slide(tree, L->text_operand, L->command_code);
	Trees__make_child(C, state->para_node);
	state->ap = C;
	state->carousel_node = C;

}
#line 290 "inweb/Chapter 3/The Weaver.w"
;
		if (L->command_code == CAROUSEL_END_CMD) 
{
#line 331 "inweb/Chapter 3/The Weaver.w"
	state->ap = state->para_node;
	state->carousel_node = NULL;

}
#line 291 "inweb/Chapter 3/The Weaver.w"
;
		/* Otherwise assume it was a tangler command, and ignore it here */
		continue;
	}

}
#line 209 "inweb/Chapter 3/The Weaver.w"
;
			
{
#line 256 "inweb/Chapter 3/The Weaver.w"
	if (L->category == BEGIN_CODE_LCAT) {
		state->line_break_pending = FALSE;
		LanguageMethods__reset_syntax_colouring(S->sect_language);
		continue;
	}

	if (L->category == END_EXTRACT_LCAT) {
		Weaver__change_material(tree, state, COMMENTARY_MATERIAL, FALSE, NULL, NULL);
		continue;
	}

	TEMPORARY_TEXT(matter) Str__copy(matter, L->text);
	if (L->is_commentary) 
{
#line 339 "inweb/Chapter 3/The Weaver.w"
	
{
#line 351 "inweb/Chapter 3/The Weaver.w"
	if (L->category == SOURCE_DISPLAY_LCAT) {
		Trees__make_child(WeaveTree__display_line(tree, L->text_operand), state->ap);
		continue;
	}

}
#line 339 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 360 "inweb/Chapter 3/The Weaver.w"
	if (Regexp__string_is_white_space(matter)) {
		if ((L->next_line) && (L->next_line->category == COMMENT_BODY_LCAT)) {
			match_results mr = Regexp__create_mr();
			if ((state->kind_of_material != CODE_MATERIAL) ||
				(Regexp__match(&mr, matter, U"\t|(%c*)|(%c*?)")))
				Trees__make_child(WeaveTree__vskip(tree, TRUE), state->ap);
			Regexp__dispose_of(&mr);
		}
		continue;
	}

}
#line 340 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 375 "inweb/Chapter 3/The Weaver.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, matter, U"%(-...%) (%c*)")) { /* continue double */
		Weaver__change_material(tree, state, COMMENTARY_MATERIAL, FALSE, NULL, NULL);
		Trees__make_child(WeaveTree__weave_item_node(tree, 2, TL_IS_2800), state->ap);
		Str__copy(matter, mr.exp[0]);
	} else if (Regexp__match(&mr, matter, U"%(...%) (%c*)")) { /* continue single */
		Weaver__change_material(tree, state, COMMENTARY_MATERIAL, FALSE, NULL, NULL);
		Trees__make_child(WeaveTree__weave_item_node(tree, 1, TL_IS_2801), state->ap);
		Str__copy(matter, mr.exp[0]);
	} else if (Regexp__match(&mr, matter, U"%(-([a-zA-Z0-9*]+)%) (%c*)")) { /* begin double */
		Weaver__change_material(tree, state, COMMENTARY_MATERIAL, FALSE, NULL, NULL);
		Trees__make_child(WeaveTree__weave_item_node(tree, 2, mr.exp[0]), state->ap);
		Str__copy(matter, mr.exp[1]);
	} else if (Regexp__match(&mr, matter, U"%(([a-zA-Z0-9*]+)%) (%c*)")) { /* begin single */
		Weaver__change_material(tree, state, COMMENTARY_MATERIAL, FALSE, NULL, NULL);
		Trees__make_child(WeaveTree__weave_item_node(tree, 1, mr.exp[0]), state->ap);
		Str__copy(matter, mr.exp[1]);
	}
	Regexp__dispose_of(&mr);

}
#line 341 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 399 "inweb/Chapter 3/The Weaver.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, matter, U"\t|(%c*)|(%c*?)")) {
		TEMPORARY_TEXT(original)
		Weaver__change_material(tree, state, CODE_MATERIAL, FALSE, NULL, NULL);
 		Str__copy(original, mr.exp[0]);
		Str__copy(matter, mr.exp[1]);
		TEMPORARY_TEXT(colouring)
		for (int i=0; i<Str__len(original); i++) PUT_TO(colouring, PLAIN_COLOUR);
		tree_node *CL = WeaveTree__code_line(tree);
		Trees__make_child(CL, state->ap);
		TextWeaver__source_code(tree, CL, original, colouring, L->enable_hyperlinks);
		DISCARD_TEXT(colouring)
		DISCARD_TEXT(original)
		Weaver__commentary_text(tree, wv, state->ap, matter);
		Regexp__dispose_of(&mr);
		continue;
	}
	Regexp__dispose_of(&mr);

}
#line 342 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 419 "inweb/Chapter 3/The Weaver.w"
	if (L->category == FOOTNOTE_TEXT_LCAT) {
		Weaver__change_material(tree, state, FOOTNOTES_MATERIAL, FALSE, NULL, NULL);
		footnote *F = L->footnote_text;
		tree_node *FN = WeaveTree__footnote(tree, F->cue_text);
		Trees__make_child(FN, state->material_node);
		if (F->cued_already == FALSE) Main__error_in_web(TL_IS_2802, L);
		state->ap = FN;
	}

}
#line 343 "inweb/Chapter 3/The Weaver.w"
;
	WRITE_TO(matter, "\n");
	Weaver__commentary_text(tree, wv, state->ap, matter);
	continue;

}
#line 268 "inweb/Chapter 3/The Weaver.w"

	else 
{
#line 434 "inweb/Chapter 3/The Weaver.w"
	
{
#line 468 "inweb/Chapter 3/The Weaver.w"
	if (state->kind_of_material != CODE_MATERIAL) {
		int will_be = CODE_MATERIAL;
		if (L->category == MACRO_DEFINITION_LCAT)
			will_be = MACRO_MATERIAL;
		else if ((L->category == BEGIN_DEFINITION_LCAT) ||
				(L->category == CONT_DEFINITION_LCAT))
			will_be = DEFINITION_MATERIAL;
		else if ((state->kind_of_material == DEFINITION_MATERIAL) &&
			((L->category == CODE_BODY_LCAT) || (L->category == COMMENT_BODY_LCAT)) &&
			(Str__len(L->text) == 0))
			will_be = DEFINITION_MATERIAL;
		programming_language *pl = L->colour_as;
		if (pl == NULL) pl = S->sect_language;
		if (will_be != CODE_MATERIAL) pl = NULL;
		theme_tag *T = Tags__find_by_name(TL_IS_2803, FALSE);
		if ((T) && (Tags__tagged_with(L->owning_paragraph, T))) {
			programming_language *prepl =
				Analyser__find_by_name(TL_IS_2804, wv->weave_web, FALSE);
			if (prepl) pl = prepl;
		}
		text_stream *note = NULL;
		if (Str__len(L->extract_to) > 0) {
			note = Str__new();
			WRITE_TO(note, "This is part of the extract file %S.", L->extract_to);
		}
		Weaver__change_material(tree, state, will_be, L->plainer, pl, note);
		state->line_break_pending = FALSE;
	}

}
#line 434 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 501 "inweb/Chapter 3/The Weaver.w"
	if (state->line_break_pending) {
		Trees__make_child(WeaveTree__vskip(tree, FALSE), state->ap);
		state->line_break_pending = FALSE;
	}
	if (Regexp__string_is_white_space(matter)) {
		state->line_break_pending = TRUE;
		goto ClumsyLabel;
	}

}
#line 435 "inweb/Chapter 3/The Weaver.w"
;

	Str__rectify_indentation(matter, 4);

	TEMPORARY_TEXT(prefatory)
	TEMPORARY_TEXT(concluding_comment)
	
{
#line 514 "inweb/Chapter 3/The Weaver.w"
	TEMPORARY_TEXT(part_before_comment)
	TEMPORARY_TEXT(part_within_comment)
	programming_language *pl = S->sect_language;
	if (L->category == TEXT_EXTRACT_LCAT) pl = L->colour_as;
	if ((pl) && (LanguageMethods__parse_comment(pl,
		matter, part_before_comment, part_within_comment))) {
		Str__copy(matter, part_before_comment);
		Str__copy(concluding_comment, part_within_comment);
	}
	DISCARD_TEXT(part_before_comment)
	DISCARD_TEXT(part_within_comment)

}
#line 441 "inweb/Chapter 3/The Weaver.w"
;
	
{
#line 529 "inweb/Chapter 3/The Weaver.w"
	if (L->category == BEGIN_DEFINITION_LCAT) {
		match_results mr = Regexp__create_mr();
		if ((Regexp__match(&mr, matter, U"@d (%c*)")) ||
			(Regexp__match(&mr, matter, U"@define (%c*)"))) {
			Str__copy(prefatory, TL_IS_2805);
			Str__copy(matter, mr.exp[0]);
		} else if (Regexp__match(&mr, matter, U"@default (%c*)")) {
			Str__copy(prefatory, TL_IS_2806);
			Str__copy(matter, mr.exp[0]);
		} else if ((Regexp__match(&mr, matter, U"@e (%c*)")) ||
			(Regexp__match(&mr, matter, U"@enum (%c*)"))) {
			Str__copy(prefatory, TL_IS_2807);
			Str__copy(matter, mr.exp[0]);
		}
		Regexp__dispose_of(&mr);
	}

}
#line 442 "inweb/Chapter 3/The Weaver.w"
;

	tree_node *CL = WeaveTree__code_line(tree);
	Trees__make_child(CL, state->ap);
	if (Str__len(prefatory) > 0)
		Trees__make_child(WeaveTree__weave_defn_node(tree, prefatory), CL);
	Str__clear(prefatory);

	
{
#line 547 "inweb/Chapter 3/The Weaver.w"
	TEMPORARY_TEXT(OUT)
	int taken = LanguageMethods__weave_code_line(OUT, S->sect_language, wv,
		W, C, S, L, matter, concluding_comment);
	if (taken) {
		tree_node *V = WeaveTree__verbatim(tree, OUT);
		Trees__make_child(V, CL);
	}
	DISCARD_TEXT(OUT)
	if (taken) goto ClumsyLabel;

}
#line 450 "inweb/Chapter 3/The Weaver.w"
;

	
{
#line 558 "inweb/Chapter 3/The Weaver.w"
	match_results mr = Regexp__create_mr();
	while (Regexp__match(&mr, matter, U"(%c*?)%@%<(%c*?)%@%>(%c*)")) {
		para_macro *pmac = Macros__find_by_name(mr.exp[1], S);
		if (pmac) {
			TEMPORARY_TEXT(front_colouring)
			LanguageMethods__syntax_colour(S->sect_language, wv, L, mr.exp[0], front_colouring);
			TextWeaver__source_code(tree, CL, mr.exp[0], front_colouring, L->enable_hyperlinks);
			DISCARD_TEXT(front_colouring)
			Str__copy(matter, mr.exp[2]);
			int defn = (L->owning_paragraph == pmac->defining_paragraph)?TRUE:FALSE;
			if (defn) Str__clear(matter);
			Trees__make_child(WeaveTree__pmac(tree, pmac, defn), CL);
		} else break;
	}
	Regexp__dispose_of(&mr);

}
#line 452 "inweb/Chapter 3/The Weaver.w"
;
	TEMPORARY_TEXT(colouring)
	LanguageMethods__syntax_colour(S->sect_language, wv, L, matter, colouring);
	TextWeaver__source_code(tree, CL, matter, colouring, L->enable_hyperlinks);
	DISCARD_TEXT(colouring)

	if (Str__len(concluding_comment) > 0)
		TextWeaver__comment_text_in_code(tree, CL, concluding_comment);
	DISCARD_TEXT(concluding_comment)
	DISCARD_TEXT(prefatory)

	ClumsyLabel: ;

}
#line 269 "inweb/Chapter 3/The Weaver.w"
;
	DISCARD_TEXT(matter)

}
#line 210 "inweb/Chapter 3/The Weaver.w"
;
		}
	}
	L = NULL;
	Weaver__change_material(tree, state, ENDNOTES_MATERIAL, FALSE, NULL, NULL);
	Weaver__show_endnotes_on_previous_paragraph(tree, wv, state->ap, current_P);

}
#line 162 "inweb/Chapter 3/The Weaver.w"
;
		}
	}

}
#line 56 "inweb/Chapter 3/The Weaver.w"
;
					
{
#line 97 "inweb/Chapter 3/The Weaver.w"
	if (wv->theme_match == NULL) {
		tree_node *F = WeaveTree__section_footer(tree, S);
		Trees__make_child(F, state->section_node);
	}

}
#line 57 "inweb/Chapter 3/The Weaver.w"
;
				}
		}
	
{
#line 79 "inweb/Chapter 3/The Weaver.w"
	if (wv->theme_match == NULL) {
		if (last_heading != NULL) {
			tree_node *F = WeaveTree__chapter_footer(tree, last_heading);
			Trees__make_child(F, state->chapter_node);
		}
	}

}
#line 60 "inweb/Chapter 3/The Weaver.w"
;
	return lines_woven;
}

#line 111 "inweb/Chapter 3/The Weaver.w"

#line 127 "inweb/Chapter 3/The Weaver.w"

#line 579 "inweb/Chapter 3/The Weaver.w"
void Weaver__show_endnotes_on_previous_paragraph(heterogeneous_tree *tree,
	weave_order *wv, tree_node *ap, paragraph *P) {
	tree_node *body = ap;
	theme_tag *T = Tags__find_by_name(TL_IS_2808, FALSE);
	if ((T) && (Tags__tagged_with(P, T)))
		
{
#line 597 "inweb/Chapter 3/The Weaver.w"
	tree_node *E = WeaveTree__endnote(tree);
	Trees__make_child(E, body); ap = E;
	TextWeaver__commentary_text(tree, ap, TL_IS_2809);
	TEMPORARY_TEXT(url)
	int ext = FALSE;
	if (Colonies__resolve_reference_in_weave(url, NULL, wv->weave_to,
		TL_IS_2810, wv->weave_web->md, NULL, &ext))
		Trees__make_child(WeaveTree__url(tree, url, TL_IS_2811, ext), ap);
	else
		TextWeaver__commentary_text(tree, ap, TL_IS_2812);
	DISCARD_TEXT(url)
	TextWeaver__commentary_text(tree, ap, TL_IS_2813);

}
#line 584 "inweb/Chapter 3/The Weaver.w"
;
	Tags__show_endnote_on_ifdefs(tree, ap, P);
	if (P->defines_macro)
		
{
#line 611 "inweb/Chapter 3/The Weaver.w"
	tree_node *E = WeaveTree__endnote(tree);
	Trees__make_child(E, body); ap = E;
	TextWeaver__commentary_text(tree, ap, TL_IS_2814);
	int ct = 0;
	macro_usage *mu;
	LOOP_OVER_LINKED_LIST(mu, macro_usage, P->defines_macro->macro_usages)
		ct++;
	if (ct == 1) TextWeaver__commentary_text(tree, ap, TL_IS_2815);
	else {
		int k = 0, used_flag = FALSE;
		LOOP_OVER_LINKED_LIST(mu, macro_usage, P->defines_macro->macro_usages)
			if (P != mu->used_in_paragraph) {
				if (used_flag) {
					if (k < ct-1) TextWeaver__commentary_text(tree, ap, TL_IS_2816);
					else TextWeaver__commentary_text(tree, ap, TL_IS_2817);
				} else {
					TextWeaver__commentary_text(tree, ap, TL_IS_2818);
				}
				Trees__make_child(WeaveTree__locale(tree, mu->used_in_paragraph, NULL), ap);
				used_flag = TRUE; k++;
				switch (mu->multiplicity) {
					case 1: break;
					case 2: TextWeaver__commentary_text(tree, ap, TL_IS_2819); break;
					case 3: TextWeaver__commentary_text(tree, ap, TL_IS_2820); break;
					case 4: TextWeaver__commentary_text(tree, ap, TL_IS_2821); break;
					case 5: TextWeaver__commentary_text(tree, ap, TL_IS_2822); break;
					default: {
						TEMPORARY_TEXT(mt)
						WRITE_TO(mt, " (%d times)", mu->multiplicity);
						TextWeaver__commentary_text(tree, ap, mt);
						DISCARD_TEXT(mt)
						break;
					}
				}
			}
	}
	TextWeaver__commentary_text(tree, ap, TL_IS_2823);

}
#line 587 "inweb/Chapter 3/The Weaver.w"
;
	language_function *fn;
	LOOP_OVER_LINKED_LIST(fn, language_function, P->functions)
		
{
#line 650 "inweb/Chapter 3/The Weaver.w"
	if (fn->usage_described == FALSE)
		Weaver__show_function_usage(tree, wv, ap, P, fn, FALSE);

}
#line 590 "inweb/Chapter 3/The Weaver.w"
;
	language_type *st;
	LOOP_OVER_LINKED_LIST(st, language_type, P->structures)
		
{
#line 654 "inweb/Chapter 3/The Weaver.w"
	tree_node *E = WeaveTree__endnote(tree);
	Trees__make_child(E, body); ap = E;
	TextWeaver__commentary_text(tree, ap, TL_IS_2824);
	TextWeaver__commentary_text(tree, ap, st->structure_name);

	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	structure_element *elt;
	LOOP_OVER_LINKED_LIST(elt, structure_element, st->elements) {
		hash_table_entry *hte =
			Analyser__find_hash_entry_for_section(elt->element_created_at->owning_section,
				elt->element_name, FALSE);
		if (hte) {
			hash_table_entry_usage *hteu;
			LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
				if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE)
					hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
		}
	}

	int usage_count = 0, external = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag) {
			usage_count++;
			if (S != P->under_section) external++;
		}
	if (external == 0) TextWeaver__commentary_text(tree, ap, TL_IS_2825);
	else {
		TextWeaver__commentary_text(tree, ap, TL_IS_2826);
		int c = 0;
		LOOP_OVER(S, section)
			if ((S->scratch_flag) && (S != P->under_section)) {
				if (c++ > 0) TextWeaver__commentary_text(tree, ap, TL_IS_2827);
				TextWeaver__commentary_text(tree, ap, S->md->sect_range);
			}
		if (P->under_section->scratch_flag) TextWeaver__commentary_text(tree, ap, TL_IS_2828);
	}
	TextWeaver__commentary_text(tree, ap, TL_IS_2829);

}
#line 593 "inweb/Chapter 3/The Weaver.w"
;
}

#line 694 "inweb/Chapter 3/The Weaver.w"
void Weaver__show_function_usage(heterogeneous_tree *tree, weave_order *wv,
	tree_node *ap, paragraph *P, language_function *fn, int as_list) {
	tree_node *body = ap;
	fn->usage_described = TRUE;
	hash_table_entry *hte =
		Analyser__find_hash_entry_for_section(fn->function_header_at->owning_section,
			fn->function_name, FALSE);
	if (as_list == FALSE) {
		tree_node *E = WeaveTree__endnote(tree);
		Trees__make_child(E, body); ap = E;
		TextWeaver__commentary_text(tree, ap, TL_IS_2830);
		TextWeaver__commentary_text(tree, ap, fn->function_name);
	}
	int used_flag = FALSE;
	hash_table_entry_usage *hteu = NULL;
	section *last_cited_in = NULL;
	int count_under = 0;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if ((P != hteu->usage_recorded_at) &&
			(P->under_section == hteu->usage_recorded_at->under_section))
			
{
#line 733 "inweb/Chapter 3/The Weaver.w"
	if (as_list == FALSE) {
		if (used_flag == FALSE) TextWeaver__commentary_text(tree, ap, TL_IS_2835);
	}
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (as_list == FALSE) {
				if (last_cited_in != P->under_section) TextWeaver__commentary_text(tree, ap, TL_IS_2836);
				else TextWeaver__commentary_text(tree, ap, TL_IS_2837);
			} else {
				Trees__make_child(WeaveTree__linebreak(tree), ap);
			}
		}
		TextWeaver__commentary_text(tree, ap, hteu->usage_recorded_at->under_section->md->sect_title);
		if (as_list == FALSE) TextWeaver__commentary_text(tree, ap, TL_IS_2838);
		else TextWeaver__commentary_text(tree, ap, TL_IS_2839);
	}
	if (count_under++ > 0) TextWeaver__commentary_text(tree, ap, TL_IS_2840);
	Trees__make_child(WeaveTree__locale(tree, hteu->usage_recorded_at, NULL), ap);
	last_cited_in = hteu->usage_recorded_at->under_section;

}
#line 714 "inweb/Chapter 3/The Weaver.w"
;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if (P->under_section != hteu->usage_recorded_at->under_section)
			
{
#line 733 "inweb/Chapter 3/The Weaver.w"
	if (as_list == FALSE) {
		if (used_flag == FALSE) TextWeaver__commentary_text(tree, ap, TL_IS_2835);
	}
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (as_list == FALSE) {
				if (last_cited_in != P->under_section) TextWeaver__commentary_text(tree, ap, TL_IS_2836);
				else TextWeaver__commentary_text(tree, ap, TL_IS_2837);
			} else {
				Trees__make_child(WeaveTree__linebreak(tree), ap);
			}
		}
		TextWeaver__commentary_text(tree, ap, hteu->usage_recorded_at->under_section->md->sect_title);
		if (as_list == FALSE) TextWeaver__commentary_text(tree, ap, TL_IS_2838);
		else TextWeaver__commentary_text(tree, ap, TL_IS_2839);
	}
	if (count_under++ > 0) TextWeaver__commentary_text(tree, ap, TL_IS_2840);
	Trees__make_child(WeaveTree__locale(tree, hteu->usage_recorded_at, NULL), ap);
	last_cited_in = hteu->usage_recorded_at->under_section;

}
#line 717 "inweb/Chapter 3/The Weaver.w"
;
	if (used_flag == FALSE) {
		if (as_list == FALSE) {
			TextWeaver__commentary_text(tree, ap, TL_IS_2831);
		} else {
			TextWeaver__commentary_text(tree, ap, TL_IS_2832);
		}
	}
	if (as_list == FALSE) {
		if ((last_cited_in != P->under_section) && (last_cited_in))
			TextWeaver__commentary_text(tree, ap, TL_IS_2833);
		TextWeaver__commentary_text(tree, ap, TL_IS_2834);
	}
}

#line 759 "inweb/Chapter 3/The Weaver.w"
void Weaver__weave_subheading(heterogeneous_tree *tree, weave_order *wv,
	tree_node *ap, text_stream *text) {
	tree_node *D = WeaveTree__subheading(tree, text);
	Trees__make_child(D, ap);
}

void Weaver__change_material(heterogeneous_tree *tree,
	weaver_state *state, int new_material, int plainly, programming_language *pl,
	text_stream *note) {
	if (state->kind_of_material != new_material) {
		tree_node *D = WeaveTree__material(tree, new_material, plainly, pl, note);
		if (state->carousel_node) Trees__make_child(D, state->carousel_node);
		else Trees__make_child(D, state->para_node);
		state->material_node = D;
		state->ap = D;
		state->kind_of_material = new_material;
	}
}

void Weaver__change_material_for_para(heterogeneous_tree *tree, weaver_state *state) {
	tree_node *D = WeaveTree__material(tree, COMMENTARY_MATERIAL, FALSE, NULL, NULL);
	Trees__make_child(D, state->para_node);
	state->material_node = D;
	state->ap = D;
	state->kind_of_material = COMMENTARY_MATERIAL;
}

void Weaver__figure(heterogeneous_tree *tree, weave_order *wv,
	tree_node *ap, text_stream *figname, int w, int h) {
	tree_node *F = WeaveTree__figure(tree, figname, w, h);
	Trees__make_child(F, ap);
}

void Weaver__commentary_text(heterogeneous_tree *tree, weave_order *wv,
	tree_node *ap, text_stream *matter) {
	TextWeaver__commentary_text(tree, ap, matter);
}

#line 802 "inweb/Chapter 3/The Weaver.w"
int Weaver__weave_table_of_contents(heterogeneous_tree *tree,
	tree_node *ap, section *S) {
	int noteworthy = 0;
	paragraph *P;
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE)))
			noteworthy++;
	if (noteworthy == 0) return FALSE;

	tree_node *TOC = WeaveTree__table_of_contents(tree, S->md->sect_range);
	Trees__make_child(TOC, ap);
	LOOP_OVER_LINKED_LIST(P, paragraph, S->paragraphs)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE))) {
			TEMPORARY_TEXT(loc)
			WRITE_TO(loc, "%S%S", P->ornament, P->paragraph_number);
			Trees__make_child(
				WeaveTree__contents_line(tree, loc,
					P->first_line_in_paragraph->text_operand, P), TOC);
			DISCARD_TEXT(loc)
		}
	return TRUE;
}


#line 12 "inweb/Chapter 3/The Weaver of Text.w"
void TextWeaver__commentary_text(heterogeneous_tree *tree, tree_node *ap, text_stream *matter) {
	TextWeaver__commentary_r(tree, ap, matter, FALSE, FALSE);
}
void TextWeaver__comment_text_in_code(heterogeneous_tree *tree, tree_node *ap, text_stream *matter) {
	TextWeaver__commentary_r(tree, ap, matter, FALSE, TRUE);
}

void TextWeaver__commentary_r(heterogeneous_tree *tree, tree_node *ap, text_stream *matter,
	int within, int in_code) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	weave_order *wv = C->wv;
	text_stream *code_in_comments_notation =
		Bibliographic__get_datum(wv->weave_web->md,
		(in_code)?(TL_IS_2841):(TL_IS_2842));
	if (Str__ne(code_in_comments_notation, TL_IS_2843)) 
{
#line 51 "inweb/Chapter 3/The Weaver of Text.w"
	for (int i=0; i < Str__len(matter); i++) {
		if (Str__get_at(matter, i) == '\\') i += Str__len(code_in_comments_notation) - 1;
		else if (Str__includes_at(matter, i, code_in_comments_notation)) {
			TEMPORARY_TEXT(before)
			Str__copy(before, matter); Str__truncate(before, i);
			TEMPORARY_TEXT(after)
			Str__substr(after, Str__at(matter,
				i + Str__len(code_in_comments_notation)), Str__end(matter));
			TextWeaver__commentary_r(tree, ap, before, within, in_code);
			TextWeaver__commentary_r(tree, ap, after, (within)?FALSE:TRUE, in_code);
			DISCARD_TEXT(before)
			DISCARD_TEXT(after)
			return;
		}
	}

}
#line 26 "inweb/Chapter 3/The Weaver of Text.w"
;

	int display_flag = TRUE;
	text_stream *tex_notation = Bibliographic__get_datum(wv->weave_web->md,
		TL_IS_2844);
	if (Str__ne(tex_notation, TL_IS_2845)) 
{
#line 99 "inweb/Chapter 3/The Weaver of Text.w"
	int N = Str__len(tex_notation);
	for (int i=0; i < Str__len(matter); i++) {
		if ((within == FALSE) && (Str__includes_at(matter, i, tex_notation))) {
			int j = i + N;
			while (j < Str__len(matter)) {
				if (Str__includes_at(matter, j, tex_notation)) {
					int allow = FALSE;
					TEMPORARY_TEXT(before)
					TEMPORARY_TEXT(maths)
					TEMPORARY_TEXT(after)
					Str__substr(before, Str__start(matter), Str__at(matter, i));
					Str__substr(maths, Str__at(matter, i + N), Str__at(matter, j));
					Str__substr(after, Str__at(matter, j + N), Str__end(matter));
					TextWeaver__commentary_r(tree, ap, before, within, in_code);
					Trees__make_child(WeaveTree__mathematics(tree, maths, display_flag), ap);
					TextWeaver__commentary_r(tree, ap, after, within, in_code);
					allow = TRUE;
					DISCARD_TEXT(before)
					DISCARD_TEXT(maths)
					DISCARD_TEXT(after)
					if (allow) return;
				}
				j++;
			}
		}
	}

}
#line 31 "inweb/Chapter 3/The Weaver of Text.w"
;
	display_flag = FALSE;
	tex_notation = Bibliographic__get_datum(wv->weave_web->md,
		TL_IS_2846);
	if (Str__ne(tex_notation, TL_IS_2847)) 
{
#line 99 "inweb/Chapter 3/The Weaver of Text.w"
	int N = Str__len(tex_notation);
	for (int i=0; i < Str__len(matter); i++) {
		if ((within == FALSE) && (Str__includes_at(matter, i, tex_notation))) {
			int j = i + N;
			while (j < Str__len(matter)) {
				if (Str__includes_at(matter, j, tex_notation)) {
					int allow = FALSE;
					TEMPORARY_TEXT(before)
					TEMPORARY_TEXT(maths)
					TEMPORARY_TEXT(after)
					Str__substr(before, Str__start(matter), Str__at(matter, i));
					Str__substr(maths, Str__at(matter, i + N), Str__at(matter, j));
					Str__substr(after, Str__at(matter, j + N), Str__end(matter));
					TextWeaver__commentary_r(tree, ap, before, within, in_code);
					Trees__make_child(WeaveTree__mathematics(tree, maths, display_flag), ap);
					TextWeaver__commentary_r(tree, ap, after, within, in_code);
					allow = TRUE;
					DISCARD_TEXT(before)
					DISCARD_TEXT(maths)
					DISCARD_TEXT(after)
					if (allow) return;
				}
				j++;
			}
		}
	}

}
#line 35 "inweb/Chapter 3/The Weaver of Text.w"
;

	text_stream *xref_notation = Bibliographic__get_datum(wv->weave_web->md,
		TL_IS_2848);
	if (Str__ne(xref_notation, TL_IS_2849)) 
{
#line 150 "inweb/Chapter 3/The Weaver of Text.w"
	int N = Str__len(xref_notation);
	for (int i=0; i < Str__len(matter); i++) {
		if ((within == FALSE) && (Str__includes_at(matter, i, xref_notation)) &&
			((i == 0) || (TextWeaver__boundary_character(TRUE,
				Str__get_at(matter, i-1))))) {
			int j = i + N+1;
			while (j < Str__len(matter)) {
				if ((Str__includes_at(matter, j, xref_notation)) &&
					(TextWeaver__boundary_character(FALSE,
						Str__get_at(matter, j+Str__len(xref_notation))))) {
					int allow = FALSE;
					TEMPORARY_TEXT(before)
					TEMPORARY_TEXT(reference)
					TEMPORARY_TEXT(after)
					Str__substr(before, Str__start(matter), Str__at(matter, i));
					Str__substr(reference, Str__at(matter, i + N), Str__at(matter, j));
					Str__substr(after, Str__at(matter, j + N), Str__end(matter));
					
{
#line 179 "inweb/Chapter 3/The Weaver of Text.w"
	TEMPORARY_TEXT(url)
	TEMPORARY_TEXT(title)
	int ext = FALSE;
	if (Colonies__resolve_reference_in_weave(url, title, wv->weave_to, reference,
		wv->weave_web->md, wv->current_weave_line, &ext)) {
		TextWeaver__commentary_r(tree, ap, before, within, in_code);
		Trees__make_child(WeaveTree__url(tree, url, title, ext), ap);
		TextWeaver__commentary_r(tree, ap, after, within, in_code);
		allow = TRUE;
	}
	DISCARD_TEXT(url)
	DISCARD_TEXT(title)

}
#line 167 "inweb/Chapter 3/The Weaver of Text.w"
;
					DISCARD_TEXT(before)
					DISCARD_TEXT(reference)
					DISCARD_TEXT(after)
					if (allow) return;
				}
				j++;
			}
		}
	}

}
#line 39 "inweb/Chapter 3/The Weaver of Text.w"
;

	if (within) {
		TextWeaver__inline_code_fragment(tree, ap, matter);
	} else {
		
{
#line 68 "inweb/Chapter 3/The Weaver of Text.w"
	for (int i=0; i < Str__len(matter); i++) {
		if ((Str__includes_at(matter, i, TL_IS_2850)) ||
				(Str__includes_at(matter, i, TL_IS_2851))) {
			TEMPORARY_TEXT(before)
			Str__copy(before, matter); Str__truncate(before, i);
			TEMPORARY_TEXT(after)
			Str__substr(after, Str__at(matter, i), Str__end(matter));
			match_results mr = Regexp__create_mr();
			if (Regexp__match(&mr, after, U"(https*://%C+)(%c*)")) {
				while (TextWeaver__boundary_character(FALSE, Str__get_last_char(mr.exp[0]))) {
					inchar32_t c = Str__get_last_char(mr.exp[0]);
					Str__delete_last_character(mr.exp[0]);
					TEMPORARY_TEXT(longer)
					WRITE_TO(longer, "%c%S", c, mr.exp[1]);
					Str__clear(mr.exp[1]);
					Str__copy(mr.exp[1], longer);
					DISCARD_TEXT(longer)
				}
				TextWeaver__commentary_r(tree, ap, before, within, in_code);
				Trees__make_child(WeaveTree__url(tree, mr.exp[0], mr.exp[0], TRUE), ap);
				TextWeaver__commentary_r(tree, ap, mr.exp[1], within, in_code);
				Regexp__dispose_of(&mr);
				return;
			}
			Regexp__dispose_of(&mr);
			DISCARD_TEXT(before)
			DISCARD_TEXT(after)
		}
	}

}
#line 44 "inweb/Chapter 3/The Weaver of Text.w"
;
		
{
#line 127 "inweb/Chapter 3/The Weaver of Text.w"
	TEMPORARY_TEXT(before)
	TEMPORARY_TEXT(cue)
	TEMPORARY_TEXT(after)
	int allow = FALSE;
	if (Parser__detect_footnote(wv->weave_web, matter, before, cue, after)) {
		footnote *F = Parser__find_footnote_in_para(
			wv->current_weave_line->owning_paragraph, cue);
		if (F) {
			F->cued_already = TRUE;
			allow = TRUE;
			TextWeaver__commentary_r(tree, ap, before, within, in_code);
			Trees__make_child(WeaveTree__footnote_cue(tree, F->cue_text), ap);
			TextWeaver__commentary_r(tree, ap, after, within, in_code);
		} else {
			Main__error_in_web(TL_IS_2852, wv->current_weave_line);
		}
	}
	DISCARD_TEXT(before)
	DISCARD_TEXT(cue)
	DISCARD_TEXT(after)
	if (allow) return;

}
#line 45 "inweb/Chapter 3/The Weaver of Text.w"
;
		TextWeaver__commentary_fragment(tree, ap, matter, in_code);
	}
}

#line 200 "inweb/Chapter 3/The Weaver of Text.w"
int TextWeaver__boundary_character(int before, inchar32_t c) {
	if (c == 0) return TRUE;
	if (Characters__is_whitespace(c)) return TRUE;
	if ((c == '.') || (c == ',') || (c == '!') || (c == '?') || (c == ';') ||
		(c == '(')|| (c == ')')) return TRUE;
	if ((before == FALSE) && (c == ':')) return TRUE;
	return FALSE;
}

#line 210 "inweb/Chapter 3/The Weaver of Text.w"
void TextWeaver__commentary_fragment(heterogeneous_tree *tree, tree_node *ap,
	text_stream *fragment, int in_code) {
	if (Str__len(fragment) > 0)
		Trees__make_child(WeaveTree__commentary(tree, fragment, in_code), ap);
}

void TextWeaver__inline_code_fragment(heterogeneous_tree *tree, tree_node *ap, text_stream *fragment) {
	tree_node *I = WeaveTree__inline(tree);
	Trees__make_child(I, ap);
	TEMPORARY_TEXT(colouring)
	for (int i=0; i< Str__len(fragment); i++) PUT_TO(colouring, EXTRACT_COLOUR);
	tree_node *SC = WeaveTree__source_code(tree, fragment, colouring);
	DISCARD_TEXT(colouring)
	Trees__make_child(SC, I);
}

#line 229 "inweb/Chapter 3/The Weaver of Text.w"
void TextWeaver__source_code(heterogeneous_tree *tree, tree_node *ap,
	text_stream *matter, text_stream *colouring, int linked) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	weave_order *wv = C->wv;
	Str__truncate(colouring, Str__len(matter));
	int from = 0;
	for (int i=0; i < Str__len(matter); i++) {
		if (linked) {
			
{
#line 261 "inweb/Chapter 3/The Weaver of Text.w"
	if ((Str__includes_at(matter, i, TL_IS_2855)) ||
		(Str__includes_at(matter, i, TL_IS_2856))) {
		TEMPORARY_TEXT(after)
		Str__substr(after, Str__at(matter, i), Str__end(matter));
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, after, U"(https*://%C+)(%c*)")) {
			tree_node *U = WeaveTree__url(tree, mr.exp[0], mr.exp[0], TRUE);
			TextWeaver__source_code_piece(tree, ap, matter, colouring, from, i);
			Trees__make_child(U, ap);
			i += Str__len(mr.exp[0]);
			from = i;
		}
		DISCARD_TEXT(after)
	}

}
#line 237 "inweb/Chapter 3/The Weaver of Text.w"
;
			text_stream *xref_notation = Bibliographic__get_datum(wv->weave_web->md,
				TL_IS_2853);
			if (Str__ne(xref_notation, TL_IS_2854))
				
{
#line 277 "inweb/Chapter 3/The Weaver of Text.w"
	int N = Str__len(xref_notation);
	if ((Str__includes_at(matter, i, xref_notation))) {
		int j = i + N+1;
		while (j < Str__len(matter)) {
			if (Str__includes_at(matter, j, xref_notation)) {
				TEMPORARY_TEXT(reference)
				Str__substr(reference, Str__at(matter, i + N), Str__at(matter, j));
				
{
#line 293 "inweb/Chapter 3/The Weaver of Text.w"
	TEMPORARY_TEXT(url)
	TEMPORARY_TEXT(title)
	int ext = FALSE;
	if (Colonies__resolve_reference_in_weave(url, title, wv->weave_to, reference,
		wv->weave_web->md, wv->current_weave_line, &ext)) {
		tree_node *U = WeaveTree__url(tree, url, title, ext);
		TextWeaver__source_code_piece(tree, ap, matter, colouring, from, i);
		Trees__make_child(U, ap);
		i = j + N;
		from = i;
	}
	DISCARD_TEXT(url)
	DISCARD_TEXT(title)

}
#line 284 "inweb/Chapter 3/The Weaver of Text.w"
;
				DISCARD_TEXT(reference)
				break;
			}
			j++;
		}
	}

}
#line 241 "inweb/Chapter 3/The Weaver of Text.w"
;
		}
		if ((Str__get_at(colouring, i) == FUNCTION_COLOUR) &&
			(wv->current_weave_line->category != TEXT_EXTRACT_LCAT)) {
			TEMPORARY_TEXT(fname)
			int j = i;
			while (Str__get_at(colouring, j) == FUNCTION_COLOUR)
				PUT_TO(fname, Str__get_at(matter, j++));
			if (Analyser__is_reserved_word_for_section(
				wv->current_weave_line->owning_section, fname, FUNCTION_COLOUR))
				
{
#line 308 "inweb/Chapter 3/The Weaver of Text.w"
	language_function *fn = Analyser__get_function(
		wv->current_weave_line->owning_section, fname, FUNCTION_COLOUR);
	if (fn) {
		source_line *defn_line = fn->function_header_at;
		if (wv->current_weave_line == defn_line) {
			if (fn->usage_described == FALSE) {
				TextWeaver__source_code_piece(tree, ap, matter, colouring, from, i);
				tree_node *FD = WeaveTree__function_defn(tree, fn);
				Trees__make_child(FD, ap);
				Weaver__show_function_usage(tree, wv, FD,
					defn_line->owning_paragraph, fn, TRUE);
				i += Str__len(fname) - 1;
				from = i+1;
			}
		} else {
			TextWeaver__source_code_piece(tree, ap, matter, colouring, from, i);
			TEMPORARY_TEXT(url)
			Colonies__paragraph_URL(url, defn_line->owning_paragraph, wv->weave_to);
			tree_node *U = WeaveTree__function_usage(tree, url, fn);
			Trees__make_child(U, ap);
			i += Str__len(fname) - 1;
			from = i+1;
		}
	}

}
#line 251 "inweb/Chapter 3/The Weaver of Text.w"
;
			DISCARD_TEXT(fname)
		}

	}
	if (from < Str__len(matter))
		TextWeaver__source_code_piece(tree, ap, matter, colouring, from, Str__len(matter));
}

#line 334 "inweb/Chapter 3/The Weaver of Text.w"
void TextWeaver__source_code_piece(heterogeneous_tree *tree, tree_node *ap,
	text_stream *matter, text_stream *colouring, int from, int to) {
	if (to > from) {
		TEMPORARY_TEXT(m)
		TEMPORARY_TEXT(c)
		Str__substr(m, Str__at(matter, from), Str__at(matter, to));
		Str__substr(c, Str__at(colouring, from), Str__at(colouring, to));
		tree_node *SC = WeaveTree__source_code(tree, m, c);
		Trees__make_child(SC, ap);
		DISCARD_TEXT(m)
		DISCARD_TEXT(c)
	}
}

#line 14 "inweb/Chapter 3/The Tangler.w"
void Tangler__tangle(web *W, tangle_target *target, filename *dest_file) {
	programming_language *lang = target->tangle_language;
	PRINT("  tangling <%/f> (written in %S)\n", dest_file, lang->language_name);

	text_stream TO_struct;
	text_stream *OUT = &TO_struct;
	if (STREAM_OPEN_TO_FILE(OUT, dest_file, ISO_ENC) == FALSE)
		Errors__fatal_with_file("unable to write tangled file", dest_file);
	
{
#line 40 "inweb/Chapter 3/The Tangler.w"
	/* (a) The shebang line, a header for scripting languages, and other heading matter */
	LanguageMethods__shebang(OUT, lang, W, target);
	LanguageMethods__disclaimer(OUT, lang, W, target);
	LanguageMethods__additional_early_matter(OUT, lang, W, target);
	chapter *C; section *S; paragraph *P;
	LOOP_OVER_PARAGRAPHS(C, S, target, P)
		if ((P->placed_very_early) && (P->defines_macro == NULL))
			Tangler__tangle_paragraph(OUT, P);

	/* (b) Results of |@d| declarations */
	
{
#line 72 "inweb/Chapter 3/The Tangler.w"
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, target)
		if (L->category == BEGIN_DEFINITION_LCAT)
			if (L->default_defn == FALSE)
				
{
#line 88 "inweb/Chapter 3/The Tangler.w"
	if (L->owning_paragraph == NULL) Main__error_in_web(TL_IS_2857, L);
	else Tags__open_ifdefs(OUT, L->owning_paragraph);
	LanguageMethods__start_definition(OUT, lang,
		L->text_operand,
		L->text_operand2, S, L);
	while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
		L = L->next_line;
		LanguageMethods__prolong_definition(OUT, lang, L->text, S, L);
	}
	LanguageMethods__end_definition(OUT, lang, S, L);
	if (L->owning_paragraph) Tags__close_ifdefs(OUT, L->owning_paragraph);

}
#line 77 "inweb/Chapter 3/The Tangler.w"
;
	LOOP_WITHIN_TANGLE(C, S, target)
		if (L->category == BEGIN_DEFINITION_LCAT)
			if (L->default_defn) {
				LanguageMethods__open_ifdef(OUT, lang, L->text_operand, FALSE);
				
{
#line 88 "inweb/Chapter 3/The Tangler.w"
	if (L->owning_paragraph == NULL) Main__error_in_web(TL_IS_2857, L);
	else Tags__open_ifdefs(OUT, L->owning_paragraph);
	LanguageMethods__start_definition(OUT, lang,
		L->text_operand,
		L->text_operand2, S, L);
	while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
		L = L->next_line;
		LanguageMethods__prolong_definition(OUT, lang, L->text, S, L);
	}
	LanguageMethods__end_definition(OUT, lang, S, L);
	if (L->owning_paragraph) Tags__close_ifdefs(OUT, L->owning_paragraph);

}
#line 82 "inweb/Chapter 3/The Tangler.w"
;
				LanguageMethods__close_ifdef(OUT, lang, L->text_operand, FALSE);
			}
	Enumerations__define_extents(OUT, target, lang);

}
#line 50 "inweb/Chapter 3/The Tangler.w"
;

	/* (c) Miscellaneous automated C predeclarations */
	LanguageMethods__additional_predeclarations(OUT, lang, W);

	/* (d) Above-the-bar code from all of the sections (global variables, and such) */
	LOOP_OVER_PARAGRAPHS(C, S, target, P)
		if ((P->placed_early) && (P->defines_macro == NULL))
			Tangler__tangle_paragraph(OUT, P);

	/* (e) Below-the-bar code: the bulk of the program itself */
	LOOP_OVER_PARAGRAPHS(C, S, target, P)
		if ((P->placed_early == FALSE) && (P->placed_very_early == FALSE) && (P->defines_macro == NULL))
			Tangler__tangle_paragraph(OUT, P);

	/* (f) Opposite of the shebang: a footer */
	LanguageMethods__gnabehs(OUT, lang, W);

}
#line 22 "inweb/Chapter 3/The Tangler.w"
;
	STREAM_CLOSE(OUT);

	
{
#line 101 "inweb/Chapter 3/The Tangler.w"
	filename *F;
	LOOP_OVER_LINKED_LIST(F, filename, W->headers)
		Shell__copy(F, Reader__tangled_folder(W), "");

}
#line 25 "inweb/Chapter 3/The Tangler.w"
;
	
{
#line 112 "inweb/Chapter 3/The Tangler.w"
	text_stream *extract_names[MAX_EXTRACT_FILES];
	text_stream extract_files[MAX_EXTRACT_FILES];
	int no_extract_files = 0;
	chapter *C; section *S; paragraph *P;
	LOOP_OVER_PARAGRAPHS(C, S, target, P)
		for (source_line *L = P->first_line_in_paragraph;
			((L) && (L->owning_paragraph == P)); L = L->next_line)
				if (Str__len(L->extract_to) > 0) {
					int j = no_extract_files;
					for (int i=0; i<no_extract_files; i++)
						if (Str__eq(L->extract_to, extract_names[i])) j = i;
					if (j == no_extract_files) {
						if (j == MAX_EXTRACT_FILES)
							Errors__fatal("too many extract files in tangle");
						extract_names[j] = Str__duplicate(L->extract_to);
						filename *F = Filenames__in(Filenames__up(dest_file), L->extract_to);
						if (STREAM_OPEN_TO_FILE(&(extract_files[j]), F, UTF8_ENC) == FALSE)
							Errors__fatal_with_file("unable to write extract file", F);
						no_extract_files++;
					}
					WRITE_TO(&(extract_files[j]), "%S\n", L->text);
				}
	for (int i=0; i<no_extract_files; i++) STREAM_CLOSE(&(extract_files[i]));

}
#line 26 "inweb/Chapter 3/The Tangler.w"
;
	LanguageMethods__additional_tangling(lang, W, target);
}

#line 141 "inweb/Chapter 3/The Tangler.w"
void Tangler__tangle_paragraph(OUTPUT_STREAM, paragraph *P) {
	Tags__open_ifdefs(OUT, P);
	int contiguous = FALSE;
	for (source_line *L = P->first_line_in_paragraph;
		((L) && (L->owning_paragraph == P)); L = L->next_line) {
		if (LanguageMethods__will_insert_in_tangle(P->under_section->sect_language, L)) {
			
{
#line 166 "inweb/Chapter 3/The Tangler.w"
	if (contiguous == FALSE) {
		contiguous = TRUE;
		LanguageMethods__insert_line_marker(OUT, P->under_section->sect_language, L);
	}

}
#line 147 "inweb/Chapter 3/The Tangler.w"
;
			LanguageMethods__insert_in_tangle(OUT, P->under_section->sect_language, L);
		}
		if ((L->category != CODE_BODY_LCAT) || (L->suppress_tangling)) {
			contiguous = FALSE;
		} else {
			
{
#line 166 "inweb/Chapter 3/The Tangler.w"
	if (contiguous == FALSE) {
		contiguous = TRUE;
		LanguageMethods__insert_line_marker(OUT, P->under_section->sect_language, L);
	}

}
#line 153 "inweb/Chapter 3/The Tangler.w"
;
			Tangler__tangle_line(OUT, L->text, P->under_section, L); WRITE("\n");
		}
	}
	Tags__close_ifdefs(OUT, P);
}

#line 176 "inweb/Chapter 3/The Tangler.w"
void Tangler__tangle_line(OUTPUT_STREAM, text_stream *original, section *S, source_line *L) {
	int mlen, slen;
	int mpos = Regexp__find_expansion(original, '@', '<', '@', '>', &mlen);
	int spos = Regexp__find_expansion(original, '[', '[', ']', ']', &slen);
	if ((mpos >= 0) && ((spos == -1) || (mpos <= spos)) &&
		(LanguageMethods__allow_expansion(S->sect_language, original)))
		
{
#line 208 "inweb/Chapter 3/The Tangler.w"
	TEMPORARY_TEXT(temp)
	Str__copy(temp, original); Str__truncate(temp, mpos);
	LanguageMethods__tangle_line(OUT, S->sect_language, temp);

	programming_language *lang = S->sect_language;
	for (int i=0; i<mlen-4; i++) Str__put_at(temp, i, Str__get_at(original, mpos+2+i));
	Str__truncate(temp, mlen-4);
	para_macro *pmac = Macros__find_by_name(temp, S);
	if (pmac) {
		LanguageMethods__before_macro_expansion(OUT, lang, pmac);
		Tangler__tangle_paragraph(OUT, pmac->defining_paragraph);
		LanguageMethods__after_macro_expansion(OUT, lang, pmac);
		LanguageMethods__insert_line_marker(OUT, lang, L);
	} else {
		Main__error_in_web(TL_IS_2858, L);
		WRITE_TO(STDERR, "Macro is '%S'\n", temp);
		LanguageMethods__comment(OUT, lang, temp); /* recover by putting macro name in comment */
	}
	TEMPORARY_TEXT(rest)
	Str__substr(rest, Str__at(original, mpos + mlen), Str__end(original));
	Tangler__tangle_line(OUT, rest, S, L);
	DISCARD_TEXT(rest)
	DISCARD_TEXT(temp)

}
#line 182 "inweb/Chapter 3/The Tangler.w"

	else if (spos >= 0)
		
{
#line 248 "inweb/Chapter 3/The Tangler.w"
	web *W = S->owning_web;

	TEMPORARY_TEXT(temp)
	for (int i=0; i<spos; i++) PUT_TO(temp, Str__get_at(original, i));
	LanguageMethods__tangle_line(OUT, S->sect_language, temp);

	for (int i=0; i<slen-4; i++) Str__put_at(temp, i, Str__get_at(original, spos+2+i));
	Str__truncate(temp, slen-4);
	if (LanguageMethods__special_tangle_command(OUT, S->sect_language, temp) == FALSE) {
		if (Bibliographic__look_up_datum(W->md, temp))
			WRITE("%S", Bibliographic__get_datum(W->md, temp));
		else
			WRITE("[[%S]]", temp);
	}

	TEMPORARY_TEXT(rest)
	Str__substr(rest, Str__at(original, spos + slen), Str__end(original));
	Tangler__tangle_line(OUT, rest, S, L);
	DISCARD_TEXT(rest)
	DISCARD_TEXT(temp)

}
#line 184 "inweb/Chapter 3/The Tangler.w"

	else
		LanguageMethods__tangle_line(OUT, S->sect_language, original); /* this is usually what happens */
}

#line 273 "inweb/Chapter 3/The Tangler.w"
tangle_target *Tangler__primary_target(web *W) {
	if (W == NULL) internal_error("no such web");
	return FIRST_IN_LINKED_LIST(tangle_target, W->tangle_targets);
}

#line 18 "inweb/Chapter 4/Types and Functions.w"

#line 20 "inweb/Chapter 4/Types and Functions.w"
language_type *first_cst_alphabetically = NULL;

language_type *Functions__new_struct(web *W, text_stream *name, source_line *L) {
	language_type *str = CREATE(language_type);
	
{
#line 32 "inweb/Chapter 4/Types and Functions.w"
	str->structure_name = Str__duplicate(name);
	str->structure_header_at = L;
	str->tangled = FALSE;
	str->typedef_ends = NULL;
	str->incorporates = NEW_LINKED_LIST(language_type);
	str->elements = NEW_LINKED_LIST(structure_element);

}
#line 24 "inweb/Chapter 4/Types and Functions.w"
;
	Analyser__mark_reserved_word_at_line(L, str->structure_name, RESERVED_COLOUR);
	
{
#line 40 "inweb/Chapter 4/Types and Functions.w"
	Tags__add_by_name(L->owning_paragraph, TL_IS_2859);
	ADD_TO_LINKED_LIST(str, language_type, W->language_types);
	ADD_TO_LINKED_LIST(str, language_type, L->owning_paragraph->structures);

}
#line 26 "inweb/Chapter 4/Types and Functions.w"
;
	
{
#line 45 "inweb/Chapter 4/Types and Functions.w"
	str->next_cst_alphabetically = NULL;
	if (first_cst_alphabetically == NULL) first_cst_alphabetically = str;
	else {
		int placed = FALSE;
		language_type *last = NULL;
		for (language_type *seq = first_cst_alphabetically; seq;
			seq = seq->next_cst_alphabetically) {
			if (Str__cmp(str->structure_name, seq->structure_name) < 0) {
				if (seq == first_cst_alphabetically) {
					str->next_cst_alphabetically = first_cst_alphabetically;
					first_cst_alphabetically = str;
				} else {
					last->next_cst_alphabetically = str;
					str->next_cst_alphabetically = seq;
				}
				placed = TRUE;
				break;
			}
			last = seq;
		}
		if (placed == FALSE) last->next_cst_alphabetically = str;
	}

}
#line 27 "inweb/Chapter 4/Types and Functions.w"
;
	return str;
}

#line 84 "inweb/Chapter 4/Types and Functions.w"

#line 86 "inweb/Chapter 4/Types and Functions.w"
structure_element *Functions__new_element(language_type *str, text_stream *elname,
	source_line *L) {
	Analyser__mark_reserved_word_at_line(L, elname, ELEMENT_COLOUR);
	structure_element *elt = CREATE(structure_element);
	elt->element_name = Str__duplicate(elname);
	elt->allow_sharing = FALSE;
	elt->element_created_at = L;
	if (LanguageMethods__share_element(L->owning_section->sect_language, elname))
		elt->allow_sharing = TRUE;
	ADD_TO_LINKED_LIST(elt, structure_element, str->elements);
	return elt;
}

#line 100 "inweb/Chapter 4/Types and Functions.w"
language_type *Functions__find_structure(web *W, text_stream *name) {
	language_type *str;
	LOOP_OVER_LINKED_LIST(str, language_type, W->language_types)
		if (Str__eq(name, str->structure_name))
			return str;
	return NULL;
}

#line 125 "inweb/Chapter 4/Types and Functions.w"

#line 127 "inweb/Chapter 4/Types and Functions.w"
language_function *Functions__new_function(text_stream *fname, source_line *L) {
	
{
#line 167 "inweb/Chapter 4/Types and Functions.w"
	paragraph *P = L->owning_paragraph;
	language_function *fn;
	LOOP_OVER_LINKED_LIST(fn, language_function, P->functions)
		if (Str__eq(fname, fn->function_name))
			return fn;

}
#line 128 "inweb/Chapter 4/Types and Functions.w"
;
	hash_table_entry *hte =
		Analyser__mark_reserved_word_at_line(L, fname, FUNCTION_COLOUR);
	language_function *fn = CREATE(language_function);
	hte->as_function = fn;
	
{
#line 144 "inweb/Chapter 4/Types and Functions.w"
	fn->function_name = Str__duplicate(fname);
	fn->function_arguments = Str__new();
	fn->function_type = Str__new();
	fn->within_namespace = FALSE;
	fn->called_from_other_sections = FALSE;
	fn->call_freely = FALSE;
	fn->function_header_at = L;
	fn->usage_described = FALSE;
	if ((Str__eq_wide_string(fname, U"main")) &&
		(L->owning_section->sect_language->C_like))
		fn->usage_described = TRUE;
	fn->no_conditionals = 0;

}
#line 133 "inweb/Chapter 4/Types and Functions.w"
;
	
{
#line 174 "inweb/Chapter 4/Types and Functions.w"
	paragraph *P = L->owning_paragraph;
	if (P) ADD_TO_LINKED_LIST(fn, language_function, P->functions);
	L->function_defined = fn;

}
#line 134 "inweb/Chapter 4/Types and Functions.w"
;
	if (L->owning_section->sect_language->supports_namespaces)
		
{
#line 179 "inweb/Chapter 4/Types and Functions.w"
	text_stream *declared_namespace = NULL;
	text_stream *ambient_namespace = L->owning_section->sect_namespace;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, fname, U"(%c+::)%c*")) {
		declared_namespace = mr.exp[0];
		fn->within_namespace = TRUE;
	} else if ((Str__eq_wide_string(fname, U"main")) &&
		(Str__eq_wide_string(ambient_namespace, U"Main::")))
		declared_namespace = TL_IS_2860;
	if ((Str__ne(declared_namespace, ambient_namespace)) &&
		(L->owning_paragraph->placed_very_early == FALSE)) {
		TEMPORARY_TEXT(err_mess)
		if (Str__len(declared_namespace) == 0)
			WRITE_TO(err_mess, "Function '%S' should have namespace prefix '%S'",
				fname, ambient_namespace);
		else if (Str__len(ambient_namespace) == 0)
			WRITE_TO(err_mess, "Function '%S' declared in a section with no namespace",
				fname);
		else
			WRITE_TO(err_mess, "Function '%S' declared in a section with the wrong namespace '%S'",
				fname, ambient_namespace);
		Main__error_in_web(err_mess, L);
		DISCARD_TEXT(err_mess)
	}
	Regexp__dispose_of(&mr);

}
#line 136 "inweb/Chapter 4/Types and Functions.w"
;
	return fn;
}

#line 209 "inweb/Chapter 4/Types and Functions.w"
int Functions__used_elsewhere(language_function *fn) {
	paragraph *P = fn->function_header_at->owning_paragraph;
	hash_table_entry *hte =
		Analyser__find_hash_entry_for_section(fn->function_header_at->owning_section,
			fn->function_name, FALSE);
	hash_table_entry_usage *hteu = NULL;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if ((P != hteu->usage_recorded_at) &&
			(P->under_section == hteu->usage_recorded_at->under_section))
			return TRUE;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if (P->under_section != hteu->usage_recorded_at->under_section)
			return TRUE;
	return FALSE;
}

#line 230 "inweb/Chapter 4/Types and Functions.w"
void Functions__catalogue(section *S, int functions_too) {
	language_type *str;
	LOOP_OVER(str, language_type)
		if (str->structure_header_at->owning_section == S)
			PRINT(" %S ", str->structure_name);
	if (functions_too) {
		language_function *fn;
		LOOP_OVER(fn, language_function)
			if (fn->function_header_at->owning_section == S)
				PRINT("\n                     %S", fn->function_name);
	}
}

#line 36 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(PARSE_TYPES_PAR_MTID, programming_language *pl, web *W)
void LanguageMethods__parse_types(web *W, programming_language *pl) {
	VOID_METHOD_CALL(pl, PARSE_TYPES_PAR_MTID, W);
}

#line 44 "inweb/Chapter 4/Language Methods.w"

#line 46 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(PARSE_FUNCTIONS_PAR_MTID, programming_language *pl, web *W)
void LanguageMethods__parse_functions(web *W, programming_language *pl) {
	VOID_METHOD_CALL(pl, PARSE_FUNCTIONS_PAR_MTID, W);
}

#line 56 "inweb/Chapter 4/Language Methods.w"

#line 58 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(FURTHER_PARSING_PAR_MTID, programming_language *pl, web *W)
void LanguageMethods__further_parsing(web *W, programming_language *pl) {
	VOID_METHOD_CALL(pl, FURTHER_PARSING_PAR_MTID, W);
}

#line 69 "inweb/Chapter 4/Language Methods.w"

#line 71 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(SUBCATEGORISE_LINE_PAR_MTID, programming_language *pl, source_line *L)
void LanguageMethods__subcategorise_line(programming_language *pl, source_line *L) {
	VOID_METHOD_CALL(pl, SUBCATEGORISE_LINE_PAR_MTID, L);
}

#line 82 "inweb/Chapter 4/Language Methods.w"

#line 84 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(PARSE_COMMENT_TAN_MTID, programming_language *pl, text_stream *line, text_stream *before, text_stream *within)

int LanguageMethods__parse_comment(programming_language *pl,
	text_stream *line, text_stream *before, text_stream *within) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, PARSE_COMMENT_TAN_MTID, line, before, within);
	return rv;
}

#line 102 "inweb/Chapter 4/Language Methods.w"

#line 104 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(SHEBANG_TAN_MTID, programming_language *pl, text_stream *OUT, web *W, tangle_target *target)
void LanguageMethods__shebang(OUTPUT_STREAM, programming_language *pl, web *W, tangle_target *target) {
	VOID_METHOD_CALL(pl, SHEBANG_TAN_MTID, OUT, W, target);
}

#line 113 "inweb/Chapter 4/Language Methods.w"

#line 115 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(SUPPRESS_DISCLAIMER_TAN_MTID, programming_language *pl)
void LanguageMethods__disclaimer(text_stream *OUT, programming_language *pl, web *W, tangle_target *target) {
	int rv = FALSE;
	INT_METHOD_CALL_WITHOUT_ARGUMENTS(rv, pl, SUPPRESS_DISCLAIMER_TAN_MTID);
	if (rv == FALSE)
		LanguageMethods__comment(OUT, pl, TL_IS_2861);
}

#line 127 "inweb/Chapter 4/Language Methods.w"

#line 129 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(ADDITIONAL_EARLY_MATTER_TAN_MTID, programming_language *pl, text_stream *OUT, web *W, tangle_target *target)
void LanguageMethods__additional_early_matter(text_stream *OUT, programming_language *pl, web *W, tangle_target *target) {
	VOID_METHOD_CALL(pl, ADDITIONAL_EARLY_MATTER_TAN_MTID, OUT, W, target);
}

#line 143 "inweb/Chapter 4/Language Methods.w"

#line 145 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(START_DEFN_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *term, text_stream *start, section *S, source_line *L)
INT_METHOD_TYPE(PROLONG_DEFN_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *more, section *S, source_line *L)
INT_METHOD_TYPE(END_DEFN_TAN_MTID, programming_language *pl, text_stream *OUT, section *S, source_line *L)

void LanguageMethods__start_definition(OUTPUT_STREAM, programming_language *pl,
	text_stream *term, text_stream *start, section *S, source_line *L) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, START_DEFN_TAN_MTID, OUT, term, start, S, L);
	if (rv == FALSE)
		Main__error_in_web(TL_IS_2862, L);
}

void LanguageMethods__prolong_definition(OUTPUT_STREAM, programming_language *pl,
	text_stream *more, section *S, source_line *L) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, PROLONG_DEFN_TAN_MTID, OUT, more, S, L);
	if (rv == FALSE)
		Main__error_in_web(TL_IS_2863, L);
}

void LanguageMethods__end_definition(OUTPUT_STREAM, programming_language *pl,
	section *S, source_line *L) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, END_DEFN_TAN_MTID, OUT, S, L);
}

#line 175 "inweb/Chapter 4/Language Methods.w"

#line 177 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(ADDITIONAL_PREDECLARATIONS_TAN_MTID, programming_language *pl, text_stream *OUT, web *W)
void LanguageMethods__additional_predeclarations(OUTPUT_STREAM, programming_language *pl, web *W) {
	VOID_METHOD_CALL(pl, ADDITIONAL_PREDECLARATIONS_TAN_MTID, OUT, W);
}

#line 188 "inweb/Chapter 4/Language Methods.w"

#line 190 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(SUPPRESS_EXPANSION_TAN_MTID, programming_language *pl, text_stream *material)
int LanguageMethods__allow_expansion(programming_language *pl, text_stream *material) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, SUPPRESS_EXPANSION_TAN_MTID, material);
	return (rv)?FALSE:TRUE;
}

#line 202 "inweb/Chapter 4/Language Methods.w"

#line 204 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(TANGLE_COMMAND_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *data)

int LanguageMethods__special_tangle_command(OUTPUT_STREAM, programming_language *pl, text_stream *data) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, TANGLE_COMMAND_TAN_MTID, OUT, data);
	return rv;
}

#line 219 "inweb/Chapter 4/Language Methods.w"

#line 221 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(WILL_TANGLE_EXTRA_LINE_TAN_MTID, programming_language *pl, source_line *L)
VOID_METHOD_TYPE(TANGLE_EXTRA_LINE_TAN_MTID, programming_language *pl, text_stream *OUT, source_line *L)
int LanguageMethods__will_insert_in_tangle(programming_language *pl, source_line *L) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, WILL_TANGLE_EXTRA_LINE_TAN_MTID, L);
	return rv;
}
void LanguageMethods__insert_in_tangle(OUTPUT_STREAM, programming_language *pl, source_line *L) {
	VOID_METHOD_CALL(pl, TANGLE_EXTRA_LINE_TAN_MTID, OUT, L);
}

#line 238 "inweb/Chapter 4/Language Methods.w"

#line 240 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(INSERT_LINE_MARKER_TAN_MTID, programming_language *pl, text_stream *OUT, source_line *L)
void LanguageMethods__insert_line_marker(OUTPUT_STREAM, programming_language *pl, source_line *L) {
	VOID_METHOD_CALL(pl, INSERT_LINE_MARKER_TAN_MTID, OUT, L);
}

#line 251 "inweb/Chapter 4/Language Methods.w"

#line 253 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(BEFORE_MACRO_EXPANSION_TAN_MTID, programming_language *pl, text_stream *OUT, para_macro *pmac)
VOID_METHOD_TYPE(AFTER_MACRO_EXPANSION_TAN_MTID, programming_language *pl, text_stream *OUT, para_macro *pmac)
void LanguageMethods__before_macro_expansion(OUTPUT_STREAM, programming_language *pl, para_macro *pmac) {
	VOID_METHOD_CALL(pl, BEFORE_MACRO_EXPANSION_TAN_MTID, OUT, pmac);
}
void LanguageMethods__after_macro_expansion(OUTPUT_STREAM, programming_language *pl, para_macro *pmac) {
	VOID_METHOD_CALL(pl, AFTER_MACRO_EXPANSION_TAN_MTID, OUT, pmac);
}

#line 268 "inweb/Chapter 4/Language Methods.w"

#line 270 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(OPEN_IFDEF_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *symbol, int sense)
VOID_METHOD_TYPE(CLOSE_IFDEF_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *symbol, int sense)
void LanguageMethods__open_ifdef(OUTPUT_STREAM, programming_language *pl, text_stream *symbol, int sense) {
	VOID_METHOD_CALL(pl, OPEN_IFDEF_TAN_MTID, OUT, symbol, sense);
}
void LanguageMethods__close_ifdef(OUTPUT_STREAM, programming_language *pl, text_stream *symbol, int sense) {
	VOID_METHOD_CALL(pl, CLOSE_IFDEF_TAN_MTID, OUT, symbol, sense);
}

#line 282 "inweb/Chapter 4/Language Methods.w"

#line 284 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(COMMENT_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *comm)
void LanguageMethods__comment(OUTPUT_STREAM, programming_language *pl, text_stream *comm) {
	VOID_METHOD_CALL(pl, COMMENT_TAN_MTID, OUT, comm);
}

#line 294 "inweb/Chapter 4/Language Methods.w"

#line 296 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(TANGLE_LINE_UNUSUALLY_TAN_MTID, programming_language *pl, text_stream *OUT, text_stream *original)
void LanguageMethods__tangle_line(OUTPUT_STREAM, programming_language *pl, text_stream *original) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, TANGLE_LINE_UNUSUALLY_TAN_MTID, OUT, original);
	if (rv == FALSE) WRITE("%S", original);
}

#line 306 "inweb/Chapter 4/Language Methods.w"

#line 308 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(GNABEHS_TAN_MTID, programming_language *pl, text_stream *OUT, web *W)
void LanguageMethods__gnabehs(OUTPUT_STREAM, programming_language *pl, web *W) {
	VOID_METHOD_CALL(pl, GNABEHS_TAN_MTID, OUT, W);
}

#line 318 "inweb/Chapter 4/Language Methods.w"

#line 320 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(ADDITIONAL_TANGLING_TAN_MTID, programming_language *pl, web *W, tangle_target *target)
void LanguageMethods__additional_tangling(programming_language *pl, web *W, tangle_target *target) {
	VOID_METHOD_CALL(pl, ADDITIONAL_TANGLING_TAN_MTID, W, target);
}

#line 330 "inweb/Chapter 4/Language Methods.w"

#line 332 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(BEGIN_WEAVE_WEA_MTID, programming_language *pl, section *S, weave_order *wv)
void LanguageMethods__begin_weave(section *S, weave_order *wv) {
	VOID_METHOD_CALL(S->sect_language, BEGIN_WEAVE_WEA_MTID, S, wv);
}

#line 340 "inweb/Chapter 4/Language Methods.w"

#line 342 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(SKIP_IN_WEAVING_WEA_MTID, programming_language *pl, weave_order *wv, source_line *L)
int LanguageMethods__skip_in_weaving(programming_language *pl, weave_order *wv, source_line *L) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, SKIP_IN_WEAVING_WEA_MTID, wv, L);
	return rv;
}

#line 355 "inweb/Chapter 4/Language Methods.w"

#line 357 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(RESET_SYNTAX_COLOURING_WEA_MTID, programming_language *pl)
void LanguageMethods__reset_syntax_colouring(programming_language *pl) {
	VOID_METHOD_CALL_WITHOUT_ARGUMENTS(pl, RESET_SYNTAX_COLOURING_WEA_MTID);
}

#line 365 "inweb/Chapter 4/Language Methods.w"

#line 367 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(SYNTAX_COLOUR_WEA_MTID, programming_language *pl,
	weave_order *wv, source_line *L, text_stream *matter, text_stream *colouring)
int LanguageMethods__syntax_colour(programming_language *pl,
	weave_order *wv, source_line *L, text_stream *matter, text_stream *colouring) {
	for (int i=0; i < Str__len(matter); i++) Str__put_at(colouring, i, PLAIN_COLOUR);
	int rv = FALSE;
	programming_language *colour_as = pl;
	if (L->category == TEXT_EXTRACT_LCAT) colour_as = L->colour_as;
	theme_tag *T = Tags__find_by_name(TL_IS_2864, FALSE);
	if ((T) && (Tags__tagged_with(L->owning_paragraph, T))) {
		programming_language *prepl = Analyser__find_by_name(TL_IS_2865, wv->weave_web, FALSE);
		if ((L->category == PREFORM_LCAT) || (L->category == PREFORM_GRAMMAR_LCAT))
			if (prepl) colour_as = prepl;
	}
	if (colour_as)
		INT_METHOD_CALL(rv, colour_as, SYNTAX_COLOUR_WEA_MTID, wv, L,
			matter, colouring);
	return rv;
}

#line 392 "inweb/Chapter 4/Language Methods.w"

#line 394 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(WEAVE_CODE_LINE_WEA_MTID, programming_language *pl, text_stream *OUT, weave_order *wv, web *W,
	chapter *C, section *S, source_line *L, text_stream *matter, text_stream *concluding_comment)
int LanguageMethods__weave_code_line(OUTPUT_STREAM, programming_language *pl, weave_order *wv,
	web *W, chapter *C, section *S, source_line *L, text_stream *matter, text_stream *concluding_comment) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, WEAVE_CODE_LINE_WEA_MTID, OUT, wv, W, C, S, L, matter, concluding_comment);
	return rv;
}

#line 406 "inweb/Chapter 4/Language Methods.w"

#line 408 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(NOTIFY_NEW_TAG_WEA_MTID, programming_language *pl, theme_tag *tag)
void LanguageMethods__new_tag_declared(theme_tag *tag) {
	programming_language *pl;
	LOOP_OVER(pl, programming_language)
		VOID_METHOD_CALL(pl, NOTIFY_NEW_TAG_WEA_MTID, tag);
}

#line 428 "inweb/Chapter 4/Language Methods.w"

#line 430 "inweb/Chapter 4/Language Methods.w"
VOID_METHOD_TYPE(ANALYSIS_ANA_MTID, programming_language *pl, web *W)
VOID_METHOD_TYPE(POST_ANALYSIS_ANA_MTID, programming_language *pl, web *W)
void LanguageMethods__early_preweave_analysis(programming_language *pl, web *W) {
	VOID_METHOD_CALL(pl, ANALYSIS_ANA_MTID, W);
}
void LanguageMethods__late_preweave_analysis(programming_language *pl, web *W) {
	VOID_METHOD_CALL(pl, POST_ANALYSIS_ANA_MTID, W);
}

#line 443 "inweb/Chapter 4/Language Methods.w"

#line 445 "inweb/Chapter 4/Language Methods.w"
INT_METHOD_TYPE(SHARE_ELEMENT_ANA_MTID, programming_language *pl, text_stream *element_name)
int LanguageMethods__share_element(programming_language *pl, text_stream *element_name) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pl, SHARE_ELEMENT_ANA_MTID, element_name);
	return rv;
}

#line 455 "inweb/Chapter 4/Language Methods.w"
int LanguageMethods__supports_definitions(programming_language *pl) {
	if (Str__len(pl->start_definition) > 0) return TRUE;
	if (Str__len(pl->prolong_definition) > 0) return TRUE;
	if (Str__len(pl->end_definition) > 0) return TRUE;
	return FALSE;
}

#line 16 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__add_fallbacks(programming_language *pl) {
	if (Methods__provided(pl->methods, PARSE_TYPES_PAR_MTID) == FALSE)
		METHOD_ADD(pl, PARSE_TYPES_PAR_MTID, ACMESupport__parse_types);
	if (Methods__provided(pl->methods, PARSE_FUNCTIONS_PAR_MTID) == FALSE)
		METHOD_ADD(pl, PARSE_FUNCTIONS_PAR_MTID, ACMESupport__parse_functions);
	if (Methods__provided(pl->methods, ANALYSIS_ANA_MTID) == FALSE)
		METHOD_ADD(pl, ANALYSIS_ANA_MTID, ACMESupport__analyse_code);
	if (Methods__provided(pl->methods, POST_ANALYSIS_ANA_MTID) == FALSE)
		METHOD_ADD(pl, POST_ANALYSIS_ANA_MTID, ACMESupport__post_analysis);
	if (Methods__provided(pl->methods, PARSE_COMMENT_TAN_MTID) == FALSE)
		METHOD_ADD(pl, PARSE_COMMENT_TAN_MTID, Painter__parse_comment);
	if (Methods__provided(pl->methods, COMMENT_TAN_MTID) == FALSE)
		METHOD_ADD(pl, COMMENT_TAN_MTID, ACMESupport__comment);
	if (Methods__provided(pl->methods, SHEBANG_TAN_MTID) == FALSE)
		METHOD_ADD(pl, SHEBANG_TAN_MTID, ACMESupport__shebang);
	if (Methods__provided(pl->methods, BEFORE_MACRO_EXPANSION_TAN_MTID) == FALSE)
		METHOD_ADD(pl, BEFORE_MACRO_EXPANSION_TAN_MTID, ACMESupport__before_macro_expansion);
	if (Methods__provided(pl->methods, AFTER_MACRO_EXPANSION_TAN_MTID) == FALSE)
		METHOD_ADD(pl, AFTER_MACRO_EXPANSION_TAN_MTID, ACMESupport__after_macro_expansion);
	if (Methods__provided(pl->methods, START_DEFN_TAN_MTID) == FALSE)
		METHOD_ADD(pl, START_DEFN_TAN_MTID, ACMESupport__start_definition);
	if (Methods__provided(pl->methods, PROLONG_DEFN_TAN_MTID) == FALSE)
		METHOD_ADD(pl, PROLONG_DEFN_TAN_MTID, ACMESupport__prolong_definition);
	if (Methods__provided(pl->methods, END_DEFN_TAN_MTID) == FALSE)
		METHOD_ADD(pl, END_DEFN_TAN_MTID, ACMESupport__end_definition);
	if (Methods__provided(pl->methods, OPEN_IFDEF_TAN_MTID) == FALSE)
		METHOD_ADD(pl, OPEN_IFDEF_TAN_MTID, ACMESupport__I6_open_ifdef);
	if (Methods__provided(pl->methods, CLOSE_IFDEF_TAN_MTID) == FALSE)
		METHOD_ADD(pl, CLOSE_IFDEF_TAN_MTID, ACMESupport__I6_close_ifdef);
	if (Methods__provided(pl->methods, INSERT_LINE_MARKER_TAN_MTID) == FALSE)
		METHOD_ADD(pl, INSERT_LINE_MARKER_TAN_MTID, ACMESupport__insert_line_marker);
	if (Methods__provided(pl->methods, SUPPRESS_DISCLAIMER_TAN_MTID) == FALSE)
		METHOD_ADD(pl, SUPPRESS_DISCLAIMER_TAN_MTID, ACMESupport__suppress_disclaimer);
	if (Methods__provided(pl->methods, BEGIN_WEAVE_WEA_MTID) == FALSE)
		METHOD_ADD(pl, BEGIN_WEAVE_WEA_MTID, ACMESupport__begin_weave);
	if (Methods__provided(pl->methods, RESET_SYNTAX_COLOURING_WEA_MTID) == FALSE)
		METHOD_ADD(pl, RESET_SYNTAX_COLOURING_WEA_MTID, ACMESupport__reset_syntax_colouring);
	if (Methods__provided(pl->methods, SYNTAX_COLOUR_WEA_MTID) == FALSE)
		METHOD_ADD(pl, SYNTAX_COLOUR_WEA_MTID, ACMESupport__syntax_colour);
}

#line 62 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__expand(OUTPUT_STREAM, text_stream *prototype, text_stream *S,
	int N, filename *F) {
	if (Str__len(prototype) > 0) {
		for (int i=0; i<Str__len(prototype); i++) {
			inchar32_t c = Str__get_at(prototype, i);
			if ((c == '%') && (Str__get_at(prototype, i+1) == 'S') && (S)) {
				WRITE("%S", S);
				i++;
			} else if ((c == '%') && (Str__get_at(prototype, i+1) == 'd') && (N >= 0)) {
				WRITE("%d", N);
				i++;
			} else if ((c == '%') && (Str__get_at(prototype, i+1) == 'f') && (F)) {
				WRITE("%/f", F);
				i++;
			} else {
				PUT(c);
			}
		}
	}
}

#line 86 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__shebang(programming_language *pl, text_stream *OUT, web *W,
	tangle_target *target) {
	ACMESupport__expand(OUT, pl->shebang, NULL, -1, NULL);
}

void ACMESupport__before_macro_expansion(programming_language *pl,
	OUTPUT_STREAM, para_macro *pmac) {
	ACMESupport__expand(OUT, pl->before_macro_expansion, NULL, -1, NULL);
}

void ACMESupport__after_macro_expansion(programming_language *pl,
	OUTPUT_STREAM, para_macro *pmac) {
	ACMESupport__expand(OUT, pl->after_macro_expansion, NULL, -1, NULL);
}

int ACMESupport__start_definition(programming_language *pl, text_stream *OUT,
	text_stream *term, text_stream *start, section *S, source_line *L) {
	if (LanguageMethods__supports_definitions(pl)) {
		ACMESupport__expand(OUT, pl->start_definition, term, -1, NULL);
		Tangler__tangle_line(OUT, start, S, L);
	}
	return TRUE;
}

int ACMESupport__prolong_definition(programming_language *pl,
	text_stream *OUT, text_stream *more, section *S, source_line *L) {
	if (LanguageMethods__supports_definitions(pl)) {
		ACMESupport__expand(OUT, pl->prolong_definition, NULL, -1, NULL);
		Tangler__tangle_line(OUT, more, S, L);
	}
	return TRUE;
}

int ACMESupport__end_definition(programming_language *pl,
	text_stream *OUT, section *S, source_line *L) {
	if (LanguageMethods__supports_definitions(pl)) {
		ACMESupport__expand(OUT, pl->end_definition, NULL, -1, NULL);
	}
	return TRUE;
}

void ACMESupport__I6_open_ifdef(programming_language *pl,
	text_stream *OUT, text_stream *symbol, int sense) {
	if (sense) ACMESupport__expand(OUT, pl->start_ifdef, symbol, -1, NULL);
	else ACMESupport__expand(OUT, pl->start_ifndef, symbol, -1, NULL);
}

void ACMESupport__I6_close_ifdef(programming_language *pl,
	text_stream *OUT, text_stream *symbol, int sense) {
	if (sense) ACMESupport__expand(OUT, pl->end_ifdef, symbol, -1, NULL);
	else ACMESupport__expand(OUT, pl->end_ifndef, symbol, -1, NULL);
}

void ACMESupport__insert_line_marker(programming_language *pl,
	text_stream *OUT, source_line *L) {
	ACMESupport__expand(OUT, pl->line_marker, NULL,
		L->source.line_count, L->source.text_file_filename);
}

void ACMESupport__comment(programming_language *pl,
	text_stream *OUT, text_stream *comm) {
	if (Str__len(pl->multiline_comment_open) > 0) {
		ACMESupport__expand(OUT, pl->multiline_comment_open, NULL, -1, NULL);
		WRITE(" %S ", comm);
		ACMESupport__expand(OUT, pl->multiline_comment_close, NULL, -1, NULL);
		WRITE("\n");
	} else if (Str__len(pl->line_comment) > 0) {
		ACMESupport__expand(OUT, pl->line_comment, NULL, -1, NULL);
		WRITE(" %S\n", comm);
	} else if (Str__len(pl->whole_line_comment) > 0) {
		ACMESupport__expand(OUT, pl->whole_line_comment, NULL, -1, NULL);
		WRITE(" %S\n", comm);
	}
}

#line 164 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__parse_types(programming_language *self, web *W) {
	if (W->main_language->type_notation[0]) {
		chapter *C;
		section *S;
		LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W)) {
			if (S->sect_language == W->main_language) {
				match_results mr = Regexp__create_mr();
				if (Regexp__match(&mr, L->text, W->main_language->type_notation)) {
					Functions__new_function(mr.exp[0], L);
				}
				Regexp__dispose_of(&mr);
			}
		}
	}
}

#line 183 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__parse_functions(programming_language *self, web *W) {
	if (W->main_language->function_notation[0]) {
		chapter *C;
		section *S;
		LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W)) {
			if (S->sect_language == W->main_language) {
				match_results mr = Regexp__create_mr();
				if ((L->category != TEXT_EXTRACT_LCAT) &&
					(Regexp__match(&mr, L->text, W->main_language->function_notation))) {
					Functions__new_function(mr.exp[0], L);
				}
				Regexp__dispose_of(&mr);
			}
		}
	}
}

#line 208 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__post_analysis(programming_language *self, web *W) {
	int check_namespaces = FALSE;
	if (Str__eq_wide_string(Bibliographic__get_datum(W->md, TL_IS_2866), U"On"))
		check_namespaces = TRUE;
	language_function *fn;
	LOOP_OVER(fn, language_function) {
		hash_table_entry *hte =
			Analyser__find_hash_entry_for_section(fn->function_header_at->owning_section,
				fn->function_name, FALSE);
		if (hte) {
			hash_table_entry_usage *hteu;
			LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages) {
				if ((hteu->form_of_usage & FCALL_USAGE) || (fn->within_namespace))
					if (hteu->usage_recorded_at->under_section != fn->function_header_at->owning_section)
						fn->called_from_other_sections = TRUE;
			}
		}
		if ((fn->within_namespace != fn->called_from_other_sections)
			&& (check_namespaces)
			&& (fn->call_freely == FALSE)) {
			if (fn->within_namespace)
				Main__error_in_web(
					TL_IS_2867,
					fn->function_header_at);
			else
				Main__error_in_web(
					TL_IS_2868,
					fn->function_header_at);
		}
	}
}

#line 244 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__analyse_code(programming_language *self, web *W) {
	language_function *fn;
	LOOP_OVER(fn, language_function)
		Analyser__find_hash_entry_for_section(fn->function_header_at->owning_section,
			fn->function_name, TRUE);
	language_type *str;
	structure_element *elt;
	LOOP_OVER_LINKED_LIST(str, language_type, W->language_types)
		LOOP_OVER_LINKED_LIST(elt, structure_element, str->elements)
			if (elt->allow_sharing == FALSE)
				Analyser__find_hash_entry_for_section(elt->element_created_at->owning_section,
					elt->element_name, TRUE);
}

#line 262 "inweb/Chapter 4/ACME Support.w"
int ACMESupport__suppress_disclaimer(programming_language *pl) {
	return pl->suppress_disclaimer;
}

#line 269 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__begin_weave(programming_language *pl, section *S, weave_order *wv) {
	reserved_word *rw;
	LOOP_OVER_LINKED_LIST(rw, reserved_word, pl->reserved_words)
		Analyser__mark_reserved_word_for_section(S, rw->word, rw->colour);
}

#line 278 "inweb/Chapter 4/ACME Support.w"
void ACMESupport__reset_syntax_colouring(programming_language *pl) {
	Painter__reset_syntax_colouring(pl);
}

int ACMESupport__syntax_colour(programming_language *pl,
	weave_order *wv, source_line *L, text_stream *matter, text_stream *colouring) {
	section *S = L->owning_section;
	hash_table *ht = &(S->sect_target->symbols);
	if ((L->category == TEXT_EXTRACT_LCAT) && (pl != S->sect_language))
		ht = &(pl->built_in_keywords);
	return Painter__syntax_colour(pl, ht, matter, colouring, FALSE);
}

#line 9 "inweb/Chapter 4/C-Like Languages.w"
void CLike__make_c_like(programming_language *pl) {
	METHOD_ADD(pl, PARSE_TYPES_PAR_MTID, CLike__parse_types);
	METHOD_ADD(pl, PARSE_FUNCTIONS_PAR_MTID, CLike__parse_functions);
	METHOD_ADD(pl, SUBCATEGORISE_LINE_PAR_MTID, CLike__subcategorise_code);

	METHOD_ADD(pl, ADDITIONAL_EARLY_MATTER_TAN_MTID, CLike__additional_early_matter);
	METHOD_ADD(pl, ADDITIONAL_PREDECLARATIONS_TAN_MTID, CLike__additional_predeclarations);
}

#line 24 "inweb/Chapter 4/C-Like Languages.w"
void CLike__parse_types(programming_language *self, web *W) {
	
{
#line 50 "inweb/Chapter 4/C-Like Languages.w"
	language_type *current_str = NULL;
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W)) {
		if (Str__len(L->extract_to) == 0) {
			match_results mr = Regexp__create_mr();

			if (Regexp__match(&mr, L->text, U"typedef struct (%i+) %c*{%c*")) {
				current_str = Functions__new_struct(W, mr.exp[0], L);
				Tags__add_by_name(L->owning_paragraph, TL_IS_2869);
			} else if ((Str__get_first_char(L->text) == '}') && (current_str)) {
				current_str->typedef_ends = L;
				current_str = NULL;
			} else if ((current_str) && (current_str->typedef_ends == NULL)) {
				
{
#line 82 "inweb/Chapter 4/C-Like Languages.w"
	TEMPORARY_TEXT(p)
	Str__copy(p, L->text);
	Str__trim_white_space(p);
	
{
#line 104 "inweb/Chapter 4/C-Like Languages.w"
	inchar32_t *modifier_patterns[] = {
		U"(struct )(%C%c*)", U"(signed )(%C%c*)", U"(unsigned )(%C%c*)",
		U"(short )(%C%c*)", U"(long )(%C%c*)", U"(static )(%C%c*)", NULL };
	int seek_modifiers = TRUE;
	while (seek_modifiers) {
		seek_modifiers = FALSE;
		for (int i = 0; modifier_patterns[i]; i++)
			if (Regexp__match(&mr, p, modifier_patterns[i])) {
				Str__copy(p, mr.exp[1]);
				seek_modifiers = TRUE;
				break;
			}
	}

}
#line 85 "inweb/Chapter 4/C-Like Languages.w"
;
	string_position pos = Str__start(p);
	if (Str__get(pos) != '/') { /* a slash must introduce a comment here */
		
{
#line 122 "inweb/Chapter 4/C-Like Languages.w"
	while ((Str__get(pos)) && (Characters__is_space_or_tab(Str__get(pos)) == FALSE))
		pos = Str__forward(pos);

}
#line 88 "inweb/Chapter 4/C-Like Languages.w"
;
		
{
#line 128 "inweb/Chapter 4/C-Like Languages.w"
	while ((Characters__is_space_or_tab(Str__get(pos))) || (Str__get(pos) == '*') ||
		(Str__get(pos) == '(') || (Str__get(pos) == ')')) pos = Str__forward(pos);

}
#line 89 "inweb/Chapter 4/C-Like Languages.w"
;
		if (Str__in_range(pos)) {
			match_results mr = Regexp__create_mr();
			TEMPORARY_TEXT(elname)
			
{
#line 135 "inweb/Chapter 4/C-Like Languages.w"
	Str__substr(elname, pos, Str__end(p));
	if (Regexp__match(&mr, elname, U"(%i+)%c*")) Str__copy(elname, mr.exp[0]);

}
#line 93 "inweb/Chapter 4/C-Like Languages.w"
;
			Functions__new_element(current_str, elname, L);
			DISCARD_TEXT(elname)
			Regexp__dispose_of(&mr);
		}
	}
	DISCARD_TEXT(p)

}
#line 64 "inweb/Chapter 4/C-Like Languages.w"
;
			} else if ((Regexp__match(&mr, L->text, U"typedef %c+")) &&
				(Regexp__match(&mr, L->text, U"%c+##%c+") == FALSE)) {
				if (L->owning_paragraph->placed_very_early == FALSE)
					L->category = TYPEDEF_LCAT;
			}
			Regexp__dispose_of(&mr);
		}
	}

}
#line 25 "inweb/Chapter 4/C-Like Languages.w"
;
	
{
#line 152 "inweb/Chapter 4/C-Like Languages.w"
	language_type *current_str;
	LOOP_OVER(current_str, language_type) {
		for (source_line *L = current_str->structure_header_at;
			((L) && (L != current_str->typedef_ends));
			L = L->next_line) {
			match_results mr = Regexp__create_mr();
			if (Regexp__match(&mr, L->text, U" struct (%i+) %i%c*"))
				
{
#line 165 "inweb/Chapter 4/C-Like Languages.w"
	text_stream *used_structure = mr.exp[0];
	language_type *str;
	LOOP_OVER_LINKED_LIST(str, language_type, W->language_types)
		if ((str != current_str) &&
			(Str__eq(used_structure, str->structure_name)))
			ADD_TO_LINKED_LIST(str, language_type, current_str->incorporates);

}
#line 159 "inweb/Chapter 4/C-Like Languages.w"
;
			Regexp__dispose_of(&mr);
		}
	}

}
#line 26 "inweb/Chapter 4/C-Like Languages.w"
;
}

#line 184 "inweb/Chapter 4/C-Like Languages.w"
int cc_sp = 0;
source_line *cc_stack[MAX_CONDITIONAL_COMPILATION_STACK];

void CLike__parse_functions(programming_language *self, web *W) {
	cc_sp = 0;
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if ((L->category == CODE_BODY_LCAT) ||
			(L->category == BEGIN_DEFINITION_LCAT) ||
			(L->category == CONT_DEFINITION_LCAT)) {
			
{
#line 203 "inweb/Chapter 4/C-Like Languages.w"
	match_results mr = Regexp__create_mr();
	if ((Regexp__match(&mr, L->text, U" *#ifn*def %c+")) ||
		(Regexp__match(&mr, L->text, U" *#IFN*DEF %c+"))) {
		if (cc_sp >= MAX_CONDITIONAL_COMPILATION_STACK)
			Main__error_in_web(TL_IS_2871, L);
		else
			cc_stack[cc_sp++] = L;
	}
	if ((Regexp__match(&mr, L->text, U" *#endif *")) ||
		(Regexp__match(&mr, L->text, U" *#ENDIF *"))) {
		if (cc_sp <= 0)
			Main__error_in_web(TL_IS_2872, L);
		else
			cc_sp--;
	}

}
#line 195 "inweb/Chapter 4/C-Like Languages.w"
;
			
{
#line 229 "inweb/Chapter 4/C-Like Languages.w"
	if (!(Characters__is_space_or_tab(Str__get_first_char(L->text)))) {
		TEMPORARY_TEXT(qualifiers)
		TEMPORARY_TEXT(modified)
		Str__copy(modified, L->text);
		
{
#line 256 "inweb/Chapter 4/C-Like Languages.w"
	inchar32_t *modifier_patterns[] = {
		U"(signed )(%C%c*)", U"(unsigned )(%C%c*)",
		U"(short )(%C%c*)", U"(long )(%C%c*)", U"(static )(%C%c*)", NULL };
	int seek_modifiers = TRUE;
	while (seek_modifiers) {
		seek_modifiers = FALSE;
		match_results mr = Regexp__create_mr();
		for (int i = 0; modifier_patterns[i]; i++)
			if (Regexp__match(&mr, modified, modifier_patterns[i])) {
				Str__concatenate(qualifiers, mr.exp[0]);
				Str__copy(modified, mr.exp[1]);
				seek_modifiers = TRUE; break;
			}
		Regexp__dispose_of(&mr);
	}

}
#line 233 "inweb/Chapter 4/C-Like Languages.w"
;
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, modified, U"(%i+) (%**)(%i+)%((%c*)")) {
			TEMPORARY_TEXT(ftype) Str__copy(ftype, mr.exp[0]);
			TEMPORARY_TEXT(asts) Str__copy(asts, mr.exp[1]);
			TEMPORARY_TEXT(fname) Str__copy(fname, mr.exp[2]);
			TEMPORARY_TEXT(arguments) Str__copy(arguments, mr.exp[3]);
			
{
#line 273 "inweb/Chapter 4/C-Like Languages.w"
	
{
#line 293 "inweb/Chapter 4/C-Like Languages.w"
	source_line *AL = L;
	int arg_lc = 1;
	while ((AL) && (arg_lc <= MAX_ARG_LINES) && (Regexp__find_open_brace(arguments) == -1)) {
		if (AL->next_line == NULL) {
			TEMPORARY_TEXT(err_mess)
			WRITE_TO(err_mess, "Function '%S' has a malformed declaration", fname);
			Main__error_in_web(err_mess, L);
			DISCARD_TEXT(err_mess)
			break;
		}
		AL = AL->next_line;
		WRITE_TO(arguments, " %S", AL->text);
		arg_lc++;
	}
	int n = Regexp__find_open_brace(arguments);
	if (n >= 0) Str__truncate(arguments, n);

}
#line 273 "inweb/Chapter 4/C-Like Languages.w"
;
	language_function *fn = Functions__new_function(fname, L);
	fn->function_arguments = Str__duplicate(arguments);
	WRITE_TO(fn->function_type, "%S%S %S", qualifiers, ftype, asts);
	if (Str__eq_wide_string(fn->function_name, U"isdigit")) fn->call_freely = TRUE;
	fn->no_conditionals = cc_sp;
	for (int i=0; i<cc_sp; i++) fn->within_conditionals[i] = cc_stack[i];

}
#line 240 "inweb/Chapter 4/C-Like Languages.w"
;
			DISCARD_TEXT(ftype)
			DISCARD_TEXT(asts)
			DISCARD_TEXT(fname)
			DISCARD_TEXT(arguments)
		}
		DISCARD_TEXT(qualifiers)
		DISCARD_TEXT(modified)
		Regexp__dispose_of(&mr);
	}

}
#line 196 "inweb/Chapter 4/C-Like Languages.w"
;
		}
	if (cc_sp > 0)
		Main__error_in_web(TL_IS_2870, NULL);
}

#line 316 "inweb/Chapter 4/C-Like Languages.w"
void CLike__subcategorise_code(programming_language *self, source_line *L) {
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, L->text, U"#include <(%C+)>%c*")) {
		text_stream *library_file = mr.exp[0];
		inchar32_t *ansi_libs[] = {
			U"assert.h", U"ctype.h", U"errno.h", U"float.h", U"limits.h",
			U"locale.h", U"math.h", U"setjmp.h", U"signal.h", U"stdarg.h",
			U"stddef.h", U"stdio.h", U"stdlib.h", U"string.h", U"time.h",
			NULL
		};
		for (int j = 0; ansi_libs[j]; j++)
			if (Str__eq_wide_string(library_file, ansi_libs[j]))
				L->category = C_LIBRARY_INCLUDE_LCAT;
	}
	Regexp__dispose_of(&mr);
}

#line 345 "inweb/Chapter 4/C-Like Languages.w"
void CLike__additional_early_matter(programming_language *self, text_stream *OUT, web *W, tangle_target *target) {
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, target)
		if (L->category == C_LIBRARY_INCLUDE_LCAT) {
			Tags__open_ifdefs(OUT, L->owning_paragraph);
			Tangler__tangle_line(OUT, L->text, S, L);
			WRITE("\n");
			Tags__close_ifdefs(OUT, L->owning_paragraph);
		}
}

#line 364 "inweb/Chapter 4/C-Like Languages.w"
void CLike__additional_predeclarations(programming_language *self, text_stream *OUT, web *W) {
	
{
#line 393 "inweb/Chapter 4/C-Like Languages.w"
	language_type *str;
	LOOP_OVER_LINKED_LIST(str, language_type, W->language_types)
		str->tangled = FALSE;
	LOOP_OVER_LINKED_LIST(str, language_type, W->language_types)
		CLike__tangle_structure(OUT, self, str);

}
#line 365 "inweb/Chapter 4/C-Like Languages.w"
;
	
{
#line 374 "inweb/Chapter 4/C-Like Languages.w"
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if (L->category == TYPEDEF_LCAT) {
			Tags__open_ifdefs(OUT, L->owning_paragraph);
			LanguageMethods__tangle_line(OUT, W->main_language, L->text);
			WRITE("\n");
			Tags__close_ifdefs(OUT, L->owning_paragraph);
		}

}
#line 366 "inweb/Chapter 4/C-Like Languages.w"
;
	
{
#line 435 "inweb/Chapter 4/C-Like Languages.w"
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if (L->function_defined) {
			if (L->owning_paragraph == NULL) {
				TEMPORARY_TEXT(err_mess)
				WRITE_TO(err_mess, "Function '%S' seems outside of any paragraph",
					L->function_defined->function_name);
				Main__error_in_web(err_mess, L);
				DISCARD_TEXT(err_mess)
				continue;
			}
			if (L->owning_paragraph->placed_very_early == FALSE) {
				language_function *fn = L->function_defined;
				int to_close = 0;
				for (int i=0; i<fn->no_conditionals; i++) {
					match_results mr = Regexp__create_mr();
					if (!(Regexp__match(&mr, fn->within_conditionals[i]->text,
						U"%c*inweb: always predeclare%c*"))) {
						WRITE("%S\n", fn->within_conditionals[i]->text);
						to_close++;
					}
				}
				Tags__open_ifdefs(OUT, L->owning_paragraph);
				LanguageMethods__insert_line_marker(OUT, W->main_language, L);
				WRITE("%S ", fn->function_type);
				LanguageMethods__tangle_line(OUT, W->main_language, fn->function_name);
				WRITE("(%S;\n", fn->function_arguments);
				Tags__close_ifdefs(OUT, L->owning_paragraph);
				for (int i=0; i<to_close; i++) {
					WRITE("#endif\n");
				}
			}
		}

}
#line 367 "inweb/Chapter 4/C-Like Languages.w"
;
}

#line 402 "inweb/Chapter 4/C-Like Languages.w"
void CLike__tangle_structure(OUTPUT_STREAM, programming_language *self, language_type *str) {
	if (str->tangled != FALSE) return;
	str->tangled = NOT_APPLICABLE;
	language_type *embodied = NULL;
	LOOP_OVER_LINKED_LIST(embodied, language_type, str->incorporates)
		CLike__tangle_structure(OUT, self, embodied);
	str->tangled = TRUE;
	Tags__open_ifdefs(OUT, str->structure_header_at->owning_paragraph);
	LanguageMethods__insert_line_marker(OUT, self, str->structure_header_at);
	for (source_line *L = str->structure_header_at; L; L = L->next_line) {
		WRITE("%S\n", L->text);
		L->suppress_tangling = TRUE;
		if (L == str->typedef_ends) break;
	}
	Tags__close_ifdefs(OUT, str->structure_header_at->owning_paragraph);
}

#line 10 "inweb/Chapter 4/InC Support.w"
void InCSupport__add_features(programming_language *pl) {
	METHOD_ADD(pl, FURTHER_PARSING_PAR_MTID, InCSupport__further_parsing);

	METHOD_ADD(pl, SUPPRESS_EXPANSION_TAN_MTID, InCSupport__suppress_expansion);
	METHOD_ADD(pl, TANGLE_COMMAND_TAN_MTID, InCSupport__special_tangle_command);
	METHOD_ADD(pl, ADDITIONAL_PREDECLARATIONS_TAN_MTID, InCSupport__additional_predeclarations);
	METHOD_ADD(pl, WILL_TANGLE_EXTRA_LINE_TAN_MTID, InCSupport__will_insert_in_tangle);
	METHOD_ADD(pl, TANGLE_EXTRA_LINE_TAN_MTID, InCSupport__insert_in_tangle);
	METHOD_ADD(pl, TANGLE_LINE_UNUSUALLY_TAN_MTID, InCSupport__tangle_line);
	METHOD_ADD(pl, GNABEHS_TAN_MTID, InCSupport__gnabehs);
	METHOD_ADD(pl, ADDITIONAL_TANGLING_TAN_MTID, InCSupport__additional_tangling);

	METHOD_ADD(pl, SKIP_IN_WEAVING_WEA_MTID, InCSupport__skip_in_weaving);
	METHOD_ADD(pl, WEAVE_CODE_LINE_WEA_MTID, InCSupport__weave_code_line);
	METHOD_ADD(pl, NOTIFY_NEW_TAG_WEA_MTID, InCSupport__new_tag_declared);

	METHOD_ADD(pl, ANALYSIS_ANA_MTID, InCSupport__analyse_code);
	METHOD_ADD(pl, SHARE_ELEMENT_ANA_MTID, InCSupport__share_element);
}

#line 33 "inweb/Chapter 4/InC Support.w"
theme_tag *Preform_theme = NULL;

#line 39 "inweb/Chapter 4/InC Support.w"
preform_nonterminal *alphabetical_list_of_nonterminals = NULL;

void InCSupport__further_parsing(programming_language *self, web *W) {
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if ((L->category == CODE_BODY_LCAT) || (L->category == CONT_DEFINITION_LCAT)) {
			
{
#line 67 "inweb/Chapter 4/InC Support.w"
	int form = NOT_A_NONTERMINAL; /* one of the four values above, or a non-negative word count */
	TEMPORARY_TEXT(pntname)
	TEMPORARY_TEXT(header)
	
{
#line 80 "inweb/Chapter 4/InC Support.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, L->text, U"(<%p+>) ::=%c*")) {
		form = A_GRAMMAR_NONTERMINAL;
		Str__copy(pntname, mr.exp[0]);
		Str__copy(header, mr.exp[0]);
		
{
#line 218 "inweb/Chapter 4/InC Support.w"
	Tags__add_by_name(L->owning_paragraph, TL_IS_2873);
	source_line *AL;
	for (AL = L; (AL) && (AL->category == CODE_BODY_LCAT); AL = AL->next_line) {
		if (Regexp__string_is_white_space(AL->text)) break;
		AL->category = PREFORM_GRAMMAR_LCAT;
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, AL->text, U"(%c+?) ==> (%c*)")) {
			AL->text_operand = Str__duplicate(mr.exp[0]);
			AL->text_operand2 = Str__duplicate(mr.exp[1]);
		} else {
			AL->text_operand = AL->text;
			AL->text_operand2 = Str__new();
		}
		
{
#line 244 "inweb/Chapter 4/InC Support.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, AL->text_operand, U"(%c*)%/%*%c*%*%/ *"))
		AL->text_operand = Str__duplicate(mr.exp[0]);
	Regexp__dispose_of(&mr);

}
#line 231 "inweb/Chapter 4/InC Support.w"
;
		
{
#line 254 "inweb/Chapter 4/InC Support.w"
	TEMPORARY_TEXT(to_scan) Str__copy(to_scan, AL->text_operand2);
	match_results mr = Regexp__create_mr();
	while (Regexp__match(&mr, to_scan, U"%c*?<<(%P+?)>> =(%c*)")) {
		TEMPORARY_TEXT(var_given) Str__copy(var_given, mr.exp[0]);
		TEMPORARY_TEXT(type_given) WRITE_TO(type_given, "int");
		Str__copy(to_scan, mr.exp[1]);
		if (Regexp__match(&mr, var_given, U"(%p+):%p+")) {
			Str__clear(type_given);
			WRITE_TO(type_given, "%S *", mr.exp[0]);
		}
		nonterminal_variable *ntv;
		LOOP_OVER(ntv, nonterminal_variable)
			if (Str__eq(ntv->ntv_name, var_given))
				break;
		if (ntv == NULL) 
{
#line 289 "inweb/Chapter 4/InC Support.w"
	ntv = CREATE(nonterminal_variable);
	ntv->ntv_name = Str__duplicate(var_given);
	ntv->ntv_type = Str__duplicate(type_given);
	LOOP_THROUGH_TEXT(P, var_given)
		if ((Str__get(P) == '-') || (Str__get(P) == ':'))
			Str__put(P, '_');
	ntv->ntv_identifier = Str__new();
	WRITE_TO(ntv->ntv_identifier, "%S_NTMV", var_given);
	ntv->first_mention = AL;

}
#line 268 "inweb/Chapter 4/InC Support.w"
;
		DISCARD_TEXT(var_given)
		DISCARD_TEXT(type_given)
	}
	DISCARD_TEXT(to_scan)
	Regexp__dispose_of(&mr);

}
#line 232 "inweb/Chapter 4/InC Support.w"
;
		Regexp__dispose_of(&mr);
	}

}
#line 85 "inweb/Chapter 4/InC Support.w"
;
	} else if (Regexp__match(&mr, L->text, U"((<%p+>) internal %?) {%c*")) {
		form = A_VORACIOUS_NONTERMINAL;
		Str__copy(pntname, mr.exp[1]);
		Str__copy(header, mr.exp[0]);
	} else if (Regexp__match(&mr, L->text, U"((<%p+>) internal) {%c*")) {
		form = A_FLEXIBLE_NONTERMINAL;
		Str__copy(pntname, mr.exp[1]);
		Str__copy(header, mr.exp[0]);
	} else if (Regexp__match(&mr, L->text, U"((<%p+>) internal (%d+)) {%c*")) {
		form = Str__atoi(mr.exp[2], 0);
		Str__copy(pntname, mr.exp[1]);
		Str__copy(header, mr.exp[0]);
	}
	Regexp__dispose_of(&mr);

}
#line 70 "inweb/Chapter 4/InC Support.w"
;
	if (form != NOT_A_NONTERMINAL) 
{
#line 122 "inweb/Chapter 4/InC Support.w"
	preform_nonterminal *pnt = CREATE(preform_nonterminal);
	pnt->where_defined = L;
	pnt->nt_name = Str__duplicate(pntname);
	pnt->unangled_name = Str__duplicate(pntname);
	pnt->as_C_identifier = Str__duplicate(pntname);
	pnt->next_pnt_alphabetically = NULL;
	
{
#line 136 "inweb/Chapter 4/InC Support.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, pntname, U"%<(%c*)%>")) pnt->unangled_name = Str__duplicate(mr.exp[0]);
	Regexp__dispose_of(&mr);

}
#line 128 "inweb/Chapter 4/InC Support.w"
;
	
{
#line 146 "inweb/Chapter 4/InC Support.w"
	Str__delete_first_character(pnt->as_C_identifier);
	LOOP_THROUGH_TEXT(pos, pnt->as_C_identifier) {
		if (Str__get(pos) == '-') Str__put(pos, '_');
		if (Str__get(pos) == '>') { Str__put(pos, 0); break; }
	}
	WRITE_TO(pnt->as_C_identifier, "_NTM");

}
#line 129 "inweb/Chapter 4/InC Support.w"
;
	
{
#line 161 "inweb/Chapter 4/InC Support.w"
	pnt->voracious = FALSE; if (form == A_VORACIOUS_NONTERMINAL) pnt->voracious = TRUE;
	pnt->as_function = TRUE; if (form == A_GRAMMAR_NONTERMINAL) pnt->as_function = FALSE;

	pnt->takes_pointer_result = FALSE;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, pnt->nt_name, U"<k-%c+")) pnt->takes_pointer_result = TRUE;
	if (Regexp__match(&mr, pnt->nt_name, U"<s-%c+")) pnt->takes_pointer_result = TRUE;
	Regexp__dispose_of(&mr);

	int min = 1, max = form;
	if (form < 0) max = INFINITE_WORD_COUNT;
	if (max == 0) min = 0;
	else if (max != INFINITE_WORD_COUNT) min = max;
	pnt->min_word_count = min;
	pnt->max_word_count = max;

}
#line 130 "inweb/Chapter 4/InC Support.w"
;

	
{
#line 178 "inweb/Chapter 4/InC Support.w"
	if (alphabetical_list_of_nonterminals == NULL) alphabetical_list_of_nonterminals = pnt;
	else {
		int placed = FALSE;
		preform_nonterminal *last = NULL;
		for (preform_nonterminal *seq = alphabetical_list_of_nonterminals; seq;
			seq = seq->next_pnt_alphabetically) {
			if (Str__cmp(pntname, seq->nt_name) < 0) {
				if (seq == alphabetical_list_of_nonterminals) {
					pnt->next_pnt_alphabetically = alphabetical_list_of_nonterminals;
					alphabetical_list_of_nonterminals = pnt;
				} else {
					last->next_pnt_alphabetically = pnt;
					pnt->next_pnt_alphabetically = seq;
				}
				placed = TRUE;
				break;
			}
			last = seq;
		}
		if (placed == FALSE) last->next_pnt_alphabetically = pnt;
	}

}
#line 132 "inweb/Chapter 4/InC Support.w"
;
	
{
#line 201 "inweb/Chapter 4/InC Support.w"
	L->preform_nonterminal_defined = pnt;
	if (Preform_theme) Tags__add_to_paragraph(L->owning_paragraph, Preform_theme, NULL);
	L->category = PREFORM_LCAT;
	L->text_operand = Str__duplicate(header);

}
#line 133 "inweb/Chapter 4/InC Support.w"
;

}
#line 71 "inweb/Chapter 4/InC Support.w"
;
	DISCARD_TEXT(pntname)
	DISCARD_TEXT(header)

}
#line 46 "inweb/Chapter 4/InC Support.w"
;
			
{
#line 305 "inweb/Chapter 4/InC Support.w"
	for (int i = 0, quoted = FALSE; i < Str__len(L->text); i++) {
		if (Str__get_at(L->text, i) == '"')
			if ((Str__get_at(L->text, i-1) != '\\') &&
				((Str__get_at(L->text, i-1) != '\'') || (Str__get_at(L->text, i+1) != '\'')))
					quoted = quoted?FALSE:TRUE;
		if ((fundamental_mode != WEAVE_MODE) && (quoted == FALSE) &&
			(Str__get_at(L->text, i) == 'I') && (Str__get_at(L->text, i+1) == '"'))
			
{
#line 316 "inweb/Chapter 4/InC Support.w"
	TEMPORARY_TEXT(lit)
	int i_was = i;
	int ended = FALSE;
	i += 2;
	while (Str__get_at(L->text, i)) {
		if (Str__get_at(L->text, i) == '"') { ended = TRUE; break; }
		PUT_TO(lit, Str__get_at(L->text, i++));
	}
	if (ended) 
{
#line 347 "inweb/Chapter 4/InC Support.w"
	text_literal *tl = CREATE(text_literal);
	tl->tl_identifier = Str__new();
	WRITE_TO(tl->tl_identifier, "TL_IS_%d", tl->allocation_id);
	tl->tl_content = Str__duplicate(lit);
	TEMPORARY_TEXT(before)
	TEMPORARY_TEXT(after)
	Str__copy(before, L->text);
	Str__truncate(before, i_was);
	Str__copy_tail(after, L->text, i+1);
	Str__clear(L->text);
	WRITE_TO(L->text, "%S%S", before, tl->tl_identifier);
	i = Str__len(L->text);
	WRITE_TO(L->text, "%S", after);
	DISCARD_TEXT(before)
	DISCARD_TEXT(after)

}
#line 324 "inweb/Chapter 4/InC Support.w"
;
	DISCARD_TEXT(lit)

}
#line 312 "inweb/Chapter 4/InC Support.w"
;
	}

}
#line 47 "inweb/Chapter 4/InC Support.w"

		}
}

#line 118 "inweb/Chapter 4/InC Support.w"

#line 287 "inweb/Chapter 4/InC Support.w"

#line 337 "inweb/Chapter 4/InC Support.w"

#line 368 "inweb/Chapter 4/InC Support.w"
int InCSupport__suppress_expansion(programming_language *self, text_stream *material) {
	if ((Str__get_at(material, 0) == '/') && (Str__get_at(material, 1) == '/'))
		return TRUE;
	return FALSE;
}

#line 392 "inweb/Chapter 4/InC Support.w"
int InCSupport__special_tangle_command(programming_language *me, OUTPUT_STREAM, text_stream *data) {
	if (Str__eq_wide_string(data, U"nonterminals")) {
		WRITE("register_tangled_nonterminals();\n");
		return TRUE;
	}
	if (Str__eq_wide_string(data, U"textliterals")) {
		WRITE("register_tangled_text_literals();\n");
		return TRUE;
	}
	return FALSE;
}

#line 416 "inweb/Chapter 4/InC Support.w"
void InCSupport__additional_predeclarations(programming_language *self, text_stream *OUT, web *W) {
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if (L->preform_nonterminal_defined) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			LanguageMethods__insert_line_marker(OUT, W->main_language, L);
			WRITE("nonterminal *%S = NULL;\n", pnt->as_C_identifier);
		}

	nonterminal_variable *ntv;
	LOOP_OVER(ntv, nonterminal_variable)
		WRITE("%S %S = %s;\n",
			ntv->ntv_type, ntv->ntv_identifier,
			(Str__eq_wide_string(ntv->ntv_type, U"int"))?"0":"NULL");

	WRITE("void register_tangled_nonterminals(void);\n");

	text_literal *tl;
	LOOP_OVER(tl, text_literal)
		WRITE("text_stream *%S = NULL;\n", tl->tl_identifier);

	WRITE("void register_tangled_text_literals(void);\n");
}

#line 445 "inweb/Chapter 4/InC Support.w"
void InCSupport__gnabehs(programming_language *self, text_stream *OUT, web *W) {
	WRITE("void register_tangled_nonterminals(void) {\n");
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, Tangler__primary_target(W))
		if (L->preform_nonterminal_defined) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			LanguageMethods__insert_line_marker(OUT, W->main_language, L);
			if (pnt->as_function) {
				WRITE("\tINTERNAL_NONTERMINAL(U\"%S\", %S, %d, %d);\n",
					pnt->nt_name, pnt->as_C_identifier,
					pnt->min_word_count, pnt->max_word_count);
				WRITE("\t%S->voracious = %d;\n",
					pnt->as_C_identifier, pnt->voracious);
			} else {
				WRITE("\tREGISTER_NONTERMINAL(U\"%S\", %S);\n",
					pnt->nt_name, pnt->as_C_identifier);
			}
		}
	WRITE("}\n");
	WRITE("void register_tangled_text_literals(void) {\n"); INDENT;
	text_literal *tl;
	LOOP_OVER(tl, text_literal)
		WRITE("%S = Str__literal(U\"%S\");\n", tl->tl_identifier, tl->tl_content);
	OUTDENT; WRITE("}\n");
}

#line 479 "inweb/Chapter 4/InC Support.w"
int InCSupport__will_insert_in_tangle(programming_language *self, source_line *L) {
	if (L->category == PREFORM_LCAT) return TRUE;
	return FALSE;
}

#line 500 "inweb/Chapter 4/InC Support.w"
void InCSupport__insert_in_tangle(programming_language *self, text_stream *OUT, source_line *L) {
	preform_nonterminal *pnt = L->preform_nonterminal_defined;
	if (pnt->as_function) {
		WRITE("int %SR(wording W, int *X, void **XP) {\n",
			pnt->as_C_identifier);
	} else {
		WRITE("int %SC(int *X, void **XP, int *R, void **RP, wording *FW, wording W) {\n",
			pnt->as_C_identifier);
		
{
#line 557 "inweb/Chapter 4/InC Support.w"
	int needs_collation = FALSE;
	for (source_line *AL = L->next_line;
		((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
		AL = AL->next_line)
			if (Str__len(AL->text_operand2) > 0)
				needs_collation = TRUE;
	if (needs_collation) 
{
#line 575 "inweb/Chapter 4/InC Support.w"
	WRITE("\tswitch(R[0]) {\n");
	int c = 0;
	for (source_line *AL = L->next_line;
		((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
		AL = AL->next_line, c++) {
		text_stream *formula = AL->text_operand2;
		if (Str__len(formula) > 0) {
			LanguageMethods__insert_line_marker(OUT, AL->owning_section->sect_language, AL);
			WRITE("\t\tcase %d: ", c);
			
{
#line 613 "inweb/Chapter 4/InC Support.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, formula, U"{ *(%c*?) *} *(%c*)")) {
		TEMPORARY_TEXT(rewritten)
		WRITE_TO(rewritten, "==");
		WRITE_TO(rewritten, "> { %S }", mr.exp[0]);
		InCSupport__tangle_line_inner(OUT, AL, pnt, rewritten);
		InCSupport__expand_formula(OUT, AL, pnt, mr.exp[1], TRUE);
		DISCARD_TEXT(rewritten)
	} else {
		if (!Regexp__match(&mr, formula, U"@<%c*")) {
			if (pnt->takes_pointer_result) WRITE("*XP = ");
			else WRITE("*X = ");
		}
		InCSupport__expand_formula(OUT, AL, pnt, formula, TRUE);
	}
	Regexp__dispose_of(&mr);

}
#line 584 "inweb/Chapter 4/InC Support.w"
;
			WRITE(";\n");
			WRITE("#pragma clang diagnostic push\n");
			WRITE("#pragma clang diagnostic ignored \"-Wunreachable-code\"\n");
			WRITE("break;\n");
			WRITE("#pragma clang diagnostic pop\n");
		}
	}
	WRITE("\t\tdefault: *X = R[0]; break;\n");
	WRITE("\t}\n");

}
#line 563 "inweb/Chapter 4/InC Support.w"

	else 
{
#line 572 "inweb/Chapter 4/InC Support.w"
	WRITE("\t*X = R[0];\n");

}
#line 564 "inweb/Chapter 4/InC Support.w"
;
	WRITE("\treturn TRUE;\n");

}
#line 508 "inweb/Chapter 4/InC Support.w"
;
		WRITE("}\n");
	}
}

#line 633 "inweb/Chapter 4/InC Support.w"
void InCSupport__expand_formula(text_stream *OUT, source_line *AL, preform_nonterminal *pnt,
	text_stream *formula, int full) {
	TEMPORARY_TEXT(expanded)
	for (int i=0; i < Str__len(formula); i++) {
		if ((Str__get_at(formula, i) == 'W') && (Str__get_at(formula, i+1) == 'R') &&
			(Str__get_at(formula, i+2) == '[') &&
			(Characters__isdigit(Str__get_at(formula, i+3))) && (Str__get_at(formula, i+4) == ']')) {
				if (pnt == NULL) {
					Main__error_in_web(TL_IS_2874, AL);
					if (AL == NULL) WRITE_TO(STDERR, "%S\n", formula);
				} else {
					WRITE_TO(expanded,
						"%S->range_result[%c]", pnt->as_C_identifier, Str__get_at(formula, i+3));
				}
				i += 4;
		} else {
			PUT_TO(expanded, Str__get_at(formula, i));
		}
	}
	if (full) Tangler__tangle_line(OUT, expanded, AL->owning_section, AL);
	else InCSupport__tangle_line_inner(OUT, AL, pnt, expanded);
	DISCARD_TEXT(expanded)
}

#line 661 "inweb/Chapter 4/InC Support.w"
int InCSupport__tangle_line(programming_language *self, text_stream *OUT, text_stream *original) {
	InCSupport__tangle_line_inner(OUT, NULL, NULL, original);
    return TRUE;
}

void InCSupport__tangle_line_inner(text_stream *OUT, source_line *AL, preform_nonterminal *pnt, text_stream *original) {
	int fcall_pos = -1;
	for (int i = 0; i < Str__len(original); i++) {
		
{
#line 703 "inweb/Chapter 4/InC Support.w"
	if ((i > 0) && (Str__get_at(original, i) == ':') && (Str__get_at(original, i+1) == ':') &&
		(Characters__isalpha(Str__get_at(original, i+2))) &&
		(Characters__isalnum(Str__get_at(original, i-1)))) {
		WRITE("__"); i++;
		continue;
	}

}
#line 669 "inweb/Chapter 4/InC Support.w"
;
		
{
#line 716 "inweb/Chapter 4/InC Support.w"
	if ((Str__get_at(original, i) == '=') &&
		(Str__get_at(original, i+1) == '=') &&
		(Str__get_at(original, i+2) == '>') &&
		(Str__get_at(original, i+3) == ' ') &&
		(Str__get_at(original, i+4) == '{')) {
		int clauses, err = FALSE;
		text_stream *clause[MAX_PREFORM_RESULT_CLAUSES];
		
{
#line 739 "inweb/Chapter 4/InC Support.w"
	clauses = 1;
	clause[0] = Str__new();
	int bl = 0;
	for (int j = i+5; j < Str__len(original); j++) {
		inchar32_t c = Str__get_at(original, j);
		if ((c == ',') && (bl == 0)) {
			if (clauses >= MAX_PREFORM_RESULT_CLAUSES) err = TRUE;
			else { clause[clauses] = Str__new(); clauses++; }
			continue;
		}
		if ((c == '}') && (bl == 0)) {
			i = j; break;
		}
		switch (c) {
			case '(': bl++; break;
			case ')': bl--; if (bl < 0) err = TRUE; break;
		}
		PUT_TO(clause[clauses-1], c);
	}
	if (bl != 0) err = TRUE;
	for (int c=0; c<clauses; c++) Str__trim_white_space(clause[c]);

}
#line 723 "inweb/Chapter 4/InC Support.w"
;
		TEMPORARY_TEXT(extra)
		if (clauses == 1) 
{
#line 766 "inweb/Chapter 4/InC Support.w"
	if (Str__eq(clause[0], TL_IS_2876)) {
		clause[1] = Str__new(); clauses = 2;
		WRITE_TO(extra, "return FAIL_NONTERMINAL;");
		Str__clear(clause[0]);
		WRITE_TO(clause[0], "-");
		WRITE_TO(clause[1], "-");
	} else if (Str__eq(clause[0], TL_IS_2877)) {
		clause[1] = Str__new(); clauses = 2;
		WRITE_TO(extra, "return FALSE;");
		Str__clear(clause[0]);
		WRITE_TO(clause[0], "-");
		WRITE_TO(clause[1], "-");
	} else if (Str__eq(clause[0], TL_IS_2878)) {
		clause[1] = Str__new(); clauses = 2;
		WRITE_TO(extra, "return FALSE;");
		Str__clear(clause[0]);
		WRITE_TO(clause[0], "-");
		WRITE_TO(clause[1], "-");
	} else if (Str__prefix_eq(clause[0], TL_IS_2879, 8)) {
		clause[1] = Str__new(); clauses = 2;
		WRITE_TO(extra, "return FAIL_NONTERMINAL + ");
		Str__substr(extra, Str__at(clause[0], 8), Str__end(clause[0]));
		WRITE_TO(extra, ";");
		Str__clear(clause[0]);
		WRITE_TO(clause[0], "0");
		WRITE_TO(clause[1], "NULL");
	} else if (Str__prefix_eq(clause[0], TL_IS_2880, 5)) {
		clause[1] = Str__new(); clauses = 2;
		TEMPORARY_TEXT(from)
		Str__substr(from, Str__at(clause[0], 5), Str__end(clause[0]));
		Str__clear(clause[0]);
		WRITE_TO(clause[0], "R[%S]", from);
		WRITE_TO(clause[1], "RP[%S]", from);
		DISCARD_TEXT(from)
	} else if (Str__eq(clause[0], TL_IS_2881)) {
		clause[1] = Str__new(); clauses = 2;
		Str__clear(clause[0]);
		WRITE_TO(clause[0], "0");
		WRITE_TO(clause[1], "NULL");
		WRITE_TO(extra, "return preform_lookahead_mode;");
	}

}
#line 725 "inweb/Chapter 4/InC Support.w"
;
		if (clauses < 2) err = TRUE;
		if (err == FALSE) 
{
#line 816 "inweb/Chapter 4/InC Support.w"
	for (int c=0; c<clauses; c++) {
		if (Str__ne(clause[c], TL_IS_2882)) {
			switch (c) {
				case 0: WRITE("*X = ");
					InCSupport__expand_formula(OUT, AL, pnt, clause[c], FALSE);
					WRITE(";"); break;
				case 1: WRITE("*XP = ");
					InCSupport__expand_formula(OUT, AL, pnt, clause[c], FALSE);
					WRITE(";"); break;
				default: {
					match_results mr = Regexp__create_mr();
					if (Regexp__match(&mr, clause[c], U"<<(%P+)>> = *(%c*)")) {
						text_stream *putative = mr.exp[0];
						text_stream *pv_identifier =
							InCSupport__nonterminal_variable_identifier(putative);
						if (pv_identifier) {
							WRITE("%S = ", pv_identifier);
							InCSupport__expand_formula(OUT, AL, pnt, mr.exp[1], FALSE);
							WRITE(";");
						} else err = TRUE;
					} else err = TRUE;
				}
			}
		}
	}
	if (Str__ne(extra, TL_IS_2883)) {
		InCSupport__expand_formula(OUT, AL, pnt, extra, FALSE);
	}

}
#line 727 "inweb/Chapter 4/InC Support.w"
;
		if (err) {
			Main__error_in_web(TL_IS_2875, AL);
			if (AL == NULL) WRITE_TO(STDERR, "%S\n", original);
		}
		continue;
	}

}
#line 670 "inweb/Chapter 4/InC Support.w"
;
		if (Str__get_at(original, i) == '<') {
			if (Str__get_at(original, i+1) == '<') {
				
{
#line 851 "inweb/Chapter 4/InC Support.w"
	match_results mr = Regexp__create_mr();
	TEMPORARY_TEXT(check_this)
	Str__substr(check_this, Str__at(original, i), Str__end(original));
	if (Regexp__match(&mr, check_this, U"<<(%P+)>>%c*")) {
		text_stream *putative = mr.exp[0];
		text_stream *pv_identifier = InCSupport__nonterminal_variable_identifier(putative);
		if (pv_identifier) {
			WRITE("%S", pv_identifier);
			i += Str__len(putative) + 3;
			DISCARD_TEXT(check_this)
			continue;
		}
	}
	DISCARD_TEXT(check_this)
	Regexp__dispose_of(&mr);

}
#line 673 "inweb/Chapter 4/InC Support.w"
;
			} else {
				
{
#line 883 "inweb/Chapter 4/InC Support.w"
	match_results mr = Regexp__create_mr();
	TEMPORARY_TEXT(check_this)
	Str__substr(check_this, Str__at(original, i), Str__end(original));
	if (Regexp__match(&mr, check_this, U"(<%p+>)%c*")) {
		text_stream *putative = mr.exp[0];
		preform_nonterminal *pnt = InCSupport__nonterminal_by_name(putative);
		if (pnt) {
			i += Str__len(putative) - 1;
			if (Str__get_at(original, i+1) == '(') {
				int arity = 1;
				for (int j = i+2, bl = 1; ((Str__get_at(original, j)) && (bl > 0)); j++) {
					if (Str__get_at(original, j) == '(') bl++;
					if (Str__get_at(original, j) == ')') { bl--; if (bl == 0) fcall_pos = j; }
					if ((Str__get_at(original, j) == ',') && (bl == 1)) arity++;
				}
				WRITE("Preform__parse_nt_against_word_range(");
			}
			WRITE("%S", pnt->as_C_identifier);
			if (fcall_pos >= 0) {
				WRITE(", "); i++;
			}
			DISCARD_TEXT(check_this)
			continue;
		}
	}
	DISCARD_TEXT(check_this)
	Regexp__dispose_of(&mr);

}
#line 675 "inweb/Chapter 4/InC Support.w"
;
			}
		}
		if (i == fcall_pos) {
			fcall_pos = -1;
			WRITE(", NULL, NULL");
		}
		PUT(Str__get_at(original, i));
	}
}

#line 917 "inweb/Chapter 4/InC Support.w"
preform_nonterminal *InCSupport__nonterminal_by_name(text_stream *name) {
	preform_nonterminal *pnt;
	LOOP_OVER(pnt, preform_nonterminal)
		if (Str__eq(name, pnt->nt_name))
			return pnt;
	return NULL;
}

#line 931 "inweb/Chapter 4/InC Support.w"
text_stream *InCSupport__nonterminal_variable_identifier(text_stream *name) {
	if (Str__eq_wide_string(name, U"r")) return TL_IS_2884;
	if (Str__eq_wide_string(name, U"rp")) return TL_IS_2885;
	nonterminal_variable *ntv;
	LOOP_OVER(ntv, nonterminal_variable)
		if (Str__eq(ntv->ntv_name, name))
			return ntv->ntv_identifier;
	return NULL;
}

#line 952 "inweb/Chapter 4/InC Support.w"
void InCSupport__additional_tangling(programming_language *self, web *W, tangle_target *target) {
	if (NUMBER_CREATED(preform_nonterminal) > 0) {
		pathname *P = Reader__tangled_folder(W);
		filename *Syntax = Filenames__in(P, TL_IS_2886);

		text_stream TO_struct;
		text_stream *OUT = &TO_struct;
		if (STREAM_OPEN_TO_FILE(OUT, Syntax, ISO_ENC) == FALSE)
			Errors__fatal_with_file("unable to write Preform file", Syntax);

		WRITE_TO(STDOUT, "Writing Preform syntax to: %/f\n", Syntax);

		WRITE("[Preform syntax generated by inweb: do not edit.]\n\n");

		if (Bibliographic__data_exists(W->md, TL_IS_2887))
			WRITE("language %S\n", Bibliographic__get_datum(W->md, TL_IS_2888));

		
{
#line 987 "inweb/Chapter 4/InC Support.w"
	chapter *C;
	section *S;
	LOOP_WITHIN_TANGLE(C, S, target)
		if (L->category == PREFORM_LCAT) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			if (pnt->as_function)
				WRITE("\n%S internal\n", pnt->nt_name);
			else
				WRITE("\n%S ::=\n", L->text_operand);
			for (source_line *AL = L->next_line;
				((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
				AL = AL->next_line) {
				WRITE("%S", AL->text_operand);
				match_results mr = Regexp__create_mr();
				if (Regexp__match(&mr, AL->text_operand2, U"%c+Issue (%c+) problem%c+"))
					WRITE("[issues %S]", mr.exp[0]);
				WRITE("\n");
				Regexp__dispose_of(&mr);
			}
		}

}
#line 969 "inweb/Chapter 4/InC Support.w"
;
		STREAM_CLOSE(OUT);
	}
}

#line 1015 "inweb/Chapter 4/InC Support.w"
void InCSupport__weave_grammar_index(OUTPUT_STREAM) {
	WRITE("\\raggedright\\tolerance=10000");
	preform_nonterminal *pnt;
	for (pnt = alphabetical_list_of_nonterminals; pnt;
		pnt = pnt->next_pnt_alphabetically) {
		WRITE("\\line{\\nonterminal{%S}%s"
			"\\leaders\\hbox to 1em{\\hss.\\hss}\\hfill {\\xreffont %S}}\n",
			pnt->unangled_name,
			(pnt->as_function)?" (internal)":"",
			pnt->where_defined->owning_section->md->sect_range);
		int said_something = FALSE;
		
{
#line 1062 "inweb/Chapter 4/InC Support.w"
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	hash_table_entry *hte = Analyser__find_hash_entry_for_section(
		pnt->where_defined->owning_section, pnt->unangled_name, FALSE);
	hash_table_entry_usage *hteu;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if (hteu->form_of_usage & PREFORM_IN_GRAMMAR_USAGE)
			hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
	int use_count = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag)
			use_count++;
	if (use_count > 0) {
		said_something = TRUE;
		WRITE("\\par\\hangindent=3em{\\it used by other nonterminals in} ");
		int c = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				if (c++ > 0) WRITE(", ");
				WRITE("{\\xreffont %S}", S->md->sect_range);
			}
		WRITE("\n\n");
	}

}
#line 1026 "inweb/Chapter 4/InC Support.w"
;
		
{
#line 1037 "inweb/Chapter 4/InC Support.w"
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	hash_table_entry *hte = Analyser__find_hash_entry_for_section(
		pnt->where_defined->owning_section, pnt->unangled_name, FALSE);
	hash_table_entry_usage *hteu;
	LOOP_OVER_LINKED_LIST(hteu, hash_table_entry_usage, hte->usages)
		if (hteu->form_of_usage & PREFORM_IN_CODE_USAGE)
			hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
	int use_count = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag)
			use_count++;
	if (use_count > 0) {
		said_something = TRUE;
		WRITE("\\par\\hangindent=3em{\\it called from} ");
		int c = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				if (c++ > 0) WRITE(", ");
				WRITE("{\\xreffont %S}", S->md->sect_range);
			}
		WRITE("\n\n");
	}

}
#line 1027 "inweb/Chapter 4/InC Support.w"
;
		if (said_something == FALSE)
			WRITE("\\par\\hangindent=3em{\\it unused}\n\n");
	}
	WRITE("\\penalty-1000\n");
	WRITE("\\smallbreak\n");
	WRITE("\\hrule\\smallbreak\n");
}

#line 1091 "inweb/Chapter 4/InC Support.w"
int skipping_internal = FALSE, preform_production_count = 0;

int InCSupport__skip_in_weaving(programming_language *self, weave_order *wv, source_line *L) {
	if ((Preform_theme) && (wv->theme_match == Preform_theme)) {
		match_results mr = Regexp__create_mr();
		if (Regexp__match(&mr, L->text, U"}%c*")) {
			skipping_internal = FALSE; Regexp__dispose_of(&mr); return TRUE; }
		if (skipping_internal) { Regexp__dispose_of(&mr); return TRUE; }
		if (Regexp__match(&mr, L->text, U"<%c*?> internal%c*")) skipping_internal = TRUE;
		Regexp__dispose_of(&mr);
	}
	return FALSE;
}

#line 1108 "inweb/Chapter 4/InC Support.w"
int InCSupport__weave_code_line(programming_language *self, text_stream *OUT,
	weave_order *wv, web *W, chapter *C, section *S, source_line *L,
	text_stream *matter, text_stream *concluding_comment) {
	if ((Preform_theme) && (wv->theme_match == Preform_theme))
		return Formats__preform_document(OUT, wv, W, C, S, L,
			matter, concluding_comment);
	return FALSE;
}

#line 1122 "inweb/Chapter 4/InC Support.w"
void InCSupport__new_tag_declared(programming_language *self, theme_tag *tag) {
	if (Str__eq_wide_string(tag->tag_name, U"Preform")) Preform_theme = tag;
}

#line 1129 "inweb/Chapter 4/InC Support.w"
void InCSupport__analyse_code(programming_language *self, web *W) {
	preform_nonterminal *pnt;
	LOOP_OVER(pnt, preform_nonterminal)
		Analyser__find_hash_entry_for_section(pnt->where_defined->owning_section,
			pnt->unangled_name, TRUE);
}

int InCSupport__share_element(programming_language *self, text_stream *elname) {
	if (Str__eq_wide_string(elname, U"word_ref1")) return TRUE;
	if (Str__eq_wide_string(elname, U"word_ref2")) return TRUE;
	if (Str__eq_wide_string(elname, U"next")) return TRUE;
	if (Str__eq_wide_string(elname, U"down")) return TRUE;
	if (Str__eq_wide_string(elname, U"allocation_id")) return TRUE;
	if (Str__eq_wide_string(elname, U"method_set")) return TRUE;
	return FALSE;
}

#line 10 "inweb/Chapter 5/Weave Tree.w"

#line 15 "inweb/Chapter 5/Weave Tree.w"

#line 19 "inweb/Chapter 5/Weave Tree.w"

#line 24 "inweb/Chapter 5/Weave Tree.w"

#line 29 "inweb/Chapter 5/Weave Tree.w"

#line 34 "inweb/Chapter 5/Weave Tree.w"

#line 39 "inweb/Chapter 5/Weave Tree.w"

#line 44 "inweb/Chapter 5/Weave Tree.w"

#line 49 "inweb/Chapter 5/Weave Tree.w"

#line 54 "inweb/Chapter 5/Weave Tree.w"

#line 58 "inweb/Chapter 5/Weave Tree.w"

#line 62 "inweb/Chapter 5/Weave Tree.w"

#line 66 "inweb/Chapter 5/Weave Tree.w"

#line 72 "inweb/Chapter 5/Weave Tree.w"

#line 76 "inweb/Chapter 5/Weave Tree.w"

#line 83 "inweb/Chapter 5/Weave Tree.w"

#line 88 "inweb/Chapter 5/Weave Tree.w"

#line 94 "inweb/Chapter 5/Weave Tree.w"

#line 101 "inweb/Chapter 5/Weave Tree.w"

#line 107 "inweb/Chapter 5/Weave Tree.w"

#line 115 "inweb/Chapter 5/Weave Tree.w"

#line 123 "inweb/Chapter 5/Weave Tree.w"

#line 129 "inweb/Chapter 5/Weave Tree.w"

#line 134 "inweb/Chapter 5/Weave Tree.w"

#line 139 "inweb/Chapter 5/Weave Tree.w"

#line 144 "inweb/Chapter 5/Weave Tree.w"

#line 148 "inweb/Chapter 5/Weave Tree.w"

#line 154 "inweb/Chapter 5/Weave Tree.w"

#line 160 "inweb/Chapter 5/Weave Tree.w"

#line 166 "inweb/Chapter 5/Weave Tree.w"

#line 171 "inweb/Chapter 5/Weave Tree.w"

#line 178 "inweb/Chapter 5/Weave Tree.w"

#line 182 "inweb/Chapter 5/Weave Tree.w"

#line 187 "inweb/Chapter 5/Weave Tree.w"

#line 191 "inweb/Chapter 5/Weave Tree.w"

#line 197 "inweb/Chapter 5/Weave Tree.w"

#line 203 "inweb/Chapter 5/Weave Tree.w"

#line 210 "inweb/Chapter 5/Weave Tree.w"

#line 215 "inweb/Chapter 5/Weave Tree.w"

#line 220 "inweb/Chapter 5/Weave Tree.w"

#line 225 "inweb/Chapter 5/Weave Tree.w"

#line 230 "inweb/Chapter 5/Weave Tree.w"

#line 236 "inweb/Chapter 5/Weave Tree.w"

#line 240 "inweb/Chapter 5/Weave Tree.w"

#line 246 "inweb/Chapter 5/Weave Tree.w"

#line 251 "inweb/Chapter 5/Weave Tree.w"

#line 253 "inweb/Chapter 5/Weave Tree.w"
tree_type *weave_tree_type = NULL;
tree_node_type *weave_document_node_type = NULL;
tree_node_type *weave_head_node_type = NULL;
tree_node_type *weave_body_node_type = NULL;
tree_node_type *weave_tail_node_type = NULL;
tree_node_type *weave_chapter_header_node_type = NULL;
tree_node_type *weave_chapter_footer_node_type = NULL;
tree_node_type *weave_section_header_node_type = NULL;
tree_node_type *weave_section_footer_node_type = NULL;
tree_node_type *weave_section_purpose_node_type = NULL;
tree_node_type *weave_verbatim_node_type = NULL;
tree_node_type *weave_subheading_node_type = NULL;
tree_node_type *weave_bar_node_type = NULL;
tree_node_type *weave_pagebreak_node_type = NULL;
tree_node_type *weave_linebreak_node_type = NULL;
tree_node_type *weave_paragraph_heading_node_type = NULL;
tree_node_type *weave_endnote_node_type = NULL;
tree_node_type *weave_figure_node_type = NULL;
tree_node_type *weave_extract_node_type = NULL;
tree_node_type *weave_audio_node_type = NULL;
tree_node_type *weave_video_node_type = NULL;
tree_node_type *weave_download_node_type = NULL;
tree_node_type *weave_material_node_type = NULL;
tree_node_type *weave_embed_node_type = NULL;
tree_node_type *weave_pmac_node_type = NULL;
tree_node_type *weave_vskip_node_type = NULL;
tree_node_type *weave_chapter_node_type = NULL;
tree_node_type *weave_section_node_type = NULL;
tree_node_type *weave_code_line_node_type = NULL;
tree_node_type *weave_function_usage_node_type = NULL;
tree_node_type *weave_commentary_node_type = NULL;
tree_node_type *weave_carousel_slide_node_type = NULL;
tree_node_type *weave_toc_node_type = NULL;
tree_node_type *weave_toc_line_node_type = NULL;
tree_node_type *weave_chapter_title_page_node_type = NULL;
tree_node_type *weave_defn_node_type = NULL;
tree_node_type *weave_source_code_node_type = NULL;
tree_node_type *weave_url_node_type = NULL;
tree_node_type *weave_footnote_cue_node_type = NULL;
tree_node_type *weave_begin_footnote_text_node_type = NULL;
tree_node_type *weave_display_line_node_type = NULL;
tree_node_type *weave_function_defn_node_type = NULL;
tree_node_type *weave_item_node_type = NULL;
tree_node_type *weave_grammar_index_node_type = NULL;
tree_node_type *weave_inline_node_type = NULL;
tree_node_type *weave_locale_node_type = NULL;
tree_node_type *weave_maths_node_type = NULL;

heterogeneous_tree *WeaveTree__new_tree(weave_order *wv) {
	if (weave_tree_type == NULL) {
		weave_tree_type = Trees__new_type(TL_IS_2889, NULL);
		weave_document_node_type =
			Trees__new_node_type(TL_IS_2890, weave_document_node_CLASS, NULL);
		weave_head_node_type =
			Trees__new_node_type(TL_IS_2891, weave_head_node_CLASS, NULL);
		weave_body_node_type =
			Trees__new_node_type(TL_IS_2892, weave_body_node_CLASS, NULL);
		weave_tail_node_type =
			Trees__new_node_type(TL_IS_2893, weave_tail_node_CLASS, NULL);
		weave_chapter_footer_node_type =
			Trees__new_node_type(TL_IS_2894, weave_chapter_footer_node_CLASS, NULL);
		weave_chapter_header_node_type =
			Trees__new_node_type(TL_IS_2895, weave_chapter_header_node_CLASS, NULL);
		weave_section_footer_node_type =
			Trees__new_node_type(TL_IS_2896, weave_section_footer_node_CLASS, NULL);
		weave_section_header_node_type =
			Trees__new_node_type(TL_IS_2897, weave_section_header_node_CLASS, NULL);
		weave_section_purpose_node_type =
			Trees__new_node_type(TL_IS_2898, weave_section_purpose_node_CLASS, NULL);

		weave_subheading_node_type =
			Trees__new_node_type(TL_IS_2899, weave_subheading_node_CLASS, NULL);
		weave_bar_node_type =
			Trees__new_node_type(TL_IS_2900, weave_bar_node_CLASS, NULL);
		weave_pagebreak_node_type =
			Trees__new_node_type(TL_IS_2901, weave_pagebreak_node_CLASS, NULL);
		weave_linebreak_node_type =
			Trees__new_node_type(TL_IS_2902, weave_linebreak_node_CLASS, NULL);
		weave_paragraph_heading_node_type =
			Trees__new_node_type(TL_IS_2903, weave_paragraph_heading_node_CLASS, NULL);
		weave_endnote_node_type =
			Trees__new_node_type(TL_IS_2904, weave_endnote_node_CLASS, NULL);
		weave_figure_node_type =
			Trees__new_node_type(TL_IS_2905, weave_figure_node_CLASS, NULL);
		weave_extract_node_type =
			Trees__new_node_type(TL_IS_2906, weave_extract_node_CLASS, NULL);
		weave_audio_node_type =
			Trees__new_node_type(TL_IS_2907, weave_audio_node_CLASS, NULL);
		weave_video_node_type =
			Trees__new_node_type(TL_IS_2908, weave_video_node_CLASS, NULL);
		weave_download_node_type =
			Trees__new_node_type(TL_IS_2909, weave_download_node_CLASS, NULL);
		weave_material_node_type =
			Trees__new_node_type(TL_IS_2910, weave_material_node_CLASS, NULL);
		weave_embed_node_type =
			Trees__new_node_type(TL_IS_2911, weave_embed_node_CLASS, NULL);
		weave_pmac_node_type =
			Trees__new_node_type(TL_IS_2912, weave_pmac_node_CLASS, NULL);
		weave_vskip_node_type =
			Trees__new_node_type(TL_IS_2913, weave_vskip_node_CLASS, NULL);
		weave_chapter_node_type =
			Trees__new_node_type(TL_IS_2914, weave_chapter_node_CLASS, NULL);
		weave_section_node_type =
			Trees__new_node_type(TL_IS_2915, weave_section_node_CLASS, NULL);
		weave_code_line_node_type =
			Trees__new_node_type(TL_IS_2916, weave_code_line_node_CLASS, NULL);
		weave_function_usage_node_type =
			Trees__new_node_type(TL_IS_2917, weave_function_usage_node_CLASS, NULL);
		weave_commentary_node_type =
			Trees__new_node_type(TL_IS_2918, weave_commentary_node_CLASS, NULL);
		weave_carousel_slide_node_type =
			Trees__new_node_type(TL_IS_2919, weave_carousel_slide_node_CLASS, NULL);
		weave_toc_node_type =
			Trees__new_node_type(TL_IS_2920, weave_toc_node_CLASS, NULL);
		weave_toc_line_node_type =
			Trees__new_node_type(TL_IS_2921, weave_toc_line_node_CLASS, NULL);
		weave_chapter_title_page_node_type =
			Trees__new_node_type(TL_IS_2922, weave_chapter_title_page_node_CLASS, NULL);
		weave_defn_node_type =
			Trees__new_node_type(TL_IS_2923, weave_defn_node_CLASS, NULL);
		weave_source_code_node_type =
			Trees__new_node_type(TL_IS_2924, weave_source_code_node_CLASS, NULL);
		weave_url_node_type =
			Trees__new_node_type(TL_IS_2925, weave_url_node_CLASS, NULL);
		weave_footnote_cue_node_type =
			Trees__new_node_type(TL_IS_2926, weave_footnote_cue_node_CLASS, NULL);
		weave_begin_footnote_text_node_type =
			Trees__new_node_type(TL_IS_2927, weave_begin_footnote_text_node_CLASS, NULL);
		weave_display_line_node_type =
			Trees__new_node_type(TL_IS_2928, weave_display_line_node_CLASS, NULL);
		weave_function_defn_node_type =
			Trees__new_node_type(TL_IS_2929, weave_function_defn_node_CLASS, NULL);
		weave_item_node_type =
			Trees__new_node_type(TL_IS_2930, weave_item_node_CLASS, NULL);
		weave_grammar_index_node_type =
			Trees__new_node_type(TL_IS_2931, weave_grammar_index_node_CLASS, NULL);
		weave_inline_node_type =
			Trees__new_node_type(TL_IS_2932, weave_inline_node_CLASS, NULL);
		weave_locale_node_type =
			Trees__new_node_type(TL_IS_2933, weave_locale_node_CLASS, NULL);
		weave_maths_node_type =
			Trees__new_node_type(TL_IS_2934, weave_maths_node_CLASS, NULL);

		weave_verbatim_node_type =
			Trees__new_node_type(TL_IS_2935, weave_verbatim_node_CLASS, NULL);
	}
	heterogeneous_tree *tree = Trees__new(weave_tree_type);
	Trees__make_root(tree, WeaveTree__document(tree, wv));
	return tree;
}

tree_node *WeaveTree__document(heterogeneous_tree *tree, weave_order *wv) {
	weave_document_node *doc = CREATE(weave_document_node);
	doc->wv = wv;
	return Trees__new_node(tree, weave_document_node_type,
		STORE_POINTER_weave_document_node(doc));
}

tree_node *WeaveTree__head(heterogeneous_tree *tree, text_stream *banner) {
	weave_head_node *head = CREATE(weave_head_node);
	head->banner = Str__duplicate(banner);
	return Trees__new_node(tree, weave_head_node_type,
		STORE_POINTER_weave_head_node(head));
}

tree_node *WeaveTree__body(heterogeneous_tree *tree) {
	weave_body_node *body = CREATE(weave_body_node);
	return Trees__new_node(tree, weave_body_node_type,
		STORE_POINTER_weave_body_node(body));
}

tree_node *WeaveTree__tail(heterogeneous_tree *tree, text_stream *rennab) {
	weave_tail_node *tail = CREATE(weave_tail_node);
	tail->rennab = Str__duplicate(rennab);
	return Trees__new_node(tree, weave_tail_node_type,
		STORE_POINTER_weave_tail_node(tail));
}

tree_node *WeaveTree__verbatim(heterogeneous_tree *tree, text_stream *content) {
	weave_verbatim_node *C = CREATE(weave_verbatim_node);
	C->content = Str__duplicate(content);
	return Trees__new_node(tree, weave_verbatim_node_type,
		STORE_POINTER_weave_verbatim_node(C));
}

tree_node *WeaveTree__section_header(heterogeneous_tree *tree, section *S) {
	weave_section_header_node *C = CREATE(weave_section_header_node);
	C->sect = S;
	return Trees__new_node(tree, weave_section_header_node_type,
		STORE_POINTER_weave_section_header_node(C));
}

tree_node *WeaveTree__section_footer(heterogeneous_tree *tree, section *S) {
	weave_section_footer_node *C = CREATE(weave_section_footer_node);
	C->sect = S;
	return Trees__new_node(tree, weave_section_footer_node_type,
		STORE_POINTER_weave_section_footer_node(C));
}

tree_node *WeaveTree__chapter(heterogeneous_tree *tree, chapter *Ch) {
	weave_chapter_node *C = CREATE(weave_chapter_node);
	C->chap = Ch;
	return Trees__new_node(tree, weave_chapter_node_type, STORE_POINTER_weave_chapter_node(C));
}

tree_node *WeaveTree__chapter_header(heterogeneous_tree *tree, chapter *Ch) {
	weave_chapter_header_node *C = CREATE(weave_chapter_header_node);
	C->chap = Ch;
	return Trees__new_node(tree, weave_chapter_header_node_type,
		STORE_POINTER_weave_chapter_header_node(C));
}

tree_node *WeaveTree__chapter_footer(heterogeneous_tree *tree, chapter *Ch) {
	weave_chapter_footer_node *C = CREATE(weave_chapter_footer_node);
	C->chap = Ch;
	return Trees__new_node(tree, weave_chapter_footer_node_type,
		STORE_POINTER_weave_chapter_footer_node(C));
}

tree_node *WeaveTree__purpose(heterogeneous_tree *tree, text_stream *P) {
	weave_section_purpose_node *C = CREATE(weave_section_purpose_node);
	C->purpose = Str__duplicate(P);
	return Trees__new_node(tree, weave_section_purpose_node_type,
		STORE_POINTER_weave_section_purpose_node(C));
}

tree_node *WeaveTree__subheading(heterogeneous_tree *tree, text_stream *P) {
	weave_subheading_node *C = CREATE(weave_subheading_node);
	C->text = Str__duplicate(P);
	return Trees__new_node(tree, weave_subheading_node_type,
		STORE_POINTER_weave_subheading_node(C));
}

tree_node *WeaveTree__pagebreak(heterogeneous_tree *tree) {
	weave_pagebreak_node *C = CREATE(weave_pagebreak_node);
	return Trees__new_node(tree, weave_pagebreak_node_type,
		STORE_POINTER_weave_pagebreak_node(C));
}

tree_node *WeaveTree__linebreak(heterogeneous_tree *tree) {
	weave_linebreak_node *C = CREATE(weave_linebreak_node);
	return Trees__new_node(tree, weave_linebreak_node_type,
		STORE_POINTER_weave_linebreak_node(C));
}

tree_node *WeaveTree__bar(heterogeneous_tree *tree) {
	weave_bar_node *C = CREATE(weave_bar_node);
	return Trees__new_node(tree, weave_bar_node_type,
		STORE_POINTER_weave_bar_node(C));
}

tree_node *WeaveTree__paragraph_heading(heterogeneous_tree *tree, paragraph *P, int no_skip) {
	weave_paragraph_heading_node *C = CREATE(weave_paragraph_heading_node);
	C->para = P;
	C->no_skip = no_skip;
	return Trees__new_node(tree, weave_paragraph_heading_node_type,
		STORE_POINTER_weave_paragraph_heading_node(C));
}

tree_node *WeaveTree__endnote(heterogeneous_tree *tree) {
	weave_endnote_node *C = CREATE(weave_endnote_node);
	return Trees__new_node(tree, weave_endnote_node_type,
		STORE_POINTER_weave_endnote_node(C));
}

tree_node *WeaveTree__figure(heterogeneous_tree *tree,
	text_stream *figname, int w, int h) {
	weave_figure_node *C = CREATE(weave_figure_node);
	C->figname = Str__duplicate(figname);
	C->w = w;
	C->h = h;
	return Trees__new_node(tree, weave_figure_node_type,
		STORE_POINTER_weave_figure_node(C));
}

tree_node *WeaveTree__raw_extract(heterogeneous_tree *tree,
	text_stream *extract) {
	weave_extract_node *C = CREATE(weave_extract_node);
	C->extract = Str__duplicate(extract);
	return Trees__new_node(tree, weave_extract_node_type,
		STORE_POINTER_weave_extract_node(C));
}

tree_node *WeaveTree__audio(heterogeneous_tree *tree,
	text_stream *audio_name, int w) {
	weave_audio_node *C = CREATE(weave_audio_node);
	C->audio_name = Str__duplicate(audio_name);
	C->w = w;
	return Trees__new_node(tree, weave_audio_node_type,
		STORE_POINTER_weave_audio_node(C));
}

tree_node *WeaveTree__video(heterogeneous_tree *tree,
	text_stream *video_name, int w, int h) {
	weave_video_node *C = CREATE(weave_video_node);
	C->video_name = Str__duplicate(video_name);
	C->w = w;
	return Trees__new_node(tree, weave_video_node_type,
		STORE_POINTER_weave_video_node(C));
}

tree_node *WeaveTree__download(heterogeneous_tree *tree,
	text_stream *download_name, text_stream *filetype) {
	weave_download_node *C = CREATE(weave_download_node);
	C->download_name = Str__duplicate(download_name);
	C->filetype = Str__duplicate(filetype);
	return Trees__new_node(tree, weave_download_node_type,
		STORE_POINTER_weave_download_node(C));
}

tree_node *WeaveTree__material(heterogeneous_tree *tree, int material_type, int plainly,
	programming_language *styling, text_stream *endnote) {
	weave_material_node *C = CREATE(weave_material_node);
	C->material_type = material_type;
	C->plainly = plainly;
	C->styling = styling;
	C->endnote = Str__duplicate(endnote);
	return Trees__new_node(tree, weave_material_node_type, STORE_POINTER_weave_material_node(C));
}

tree_node *WeaveTree__embed(heterogeneous_tree *tree,
	text_stream *service, text_stream *ID, int w, int h) {
	weave_embed_node *C = CREATE(weave_embed_node);
	C->service = Str__duplicate(service);
	C->ID = Str__duplicate(ID);
	C->w = w;
	C->h = h;
	return Trees__new_node(tree, weave_embed_node_type, STORE_POINTER_weave_embed_node(C));
}

#line 588 "inweb/Chapter 5/Weave Tree.w"
tree_node *WeaveTree__pmac(heterogeneous_tree *tree, para_macro *pmac, int defn) {
	weave_pmac_node *C = CREATE(weave_pmac_node);
	C->pmac = pmac;
	C->defn = defn;
	return Trees__new_node(tree, weave_pmac_node_type, STORE_POINTER_weave_pmac_node(C));
}

#line 600 "inweb/Chapter 5/Weave Tree.w"
tree_node *WeaveTree__vskip(heterogeneous_tree *tree, int in_comment) {
	weave_vskip_node *C = CREATE(weave_vskip_node);
	C->in_comment = in_comment;
	return Trees__new_node(tree, weave_vskip_node_type, STORE_POINTER_weave_vskip_node(C));
}

tree_node *WeaveTree__section(heterogeneous_tree *tree, section *sect) {
	weave_section_node *C = CREATE(weave_section_node);
	C->sect = sect;
	return Trees__new_node(tree, weave_section_node_type, STORE_POINTER_weave_section_node(C));
}

tree_node *WeaveTree__code_line(heterogeneous_tree *tree) {
	weave_code_line_node *C = CREATE(weave_code_line_node);
	return Trees__new_node(tree, weave_code_line_node_type, STORE_POINTER_weave_code_line_node(C));
}

tree_node *WeaveTree__function_usage(heterogeneous_tree *tree,
	text_stream *url, language_function *fn) {
	weave_function_usage_node *C = CREATE(weave_function_usage_node);
	C->url = Str__duplicate(url);
	C->fn = fn;
	return Trees__new_node(tree, weave_function_usage_node_type, STORE_POINTER_weave_function_usage_node(C));
}

tree_node *WeaveTree__commentary(heterogeneous_tree *tree, text_stream *text, int in_code) {
	weave_commentary_node *C = CREATE(weave_commentary_node);
	C->text = Str__duplicate(text);
	C->in_code = in_code;
	return Trees__new_node(tree, weave_commentary_node_type, STORE_POINTER_weave_commentary_node(C));
}

tree_node *WeaveTree__carousel_slide(heterogeneous_tree *tree, text_stream *caption, int c) {
	weave_carousel_slide_node *C = CREATE(weave_carousel_slide_node);
	C->caption = Str__duplicate(caption);
	C->caption_command = c;
	return Trees__new_node(tree, weave_carousel_slide_node_type, STORE_POINTER_weave_carousel_slide_node(C));
}

tree_node *WeaveTree__table_of_contents(heterogeneous_tree *tree, text_stream *text1) {
	weave_toc_node *C = CREATE(weave_toc_node);
	C->text1 = Str__duplicate(text1);
	return Trees__new_node(tree, weave_toc_node_type, STORE_POINTER_weave_toc_node(C));
}

tree_node *WeaveTree__contents_line(heterogeneous_tree *tree,
	text_stream *text1, text_stream *text2, paragraph *P) {
	weave_toc_line_node *C = CREATE(weave_toc_line_node);
	C->text1 = Str__duplicate(text1);
	C->text2 = Str__duplicate(text2);
	C->para = P;
	return Trees__new_node(tree, weave_toc_line_node_type, STORE_POINTER_weave_toc_line_node(C));
}

tree_node *WeaveTree__weave_chapter_title_page_node(heterogeneous_tree *tree) {
	weave_chapter_title_page_node *C = CREATE(weave_chapter_title_page_node);
	return Trees__new_node(tree, weave_chapter_title_page_node_type, STORE_POINTER_weave_chapter_title_page_node(C));
}

tree_node *WeaveTree__weave_defn_node(heterogeneous_tree *tree, text_stream *keyword) {
	weave_defn_node *C = CREATE(weave_defn_node);
	C->keyword = Str__duplicate(keyword);
	return Trees__new_node(tree, weave_defn_node_type, STORE_POINTER_weave_defn_node(C));
}

#line 676 "inweb/Chapter 5/Weave Tree.w"
tree_node *WeaveTree__source_code(heterogeneous_tree *tree,
	text_stream *matter, text_stream *colouring) {
	if (Str__len(colouring) != Str__len(matter)) internal_error("bad source segment");

	for (int i=0; i<Str__len(matter); i++) {
		inchar32_t c = Str__get_at(matter, i);
		if (c == '\t') {
			Str__put_at(matter, i, ' ');
			int extra_spaces =
				SPACES_PER_TAB_IN_WOVEN_CODE - 1 - (i % SPACES_PER_TAB_IN_WOVEN_CODE);
			if (extra_spaces > 0) {
				for (int j=0; j<extra_spaces; j++) {
					PUT_TO(matter, ' '); PUT_TO(colouring, PLAIN_COLOUR);
				}
				for (int j=Str__len(matter)-1; j >= i+extra_spaces; j--) {
					Str__put_at(matter, j, Str__get_at(matter, j-extra_spaces));
					Str__put_at(colouring, j, Str__get_at(colouring, j-extra_spaces));
				}
				for (int j=0; j<extra_spaces; j++) {
					Str__put_at(matter, i+1+j, ' ');
					Str__put_at(colouring, i+1+j, PLAIN_COLOUR);
				}
			}
		}
	}

	weave_source_code_node *C = CREATE(weave_source_code_node);
	C->matter = Str__duplicate(matter);
	C->colouring = Str__duplicate(colouring);
	return Trees__new_node(tree, weave_source_code_node_type, STORE_POINTER_weave_source_code_node(C));
}

tree_node *WeaveTree__url(heterogeneous_tree *tree, text_stream *url,
	text_stream *content, int external) {
	weave_url_node *C = CREATE(weave_url_node);
	C->url = Str__duplicate(url);
	C->content = Str__duplicate(content);
	C->external = external;
	return Trees__new_node(tree, weave_url_node_type, STORE_POINTER_weave_url_node(C));
}

tree_node *WeaveTree__footnote_cue(heterogeneous_tree *tree, text_stream *cue) {
	weave_footnote_cue_node *C = CREATE(weave_footnote_cue_node);
	C->cue_text = Str__duplicate(cue);
	return Trees__new_node(tree, weave_footnote_cue_node_type, STORE_POINTER_weave_footnote_cue_node(C));
}

tree_node *WeaveTree__footnote(heterogeneous_tree *tree, text_stream *cue) {
	weave_begin_footnote_text_node *C = CREATE(weave_begin_footnote_text_node);
	C->cue_text = Str__duplicate(cue);
	return Trees__new_node(tree, weave_begin_footnote_text_node_type, STORE_POINTER_weave_begin_footnote_text_node(C));
}

#line 733 "inweb/Chapter 5/Weave Tree.w"
tree_node *WeaveTree__function_defn(heterogeneous_tree *tree, language_function *fn) {
	weave_function_defn_node *C = CREATE(weave_function_defn_node);
	C->fn = fn;
	return Trees__new_node(tree, weave_function_defn_node_type, STORE_POINTER_weave_function_defn_node(C));
}

#line 743 "inweb/Chapter 5/Weave Tree.w"
tree_node *WeaveTree__display_line(heterogeneous_tree *tree, text_stream *text) {
	weave_display_line_node *C = CREATE(weave_display_line_node);
	C->text = Str__duplicate(text);
	return Trees__new_node(tree, weave_display_line_node_type, STORE_POINTER_weave_display_line_node(C));
}

#line 762 "inweb/Chapter 5/Weave Tree.w"
tree_node *WeaveTree__weave_item_node(heterogeneous_tree *tree, int depth, text_stream *label) {
	weave_item_node *C = CREATE(weave_item_node);
	C->depth = depth;
	C->label = Str__duplicate(label);
	return Trees__new_node(tree, weave_item_node_type, STORE_POINTER_weave_item_node(C));
}

tree_node *WeaveTree__grammar_index(heterogeneous_tree *tree) {
	weave_grammar_index_node *C = CREATE(weave_grammar_index_node);
	return Trees__new_node(tree, weave_grammar_index_node_type, STORE_POINTER_weave_grammar_index_node(C));
}

tree_node *WeaveTree__inline(heterogeneous_tree *tree) {
	weave_inline_node *C = CREATE(weave_inline_node);
	return Trees__new_node(tree, weave_inline_node_type, STORE_POINTER_weave_inline_node(C));
}

tree_node *WeaveTree__locale(heterogeneous_tree *tree, paragraph *par1, paragraph *par2) {
	weave_locale_node *C = CREATE(weave_locale_node);
	C->par1 = par1;
	C->par2 = par2;
	return Trees__new_node(tree, weave_locale_node_type, STORE_POINTER_weave_locale_node(C));
}

tree_node *WeaveTree__mathematics(heterogeneous_tree *tree, text_stream *content, int displayed) {
	weave_maths_node *C = CREATE(weave_maths_node);
	C->content = Str__duplicate(content);
	C->displayed = displayed;
	return Trees__new_node(tree, weave_maths_node_type, STORE_POINTER_weave_maths_node(C));
}

void WeaveTree__show(text_stream *OUT, heterogeneous_tree *T) {
	WRITE("%S\n", T->type->name);
	INDENT;
	Debugging__render(NULL, OUT, T);
	OUTDENT;
}

void WeaveTree__prune(heterogeneous_tree *T) {
	Trees__prune_tree(T, &WeaveTree__prune_visit, NULL);
}

int WeaveTree__prune_visit(tree_node *N, void *state) {
	if ((N->type->required_CLASS == weave_material_node_CLASS) && (N->child == NULL))
		return TRUE;
	if ((N->type->required_CLASS == weave_vskip_node_CLASS) && (N->next == NULL))
		return TRUE;
	if ((N->type->required_CLASS == weave_vskip_node_CLASS) &&
		(N->next->type->required_CLASS == weave_item_node_CLASS))
		return TRUE;
	return FALSE;
}

#line 17 "inweb/Chapter 5/Format Methods.w"

weave_format *Formats__create_weave_format(text_stream *name, text_stream *ext) {
	weave_format *wf = CREATE(weave_format);
	wf->format_name = Str__duplicate(name);
	wf->woven_extension = Str__duplicate(ext);
	wf->methods = Methods__new_set();
	return wf;
}

weave_format *Formats__find_by_name(text_stream *name) {
	weave_format *wf;
	LOOP_OVER(wf, weave_format)
		if (Str__eq_insensitive(name, wf->format_name))
			return wf;
	return NULL;
}

#line 40 "inweb/Chapter 5/Format Methods.w"
text_stream *Formats__file_extension(weave_format *wf) {
	return wf->woven_extension;
}

#line 48 "inweb/Chapter 5/Format Methods.w"
void Formats__create_weave_formats(void) {
	Debugging__create();
	TeX__create();
	PlainText__create();
	HTMLFormat__create();
}

#line 68 "inweb/Chapter 5/Format Methods.w"

#line 70 "inweb/Chapter 5/Format Methods.w"
INT_METHOD_TYPE(BEGIN_WEAVING_FOR_MTID, weave_format *wf, web *W, weave_pattern *pattern)
VOID_METHOD_TYPE(END_WEAVING_FOR_MTID, weave_format *wf, web *W, weave_pattern *pattern)
int Formats__begin_weaving(web *W, weave_pattern *pattern) {
	int rv = FALSE;
	INT_METHOD_CALL(rv, pattern->pattern_format, BEGIN_WEAVING_FOR_MTID, W, pattern);
	if (rv) return rv;
	return SWARM_OFF_SWM;
}
void Formats__end_weaving(web *W, weave_pattern *pattern) {
	VOID_METHOD_CALL(pattern->pattern_format, END_WEAVING_FOR_MTID, W, pattern);
}

#line 92 "inweb/Chapter 5/Format Methods.w"

#line 94 "inweb/Chapter 5/Format Methods.w"
VOID_METHOD_TYPE(RENDER_FOR_MTID, weave_format *wf, text_stream *OUT, heterogeneous_tree *tree)
void Formats__render(text_stream *OUT, heterogeneous_tree *tree, filename *into) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	weave_format *wf = C->wv->format;
	TEMPORARY_TEXT(template)
	WRITE_TO(template, "template-body%S", wf->woven_extension);
	filename *F = Patterns__find_template(C->wv->pattern, template);
	TEMPORARY_TEXT(interior)
	VOID_METHOD_CALL(wf, RENDER_FOR_MTID, interior, tree);
	Bibliographic__set_datum(C->wv->weave_web->md, TL_IS_2936, interior);
	if (F) Collater__for_order(OUT, C->wv, F, into);
	else WRITE("%S", interior);
	DISCARD_TEXT(interior)
	DISCARD_TEXT(template)
}

#line 115 "inweb/Chapter 5/Format Methods.w"

#line 117 "inweb/Chapter 5/Format Methods.w"
INT_METHOD_TYPE(PREFORM_DOCUMENT_FOR_MTID, weave_format *wf, text_stream *OUT,
	weave_order *wv, web *W, chapter *C, section *S, source_line *L,
	text_stream *matter, text_stream *concluding_comment)
int Formats__preform_document(OUTPUT_STREAM, weave_order *wv, web *W,
	chapter *C, section *S, source_line *L, text_stream *matter,
	text_stream *concluding_comment) {
	weave_format *wf = wv->format;
	int rv = FALSE;
	INT_METHOD_CALL(rv, wf, PREFORM_DOCUMENT_FOR_MTID, OUT, wv, W, C, S, L, matter,
		concluding_comment);
	return rv;
}

#line 136 "inweb/Chapter 5/Format Methods.w"

#line 138 "inweb/Chapter 5/Format Methods.w"
VOID_METHOD_TYPE(POST_PROCESS_POS_MTID, weave_format *wf, weave_order *wv, int open_afterwards)
void Formats__post_process_weave(weave_order *wv, int open_afterwards) {
	VOID_METHOD_CALL(wv->format, POST_PROCESS_POS_MTID, wv, open_afterwards);
}

#line 148 "inweb/Chapter 5/Format Methods.w"

#line 150 "inweb/Chapter 5/Format Methods.w"
VOID_METHOD_TYPE(POST_PROCESS_REPORT_POS_MTID, weave_format *wf, weave_order *wv)
void Formats__report_on_post_processing(weave_order *wv) {
	TeXUtilities__report_on_post_processing(wv);
	VOID_METHOD_CALL(wv->format, POST_PROCESS_REPORT_POS_MTID, wv);
}

#line 160 "inweb/Chapter 5/Format Methods.w"

#line 162 "inweb/Chapter 5/Format Methods.w"
INT_METHOD_TYPE(POST_PROCESS_SUBSTITUTE_POS_MTID, weave_format *wf, text_stream *OUT,
	weave_order *wv, text_stream *detail, weave_pattern *pattern)
int Formats__substitute_post_processing_data(OUTPUT_STREAM, weave_order *wv,
	text_stream *detail, weave_pattern *pattern) {
	int rv = TeXUtilities__substitute_post_processing_data(OUT, wv, detail);
	INT_METHOD_CALL(rv, wv->format, POST_PROCESS_SUBSTITUTE_POS_MTID, OUT, wv, detail, pattern);
	return rv;
}

#line 9 "inweb/Chapter 5/Plain Text Format.w"
void PlainText__create(void) {
	weave_format *wf = Formats__create_weave_format(TL_IS_2937, TL_IS_2938);
	METHOD_ADD(wf, RENDER_FOR_MTID, PlainText__render);
}

#line 22 "inweb/Chapter 5/Plain Text Format.w"

void PlainText__render(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) {
	PlainText_render_state prs;
	prs.OUT = OUT;
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	prs.wv = C->wv;
	Trees__traverse_from(tree->root, &PlainText__render_visit, (void *) &prs, 0);
}

int PlainText__render_visit(tree_node *N, void *state, int L) {
	PlainText_render_state *prs = (PlainText_render_state *) state;
	text_stream *OUT = prs->OUT;
	if ((N->type == weave_document_node_type) ||
		(N->type == weave_head_node_type) ||
		(N->type == weave_body_node_type) ||
		(N->type == weave_tail_node_type) ||
		(N->type == weave_chapter_title_page_node_type) ||
		(N->type == weave_chapter_footer_node_type) ||
		(N->type == weave_figure_node_type) ||
		(N->type == weave_audio_node_type) ||
		(N->type == weave_video_node_type) ||
		(N->type == weave_download_node_type) ||
		(N->type == weave_material_node_type) ||
		(N->type == weave_chapter_node_type) ||
		(N->type == weave_carousel_slide_node_type) ||
		(N->type == weave_toc_node_type) ||
		(N->type == weave_toc_line_node_type) ||
		(N->type == weave_grammar_index_node_type) ||
		(N->type == weave_inline_node_type)) 
{
#line 135 "inweb/Chapter 5/Plain Text Format.w"
	;

}
#line 50 "inweb/Chapter 5/Plain Text Format.w"


	else if (N->type == weave_verbatim_node_type) 
{
#line 131 "inweb/Chapter 5/Plain Text Format.w"
	weave_verbatim_node *C = RETRIEVE_POINTER_weave_verbatim_node(N->content);
	WRITE("%S", C->content);

}
#line 52 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_chapter_header_node_type) 
{
#line 86 "inweb/Chapter 5/Plain Text Format.w"
	weave_chapter_header_node *C = RETRIEVE_POINTER_weave_chapter_header_node(N->content);
	WRITE("%S\n\n", C->chap->md->ch_title);
	section *S;
	LOOP_OVER_LINKED_LIST(S, section, C->chap->sections)
		WRITE("  %S\n    %S\n",
			S->md->sect_title, S->sect_purpose);
	WRITE("\n");

}
#line 53 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_section_header_node_type) 
{
#line 95 "inweb/Chapter 5/Plain Text Format.w"
	weave_section_header_node *C = RETRIEVE_POINTER_weave_section_header_node(N->content);
	WRITE("%S\n\n", C->sect->md->sect_title);

}
#line 54 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_section_footer_node_type) 
{
#line 99 "inweb/Chapter 5/Plain Text Format.w"
	WRITE("\n\n");

}
#line 55 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_section_purpose_node_type) 
{
#line 102 "inweb/Chapter 5/Plain Text Format.w"
	weave_section_purpose_node *C = RETRIEVE_POINTER_weave_section_purpose_node(N->content);
	WRITE("%S\n\n", C->purpose);

}
#line 56 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_subheading_node_type) 
{
#line 106 "inweb/Chapter 5/Plain Text Format.w"
	weave_subheading_node *C = RETRIEVE_POINTER_weave_subheading_node(N->content);
	WRITE("%S\n\n", C->text);

}
#line 57 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_bar_node_type) 
{
#line 110 "inweb/Chapter 5/Plain Text Format.w"
	WRITE("\n----------------------------------------------------------------------\n\n");

}
#line 58 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_pagebreak_node_type) 
{
#line 113 "inweb/Chapter 5/Plain Text Format.w"
	;

}
#line 59 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_linebreak_node_type) 
{
#line 116 "inweb/Chapter 5/Plain Text Format.w"
	WRITE("\n");

}
#line 60 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_paragraph_heading_node_type) 
{
#line 119 "inweb/Chapter 5/Plain Text Format.w"
	weave_paragraph_heading_node *C = RETRIEVE_POINTER_weave_paragraph_heading_node(N->content);
	WRITE("\n");
	WRITE("%S%S", C->para->ornament, C->para->paragraph_number);
	if (Str__len(C->para->heading_text) > 0) WRITE(" %S", C->para->heading_text);
	WRITE(".  ");

}
#line 61 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_endnote_node_type) 
{
#line 126 "inweb/Chapter 5/Plain Text Format.w"
	
{
#line 216 "inweb/Chapter 5/Plain Text Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &PlainText__render_visit, (void *) prs, L+1);

}
#line 126 "inweb/Chapter 5/Plain Text Format.w"
;
	WRITE("\n");
	return FALSE;

}
#line 62 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_embed_node_type) 
{
#line 138 "inweb/Chapter 5/Plain Text Format.w"
	weave_embed_node *C = RETRIEVE_POINTER_weave_embed_node(N->content);
	WRITE("[See %S video with ID %S.]\n", C->service, C->ID);

}
#line 63 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_pmac_node_type) 
{
#line 142 "inweb/Chapter 5/Plain Text Format.w"
	weave_pmac_node *C = RETRIEVE_POINTER_weave_pmac_node(N->content);
	WRITE("<%S (%S)>%s",
		C->pmac->macro_name, C->pmac->defining_paragraph->paragraph_number,
		(C->defn)?" =":"");

}
#line 64 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_vskip_node_type) 
{
#line 148 "inweb/Chapter 5/Plain Text Format.w"
	WRITE("\n");

}
#line 65 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_section_node_type) 
{
#line 151 "inweb/Chapter 5/Plain Text Format.w"
	weave_section_node *C = RETRIEVE_POINTER_weave_section_node(N->content);
	LOG("It was %d\n", C->allocation_id);

}
#line 66 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_code_line_node_type) 
{
#line 155 "inweb/Chapter 5/Plain Text Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &PlainText__render_visit, (void *) prs, L+1);
	WRITE("\n");
	return FALSE;

}
#line 67 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_function_usage_node_type) 
{
#line 161 "inweb/Chapter 5/Plain Text Format.w"
	weave_function_usage_node *C = RETRIEVE_POINTER_weave_function_usage_node(N->content);
	WRITE("%S", C->fn->function_name);
	return FALSE;

}
#line 68 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_commentary_node_type) 
{
#line 166 "inweb/Chapter 5/Plain Text Format.w"
	weave_commentary_node *C = RETRIEVE_POINTER_weave_commentary_node(N->content);
	if (C->in_code) WRITE(" /* ");
	WRITE("%S", C->text);
	if (C->in_code) WRITE(" */ ");

}
#line 69 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_defn_node_type) 
{
#line 172 "inweb/Chapter 5/Plain Text Format.w"
	weave_defn_node *C = RETRIEVE_POINTER_weave_defn_node(N->content);
	WRITE("%S ", C->keyword);

}
#line 70 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_source_code_node_type) 
{
#line 176 "inweb/Chapter 5/Plain Text Format.w"
	weave_source_code_node *C = RETRIEVE_POINTER_weave_source_code_node(N->content);
	WRITE("%S", C->matter);

}
#line 71 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_url_node_type) 
{
#line 180 "inweb/Chapter 5/Plain Text Format.w"
	weave_url_node *C = RETRIEVE_POINTER_weave_url_node(N->content);
	WRITE("%S", C->url);

}
#line 72 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_footnote_cue_node_type) 
{
#line 184 "inweb/Chapter 5/Plain Text Format.w"
	weave_footnote_cue_node *C = RETRIEVE_POINTER_weave_footnote_cue_node(N->content);
	WRITE("[%S]", C->cue_text);

}
#line 73 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_begin_footnote_text_node_type) 
{
#line 188 "inweb/Chapter 5/Plain Text Format.w"
	WRITE("\n");

}
#line 74 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_display_line_node_type) 
{
#line 191 "inweb/Chapter 5/Plain Text Format.w"
	weave_display_line_node *C = RETRIEVE_POINTER_weave_display_line_node(N->content);
	WRITE("    %S\n", C->text);

}
#line 75 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_function_defn_node_type) 
{
#line 195 "inweb/Chapter 5/Plain Text Format.w"
	weave_function_defn_node *C = RETRIEVE_POINTER_weave_function_defn_node(N->content);
	WRITE("%S", C->fn->function_name);
	return TRUE;

}
#line 76 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_item_node_type) 
{
#line 200 "inweb/Chapter 5/Plain Text Format.w"
	weave_item_node *C = RETRIEVE_POINTER_weave_item_node(N->content);
	for (int i=1; i<C->depth; i++) WRITE("  ");
	WRITE("(%S) ", C->label);

}
#line 77 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_locale_node_type) 
{
#line 205 "inweb/Chapter 5/Plain Text Format.w"
	weave_locale_node *C = RETRIEVE_POINTER_weave_locale_node(N->content);
	WRITE("%S%S", C->par1->ornament, C->par1->paragraph_number);
	if (C->par2) WRITE("-%S", C->par2->paragraph_number);

}
#line 78 "inweb/Chapter 5/Plain Text Format.w"

	else if (N->type == weave_maths_node_type) 
{
#line 210 "inweb/Chapter 5/Plain Text Format.w"
	weave_maths_node *C = RETRIEVE_POINTER_weave_maths_node(N->content);
	if (C->displayed) WRITE("\n");
	WRITE("%S", C->content);
	if (C->displayed) WRITE("\n\n");

}
#line 79 "inweb/Chapter 5/Plain Text Format.w"


	else internal_error("unable to render unknown node");
	return TRUE;
}

#line 9 "inweb/Chapter 5/TeX Format.w"
void TeX__create(void) {
	weave_format *wf = Formats__create_weave_format(TL_IS_2939, TL_IS_2940);
	METHOD_ADD(wf, RENDER_FOR_MTID, TeX__render_TeX);
	METHOD_ADD(wf, PREFORM_DOCUMENT_FOR_MTID, TeX__preform_document);
}

#line 23 "inweb/Chapter 5/TeX Format.w"

#line 25 "inweb/Chapter 5/TeX Format.w"
void TeX__render_TeX(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) {
	TeX__render_inner(OUT, tree, PDFTEX_TEX_FORM);
}

#line 38 "inweb/Chapter 5/TeX Format.w"

void TeX__render_inner(text_stream *OUT, heterogeneous_tree *tree, int form) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	TeX_render_state trs;
	trs.OUT = OUT;
	trs.wv = C->wv;
	trs.TeX_form = form;
	Trees__traverse_from(tree->root, &TeX__render_visit, (void *) &trs, 0);
}

#line 51 "inweb/Chapter 5/TeX Format.w"
int TeX__render_visit(tree_node *N, void *state, int L) {
	TeX_render_state *trs = (TeX_render_state *) state;
	text_stream *OUT = trs->OUT;
	if ((N->type == weave_document_node_type) ||
		(N->type == weave_body_node_type) ||
		(N->type == weave_chapter_title_page_node_type) ||
		(N->type == weave_chapter_footer_node_type) ||
		(N->type == weave_section_footer_node_type) ||
		(N->type == weave_audio_node_type) ||
		(N->type == weave_video_node_type) ||
		(N->type == weave_download_node_type) ||
		(N->type == weave_chapter_node_type) ||
		(N->type == weave_carousel_slide_node_type) ||
		(N->type == weave_begin_footnote_text_node_type)) 
{
#line 236 "inweb/Chapter 5/TeX Format.w"
	;

}
#line 64 "inweb/Chapter 5/TeX Format.w"


	else if (N->type == weave_head_node_type) 
{
#line 106 "inweb/Chapter 5/TeX Format.w"
	weave_head_node *C = RETRIEVE_POINTER_weave_head_node(N->content);
	WRITE("%% %S\n", C->banner);

}
#line 66 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_tail_node_type) 
{
#line 110 "inweb/Chapter 5/TeX Format.w"
	weave_tail_node *C = RETRIEVE_POINTER_weave_tail_node(N->content);
	WRITE("%% %S\n", C->rennab);
	WRITE("\\end\n");

}
#line 67 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_verbatim_node_type) 
{
#line 232 "inweb/Chapter 5/TeX Format.w"
	weave_verbatim_node *C = RETRIEVE_POINTER_weave_verbatim_node(N->content);
	WRITE("%S", C->content);

}
#line 68 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_chapter_header_node_type) 
{
#line 115 "inweb/Chapter 5/TeX Format.w"
	weave_chapter_header_node *C = RETRIEVE_POINTER_weave_chapter_header_node(N->content);
	if (Str__ne(C->chap->md->ch_range, TL_IS_2941)) {
		TeX__general_heading(OUT, trs->wv,
			FIRST_IN_LINKED_LIST(section, C->chap->sections), NULL, C->chap->md->ch_title,
			3, FALSE);
		WRITE("%S\\medskip\n", C->chap->md->rubric);
		section *S;
		LOOP_OVER_LINKED_LIST(S, section, C->chap->sections) {
			WRITE("\\smallskip\\noindent ");
			if (trs->wv->pattern->number_sections) WRITE("%d. ", S->printed_number);
			WRITE("{\\it %S}\\qquad\n%S", S->md->sect_title, S->sect_purpose);
		}
	}

}
#line 69 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_section_header_node_type) 
{
#line 130 "inweb/Chapter 5/TeX Format.w"
	weave_section_header_node *C = RETRIEVE_POINTER_weave_section_header_node(N->content);
	TeX__general_heading(OUT, trs->wv, C->sect, NULL,
		C->sect->md->sect_title, 2, FALSE);

}
#line 70 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_section_purpose_node_type) 
{
#line 135 "inweb/Chapter 5/TeX Format.w"
	weave_section_purpose_node *C = RETRIEVE_POINTER_weave_section_purpose_node(N->content);
	WRITE("\\smallskip\\par\\noindent{\\it %S}\\smallskip\\noindent\n", C->purpose);

}
#line 71 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_subheading_node_type) 
{
#line 139 "inweb/Chapter 5/TeX Format.w"
	weave_subheading_node *C = RETRIEVE_POINTER_weave_subheading_node(N->content);
	WRITE("\\par\\noindent{\\bf %S}\\mark{%S}\\medskip\n", C->text, NULL);

}
#line 72 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_bar_node_type) 
{
#line 143 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\par\\medskip\\noindent\\hrule\\medskip\\noindent\n");

}
#line 73 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_pagebreak_node_type) 
{
#line 146 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\vfill\\eject\n");

}
#line 74 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_linebreak_node_type) 
{
#line 149 "inweb/Chapter 5/TeX Format.w"
	WRITE("\n");

}
#line 75 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_paragraph_heading_node_type) 
{
#line 152 "inweb/Chapter 5/TeX Format.w"
	weave_paragraph_heading_node *C =
		RETRIEVE_POINTER_weave_paragraph_heading_node(N->content);
	TeX__general_heading(OUT, trs->wv, C->para->under_section,
		C->para, TL_IS_2942, 0, FALSE);

}
#line 76 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_endnote_node_type) 
{
#line 158 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\par\\noindent\\penalty10000\n");
	WRITE("{\\usagefont ");
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 160 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("}\\smallskip\n");
	return FALSE;

}
#line 77 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_figure_node_type) 
{
#line 172 "inweb/Chapter 5/TeX Format.w"
	weave_figure_node *C = RETRIEVE_POINTER_weave_figure_node(N->content);
	filename *F = Filenames__in(
		Pathnames__down(trs->wv->weave_web->md->path_to_web, TL_IS_2943),
		C->figname);
	WRITE("\\pdfximage");
	if (C->w >= 0) WRITE(" width %d cm{%f}\n", C->w/POINTS_PER_CM, F);
	else if (C->h >= 0) WRITE(" height %d cm{%f}\n", C->h/POINTS_PER_CM, F);
	else WRITE("{%f}\n", F);
	WRITE("\\smallskip\\noindent"
		"\\hbox to\\hsize{\\hfill\\pdfrefximage \\pdflastximage\\hfill}"
		"\\smallskip\n");

}
#line 78 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_material_node_type) 
{
#line 185 "inweb/Chapter 5/TeX Format.w"
	weave_material_node *C = RETRIEVE_POINTER_weave_material_node(N->content);
	paragraph *first_in_para = NULL;
	if ((N == N->parent->child) &&
		(N->parent->type == weave_paragraph_heading_node_type)) {
		weave_paragraph_heading_node *PC =
			RETRIEVE_POINTER_weave_paragraph_heading_node(N->parent->content);
		first_in_para = PC->para;
	}
	if (C->material_type == COMMENTARY_MATERIAL)
		
{
#line 208 "inweb/Chapter 5/TeX Format.w"
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 208 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("\n");

}
#line 194 "inweb/Chapter 5/TeX Format.w"

	else if (C->material_type == CODE_MATERIAL)
		
{
#line 212 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\beginlines\n");
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 213 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("\\endlines\n");

}
#line 196 "inweb/Chapter 5/TeX Format.w"

	else if (C->material_type == FOOTNOTES_MATERIAL)
		
{
#line 217 "inweb/Chapter 5/TeX Format.w"
	return FALSE;

}
#line 198 "inweb/Chapter 5/TeX Format.w"

	else if (C->material_type == ENDNOTES_MATERIAL)
		
{
#line 220 "inweb/Chapter 5/TeX Format.w"
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 220 "inweb/Chapter 5/TeX Format.w"
;

}
#line 200 "inweb/Chapter 5/TeX Format.w"

	else if (C->material_type == MACRO_MATERIAL)
		
{
#line 223 "inweb/Chapter 5/TeX Format.w"
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 223 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("\n");

}
#line 202 "inweb/Chapter 5/TeX Format.w"

	else if (C->material_type == DEFINITION_MATERIAL)
		
{
#line 227 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\beginlines\n");
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 228 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("\\endlines\n");

}
#line 204 "inweb/Chapter 5/TeX Format.w"
;
	return FALSE;

}
#line 79 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_embed_node_type) 
{
#line 239 "inweb/Chapter 5/TeX Format.w"
	weave_embed_node *C = RETRIEVE_POINTER_weave_embed_node(N->content);
	LOG("It was %d\n", C->allocation_id);

}
#line 80 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_pmac_node_type) 
{
#line 243 "inweb/Chapter 5/TeX Format.w"
	weave_pmac_node *C = RETRIEVE_POINTER_weave_pmac_node(N->content);
	TeX__para_macro(OUT, trs->wv, C->pmac, C->defn);

}
#line 81 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_vskip_node_type) 
{
#line 247 "inweb/Chapter 5/TeX Format.w"
	weave_vskip_node *C = RETRIEVE_POINTER_weave_vskip_node(N->content);
	if (C->in_comment) WRITE("\\smallskip\\par\\noindent%%\n");
	else WRITE("\\smallskip\n");

}
#line 82 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_section_node_type) 
{
#line 252 "inweb/Chapter 5/TeX Format.w"
	weave_section_node *C = RETRIEVE_POINTER_weave_section_node(N->content);
	LOG("It was %d\n", C->allocation_id);

}
#line 83 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_code_line_node_type) 
{
#line 256 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\smallskip\\par\\noindent ");
	WRITE("|");
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 258 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("|");
	WRITE("\n");
	return FALSE;

}
#line 84 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_function_usage_node_type) 
{
#line 264 "inweb/Chapter 5/TeX Format.w"
	weave_function_usage_node *C =
		RETRIEVE_POINTER_weave_function_usage_node(N->content);
	WRITE("%S", C->fn->function_name);
	return FALSE;

}
#line 85 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_commentary_node_type) 
{
#line 270 "inweb/Chapter 5/TeX Format.w"
	weave_commentary_node *C =
		RETRIEVE_POINTER_weave_commentary_node(N->content);
	if (C->in_code) WRITE(" |\\hfill{\\ttninepoint\\it ");
	TeX__commentary_text(OUT, trs->wv, C->text);
	if (C->in_code) WRITE("}|");

}
#line 86 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_toc_node_type) 
{
#line 277 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\medskip\\hrule\\smallskip\\par\\noindent{\\usagefont ");
	for (tree_node *M = N->child; M; M = M->next) {
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);
		if (M->next) WRITE("; ");
	}
	WRITE("}\\par\\medskip\\hrule\\bigskip\n");
	return FALSE;

}
#line 87 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_toc_line_node_type) 
{
#line 286 "inweb/Chapter 5/TeX Format.w"
	weave_toc_line_node *C = RETRIEVE_POINTER_weave_toc_line_node(N->content);
	WRITE("%S~%S", C->text1, C->text2);

}
#line 88 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_defn_node_type) 
{
#line 290 "inweb/Chapter 5/TeX Format.w"
	weave_defn_node *C = RETRIEVE_POINTER_weave_defn_node(N->content);
	WRITE("|{\\ninebf %S} |", C->keyword);

}
#line 89 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_source_code_node_type) 
{
#line 294 "inweb/Chapter 5/TeX Format.w"
	weave_source_code_node *C =
		RETRIEVE_POINTER_weave_source_code_node(N->content);
	int starts = FALSE;
	if (N == N->parent->child) starts = TRUE;
	TeX__source_code(OUT, trs->wv,
		C->matter, C->colouring, starts);

}
#line 90 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_url_node_type) 
{
#line 302 "inweb/Chapter 5/TeX Format.w"
	weave_url_node *C = RETRIEVE_POINTER_weave_url_node(N->content);
	WRITE("%S", C->url);

}
#line 91 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_footnote_cue_node_type) 
{
#line 310 "inweb/Chapter 5/TeX Format.w"
	weave_footnote_cue_node *C = RETRIEVE_POINTER_weave_footnote_cue_node(N->content);
	WRITE("\\footnote{${}^{%S}$}{", C->cue_text);
	tree_node *M = N;
	while ((M) && (M->type != weave_paragraph_heading_node_type)) M = M->parent;
	if (M == NULL) internal_error("tree without section nodes");
	M = M->child;
	int found = FALSE;
	while (M) {
		if (M->type == weave_material_node_type) {
			weave_material_node *MC = RETRIEVE_POINTER_weave_material_node(M->content);
			if (MC->material_type == FOOTNOTES_MATERIAL) {
				tree_node *F = M->child;
				while (F) {
					if (F->type == weave_begin_footnote_text_node_type) {
						weave_begin_footnote_text_node *FC =
							RETRIEVE_POINTER_weave_begin_footnote_text_node(F->content);
						if (Str__eq(FC->cue_text, C->cue_text))
							
{
#line 346 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *X = F->child->next; X; X = X->next)
		Trees__traverse_from(X, &TeX__render_visit, (void *) trs, L+1);
	found = TRUE;

}
#line 327 "inweb/Chapter 5/TeX Format.w"
;
					}
					F = F->next;
				}
			}
		}
		M = M->next;
	}
	WRITE("}");
	if (found == FALSE) internal_error("cue without text");

}
#line 92 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_display_line_node_type) 
{
#line 351 "inweb/Chapter 5/TeX Format.w"
	weave_display_line_node *C =
		RETRIEVE_POINTER_weave_display_line_node(N->content);
	WRITE("\\quotesource{%S}\n", C->text);

}
#line 93 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_function_defn_node_type) 
{
#line 356 "inweb/Chapter 5/TeX Format.w"
	weave_function_defn_node *C =
		RETRIEVE_POINTER_weave_function_defn_node(N->content);
	TeX__change_colour_PDF(OUT, FUNCTION_COLOUR, TRUE);
	WRITE("%S", C->fn->function_name);
	TeX__change_colour_PDF(OUT, PLAIN_COLOUR, TRUE);
	return FALSE;

}
#line 94 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_item_node_type) 
{
#line 364 "inweb/Chapter 5/TeX Format.w"
	weave_item_node *C = RETRIEVE_POINTER_weave_item_node(N->content);
	if (Str__len(C->label) > 0) {
		if (C->depth == 1) WRITE("\\item{(%S)}", C->label);
		else WRITE("\\itemitem{(%S)}", C->label);
	} else {
		if (C->depth == 1) WRITE("\\item{}");
		else WRITE("\\itemitem{}");
	}

}
#line 95 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_grammar_index_node_type) 
{
#line 374 "inweb/Chapter 5/TeX Format.w"
	InCSupport__weave_grammar_index(OUT);

}
#line 96 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_inline_node_type) 
{
#line 377 "inweb/Chapter 5/TeX Format.w"
	WRITE("|");
	
{
#line 394 "inweb/Chapter 5/TeX Format.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &TeX__render_visit, (void *) trs, L+1);

}
#line 378 "inweb/Chapter 5/TeX Format.w"
;
	WRITE("|");
	return FALSE;

}
#line 97 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_locale_node_type) 
{
#line 383 "inweb/Chapter 5/TeX Format.w"
	weave_locale_node *C = RETRIEVE_POINTER_weave_locale_node(N->content);
	WRITE("$\\%S$%S", C->par1->ornament, C->par1->paragraph_number);
	if (C->par2) WRITE("-%S", C->par2->paragraph_number);

}
#line 98 "inweb/Chapter 5/TeX Format.w"

	else if (N->type == weave_maths_node_type) 
{
#line 388 "inweb/Chapter 5/TeX Format.w"
	weave_maths_node *C = RETRIEVE_POINTER_weave_maths_node(N->content);
	if (C->displayed) WRITE("$$"); else WRITE("$");
	WRITE("%S", C->content);
	if (C->displayed) WRITE("$$"); else WRITE("$");

}
#line 99 "inweb/Chapter 5/TeX Format.w"


	else internal_error("unable to render unknown node");
	return TRUE;
}

#line 398 "inweb/Chapter 5/TeX Format.w"
text_stream *P_literal = NULL;
void TeX__general_heading(text_stream *OUT, weave_order *wv,
	section *S, paragraph *P, text_stream *heading_text, int weight, int no_skip) {
	text_stream *TeX_macro = NULL;
	
{
#line 443 "inweb/Chapter 5/TeX Format.w"
	switch (weight) {
		case 0: TeX_macro = TL_IS_2944; break;
		case 1: TeX_macro = TL_IS_2945; break;
		case 2: TeX_macro = TL_IS_2946; break;
		default: TeX_macro = TL_IS_2947; break;
	}
	if (wv->theme_match) {
		switch (weight) {
			case 0: TeX_macro = TL_IS_2948; break;
			case 1: TeX_macro = TL_IS_2949; break;
			case 2: TeX_macro = TL_IS_2950; break;
			default: TeX_macro = TL_IS_2951; break;
		}
	}
	if (no_skip) {
		switch (weight) {
			case 0: TeX_macro = TL_IS_2952; break;
			case 1: TeX_macro = TL_IS_2953; break;
		}
	}

}
#line 402 "inweb/Chapter 5/TeX Format.w"
;

	if (P_literal == NULL) P_literal = Str__new_from_wide_string(U"P");
	text_stream *orn = (P)?(P->ornament):P_literal;
	text_stream *N = (P)?(P->paragraph_number):NULL;
	TEMPORARY_TEXT(mark)
	
{
#line 474 "inweb/Chapter 5/TeX Format.w"
	text_stream *chaptermark = Str__new();
	text_stream *sectionmark = Str__new();
	if (weight == 3) {
		Str__copy(chaptermark, S->owning_chapter->md->ch_title);
		Str__clear(sectionmark);
	}
	if (weight == 2) {
		Str__copy(sectionmark, S->md->sect_title);
		Str__clear(chaptermark);
		if (Str__len(chaptermark) > 0) {
			Str__clear(sectionmark);
			WRITE_TO(sectionmark, " - %S", S->md->sect_title);
		}
	}
	WRITE_TO(mark, "%S%S\\quad$\\%S$%S", chaptermark, sectionmark, orn, N);

}
#line 408 "inweb/Chapter 5/TeX Format.w"
;
	TEMPORARY_TEXT(modified)
	Str__copy(modified, heading_text);
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, modified, U"(%c*?): (%c*)")) {
		Str__clear(modified);
		WRITE_TO(modified, "{\\sinchhigh %S}\\quad %S", mr.exp[0], mr.exp[1]);
	}
	if (weight == 2)
		WRITE("\\%S{%S}{%S}{%S}{\\%S}{%S}%%\n",
			TeX_macro, N, modified, mark, orn, NULL);
	else
		WRITE("\\%S{%S}{%S}{%S}{\\%S}{%S}%%\n",
			TeX_macro, N, modified, mark, orn, S->md->sect_range);
	DISCARD_TEXT(mark)
	DISCARD_TEXT(modified)
	Regexp__dispose_of(&mr);
}

#line 496 "inweb/Chapter 5/TeX Format.w"
void TeX__source_code(text_stream *OUT, weave_order *wv,
	text_stream *matter, text_stream *colouring, int starts) {
	int current_colour = PLAIN_COLOUR, colour_wanted = PLAIN_COLOUR;
	for (int i=0; i < Str__len(matter); i++) {
		colour_wanted = (int) Str__get_at(colouring, i);
		
{
#line 509 "inweb/Chapter 5/TeX Format.w"
	if (colour_wanted != current_colour) {
		TeX__change_colour_PDF(OUT, colour_wanted, TRUE);
		current_colour = colour_wanted;
	}

}
#line 501 "inweb/Chapter 5/TeX Format.w"
;
		if (Str__get_at(matter, i) == '|') WRITE("|\\||");
		else WRITE("%c", Str__get_at(matter, i));
	}
	colour_wanted = PLAIN_COLOUR; 
{
#line 509 "inweb/Chapter 5/TeX Format.w"
	if (colour_wanted != current_colour) {
		TeX__change_colour_PDF(OUT, colour_wanted, TRUE);
		current_colour = colour_wanted;
	}

}
#line 505 "inweb/Chapter 5/TeX Format.w"
;
}

#line 515 "inweb/Chapter 5/TeX Format.w"
void TeX__change_colour_PDF(text_stream *OUT, int col, int in_code) {
	char *inout = "";
	if (in_code) inout = "|";
	switch (col) {
		case DEFINITION_COLOUR:
			WRITE("%s\\pdfliteral direct{1 1 0 0 k}%s", inout, inout); break;
		case FUNCTION_COLOUR:
			WRITE("%s\\pdfliteral direct{0 1 1 0 k}%s", inout, inout); break;
		case PLAIN_COLOUR:
			WRITE("%s\\special{PDF:0 g}%s", inout, inout); break;
		case EXTRACT_COLOUR:
			WRITE("%s\\special{PDF:0 g}%s", inout, inout); break;
	}
}

#line 538 "inweb/Chapter 5/TeX Format.w"
void TeX__para_macro(text_stream *OUT, weave_order *wv, para_macro *pmac, int defn) {
	if (defn)
		WRITE("|\\pdfdest num %d fit ",
			pmac->allocation_id + 100);
	else
		WRITE("|\\pdfstartlink attr{/C [0.9 0 0] /Border [0 0 0]} goto num %d ",
			pmac->allocation_id + 100);
	WRITE("$\\langle${\\xreffont");
	TeX__change_colour_PDF(OUT, DEFINITION_COLOUR, FALSE);
	WRITE("%S ", pmac->macro_name);
	WRITE("{\\sevenss %S}}", pmac->defining_paragraph->paragraph_number);
	TeX__change_colour_PDF(OUT, PLAIN_COLOUR, FALSE);
	WRITE("$\\rangle$ ");
	if (defn)
		WRITE("$\\equiv$|");
	else
		WRITE("\\pdfendlink|");
}

#line 558 "inweb/Chapter 5/TeX Format.w"
void TeX__commentary_text(text_stream *OUT, weave_order *wv, text_stream *id) {
	int math_mode = FALSE;
	for (int i=0; i < Str__len(id); i++) {
		switch (Str__get_at(id, i)) {
			case '$': math_mode = (math_mode)?FALSE:TRUE;
				WRITE("%c", Str__get_at(id, i)); break;
			case '_': if (math_mode) WRITE("_"); else WRITE("\\_"); break;
			case '"':
				if ((Str__get_at(id, i) == '"') &&
					((i==0) || (Str__get_at(id, i-1) == ' ') ||
						(Str__get_at(id, i-1) == '(')))
					WRITE("``");
				else
					WRITE("''");
				break;
			default: WRITE("%c", Str__get_at(id, i));
				break;
		}
	}
}

#line 583 "inweb/Chapter 5/TeX Format.w"
int TeX__preform_document(weave_format *self, text_stream *OUT, web *W,
	weave_order *wv, chapter *C, section *S, source_line *L, text_stream *matter,
	text_stream *concluding_comment) {
	if (L->preform_nonterminal_defined) {
		preform_production_count = 0;
		
{
#line 600 "inweb/Chapter 5/TeX Format.w"
	WRITE("\\nonterminal{%S} |::=|",
		L->preform_nonterminal_defined->unangled_name);
	if (L->preform_nonterminal_defined->as_function) {
		WRITE("\\quad{\\it internal definition");
		if (L->preform_nonterminal_defined->voracious)
			WRITE(" (voracious)");
		else if (L->preform_nonterminal_defined->min_word_count ==
			L->preform_nonterminal_defined->max_word_count)
			WRITE(" (%d word%s)",
				L->preform_nonterminal_defined->min_word_count,
				(L->preform_nonterminal_defined->min_word_count != 1)?"s":"");
		WRITE("}");
	}
	WRITE("\n");

}
#line 588 "inweb/Chapter 5/TeX Format.w"
;
		return TRUE;
	} else {
		if (L->category == PREFORM_GRAMMAR_LCAT) {
			
{
#line 616 "inweb/Chapter 5/TeX Format.w"
	TEMPORARY_TEXT(problem)
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, matter, U"Issue (%c*?) problem"))
		Str__copy(problem, mr.exp[0]);
	else if (Regexp__match(&mr, matter, U"FAIL_NONTERMINAL %+"))
		WRITE_TO(problem, "fail and skip");
	else if (Regexp__match(&mr, matter, U"FAIL_NONTERMINAL"))
		WRITE_TO(problem, "fail");
	preform_production_count++;
	WRITE_TO(matter, "|%S|", L->text_operand);
	while (Regexp__match(&mr, matter, U"(%c+?)|(%c+)")) {
		Str__clear(matter);
		WRITE_TO(matter, "%S___stroke___%S", mr.exp[0], mr.exp[1]);
	}
	while (Regexp__match(&mr, matter, U"(%c*?)___stroke___(%c*)")) {
		Str__clear(matter);
		WRITE_TO(matter, "%S|\\||%S", mr.exp[0], mr.exp[1]);
	}
	while (Regexp__match(&mr, matter, U"(%c*)<(%c*?)>(%c*)")) {
		Str__clear(matter);
		WRITE_TO(matter, "%S|\\nonterminal{%S}|%S",
			mr.exp[0], mr.exp[1], mr.exp[2]);
	}
	TEMPORARY_TEXT(label)
	int N = preform_production_count;
	int L = ((N-1)%26) + 1;
	if (N <= 26) WRITE_TO(label, "%c", 'a'+L-1);
	else if (N <= 52) WRITE_TO(label, "%c%c", 'a'+L-1, 'a'+L-1);
	else if (N <= 78) WRITE_TO(label, "%c%c%c", 'a'+L-1, 'a'+L-1, 'a'+L-1);
	else {
		int n = (N-1)/26;
		WRITE_TO(label, "%c${}^{%d}$", 'a'+L-1, n);
	}
	WRITE("\\qquad {\\hbox to 0.4in{\\it %S\\hfil}}%S", label, matter);
	if (Str__len(problem) > 0)
		WRITE("\\hfill$\\longrightarrow$ {\\ttninepoint\\it %S}", problem);
	else if (Str__len(concluding_comment) > 0) {
		WRITE(" \\hfill{\\ttninepoint\\it ");
		if (Str__len(concluding_comment) > 0)
			TeX__commentary_text(OUT, wv, concluding_comment);
		WRITE("}");
	}
	WRITE("\n");
	DISCARD_TEXT(label)
	DISCARD_TEXT(problem)
	Regexp__dispose_of(&mr);

}
#line 592 "inweb/Chapter 5/TeX Format.w"
;
			return TRUE;
		}
	}
	return FALSE;
}

#line 9 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__create(void) {
	
{
#line 15 "inweb/Chapter 5/HTML Formats.w"
	weave_format *wf = Formats__create_weave_format(TL_IS_2954, TL_IS_2955);
	METHOD_ADD(wf, RENDER_FOR_MTID, HTMLFormat__render);

}
#line 10 "inweb/Chapter 5/HTML Formats.w"
;
	
{
#line 19 "inweb/Chapter 5/HTML Formats.w"
	weave_format *wf = Formats__create_weave_format(TL_IS_2956, TL_IS_2957);
	METHOD_ADD(wf, RENDER_FOR_MTID, HTMLFormat__render_EPUB);
	METHOD_ADD(wf, BEGIN_WEAVING_FOR_MTID, HTMLFormat__begin_weaving_EPUB);
	METHOD_ADD(wf, END_WEAVING_FOR_MTID, HTMLFormat__end_weaving_EPUB);

}
#line 11 "inweb/Chapter 5/HTML Formats.w"
;
}

#line 41 "inweb/Chapter 5/HTML Formats.w"

#line 45 "inweb/Chapter 5/HTML Formats.w"
HTML_render_state HTMLFormat__initial_state(text_stream *OUT, weave_order *wv,
	int EPUB_mode, filename *into) {
	HTML_render_state hrs;
	hrs.OUT = OUT;
	hrs.into_file = into;
	hrs.wv = wv;
	hrs.EPUB_flag = EPUB_mode;
	hrs.popup_counter = 1;
	hrs.carousel_number = 1;
	hrs.slide_number = -1;
	hrs.slide_of = -1;
	hrs.copy_rule = Assets__new_rule(NULL, TL_IS_2958, TL_IS_2959, NULL);

	Swarm__ensure_plugin(wv, TL_IS_2960);
	hrs.colours = Swarm__ensure_colour_scheme(wv, TL_IS_2961, TL_IS_2962);
	return hrs;
}

#line 67 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__render(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	HTML__declare_as_HTML(OUT, FALSE);
	HTML_render_state hrs = HTMLFormat__initial_state(OUT, C->wv, FALSE, C->wv->weave_to);
	Trees__traverse_from(tree->root, &HTMLFormat__render_visit, (void *) &hrs, 0);
	HTML__completed(OUT);
}
void HTMLFormat__render_EPUB(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	HTML__declare_as_HTML(OUT, TRUE);
	HTML_render_state hrs = HTMLFormat__initial_state(OUT, C->wv, TRUE, C->wv->weave_to);
	Trees__traverse_from(tree->root, &HTMLFormat__render_visit, (void *) &hrs, 0);
	Epub__note_page(C->wv->weave_web->as_ebook, C->wv->weave_to, C->wv->booklet_title, TL_IS_2963);
	HTML__completed(OUT);
}

#line 86 "inweb/Chapter 5/HTML Formats.w"
int HTMLFormat__render_visit(tree_node *N, void *state, int L) {
	HTML_render_state *hrs = (HTML_render_state *) state;
	text_stream *OUT = hrs->OUT;
	if ((N->type == weave_document_node_type) ||
		(N->type == weave_body_node_type) ||
		(N->type == weave_chapter_header_node_type) ||
		(N->type == weave_chapter_footer_node_type) ||
		(N->type == weave_pagebreak_node_type) ||
		(N->type == weave_chapter_node_type) ||
		(N->type == weave_chapter_title_page_node_type) ||
		(N->type == weave_grammar_index_node_type)) 
{
#line 907 "inweb/Chapter 5/HTML Formats.w"
	;

}
#line 96 "inweb/Chapter 5/HTML Formats.w"


	else if (N->type == weave_head_node_type) 
{
#line 142 "inweb/Chapter 5/HTML Formats.w"
	weave_head_node *C = RETRIEVE_POINTER_weave_head_node(N->content);
	HTML__comment(OUT, C->banner);

}
#line 98 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_tail_node_type) 
{
#line 282 "inweb/Chapter 5/HTML Formats.w"
	weave_tail_node *C = RETRIEVE_POINTER_weave_tail_node(N->content);
	HTML__comment(OUT, C->rennab);

}
#line 99 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_verbatim_node_type) 
{
#line 867 "inweb/Chapter 5/HTML Formats.w"
	weave_verbatim_node *C = RETRIEVE_POINTER_weave_verbatim_node(N->content);
	WRITE("%S", C->content);

}
#line 100 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_section_header_node_type) 
{
#line 146 "inweb/Chapter 5/HTML Formats.w"
	if (hrs->EPUB_flag == FALSE) {
		weave_section_header_node *C =
			RETRIEVE_POINTER_weave_section_header_node(N->content);
		Swarm__ensure_plugin(hrs->wv, TL_IS_2964);
		HTML_OPEN_WITH("div", "class=\"breadcrumbs\"");
		HTML_OPEN_WITH("ul", "class=\"crumbs\"");
		Colonies__drop_initial_breadcrumbs(OUT,
			hrs->wv->weave_to, hrs->wv->breadcrumbs);
		text_stream *bct = Bibliographic__get_datum(hrs->wv->weave_web->md, TL_IS_2965);
		if (Str__len(Bibliographic__get_datum(hrs->wv->weave_web->md, TL_IS_2966)) > 0)
			bct = Bibliographic__get_datum(hrs->wv->weave_web->md, TL_IS_2967);
		if (hrs->wv->self_contained == FALSE) {
			Colonies__write_breadcrumb(OUT, bct, TL_IS_2968);
			if (hrs->wv->weave_web->md->chaptered) {
				TEMPORARY_TEXT(chapter_link)
				WRITE_TO(chapter_link, "index.html#%s%S",
					(hrs->wv->weave_web->as_ebook)?"C":"",
					C->sect->owning_chapter->md->ch_range);
				Colonies__write_breadcrumb(OUT,
					C->sect->owning_chapter->md->ch_title, chapter_link);
				DISCARD_TEXT(chapter_link)
			}
			Colonies__write_breadcrumb(OUT, C->sect->md->sect_title, NULL);
		} else {
			Colonies__write_breadcrumb(OUT, bct, NULL);
		}
		HTML_CLOSE("ul");
		HTML_CLOSE("div");
	}

}
#line 101 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_section_footer_node_type) 
{
#line 177 "inweb/Chapter 5/HTML Formats.w"
	weave_section_footer_node *C =
		RETRIEVE_POINTER_weave_section_footer_node(N->content);
	int count = 0;
	chapter *Ch;
	section *next_S = NULL, *prev_S = NULL, *last = NULL;
	LOOP_OVER_LINKED_LIST(Ch, chapter, hrs->wv->weave_web->chapters) {
		if (Ch->md->imported == FALSE) {
			section *S;
			LOOP_OVER_LINKED_LIST(S, section, Ch->sections) {
				count ++;
				if (S == C->sect) prev_S = last;
				if (last == C->sect) next_S = S;
				last = S;
			}
		}
	}
	if (count >= 2) {
		HTML_OPEN_WITH("nav", "role=\"progress\"");
		HTML_OPEN_WITH("div", "class=\"progresscontainer\"");
		HTML_OPEN_WITH("ul", "class=\"progressbar\"");
		
{
#line 260 "inweb/Chapter 5/HTML Formats.w"
	if (prev_S) HTML_OPEN_WITH("li", "class=\"progressprev\"")
	else HTML_OPEN_WITH("li", "class=\"progressprevoff\"");
	TEMPORARY_TEXT(TEMP)
	if (prev_S) Colonies__section_URL(TEMP, prev_S->md);
	if (prev_S) HTML__begin_link(OUT, TEMP);
	WRITE("&#10094;");
	if (prev_S) HTML__end_link(OUT);
	DISCARD_TEXT(TEMP)
	HTML_CLOSE("li");

}
#line 197 "inweb/Chapter 5/HTML Formats.w"
;
		chapter *Ch;
		LOOP_OVER_LINKED_LIST(Ch, chapter, hrs->wv->weave_web->chapters) {
			if (Ch->md->imported == FALSE) {
				if (Str__ne(Ch->md->ch_range, TL_IS_2969)) {
					if (Ch == C->sect->owning_chapter) {
						HTML_OPEN_WITH("li", "class=\"progresscurrentchapter\"");
					} else {
						HTML_OPEN_WITH("li", "class=\"progresschapter\"");
					}
					section *S = FIRST_IN_LINKED_LIST(section, Ch->sections);
					if (S) {
						TEMPORARY_TEXT(TEMP)
						Colonies__section_URL(TEMP, S->md);
						if (Ch != C->sect->owning_chapter) {
							HTML__begin_link(OUT, TEMP);
						}
						WRITE("%S", Ch->md->ch_range);
						if (Ch != C->sect->owning_chapter) {
							HTML__end_link(OUT);
						}
						DISCARD_TEXT(TEMP)
					}
					HTML_CLOSE("li");
				}
				if (Ch == C->sect->owning_chapter) {
					section *S;
					LOOP_OVER_LINKED_LIST(S, section, Ch->sections) {
						TEMPORARY_TEXT(label)
						int on = FALSE;
						LOOP_THROUGH_TEXT(pos, S->md->sect_range) {
							if (Str__get(pos) == '/') on = TRUE;
							else if (on) PUT_TO(label, Str__get(pos));
						}
						if (Str__eq(Bibliographic__get_datum(hrs->wv->weave_web->md,
							TL_IS_2970), TL_IS_2971))
							Str__delete_first_character(label);
						if (S == C->sect) {
							HTML_OPEN_WITH("li", "class=\"progresscurrent\"");
							WRITE("%S", label);
							HTML_CLOSE("li");
						} else {
							HTML_OPEN_WITH("li", "class=\"progresssection\"");
							TEMPORARY_TEXT(TEMP)
							Colonies__section_URL(TEMP, S->md);
							HTML__begin_link(OUT, TEMP);
							WRITE("%S", label);
							HTML__end_link(OUT);
							DISCARD_TEXT(TEMP)
							HTML_CLOSE("li");
						}
						DISCARD_TEXT(label)
					}
				}
			}
		}
		
{
#line 271 "inweb/Chapter 5/HTML Formats.w"
	if (next_S) HTML_OPEN_WITH("li", "class=\"progressnext\"")
	else HTML_OPEN_WITH("li", "class=\"progressnextoff\"");
	TEMPORARY_TEXT(TEMP)
	if (next_S) Colonies__section_URL(TEMP, next_S->md);
	if (next_S) HTML__begin_link(OUT, TEMP);
	WRITE("&#10095;");
	if (next_S) HTML__end_link(OUT);
	DISCARD_TEXT(TEMP)
	HTML_CLOSE("li");

}
#line 253 "inweb/Chapter 5/HTML Formats.w"
;
		HTML_CLOSE("ul");
		HTML_CLOSE("div");
		HTML_CLOSE("nav");
	}

}
#line 102 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_section_purpose_node_type) 
{
#line 286 "inweb/Chapter 5/HTML Formats.w"
	weave_section_purpose_node *C =
		RETRIEVE_POINTER_weave_section_purpose_node(N->content);
	HTML_OPEN_WITH("p", "class=\"purpose\"");
	HTMLFormat__escape_text(OUT, C->purpose);
	HTML_CLOSE("p"); WRITE("\n");

}
#line 103 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_subheading_node_type) 
{
#line 293 "inweb/Chapter 5/HTML Formats.w"
	weave_subheading_node *C = RETRIEVE_POINTER_weave_subheading_node(N->content);
	HTML_OPEN("h3");
	HTMLFormat__escape_text(OUT, C->text);
	HTML_CLOSE("h3"); WRITE("\n");

}
#line 104 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_bar_node_type) 
{
#line 299 "inweb/Chapter 5/HTML Formats.w"
	HTML__hr(OUT, NULL);

}
#line 105 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_paragraph_heading_node_type) 
{
#line 302 "inweb/Chapter 5/HTML Formats.w"
	weave_paragraph_heading_node *C =
		RETRIEVE_POINTER_weave_paragraph_heading_node(N->content);
	paragraph *P = C->para;
	if (P == NULL) internal_error("no para");
	if (N->child == NULL) {
		paragraph *first_in_para = P;
		
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 308 "inweb/Chapter 5/HTML Formats.w"
;
	}

}
#line 106 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_endnote_node_type) 
{
#line 312 "inweb/Chapter 5/HTML Formats.w"
	HTML_OPEN("li");
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 313 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("li");
	return FALSE;

}
#line 107 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_figure_node_type) 
{
#line 318 "inweb/Chapter 5/HTML Formats.w"
	weave_figure_node *C = RETRIEVE_POINTER_weave_figure_node(N->content);
	filename *F = Filenames__in(
		Pathnames__down(hrs->wv->weave_web->md->path_to_web, TL_IS_2972),
		C->figname);
	filename *RF = Filenames__from_text(C->figname);
	HTML_OPEN_WITH("p", "class=\"center-p\"");
	HTML__image_to_dimensions(OUT, RF, C->w, C->h);
	Assets__include_asset(OUT, hrs->copy_rule, hrs->wv->weave_web, F, NULL,
		hrs->wv->pattern, hrs->wv->weave_to);
	HTML_CLOSE("p");
	WRITE("\n");

}
#line 108 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_extract_node_type) 
{
#line 331 "inweb/Chapter 5/HTML Formats.w"
	weave_extract_node *C = RETRIEVE_POINTER_weave_extract_node(N->content);
	filename *F = Filenames__in(
		Pathnames__down(hrs->wv->weave_web->md->path_to_web, TL_IS_2973),
		C->extract);
	HTML_OPEN_WITH("div", "class=\"inweb-extract\"");
	FILE *B = BinaryFiles__try_to_open_for_reading(F);
	if (B == NULL) {
		Main__error_in_web(TL_IS_2974,
			hrs->wv->current_weave_line);
	} else {
		while (TRUE) {
			int c = getc(B);
			if (c == EOF) break;
			PUT((inchar32_t) c);
		}
		BinaryFiles__close(B);
	}
	HTML_CLOSE("div");
	WRITE("\n");

}
#line 109 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_audio_node_type) 
{
#line 352 "inweb/Chapter 5/HTML Formats.w"
	weave_audio_node *C = RETRIEVE_POINTER_weave_audio_node(N->content);
	filename *F = Filenames__in(
		Pathnames__down(hrs->wv->weave_web->md->path_to_web, TL_IS_2975),
		C->audio_name);
	Assets__include_asset(OUT, hrs->copy_rule, hrs->wv->weave_web, F, NULL,
		hrs->wv->pattern, hrs->wv->weave_to);
	HTML_OPEN_WITH("p", "class=\"center-p\"");
	WRITE("<audio controls>\n");
	WRITE("<source src=\"%S\" type=\"audio/mpeg\">\n", C->audio_name);
	WRITE("Your browser does not support the audio element.\n");
	WRITE("</audio>\n");
	HTML_CLOSE("p");
	WRITE("\n");

}
#line 110 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_video_node_type) 
{
#line 367 "inweb/Chapter 5/HTML Formats.w"
	weave_video_node *C = RETRIEVE_POINTER_weave_video_node(N->content);
	filename *F = Filenames__in(
		Pathnames__down(hrs->wv->weave_web->md->path_to_web, TL_IS_2976),
		C->video_name);
	Assets__include_asset(OUT, hrs->copy_rule, hrs->wv->weave_web, F, NULL,
		hrs->wv->pattern, hrs->wv->weave_to);
	HTML_OPEN_WITH("p", "class=\"center-p\"");
	if ((C->w > 0) && (C->h > 0))
		WRITE("<video width=\"%d\" height=\"%d\" controls>", C->w, C->h);
	else if (C->w > 0)
		WRITE("<video width=\"%d\" controls>", C->w);
	else if (C->h > 0)
		WRITE("<video height=\"%d\" controls>", C->h);
	else
		WRITE("<video controls>");
	WRITE("<source src=\"%S\" type=\"video/mp4\">\n", C->video_name);
	WRITE("Your browser does not support the video tag.\n");
	WRITE("</video>\n");
	HTML_CLOSE("p");
	WRITE("\n");

}
#line 111 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_download_node_type) 
{
#line 389 "inweb/Chapter 5/HTML Formats.w"
	weave_download_node *C = RETRIEVE_POINTER_weave_download_node(N->content);
	pathname *P = Pathnames__down(hrs->wv->weave_web->md->path_to_web, TL_IS_2977);
	filename *F = Filenames__in(P, C->download_name);
	filename *TF = Patterns__find_file_in_subdirectory(hrs->wv->pattern, TL_IS_2978,
		TL_IS_2979);
	if (TF == NULL) {
		Main__error_in_web(TL_IS_2980, hrs->wv->current_weave_line);
	} else {
		Swarm__ensure_plugin(hrs->wv, TL_IS_2981);
		pathname *TOP =
			Assets__include_asset(OUT, hrs->copy_rule, hrs->wv->weave_web, F, NULL,
				hrs->wv->pattern, hrs->wv->weave_to);
		if (TOP == NULL) TOP = Filenames__up(F);
		TEMPORARY_TEXT(url)
		TEMPORARY_TEXT(size)
		Pathnames__relative_URL(url, Filenames__up(hrs->wv->weave_to), TOP);
		WRITE_TO(url, "%S", Filenames__get_leafname(F));
		int N = Filenames__size(F);
		if (N > 0) 
{
#line 423 "inweb/Chapter 5/HTML Formats.w"
	WRITE_TO(size, " (");
	if (Str__len(C->filetype) > 0) WRITE_TO(size, "%S, ", C->filetype);
	int x = 0, y = 0;
	text_stream *unit = TL_IS_2986; x = N; y = 0;
	if (N > 1) { unit = TL_IS_2987; }
	if (N >= 1024) { unit = TL_IS_2988; x = 10*N/1024; y = x%10; x = x/10; }
	if (N >= 1024*1024) { unit = TL_IS_2989; x = 10*N/1024/1024; y = x%10; x = x/10; }
	if (N >= 1024*1024*1024) { unit = TL_IS_2990; x = 10*N/1024/1024/1024; y = x%10; x = x/10; }
	WRITE_TO(size, "%d", x);
	if (y > 0) WRITE_TO(size, ".%d", y);
	WRITE_TO(size, "%S", unit);
	WRITE_TO(size, ")");

}
#line 407 "inweb/Chapter 5/HTML Formats.w"

		else Main__error_in_web(TL_IS_2982,
				hrs->wv->current_weave_line);
		filename *D = Filenames__from_text(C->download_name);
		Bibliographic__set_datum(hrs->wv->weave_web->md, TL_IS_2983,
			Filenames__get_leafname(D));
		Bibliographic__set_datum(hrs->wv->weave_web->md, TL_IS_2984, url);
		Bibliographic__set_datum(hrs->wv->weave_web->md, TL_IS_2985, size);
		Collater__for_web_and_pattern(OUT, hrs->wv->weave_web, hrs->wv->pattern,
			TF, hrs->into_file);
		WRITE("\n");
		DISCARD_TEXT(url)
		DISCARD_TEXT(size)
	}

}
#line 112 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_material_node_type) 
{
#line 437 "inweb/Chapter 5/HTML Formats.w"
	weave_material_node *C = RETRIEVE_POINTER_weave_material_node(N->content);
	paragraph *first_in_para = NULL;
	if ((N == N->parent->child) &&
		(N->parent->type == weave_paragraph_heading_node_type)) {
		weave_paragraph_heading_node *PC =
			RETRIEVE_POINTER_weave_paragraph_heading_node(N->parent->content);
		first_in_para = PC->para;
	}
	if (C->material_type == COMMENTARY_MATERIAL)
		
{
#line 468 "inweb/Chapter 5/HTML Formats.w"
	int item_depth = 0;
	for (tree_node *M = N->child; M; M = M->next) {
		if (M->type == weave_item_node_type) {
			
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 471 "inweb/Chapter 5/HTML Formats.w"
;
			weave_item_node *C = RETRIEVE_POINTER_weave_item_node(M->content);
			HTMLFormat__go_to_depth(hrs, item_depth, C->depth);
			item_depth = C->depth;
			Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);
			continue;
		}
		if (HTMLFormat__interior_material(M)) 
{
#line 493 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		first_in_para = NULL;
	} else {
		if (item_depth == 0) HTML_OPEN_WITH("p", "class=\"commentary\"");
	}
	while (M) {
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);
		if ((M->next == NULL) || (HTMLFormat__interior_material(M->next) == FALSE)) break;
		M = M->next;
	}
	if (item_depth == 0) { HTML_CLOSE("p"); WRITE("\n"); }
	continue;

}
#line 478 "inweb/Chapter 5/HTML Formats.w"
;
		
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 479 "inweb/Chapter 5/HTML Formats.w"
;
		if (item_depth > 0) {
			HTMLFormat__go_to_depth(hrs, item_depth, 0);
			item_depth = 0;
		}
		if (M->type == weave_vskip_node_type) continue;
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);
	}
	if (item_depth > 0) {
		HTMLFormat__go_to_depth(hrs, item_depth, 0);
		item_depth = 0;
	}

}
#line 446 "inweb/Chapter 5/HTML Formats.w"

	else if (C->material_type == CODE_MATERIAL)
		
{
#line 509 "inweb/Chapter 5/HTML Formats.w"
	
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 509 "inweb/Chapter 5/HTML Formats.w"
;
	if (C->styling) {
		TEMPORARY_TEXT(csname)
		WRITE_TO(csname, "%S-Colours", C->styling->language_name);
		hrs->colours = Swarm__ensure_colour_scheme(hrs->wv,
			csname, C->styling->language_name);
		DISCARD_TEXT(csname)
	}
	TEMPORARY_TEXT(cl)
	WRITE_TO(cl, "%S", hrs->colours->prefix);
	if (C->plainly) WRITE_TO(cl, "undisplayed-code");
	else WRITE_TO(cl, "displayed-code");
	WRITE("<pre class=\"%S all-displayed-code code-font\">\n", cl);
	DISCARD_TEXT(cl)
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 523 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("pre"); WRITE("\n");
	if (Str__len(C->endnote) > 0) {
		HTML_OPEN_WITH("ul", "class=\"endnotetexts\"");
		HTML_OPEN("li");
		HTMLFormat__escape_text(OUT, C->endnote);
		HTML_CLOSE("li");
		HTML_CLOSE("ul"); WRITE("\n");
	}

}
#line 448 "inweb/Chapter 5/HTML Formats.w"

	else if (C->material_type == FOOTNOTES_MATERIAL)
		
{
#line 534 "inweb/Chapter 5/HTML Formats.w"
	
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 534 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_OPEN_WITH("ul", "class=\"footnotetexts\"");
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 536 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("ul"); WRITE("\n");

}
#line 450 "inweb/Chapter 5/HTML Formats.w"

	else if (C->material_type == ENDNOTES_MATERIAL)
		
{
#line 540 "inweb/Chapter 5/HTML Formats.w"
	
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 540 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_OPEN_WITH("ul", "class=\"endnotetexts\"");
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 542 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("ul"); WRITE("\n");

}
#line 452 "inweb/Chapter 5/HTML Formats.w"

	else if (C->material_type == MACRO_MATERIAL)
		
{
#line 546 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
	} else {
		HTML_OPEN_WITH("p", "class=\"commentary\"");
	}
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 552 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("p"); WRITE("\n");

}
#line 454 "inweb/Chapter 5/HTML Formats.w"

	else if (C->material_type == DEFINITION_MATERIAL)
		
{
#line 556 "inweb/Chapter 5/HTML Formats.w"
	
{
#line 460 "inweb/Chapter 5/HTML Formats.w"
	if (first_in_para) {
		HTML_OPEN_WITH("p", "class=\"commentary firstcommentary\"");
		HTMLFormat__paragraph_number(OUT, first_in_para);
		HTML_CLOSE("p"); WRITE("\n");
		first_in_para = NULL;
	}

}
#line 556 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_OPEN_WITH("pre", "class=\"definitions code-font\"");
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 558 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("pre"); WRITE("\n");

}
#line 456 "inweb/Chapter 5/HTML Formats.w"
;
	return FALSE;

}
#line 113 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_embed_node_type) 
{
#line 566 "inweb/Chapter 5/HTML Formats.w"
	weave_embed_node *C = RETRIEVE_POINTER_weave_embed_node(N->content);
	text_stream *CH = TL_IS_2991;
	text_stream *CW = TL_IS_2992;
	if (C->w > 0) { Str__clear(CW); WRITE_TO(CW, "%d", C->w); }
	if (C->h > 0) { Str__clear(CH); WRITE_TO(CH, "%d", C->h); }
	TEMPORARY_TEXT(embed_leaf)
	WRITE_TO(embed_leaf, "%S.html", C->service);
	filename *F = Patterns__find_file_in_subdirectory(hrs->wv->pattern, TL_IS_2993, embed_leaf);
	DISCARD_TEXT(embed_leaf)
	if (F == NULL) {
		Main__error_in_web(TL_IS_2994, hrs->wv->current_weave_line);
	} else {
		Bibliographic__set_datum(hrs->wv->weave_web->md, TL_IS_2995, C->ID);
		Bibliographic__set_datum(hrs->wv->weave_web->md, TL_IS_2996, CW);
		Bibliographic__set_datum(hrs->wv->weave_web->md, TL_IS_2997, CH);
		HTML_OPEN_WITH("p", "class=\"center-p\"");
		Collater__for_web_and_pattern(OUT, hrs->wv->weave_web, hrs->wv->pattern,
			F, hrs->into_file);
		HTML_CLOSE("p");
		WRITE("\n");
	}

}
#line 114 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_pmac_node_type) 
{
#line 589 "inweb/Chapter 5/HTML Formats.w"
	weave_pmac_node *C = RETRIEVE_POINTER_weave_pmac_node(N->content);
	paragraph *P = C->pmac->defining_paragraph;
	HTML_OPEN_WITH("span", "class=\"named-paragraph-container code-font\"");
	if (C->defn == FALSE) {
		TEMPORARY_TEXT(url)
		Colonies__paragraph_URL(url, P, hrs->wv->weave_to);
		HTML__begin_link_with_class(OUT, TL_IS_2998, url);
		DISCARD_TEXT(url)
	}
	HTML_OPEN_WITH("span", "class=\"%s\"",
		(C->defn)?"named-paragraph-defn":"named-paragraph");
	HTMLFormat__escape_text(OUT, C->pmac->macro_name);
	HTML_CLOSE("span");
	HTML_OPEN_WITH("span", "class=\"named-paragraph-number\"");
	HTMLFormat__escape_text(OUT, P->paragraph_number);
	HTML_CLOSE("span");
	if (C->defn == FALSE) HTML__end_link(OUT);
	HTML_CLOSE("span");
	if (C->defn) {
		HTMLFormat__change_colour(OUT, COMMENT_COLOUR, hrs->colours);
		WRITE(" =");
		HTMLFormat__change_colour(OUT, -1, hrs->colours);
	}

}
#line 115 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_vskip_node_type) 
{
#line 614 "inweb/Chapter 5/HTML Formats.w"
	WRITE("\n");

}
#line 116 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_section_node_type) 
{
#line 617 "inweb/Chapter 5/HTML Formats.w"
	weave_section_node *C = RETRIEVE_POINTER_weave_section_node(N->content);
	LOG("It was %d\n", C->allocation_id);

}
#line 117 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_code_line_node_type) 
{
#line 621 "inweb/Chapter 5/HTML Formats.w"
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 621 "inweb/Chapter 5/HTML Formats.w"
;
	WRITE("\n");
	return FALSE;

}
#line 118 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_function_usage_node_type) 
{
#line 626 "inweb/Chapter 5/HTML Formats.w"
	weave_function_usage_node *C = RETRIEVE_POINTER_weave_function_usage_node(N->content);
	HTML__begin_link_with_class(OUT, TL_IS_2999, C->url);
	HTMLFormat__change_colour(OUT, FUNCTION_COLOUR, hrs->colours);
	WRITE("%S", C->fn->function_name);
	HTMLFormat__change_colour(OUT, -1, hrs->colours);
	HTML__end_link(OUT);

}
#line 119 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_commentary_node_type) 
{
#line 634 "inweb/Chapter 5/HTML Formats.w"
	weave_commentary_node *C = RETRIEVE_POINTER_weave_commentary_node(N->content);
	if (C->in_code) HTMLFormat__change_colour(OUT, COMMENT_COLOUR, hrs->colours);
	for (int i=0; i < Str__len(C->text); i++) {
		if (Str__get_at(C->text, i) == '&') WRITE("&amp;");
		else if (Str__get_at(C->text, i) == '<') WRITE("&lt;");
		else if (Str__get_at(C->text, i) == '>') WRITE("&gt;");
		else if ((i == 0) && (Str__get_at(C->text, i) == '-') &&
			(Str__get_at(C->text, i+1) == '-') &&
			((Str__get_at(C->text, i+2) == ' ') || (Str__get_at(C->text, i+2) == 0))) {
			WRITE("&mdash;"); i++;
		} else if ((Str__get_at(C->text, i) == ' ') && (Str__get_at(C->text, i+1) == '-') &&
			(Str__get_at(C->text, i+2) == '-') &&
			((Str__get_at(C->text, i+3) == ' ') || (Str__get_at(C->text, i+3) == '\n') ||
			(Str__get_at(C->text, i+3) == 0))) {
			WRITE(" &mdash;"); i+=2;
		} else PUT(Str__get_at(C->text, i));
	}
	if (C->in_code) HTMLFormat__change_colour(OUT, -1, hrs->colours);

}
#line 120 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_carousel_slide_node_type) 
{
#line 654 "inweb/Chapter 5/HTML Formats.w"
	weave_carousel_slide_node *C = RETRIEVE_POINTER_weave_carousel_slide_node(N->content);
	Swarm__ensure_plugin(hrs->wv, TL_IS_3000);
	TEMPORARY_TEXT(carousel_id)
	TEMPORARY_TEXT(carousel_dots_id)
	text_stream *caption_class = NULL;
	text_stream *slide_count_class = TL_IS_3001;
	switch (C->caption_command) {
		case CAROUSEL_CMD: caption_class = TL_IS_3002; break;
		case CAROUSEL_ABOVE_CMD: caption_class = TL_IS_3003;
			slide_count_class = TL_IS_3004; break;
		case CAROUSEL_BELOW_CMD: caption_class = TL_IS_3005;
			slide_count_class = TL_IS_3006; break;
	}
	WRITE_TO(carousel_id, "carousel-no-%d", hrs->carousel_number);
	WRITE_TO(carousel_dots_id, "carousel-dots-no-%d", hrs->carousel_number);
	if (hrs->slide_number == -1) {
		hrs->slide_number = 1;
		hrs->slide_of = 0;
		for (tree_node *X = N; (X) && (X->type == N->type); X = X->next) hrs->slide_of++;
	} else {
		hrs->slide_number++;
		if (hrs->slide_number > hrs->slide_of) internal_error("miscounted slides");
	}
	if (hrs->slide_number == 1) {
		WRITE("<div class=\"carousel-container\" id=\"%S\">\n", carousel_id);
	}
	WRITE("<div class=\"carousel-slide fading-slide\"");
	if (hrs->slide_number == 1) WRITE(" style=\"display: block;\"");
	else WRITE(" style=\"display: none;\"");
	WRITE(">\n");
	if (C->caption_command == CAROUSEL_ABOVE_CMD) {
		
{
#line 727 "inweb/Chapter 5/HTML Formats.w"
	if (C->caption_command != CAROUSEL_UNCAPTIONED_CMD)
		WRITE("<div class=\"%S\">%S</div>\n", caption_class, C->caption);

}
#line 685 "inweb/Chapter 5/HTML Formats.w"
;
		WRITE("<div class=\"%S\">%d / %d</div>\n",
			slide_count_class, hrs->slide_number, hrs->slide_of);
	} else {
		WRITE("<div class=\"%S\">%d / %d</div>\n",
			slide_count_class, hrs->slide_number, hrs->slide_of);
	}
	WRITE("<div class=\"carousel-content\">");
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 693 "inweb/Chapter 5/HTML Formats.w"
;
	WRITE("</div>\n");
	if (C->caption_command != CAROUSEL_ABOVE_CMD) 
{
#line 727 "inweb/Chapter 5/HTML Formats.w"
	if (C->caption_command != CAROUSEL_UNCAPTIONED_CMD)
		WRITE("<div class=\"%S\">%S</div>\n", caption_class, C->caption);

}
#line 695 "inweb/Chapter 5/HTML Formats.w"
;
	WRITE("</div>\n");
	if (hrs->slide_number == hrs->slide_of) {
		WRITE("<a class=\"carousel-prev-button\" ");
		WRITE("onclick=\"carouselMoveSlide(&quot;%S&quot;, &quot;%S&quot;, -1)\"",
			carousel_id, carousel_dots_id);
		WRITE(">&#10094;</a>\n");
		WRITE("<a class=\"carousel-next-button\" ");
		WRITE("onclick=\"carouselMoveSlide(&quot;%S&quot;, &quot;%S&quot;, 1)\"",
			carousel_id, carousel_dots_id);
		WRITE(">&#10095;</a>\n");
		WRITE("</div>\n");
		WRITE("<div class=\"carousel-dots-container\" id=\"%S\">\n", carousel_dots_id);
		for (int i=1; i<=hrs->slide_of; i++) {
			if (i == 1)
				WRITE("<span class=\"carousel-dot carousel-dot-active\" ");
			else
				WRITE("<span class=\"carousel-dot\" ");
			WRITE("onclick=\"carouselSetSlide(&quot;%S&quot;, &quot;%S&quot;, %d)\"",
				carousel_id, carousel_dots_id, i-1);
			WRITE("></span>\n");
		}
		WRITE("</div>\n");
		hrs->slide_number = -1;
		hrs->slide_of = -1;
		hrs->carousel_number++;
	}
	DISCARD_TEXT(carousel_id)
	DISCARD_TEXT(carousel_dots_id)
	return FALSE;

}
#line 121 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_toc_node_type) 
{
#line 731 "inweb/Chapter 5/HTML Formats.w"
	HTML_OPEN_WITH("ul", "class=\"toc\"");
	for (tree_node *M = N->child; M; M = M->next) {
		HTML_OPEN("li");
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);
		HTML_CLOSE("li");
	}
	HTML_CLOSE("ul");
	HTML__hr(OUT, "tocbar");
	WRITE("\n");
	return FALSE;

}
#line 122 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_toc_line_node_type) 
{
#line 743 "inweb/Chapter 5/HTML Formats.w"
	weave_toc_line_node *C = RETRIEVE_POINTER_weave_toc_line_node(N->content);
	TEMPORARY_TEXT(TEMP)
	Colonies__paragraph_URL(TEMP, C->para, hrs->wv->weave_to);
	HTML__begin_link(OUT, TEMP);
	DISCARD_TEXT(TEMP)
	WRITE("%s%S", (Str__get_first_char(C->para->ornament) == 'S')?"&#167;":"&para;",
		C->para->paragraph_number);
	WRITE(". %S", C->text2);
	HTML__end_link(OUT);

}
#line 123 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_defn_node_type) 
{
#line 754 "inweb/Chapter 5/HTML Formats.w"
	weave_defn_node *C = RETRIEVE_POINTER_weave_defn_node(N->content);
	HTML_OPEN_WITH("span", "class=\"definition-keyword\"");
	WRITE("%S", C->keyword);
	HTML_CLOSE("span");
	WRITE(" ");

}
#line 124 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_source_code_node_type) 
{
#line 761 "inweb/Chapter 5/HTML Formats.w"
	weave_source_code_node *C = RETRIEVE_POINTER_weave_source_code_node(N->content);
	int starts = FALSE;
	if (N == N->parent->child) starts = TRUE;
		int current_colour = -1, colour_wanted = PLAIN_COLOUR;
	for (int i=0; i < Str__len(C->matter); i++) {
		colour_wanted = (int) Str__get_at(C->colouring, i);
		if (colour_wanted != current_colour) {
			if (current_colour >= 0) HTML_CLOSE("span");
			HTMLFormat__change_colour(OUT, colour_wanted, hrs->colours);
			current_colour = colour_wanted;
		}
		if (Str__get_at(C->matter, i) == '<') WRITE("&lt;");
		else if (Str__get_at(C->matter, i) == '>') WRITE("&gt;");
		else if (Str__get_at(C->matter, i) == '&') WRITE("&amp;");
		else WRITE("%c", Str__get_at(C->matter, i));
	}
	if (current_colour >= 0) HTMLFormat__change_colour(OUT, -1, hrs->colours);

}
#line 125 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_url_node_type) 
{
#line 780 "inweb/Chapter 5/HTML Formats.w"
	weave_url_node *C = RETRIEVE_POINTER_weave_url_node(N->content);
	HTML__begin_link_with_class(OUT, (C->external)?TL_IS_3007:TL_IS_3008, C->url);
	WRITE("%S", C->content);
	HTML__end_link(OUT);

}
#line 126 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_footnote_cue_node_type) 
{
#line 786 "inweb/Chapter 5/HTML Formats.w"
	weave_footnote_cue_node *C = RETRIEVE_POINTER_weave_footnote_cue_node(N->content);
	text_stream *fn_plugin_name = hrs->wv->pattern->footnotes_plugin;
	if (Str__len(fn_plugin_name) > 0)
		Swarm__ensure_plugin(hrs->wv, fn_plugin_name);
	if (hrs->EPUB_flag) {
		if (N->parent->type != weave_begin_footnote_text_node_type)
			WRITE("<a id=\"fnref%S\"></a>", C->cue_text);
		WRITE("<sup><a href=\"#fn%S\" rel=\"footnote\">%S</a></sup>",
			C->cue_text, C->cue_text);
	} else
		WRITE("<sup id=\"fnref:%S\"><a href=\"#fn:%S\" rel=\"footnote\">%S</a></sup>",
			C->cue_text, C->cue_text, C->cue_text);

}
#line 127 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_begin_footnote_text_node_type) 
{
#line 800 "inweb/Chapter 5/HTML Formats.w"
	weave_begin_footnote_text_node *C =
		RETRIEVE_POINTER_weave_begin_footnote_text_node(N->content);
	text_stream *fn_plugin_name = hrs->wv->pattern->footnotes_plugin;
	if ((Str__len(fn_plugin_name) > 0) && (hrs->EPUB_flag == FALSE))
		Swarm__ensure_plugin(hrs->wv, fn_plugin_name);
	if (hrs->EPUB_flag)
		WRITE("<li class=\"footnote\" id=\"fn%S\"><p class=\"inwebfootnote\">",
			C->cue_text);
	else
		WRITE("<li class=\"footnote\" id=\"fn:%S\"><p class=\"inwebfootnote\">",
			C->cue_text);
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 811 "inweb/Chapter 5/HTML Formats.w"
;
	if (hrs->EPUB_flag)
		WRITE("<a href=\"#fnref%S\"> (return to text)</a></p></li>",
			C->cue_text);
	else
		WRITE("<a href=\"#fnref:%S\" title=\"return to text\"> &#x21A9;</a></p></li>",
			C->cue_text);
	return FALSE;

}
#line 128 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_display_line_node_type) 
{
#line 821 "inweb/Chapter 5/HTML Formats.w"
	weave_display_line_node *C =
		RETRIEVE_POINTER_weave_display_line_node(N->content);
	HTML_OPEN("blockquote"); WRITE("\n"); INDENT;
	HTML_OPEN("p");
	HTMLFormat__escape_text(OUT, C->text);
	HTML_CLOSE("p");
	OUTDENT; HTML_CLOSE("blockquote"); WRITE("\n");

}
#line 129 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_function_defn_node_type) 
{
#line 830 "inweb/Chapter 5/HTML Formats.w"
	weave_function_defn_node *C =
		RETRIEVE_POINTER_weave_function_defn_node(N->content);
	if ((Functions__used_elsewhere(C->fn)) && (hrs->EPUB_flag == FALSE)) {
		Swarm__ensure_plugin(hrs->wv, TL_IS_3009);
		HTMLFormat__change_colour(OUT, FUNCTION_COLOUR, hrs->colours);
		WRITE("%S", C->fn->function_name);
		WRITE("</span>");
		WRITE("<button class=\"popup\" onclick=\"togglePopup('usagePopup%d')\">",
			hrs->popup_counter);
		HTMLFormat__change_colour(OUT, COMMENT_COLOUR, hrs->colours);
		WRITE("?");
		HTMLFormat__change_colour(OUT, -1, hrs->colours);
		WRITE("<span class=\"popuptext\" id=\"usagePopup%d\">Usage of ", hrs->popup_counter);
		HTML_OPEN_WITH("span", "class=\"code-font\"");
		HTMLFormat__change_colour(OUT, FUNCTION_COLOUR, hrs->colours);
		WRITE("%S", C->fn->function_name);
		HTMLFormat__change_colour(OUT, -1, hrs->colours);
		HTML_CLOSE("span");
		WRITE(":<br/>");
		
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 849 "inweb/Chapter 5/HTML Formats.w"
;
		HTMLFormat__change_colour(OUT, -1, hrs->colours);
		WRITE("</button>");
		hrs->popup_counter++;
	} else {
		HTMLFormat__change_colour(OUT, FUNCTION_COLOUR, hrs->colours);
		WRITE("%S", C->fn->function_name);
		HTMLFormat__change_colour(OUT, -1, hrs->colours);
	}
	return FALSE;

}
#line 130 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_item_node_type) 
{
#line 861 "inweb/Chapter 5/HTML Formats.w"
	weave_item_node *C = RETRIEVE_POINTER_weave_item_node(N->content);
	if (Str__eq(C->label, TL_IS_3010)) WRITE("&#9679; ");
	else if (Str__len(C->label) > 0) WRITE("(%S) ", C->label);
	else WRITE(" ");

}
#line 131 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_inline_node_type) 
{
#line 871 "inweb/Chapter 5/HTML Formats.w"
	HTML_OPEN_WITH("span", "class=\"extract\"");
	
{
#line 910 "inweb/Chapter 5/HTML Formats.w"
	for (tree_node *M = N->child; M; M = M->next)
		Trees__traverse_from(M, &HTMLFormat__render_visit, (void *) hrs, L+1);

}
#line 872 "inweb/Chapter 5/HTML Formats.w"
;
	HTML_CLOSE("span");
	return FALSE;

}
#line 132 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_locale_node_type) 
{
#line 877 "inweb/Chapter 5/HTML Formats.w"
	weave_locale_node *C = RETRIEVE_POINTER_weave_locale_node(N->content);
	TEMPORARY_TEXT(TEMP)
	Colonies__paragraph_URL(TEMP, C->par1, hrs->wv->weave_to);
	HTML__begin_link(OUT, TEMP);
	DISCARD_TEXT(TEMP)
	WRITE("%s%S",
		(Str__get_first_char(C->par1->ornament) == 'S')?"&#167;":"&para;",
		C->par1->paragraph_number);
	if (C->par2) WRITE("-%S", C->par2->paragraph_number);
	HTML__end_link(OUT);

}
#line 133 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_maths_node_type) 
{
#line 889 "inweb/Chapter 5/HTML Formats.w"
	weave_maths_node *C = RETRIEVE_POINTER_weave_maths_node(N->content);
	text_stream *plugin_name = hrs->wv->pattern->mathematics_plugin;
	if ((Str__len(plugin_name) == 0) || (hrs->EPUB_flag)) {
		TEMPORARY_TEXT(R)
		TeXUtilities__remove_math_mode(R, C->content);
		HTMLFormat__escape_text(OUT, R);
		DISCARD_TEXT(R)
	} else {
		Swarm__ensure_plugin(hrs->wv, plugin_name);
		if (C->displayed) WRITE("$$"); else WRITE("\\(");
		HTMLFormat__escape_text(OUT, C->content);
		if (C->displayed) WRITE("$$"); else WRITE("\\)");
	}

}
#line 134 "inweb/Chapter 5/HTML Formats.w"

	else if (N->type == weave_linebreak_node_type) 
{
#line 904 "inweb/Chapter 5/HTML Formats.w"
	WRITE("<br/>");

}
#line 135 "inweb/Chapter 5/HTML Formats.w"


	else internal_error("unable to render unknown node");
	return TRUE;
}

#line 917 "inweb/Chapter 5/HTML Formats.w"
int HTMLFormat__interior_material(tree_node *N) {
	if (N->type == weave_commentary_node_type) return TRUE;
	if (N->type == weave_url_node_type) return TRUE;
	if (N->type == weave_inline_node_type) return TRUE;
	if (N->type == weave_locale_node_type) return TRUE;
	if (N->type == weave_maths_node_type) return TRUE;
	if (N->type == weave_footnote_cue_node_type) return TRUE;
	return FALSE;
}

#line 931 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__go_to_depth(HTML_render_state *hrs, int from_depth, int to_depth) {
	text_stream *OUT = hrs->OUT;
	if (from_depth == to_depth) {
		HTML_CLOSE("li");
	} else {
		while (from_depth < to_depth) {
			HTML_OPEN_WITH("ul", "class=\"items\""); from_depth++;
		}
		while (from_depth > to_depth) {
			HTML_CLOSE("li");
			HTML_CLOSE("ul");
			WRITE("\n"); from_depth--;
		}
	}
	if (to_depth > 0) HTML_OPEN("li");
}

#line 949 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__paragraph_number(text_stream *OUT, paragraph *P) {
	TEMPORARY_TEXT(TEMP)
	Colonies__paragraph_anchor(TEMP, P);
	HTML__anchor_with_class(OUT, TEMP, TL_IS_3011);
	DISCARD_TEXT(TEMP)
	if (P->invisible == FALSE) {
		HTML_OPEN("b");
		WRITE("%s%S", (Str__get_first_char(P->ornament) == 'S')?"&#167;":"&para;",
			P->paragraph_number);
		WRITE(". %S%s ", P->heading_text, (Str__len(P->heading_text) > 0)?".":"");
		HTML_CLOSE("b");
	}
}

#line 964 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__change_colour(text_stream *OUT, int col, colour_scheme *cs) {
	if (col == -1) {
		HTML_CLOSE("span");
	} else {
		char *cl = "plain";
		switch (col) {
			case DEFINITION_COLOUR: 	cl = "definition-syntax"; break;
			case FUNCTION_COLOUR: 		cl = "function-syntax"; break;
			case IDENTIFIER_COLOUR: 	cl = "identifier-syntax"; break;
			case ELEMENT_COLOUR:		cl = "element-syntax"; break;
			case RESERVED_COLOUR: 		cl = "reserved-syntax"; break;
			case STRING_COLOUR: 		cl = "string-syntax"; break;
			case CHARACTER_COLOUR:      cl = "character-syntax"; break;
			case CONSTANT_COLOUR: 		cl = "constant-syntax"; break;
			case PLAIN_COLOUR: 			cl = "plain-syntax"; break;
			case EXTRACT_COLOUR: 		cl = "extract-syntax"; break;
			case COMMENT_COLOUR: 		cl = "comment-syntax"; break;
			default: PRINT("col: %d\n", col); internal_error("bad colour"); break;
		}
		HTML_OPEN_WITH("span", "class=\"%S%s\"", cs->prefix, cl);
	}
}

#line 988 "inweb/Chapter 5/HTML Formats.w"
void HTMLFormat__escape_text(text_stream *OUT, text_stream *id) {
	for (int i=0; i < Str__len(id); i++) {
		if (Str__get_at(id, i) == '&') WRITE("&amp;");
		else if (Str__get_at(id, i) == '<') WRITE("&lt;");
		else if (Str__get_at(id, i) == '>') WRITE("&gt;");
		else PUT(Str__get_at(id, i));
	}
}

#line 1000 "inweb/Chapter 5/HTML Formats.w"
int HTMLFormat__begin_weaving_EPUB(weave_format *wf, web *W, weave_pattern *pattern) {
	TEMPORARY_TEXT(T)
	WRITE_TO(T, "%S", Bibliographic__get_datum(W->md, TL_IS_3012));
	W->as_ebook = Epub__new(T, "P");
	filename *CSS = Patterns__find_file_in_subdirectory(pattern, TL_IS_3013, TL_IS_3014);
	Epub__use_CSS_throughout(W->as_ebook, CSS);
	Epub__attach_metadata(W->as_ebook, U"identifier", T);
	DISCARD_TEXT(T)

	pathname *P = Reader__woven_folder(W);
	W->redirect_weaves_to = Epub__begin_construction(W->as_ebook, P, NULL);
	Shell__copy(CSS, W->redirect_weaves_to, "");
	return SWARM_SECTIONS_SWM;
}

void HTMLFormat__end_weaving_EPUB(weave_format *wf, web *W, weave_pattern *pattern) {
	Epub__end_construction(W->as_ebook);
}

#line 9 "inweb/Chapter 5/Debugging Format.w"
void Debugging__create(void) {
	weave_format *wf = Formats__create_weave_format(TL_IS_3015, TL_IS_3016);
	METHOD_ADD(wf, RENDER_FOR_MTID, Debugging__render);
}

#line 22 "inweb/Chapter 5/Debugging Format.w"

void Debugging__render(weave_format *self, text_stream *OUT, heterogeneous_tree *tree) {
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(tree->root->content);
	debugging_render_state drs;
	drs.OUT = OUT;
	drs.wv = C->wv;
	Trees__traverse_from(tree->root, &Debugging__render_visit, (void *) &drs, 0);
}

int Debugging__render_visit(tree_node *N, void *state, int L) {
	debugging_render_state *drs = (debugging_render_state *) state;
	text_stream *OUT = drs->OUT;
	for (int i=0; i<L; i++) WRITE("  ");
	WRITE("%S", N->type->node_type_name);
	if (N->type == weave_document_node_type) 
{
#line 87 "inweb/Chapter 5/Debugging Format.w"
	weave_document_node *C = RETRIEVE_POINTER_weave_document_node(N->content);
	WRITE(" weave order %d", C->wv->allocation_id);

}
#line 36 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_head_node_type) 
{
#line 91 "inweb/Chapter 5/Debugging Format.w"
	weave_head_node *C = RETRIEVE_POINTER_weave_head_node(N->content);
	WRITE(" banner <%S>", C->banner);

}
#line 37 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_body_node_type) 
{
#line 95 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 38 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_tail_node_type) 
{
#line 98 "inweb/Chapter 5/Debugging Format.w"
	weave_tail_node *C = RETRIEVE_POINTER_weave_tail_node(N->content);
	WRITE(" rennab <%S>", C->rennab);

}
#line 39 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_verbatim_node_type) 
{
#line 102 "inweb/Chapter 5/Debugging Format.w"
	weave_verbatim_node *C = RETRIEVE_POINTER_weave_verbatim_node(N->content);
	Debugging__show_text(OUT, C->content, 80);

}
#line 40 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_chapter_header_node_type) 
{
#line 114 "inweb/Chapter 5/Debugging Format.w"
	weave_chapter_header_node *C = RETRIEVE_POINTER_weave_chapter_header_node(N->content);
	WRITE(" <%S>", C->chap->md->ch_title);

}
#line 41 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_chapter_footer_node_type) 
{
#line 118 "inweb/Chapter 5/Debugging Format.w"
	weave_chapter_footer_node *C = RETRIEVE_POINTER_weave_chapter_footer_node(N->content);
	WRITE(" <%S>", C->chap->md->ch_title);

}
#line 42 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_section_header_node_type) 
{
#line 106 "inweb/Chapter 5/Debugging Format.w"
	weave_section_header_node *C = RETRIEVE_POINTER_weave_section_header_node(N->content);
	WRITE(" <%S>", C->sect->md->sect_title);

}
#line 43 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_section_footer_node_type) 
{
#line 110 "inweb/Chapter 5/Debugging Format.w"
	weave_section_footer_node *C = RETRIEVE_POINTER_weave_section_footer_node(N->content);
	WRITE(" <%S>", C->sect->md->sect_title);

}
#line 44 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_section_purpose_node_type) 
{
#line 122 "inweb/Chapter 5/Debugging Format.w"
	weave_section_purpose_node *C = RETRIEVE_POINTER_weave_section_purpose_node(N->content);
	WRITE(" <%S>", C->purpose);

}
#line 45 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_subheading_node_type) 
{
#line 126 "inweb/Chapter 5/Debugging Format.w"
	weave_subheading_node *C = RETRIEVE_POINTER_weave_subheading_node(N->content);
	WRITE(" <%S>", C->text);

}
#line 46 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_bar_node_type) 
{
#line 130 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 47 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_pagebreak_node_type) 
{
#line 133 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 48 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_linebreak_node_type) 
{
#line 136 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 49 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_paragraph_heading_node_type) 
{
#line 139 "inweb/Chapter 5/Debugging Format.w"
	weave_paragraph_heading_node *C = RETRIEVE_POINTER_weave_paragraph_heading_node(N->content);
	Debugging__show_para(OUT, C->para);
	if (C->no_skip) WRITE(" (no skip)");

}
#line 50 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_endnote_node_type) 
{
#line 144 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 51 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_figure_node_type) 
{
#line 147 "inweb/Chapter 5/Debugging Format.w"
	weave_figure_node *C = RETRIEVE_POINTER_weave_figure_node(N->content);
	WRITE(" <%S> %d by %d", C->figname, C->w, C->h);

}
#line 52 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_audio_node_type) 
{
#line 151 "inweb/Chapter 5/Debugging Format.w"
	weave_audio_node *C = RETRIEVE_POINTER_weave_audio_node(N->content);
	WRITE(" <%S> %d", C->audio_name, C->w);

}
#line 53 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_video_node_type) 
{
#line 155 "inweb/Chapter 5/Debugging Format.w"
	weave_video_node *C = RETRIEVE_POINTER_weave_video_node(N->content);
	WRITE(" <%S> %d", C->video_name, C->w);

}
#line 54 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_download_node_type) 
{
#line 159 "inweb/Chapter 5/Debugging Format.w"
	weave_download_node *C = RETRIEVE_POINTER_weave_download_node(N->content);
	WRITE(" <%S> %S", C->download_name, C->filetype);

}
#line 55 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_material_node_type) 
{
#line 163 "inweb/Chapter 5/Debugging Format.w"
	weave_material_node *C = RETRIEVE_POINTER_weave_material_node(N->content);
	WRITE(" ");
	Debugging__show_mat(OUT, C->material_type);
	if (C->material_type == CODE_MATERIAL) WRITE(": %S", C->styling->language_name);
	if (C->plainly) WRITE(" (plainly)");

}
#line 56 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_embed_node_type) 
{
#line 170 "inweb/Chapter 5/Debugging Format.w"
	weave_embed_node *C = RETRIEVE_POINTER_weave_embed_node(N->content);
	WRITE(" service <%S> ID <%S> %d by %d", C->service, C->ID, C->w, C->h);

}
#line 57 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_pmac_node_type) 
{
#line 174 "inweb/Chapter 5/Debugging Format.w"
	weave_pmac_node *C = RETRIEVE_POINTER_weave_pmac_node(N->content);
	WRITE(" <%S>", C->pmac->macro_name);
	if (C->defn) WRITE(" (definition)");

}
#line 58 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_vskip_node_type) 
{
#line 179 "inweb/Chapter 5/Debugging Format.w"
	weave_vskip_node *C = RETRIEVE_POINTER_weave_vskip_node(N->content);
	if (C->in_comment) WRITE(" (in comment)");

}
#line 59 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_chapter_node_type) 
{
#line 183 "inweb/Chapter 5/Debugging Format.w"
	weave_chapter_node *C = RETRIEVE_POINTER_weave_chapter_node(N->content);
	WRITE(" <%S>", C->chap->md->ch_title);

}
#line 60 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_section_node_type) 
{
#line 187 "inweb/Chapter 5/Debugging Format.w"
	weave_section_node *C = RETRIEVE_POINTER_weave_section_node(N->content);
	WRITE(" <%S>", C->sect->md->sect_title);

}
#line 61 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_code_line_node_type) 
{
#line 191 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 62 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_function_usage_node_type) 
{
#line 194 "inweb/Chapter 5/Debugging Format.w"
	weave_function_usage_node *C = RETRIEVE_POINTER_weave_function_usage_node(N->content);
	WRITE(" <%S>", C->fn->function_name);

}
#line 63 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_commentary_node_type) 
{
#line 198 "inweb/Chapter 5/Debugging Format.w"
	weave_commentary_node *C = RETRIEVE_POINTER_weave_commentary_node(N->content);
	Debugging__show_text(OUT, C->text, 80);
	if (C->in_code) WRITE(" (code)");

}
#line 64 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_carousel_slide_node_type) 
{
#line 203 "inweb/Chapter 5/Debugging Format.w"
	weave_carousel_slide_node *C = RETRIEVE_POINTER_weave_carousel_slide_node(N->content);
	WRITE(" caption <%S>", C->caption);

}
#line 65 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_toc_node_type) 
{
#line 207 "inweb/Chapter 5/Debugging Format.w"
	weave_toc_node *C = RETRIEVE_POINTER_weave_toc_node(N->content);
	WRITE(" - <%S>", C->text1);

}
#line 66 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_toc_line_node_type) 
{
#line 211 "inweb/Chapter 5/Debugging Format.w"
	weave_toc_line_node *C = RETRIEVE_POINTER_weave_toc_line_node(N->content);
	WRITE(" - <%S, %S>", C->text1, C->text2);
	if (C->para) Debugging__show_para(OUT, C->para);

}
#line 67 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_chapter_title_page_node_type) 
{
#line 216 "inweb/Chapter 5/Debugging Format.w"
	weave_chapter_title_page_node *C = RETRIEVE_POINTER_weave_chapter_title_page_node(N->content);
	WRITE(" - something %d", C->allocation_id);

}
#line 68 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_defn_node_type) 
{
#line 220 "inweb/Chapter 5/Debugging Format.w"
	weave_defn_node *C = RETRIEVE_POINTER_weave_defn_node(N->content);
	WRITE(" <%S>", C->keyword);

}
#line 69 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_source_code_node_type) 
{
#line 224 "inweb/Chapter 5/Debugging Format.w"
	weave_source_code_node *C = RETRIEVE_POINTER_weave_source_code_node(N->content);
	WRITE(" <%S>\n", C->matter);
	for (int i=0; i<L; i++) WRITE("  ");
	WRITE("           ");
	WRITE(" _%S_", C->colouring);

}
#line 70 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_url_node_type) 
{
#line 231 "inweb/Chapter 5/Debugging Format.w"
	weave_url_node *C = RETRIEVE_POINTER_weave_url_node(N->content);
	WRITE(" content <%S> url <%S>", C->content, C->url);

}
#line 71 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_footnote_cue_node_type) 
{
#line 235 "inweb/Chapter 5/Debugging Format.w"
	weave_footnote_cue_node *C = RETRIEVE_POINTER_weave_footnote_cue_node(N->content);
	WRITE(" [%S]", C->cue_text);

}
#line 72 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_begin_footnote_text_node_type) 
{
#line 239 "inweb/Chapter 5/Debugging Format.w"
	weave_begin_footnote_text_node *C = RETRIEVE_POINTER_weave_begin_footnote_text_node(N->content);
	WRITE(" [%S]", C->cue_text);

}
#line 73 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_display_line_node_type) 
{
#line 243 "inweb/Chapter 5/Debugging Format.w"
	weave_display_line_node *C = RETRIEVE_POINTER_weave_display_line_node(N->content);
	WRITE(" <%S>", C->text);

}
#line 74 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_function_defn_node_type) 
{
#line 247 "inweb/Chapter 5/Debugging Format.w"
	weave_function_defn_node *C = RETRIEVE_POINTER_weave_function_defn_node(N->content);
	WRITE(" <%S>", C->fn->function_name);

}
#line 75 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_item_node_type) 
{
#line 251 "inweb/Chapter 5/Debugging Format.w"
	weave_item_node *C = RETRIEVE_POINTER_weave_item_node(N->content);
	WRITE(" depth %d label <%S>", C->depth, C->label);

}
#line 76 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_grammar_index_node_type) 
{
#line 255 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 77 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_inline_node_type) 
{
#line 258 "inweb/Chapter 5/Debugging Format.w"
	;

}
#line 78 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_locale_node_type) 
{
#line 261 "inweb/Chapter 5/Debugging Format.w"
	weave_locale_node *C = RETRIEVE_POINTER_weave_locale_node(N->content);
	Debugging__show_para(OUT, C->par1);
	if (C->par2) {
		WRITE(" to ");
		Debugging__show_para(OUT, C->par2);
	}

}
#line 79 "inweb/Chapter 5/Debugging Format.w"

	else if (N->type == weave_maths_node_type) 
{
#line 269 "inweb/Chapter 5/Debugging Format.w"
	weave_maths_node *C = RETRIEVE_POINTER_weave_maths_node(N->content);
	WRITE(" <%S>", C->content);
	if (C->displayed) WRITE(" (displayed)");

}
#line 80 "inweb/Chapter 5/Debugging Format.w"

	else WRITE("Unknown node");
	WRITE("\n");
	return TRUE;
}

#line 274 "inweb/Chapter 5/Debugging Format.w"
void Debugging__show_text(text_stream *OUT, text_stream *text, int limit) {
	WRITE(" <");
	for (int i=0; (i<limit) && (i<Str__len(text)); i++)
		if (Str__get_at(text, i) == '\n')
			WRITE("\\n");
		else
			PUT(Str__get_at(text, i));
	WRITE(">");
	if (Str__len(text) > limit) WRITE(" ... continues to %d chars", Str__len(text));
}

void Debugging__show_para(text_stream *OUT, paragraph *P) {
	WRITE(" P%S", P->paragraph_number);
	if (Str__len(P->heading_text) > 0) WRITE("'%S'", P->heading_text);
}

void Debugging__show_mat(text_stream *OUT, int m) {
	switch (m) {
		case COMMENTARY_MATERIAL: WRITE("discussion"); break;
		case MACRO_MATERIAL: WRITE("paragraph macro"); break;
		case DEFINITION_MATERIAL: WRITE("definition"); break;
		case CODE_MATERIAL: WRITE("code"); break;
		case ENDNOTES_MATERIAL: WRITE("endnotes"); break;
		case FOOTNOTES_MATERIAL: WRITE("footnotes"); break;
		default: WRITE("unknown"); break;
	}
}

#line 28 "inweb/Chapter 5/TeX Utilities.w"

#line 30 "inweb/Chapter 5/TeX Utilities.w"
tex_results *TeXUtilities__new_results(weave_order *wv, filename *CF) {
	tex_results *res = CREATE(tex_results);
	res->overfull_hbox_count = 0;
	res->tex_error_count = 0;
	res->page_count = 0;
	res->pdf_size = 0;
	res->PDF_filename = Filenames__set_extension(CF, TL_IS_3017);
	return res;
}

#line 44 "inweb/Chapter 5/TeX Utilities.w"
void TeXUtilities__post_process_weave(weave_order *wv, filename *CF) {
	wv->post_processing_results = TeXUtilities__new_results(wv, CF);
	TextFiles__read(CF, FALSE,
		"can't open console file", TRUE, TeXUtilities__scan_console_line, NULL,
		(void *) wv->post_processing_results);
}

#line 52 "inweb/Chapter 5/TeX Utilities.w"
void TeXUtilities__scan_console_line(text_stream *line, text_file_position *tfp,
	void *res_V) {
	tex_results *res = (tex_results *) res_V;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line,
		U"Output written %c*? %((%d+) page%c*?(%d+) bytes%).")) {
		res->page_count = Str__atoi(mr.exp[0], 0);
		res->pdf_size = Str__atoi(mr.exp[1], 0);
	}
	if (Regexp__match(&mr, line, U"%c+verfull \\hbox%c+"))
		res->overfull_hbox_count++;
	else if (Str__get_first_char(line) == '!') {
		res->tex_error_count++;
	}
	Regexp__dispose_of(&mr);
}

#line 72 "inweb/Chapter 5/TeX Utilities.w"
void TeXUtilities__report_on_post_processing(weave_order *wv) {
	tex_results *res = wv->post_processing_results;
	if (res) {
		PRINT(": %dpp %dK", res->page_count, res->pdf_size/1024);
		if (res->overfull_hbox_count > 0)
			PRINT(", %d overfull hbox(es)", res->overfull_hbox_count);
		if (res->tex_error_count > 0)
			PRINT(", %d error(s)", res->tex_error_count);
	}
}

#line 86 "inweb/Chapter 5/TeX Utilities.w"
int TeXUtilities__substitute_post_processing_data(text_stream *to, weave_order *wv,
	text_stream *detail) {
	if (wv) {
		tex_results *res = wv->post_processing_results;
		if (res) {
			if (Str__eq_wide_string(detail, U"PDF Size")) {
				WRITE_TO(to, "%dKB", res->pdf_size/1024);
			} else if (Str__eq_wide_string(detail, U"Extent")) {
				WRITE_TO(to, "%dpp", res->page_count);
			} else if (Str__eq_wide_string(detail, U"Leafname")) {
				Str__copy(to, Filenames__get_leafname(res->PDF_filename));
			} else if (Str__eq_wide_string(detail, U"Errors")) {
				Str__clear(to);
				if ((res->overfull_hbox_count > 0) || (res->tex_error_count > 0))
					WRITE_TO(to, ": ");
				if (res->overfull_hbox_count > 0)
					WRITE_TO(to, "%d overfull line%s",
						res->overfull_hbox_count,
						(res->overfull_hbox_count>1)?"s":"");
				if ((res->overfull_hbox_count > 0) && (res->tex_error_count > 0))
					WRITE_TO(to, ", ");
				if (res->tex_error_count > 0)
					WRITE_TO(to, "%d TeX error%s",
						res->tex_error_count,
						(res->tex_error_count>1)?"s":"");
			} else return FALSE;
			return TRUE;
		}
	}
	return FALSE;
}

#line 126 "inweb/Chapter 5/TeX Utilities.w"
void TeXUtilities__remove_math_mode(OUTPUT_STREAM, text_stream *text) {
	TEMPORARY_TEXT(math_matter)
	TeXUtilities__remove_math_mode_range(math_matter, text, 0, Str__len(text)-1);
	WRITE("%S", math_matter);
	DISCARD_TEXT(math_matter)
}

void TeXUtilities__remove_math_mode_range(OUTPUT_STREAM, text_stream *text, int from, int to) {
	for (int i=from; i <= to; i++) {
		
{
#line 157 "inweb/Chapter 5/TeX Utilities.w"
	if ((Str__get_at(text, i) == '\\') &&
		(Str__get_at(text, i+1) == 'o') && (Str__get_at(text, i+2) == 'v') &&
		(Str__get_at(text, i+3) == 'e') && (Str__get_at(text, i+4) == 'r') &&
		(Str__get_at(text, i+5) == '{')) {
		int bl = 1;
		int j = i-1;
		for (; j >= from; j--) {
			inchar32_t c = Str__get_at(text, j);
			if (c == '{') {
				bl--;
				if (bl == 0) break;
			}
			if (c == '}') bl++;
		}
		TeXUtilities__remove_math_mode_range(OUT, text, from, j-1);
		WRITE("((");
		TeXUtilities__remove_math_mode_range(OUT, text, j+2, i-2);
		WRITE(") / (");
		j=i+6; bl = 1;
		for (; j <= to; j++) {
			inchar32_t c = Str__get_at(text, j);
			if (c == '}') {
				bl--;
				if (bl == 0) break;
			}
			if (c == '{') bl++;
		}
		TeXUtilities__remove_math_mode_range(OUT, text, i+6, j-1);
		WRITE("))");
		TeXUtilities__remove_math_mode_range(OUT, text, j+2, to);
		return;
	}

}
#line 135 "inweb/Chapter 5/TeX Utilities.w"
;
	}
	for (int i=from; i <= to; i++) {
		
{
#line 193 "inweb/Chapter 5/TeX Utilities.w"
	if ((Str__get_at(text, i) == '{') && (Str__get_at(text, i+1) == '\\') &&
		(((Str__get_at(text, i+2) == 'r') && (Str__get_at(text, i+3) == 'm')) ||
			((Str__get_at(text, i+2) == 'i') && (Str__get_at(text, i+3) == 't'))) &&
		(Str__get_at(text, i+4) == ' ')) {
		TeXUtilities__remove_math_mode_range(OUT, text, from, i-1);
		int j=i+5;
		for (; j <= to; j++)
			if (Str__get_at(text, j) == '}')
				break;
		TeXUtilities__remove_math_mode_range(OUT, text, i+5, j-1);
		TeXUtilities__remove_math_mode_range(OUT, text, j+1, to);
		return;
	}

}
#line 138 "inweb/Chapter 5/TeX Utilities.w"
;
		
{
#line 211 "inweb/Chapter 5/TeX Utilities.w"
	if ((Str__get_at(text, i) == '\\') &&
		(Str__get_at(text, i+1) == 's') && (Str__get_at(text, i+2) == 'q') &&
		(Str__get_at(text, i+3) == 'r') && (Str__get_at(text, i+4) == 't') &&
		(Str__get_at(text, i+5) == '{')) {
		if ((Str__get_at(text, i-4) == '{') &&
			(Str__get_at(text, i-3) == '}') &&
			(Str__get_at(text, i-2) == '^') &&
			(Str__get_at(text, i-1) == '3')) {
			TeXUtilities__remove_math_mode_range(OUT, text, from, i-5);
			WRITE(" curt(");
		} else {
			TeXUtilities__remove_math_mode_range(OUT, text, from, i-1);
			WRITE(" sqrt(");
		}
		int j=i+6, bl = 1;
		for (; j <= to; j++) {
			inchar32_t c = Str__get_at(text, j);
			if (c == '}') {
				bl--;
				if (bl == 0) break;
			}
			if (c == '{') bl++;
		}
		TeXUtilities__remove_math_mode_range(OUT, text, i+6, j-1);
		WRITE(")");
		TeXUtilities__remove_math_mode_range(OUT, text, j+1, to);
		return;
	}

}
#line 139 "inweb/Chapter 5/TeX Utilities.w"
;
	}
	int math_mode = FALSE;
	for (int i=from; i <= to; i++) {
		switch (Str__get_at(text, i)) {
			case '$':
				if (Str__get_at(text, i+1) == '$') i++;
				math_mode = (math_mode)?FALSE:TRUE; break;
			case '~': if (math_mode) WRITE(" "); else WRITE("~"); break;
			case '\\': 
{
#line 241 "inweb/Chapter 5/TeX Utilities.w"
	TEMPORARY_TEXT(macro)
	i++;
	while ((i < Str__len(text)) && (Characters__isalpha(Str__get_at(text, i))))
		PUT_TO(macro, Str__get_at(text, i++));
	if (Str__eq(macro, TL_IS_3018)) 
{
#line 364 "inweb/Chapter 5/TeX Utilities.w"
	if (Str__get_at(text, i) == '\\') {
		Str__clear(macro);
		i++;
		while ((i < Str__len(text)) && (Characters__isalpha(Str__get_at(text, i))))
			PUT_TO(macro, Str__get_at(text, i++));
		if (Str__eq(macro, TL_IS_3114)) PUT((inchar32_t) 0x2204);
		else if (Str__eq(macro, TL_IS_3115)) { PUT((inchar32_t) 0x00AC); PUT((inchar32_t) 0x2200); }
		else {
			PRINT("Don't know how to apply '\\not' to '\\%S'\n", macro);
		}
	} else {
		PRINT("Don't know how to apply '\\not' here\n");
	}

}
#line 245 "inweb/Chapter 5/TeX Utilities.w"

	else 
{
#line 251 "inweb/Chapter 5/TeX Utilities.w"
	if (Str__eq(macro, TL_IS_3019)) WRITE("<=");
	else if (Str__eq(macro, TL_IS_3020)) WRITE(">=");
	else if (Str__eq(macro, TL_IS_3021)) WRITE("~");
	else if (Str__eq(macro, TL_IS_3022)) WRITE("");
	else if (Str__eq(macro, TL_IS_3023)) WRITE("");
	else if (Str__eq(macro, TL_IS_3024)) WRITE("");
	else if (Str__eq(macro, TL_IS_3025)) WRITE("=>");
	else if (Str__eq(macro, TL_IS_3026)) WRITE("<=>");
	else if (Str__eq(macro, TL_IS_3027)) WRITE("-->");
	else if (Str__eq(macro, TL_IS_3028)) WRITE("-->");
	else if (Str__eq(macro, TL_IS_3029)) WRITE("-->");
	else if (Str__eq(macro, TL_IS_3030)) WRITE("<--");
	else if (Str__eq(macro, TL_IS_3031)) WRITE("<--");
	else if (Str__eq(macro, TL_IS_3032)) WRITE("{");
	else if (Str__eq(macro, TL_IS_3033)) WRITE("|");
	else if (Str__eq(macro, TL_IS_3034)) WRITE("}");
	else if (Str__eq(macro, TL_IS_3035)) WRITE(".");
	else if (Str__eq(macro, TL_IS_3036)) WRITE("...");
	else if (Str__eq(macro, TL_IS_3037)) WRITE("...");
	else if (Str__eq(macro, TL_IS_3038)) WRITE("*");
	else if (Str__eq(macro, TL_IS_3039)) WRITE("  ");
	else if (Str__eq(macro, TL_IS_3040)) WRITE("    ");
	else if (Str__eq(macro, TL_IS_3041)) WRITE("TeX");
	else if (Str__eq(macro, TL_IS_3042)) WRITE("!=");
	else if (Str__eq(macro, TL_IS_3043)) WRITE("!=");
	else if (Str__eq(macro, TL_IS_3044)) WRITE("l");
	else if (Str__eq(macro, TL_IS_3045)) WRITE("log");
	else if (Str__eq(macro, TL_IS_3046)) WRITE("exp");
	else if (Str__eq(macro, TL_IS_3047)) WRITE("sin");
	else if (Str__eq(macro, TL_IS_3048)) WRITE("cos");
	else if (Str__eq(macro, TL_IS_3049)) WRITE("tan");
	else if (Str__eq(macro, TL_IS_3050)) WRITE("T");
	else if (Str__eq(macro, TL_IS_3051)) PUT((inchar32_t) 0x0391);
	else if (Str__eq(macro, TL_IS_3052)) PUT((inchar32_t) 0x0392);
	else if (Str__eq(macro, TL_IS_3053)) PUT((inchar32_t) 0x0393);
	else if (Str__eq(macro, TL_IS_3054)) PUT((inchar32_t) 0x0394);
	else if (Str__eq(macro, TL_IS_3055)) PUT((inchar32_t) 0x0395);
	else if (Str__eq(macro, TL_IS_3056)) PUT((inchar32_t) 0x0396);
	else if (Str__eq(macro, TL_IS_3057)) PUT((inchar32_t) 0x0397);
	else if (Str__eq(macro, TL_IS_3058)) PUT((inchar32_t) 0x0398);
	else if (Str__eq(macro, TL_IS_3059)) PUT((inchar32_t) 0x0399);
	else if (Str__eq(macro, TL_IS_3060)) PUT((inchar32_t) 0x039A);
	else if (Str__eq(macro, TL_IS_3061)) PUT((inchar32_t) 0x039B);
	else if (Str__eq(macro, TL_IS_3062)) PUT((inchar32_t) 0x039C);
	else if (Str__eq(macro, TL_IS_3063)) PUT((inchar32_t) 0x039D);
	else if (Str__eq(macro, TL_IS_3064)) PUT((inchar32_t) 0x039E);
	else if (Str__eq(macro, TL_IS_3065)) PUT((inchar32_t) 0x039F);
	else if (Str__eq(macro, TL_IS_3066)) PUT((inchar32_t) 0x03A0);
	else if (Str__eq(macro, TL_IS_3067)) PUT((inchar32_t) 0x03A1);
	else if (Str__eq(macro, TL_IS_3068)) PUT((inchar32_t) 0x03A2);
	else if (Str__eq(macro, TL_IS_3069)) PUT((inchar32_t) 0x03A3);
	else if (Str__eq(macro, TL_IS_3070)) PUT((inchar32_t) 0x03A4);
	else if (Str__eq(macro, TL_IS_3071)) PUT((inchar32_t) 0x03A5);
	else if (Str__eq(macro, TL_IS_3072)) PUT((inchar32_t) 0x03A6);
	else if (Str__eq(macro, TL_IS_3073)) PUT((inchar32_t) 0x03A7);
	else if (Str__eq(macro, TL_IS_3074)) PUT((inchar32_t) 0x03A8);
	else if (Str__eq(macro, TL_IS_3075)) PUT((inchar32_t) 0x03A9);
	else if (Str__eq(macro, TL_IS_3076)) PUT((inchar32_t) 0x03B1);
	else if (Str__eq(macro, TL_IS_3077)) PUT((inchar32_t) 0x03B2);
	else if (Str__eq(macro, TL_IS_3078)) PUT((inchar32_t) 0x03B3);
	else if (Str__eq(macro, TL_IS_3079)) PUT((inchar32_t) 0x03B4);
	else if (Str__eq(macro, TL_IS_3080)) PUT((inchar32_t) 0x03B5);
	else if (Str__eq(macro, TL_IS_3081)) PUT((inchar32_t) 0x03B6);
	else if (Str__eq(macro, TL_IS_3082)) PUT((inchar32_t) 0x03B7);
	else if (Str__eq(macro, TL_IS_3083)) PUT((inchar32_t) 0x03B8);
	else if (Str__eq(macro, TL_IS_3084)) PUT((inchar32_t) 0x03B9);
	else if (Str__eq(macro, TL_IS_3085)) PUT((inchar32_t) 0x03BA);
	else if (Str__eq(macro, TL_IS_3086)) PUT((inchar32_t) 0x03BB);
	else if (Str__eq(macro, TL_IS_3087)) PUT((inchar32_t) 0x03BC);
	else if (Str__eq(macro, TL_IS_3088)) PUT((inchar32_t) 0x03BD);
	else if (Str__eq(macro, TL_IS_3089)) PUT((inchar32_t) 0x03BE);
	else if (Str__eq(macro, TL_IS_3090)) PUT((inchar32_t) 0x03BF);
	else if (Str__eq(macro, TL_IS_3091)) PUT((inchar32_t) 0x03C0);
	else if (Str__eq(macro, TL_IS_3092)) PUT((inchar32_t) 0x03C1);
	else if (Str__eq(macro, TL_IS_3093)) PUT((inchar32_t) 0x03C2);
	else if (Str__eq(macro, TL_IS_3094)) PUT((inchar32_t) 0x03C3);
	else if (Str__eq(macro, TL_IS_3095)) PUT((inchar32_t) 0x03C4);
	else if (Str__eq(macro, TL_IS_3096)) PUT((inchar32_t) 0x03C5);
	else if (Str__eq(macro, TL_IS_3097)) PUT((inchar32_t) 0x03C6);
	else if (Str__eq(macro, TL_IS_3098)) PUT((inchar32_t) 0x03C7);
	else if (Str__eq(macro, TL_IS_3099)) PUT((inchar32_t) 0x03C8);
	else if (Str__eq(macro, TL_IS_3100)) PUT((inchar32_t) 0x03C9);
	else if (Str__eq(macro, TL_IS_3101)) PUT((inchar32_t) 0x2203);
	else if (Str__eq(macro, TL_IS_3102)) PUT((inchar32_t) 0x2208);
	else if (Str__eq(macro, TL_IS_3103)) PUT((inchar32_t) 0x2200);
	else if (Str__eq(macro, TL_IS_3104)) PUT((inchar32_t) 0x2229);
	else if (Str__eq(macro, TL_IS_3105)) PUT((inchar32_t) 0x2205);
	else if (Str__eq(macro, TL_IS_3106)) PUT((inchar32_t) 0x2286);
	else if (Str__eq(macro, TL_IS_3107)) PUT((inchar32_t) 0x2227);
	else if (Str__eq(macro, TL_IS_3108)) PUT((inchar32_t) 0x2228);
	else if (Str__eq(macro, TL_IS_3109)) PUT((inchar32_t) 0x00AC);
	else if (Str__eq(macro, TL_IS_3110)) PUT((inchar32_t) 0x03A3);
	else if (Str__eq(macro, TL_IS_3111)) PUT((inchar32_t) 0x03A0);
	else {
		if (Str__len(macro) > 0) {
			int suspect = TRUE;
			LOOP_THROUGH_TEXT(pos, macro) {
				inchar32_t c = Str__get(pos);
				if ((c >= 'A') && (c <= 'Z')) continue;
				if ((c >= 'a') && (c <= 'z')) continue;
				suspect = FALSE;
			}
			if (Str__eq(macro, TL_IS_3112)) suspect = FALSE;
			if (Str__eq(macro, TL_IS_3113)) suspect = FALSE;
			if (suspect)
				PRINT("[Passing through unknown TeX macro \\%S:\n  %S\n", macro, text);
		}
		WRITE("\\%S", macro);
	}

}
#line 246 "inweb/Chapter 5/TeX Utilities.w"
;
	DISCARD_TEXT(macro)
	i--;

}
#line 148 "inweb/Chapter 5/TeX Utilities.w"
; break;
			default: PUT(Str__get_at(text, i)); break;
		}
	}
}

#line 12 "inweb/Chapter 6/Makefiles.w"
void Makefiles__write(web *W, filename *prototype, filename *F, module_search *I,
	text_stream *platform) {
	linked_list *L = NEW_LINKED_LIST(preprocessor_macro);
	Preprocessor__new_macro(L,
		TL_IS_3116, NULL,
		Makefiles__platform_settings_expander, NULL);
	Preprocessor__new_macro(L,
		TL_IS_3117, NULL,
		Makefiles__identity_settings_expander, NULL);
	preprocessor_macro *mf = Preprocessor__new_macro(L,
		TL_IS_3118, TL_IS_3119,
		Makefiles__modify_filenames_expander, NULL);
	Preprocessor__do_not_suppress_whitespace(mf);
	Preprocessor__new_macro(L,
		TL_IS_3120, TL_IS_3121,
		Makefiles__component_expander, NULL);
	Preprocessor__new_macro(L,
		TL_IS_3122, TL_IS_3123,
		Makefiles__dependent_files_expander, NULL);
	Preprocessor__new_loop_macro(L,
		TL_IS_3124, TL_IS_3125,
		Makefiles__components_expander, NULL);

	makefile_specifics *specifics = CREATE(makefile_specifics);
	
{
#line 62 "inweb/Chapter 6/Makefiles.w"
	specifics->for_web = W;
	specifics->tools_dictionary = Dictionaries__new(16, FALSE);
	specifics->webs_dictionary = Dictionaries__new(16, FALSE);
	specifics->modules_dictionary = Dictionaries__new(16, FALSE);
	specifics->search_path = I;
	specifics->which_platform = platform;

}
#line 36 "inweb/Chapter 6/Makefiles.w"
;

	text_stream *header = Str__new();
	WRITE_TO(header, "# This makefile was automatically written by inweb -makefile\n");
	WRITE_TO(header, "# and is not intended for human editing\n\n");
	WRITE_TO(STDOUT, "(Read script from %f)\n", prototype);

	Preprocessor__preprocess(prototype, F, header, L,
		STORE_POINTER_makefile_specifics(specifics), '#', ISO_ENC);
}

#line 60 "inweb/Chapter 6/Makefiles.w"

#line 72 "inweb/Chapter 6/Makefiles.w"
void Makefiles__identity_settings_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	makefile_specifics *specifics = RETRIEVE_POINTER_makefile_specifics(PPS->specifics);
	text_stream *OUT = PPS->dest;
	WRITE("INWEB = "); Makefiles__pathname_slashed(OUT, path_to_inweb); WRITE("/Tangled/inweb\n");
	pathname *path_to_intest = Pathnames__down(Pathnames__up(path_to_inweb), TL_IS_3126);
	WRITE("INTEST = "); Makefiles__pathname_slashed(OUT, path_to_intest); WRITE("/Tangled/intest\n");
	if (specifics->for_web) {
		WRITE("MYNAME = %S\n", Pathnames__directory_name(specifics->for_web->md->path_to_web));
		WRITE("ME = "); Makefiles__pathname_slashed(OUT, specifics->for_web->md->path_to_web);
		WRITE("\n");
		PPS->last_line_was_blank = FALSE;
	}
}

#line 94 "inweb/Chapter 6/Makefiles.w"
void Makefiles__platform_settings_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	makefile_specifics *specifics = RETRIEVE_POINTER_makefile_specifics(PPS->specifics);
	text_stream *INWEBPLATFORM = Str__duplicate(specifics->which_platform);
	if (Str__len(INWEBPLATFORM) == 0) {
		filename *ps = Filenames__in(path_to_inweb, TL_IS_3127);
		TextFiles__read(ps, FALSE, "can't open platform settings file",
			TRUE, Makefiles__seek_INWEBPLATFORM, NULL, INWEBPLATFORM);
	}
	if (Str__len(INWEBPLATFORM) == 0) {
		Errors__in_text_file(
			"found platform settings file, but it does not set INWEBPLATFORM", tfp);
	} else {
		pathname *P = Pathnames__down(path_to_inweb, TL_IS_3128);
		P = Pathnames__down(P, TL_IS_3129);
		WRITE_TO(INWEBPLATFORM, ".mkscript");
		filename *F = Filenames__in(P, INWEBPLATFORM);
		TextFiles__read(F, FALSE, "can't open platform definitions file",
			TRUE, Preprocessor__scan_line, NULL, PPS);
		WRITE_TO(STDOUT, "(Read definitions file '%S' from ", INWEBPLATFORM);
		Pathnames__to_text_relative(STDOUT, path_to_inweb, P);
		WRITE_TO(STDOUT, ")\n");
	}
}

void Makefiles__seek_INWEBPLATFORM(text_stream *line, text_file_position *tfp, void *X) {
	text_stream *OUT = (text_stream *) X;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U" *INWEBPLATFORM = (%C+) *")) WRITE("%S", mr.exp[0]);
	Regexp__dispose_of(&mr);
}

#line 129 "inweb/Chapter 6/Makefiles.w"
void Makefiles__modify_filenames_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	text_stream *OUT = PPS->dest;

	text_stream *original = parameter_values[0];
	text_stream *suffix = parameter_values[1];
	text_stream *prefix = parameter_values[2];

	inchar32_t previous = 'X'; int quoted = FALSE, boundary = FALSE;
	TEMPORARY_TEXT(captured)
	LOOP_THROUGH_TEXT(pos, original) {
		inchar32_t c = Str__get(pos);
		if (c == '\'') { quoted = quoted?FALSE:TRUE; }
		if (Characters__is_whitespace(c)) {
			if ((previous != '\\') && (quoted == FALSE)) boundary = TRUE;
		} else {
			if (boundary) 
{
#line 156 "inweb/Chapter 6/Makefiles.w"
	Str__trim_white_space(captured);
	if (Str__len(captured) > 0) {
		int in_quotes = FALSE;
		if ((Str__get_first_char(captured) == '\'') && (Str__get_last_char(captured) == '\'')) {
			Str__delete_first_character(captured);
			Str__delete_last_character(captured);
			in_quotes = TRUE;
		}
		if (in_quotes) WRITE("'");
		int last_slash = -1;
		for (int i=0; i<Str__len(captured); i++)
			if (Str__get_at(captured, i) == '/')
				last_slash = i;
		int last_dot = Str__len(captured);
		for (int i=last_slash+1; i<Str__len(captured); i++)
			if (Str__get_at(captured, i) == '.')
				last_dot = i;
		for (int i=0; i<=last_slash; i++) PUT(Str__get_at(captured, i));
		WRITE("%S", prefix);
		for (int i=last_slash+1; i<last_dot; i++) PUT(Str__get_at(captured, i));
		WRITE("%S", suffix);
		for (int i=last_dot; i<Str__len(captured); i++) PUT(Str__get_at(captured, i));
		if (in_quotes) WRITE("'");
		Str__clear(captured);
		WRITE(" ");
	}

}
#line 145 "inweb/Chapter 6/Makefiles.w"
;
			boundary = FALSE;
		}
		PUT_TO(captured, c);
		previous = c;
	}
	
{
#line 156 "inweb/Chapter 6/Makefiles.w"
	Str__trim_white_space(captured);
	if (Str__len(captured) > 0) {
		int in_quotes = FALSE;
		if ((Str__get_first_char(captured) == '\'') && (Str__get_last_char(captured) == '\'')) {
			Str__delete_first_character(captured);
			Str__delete_last_character(captured);
			in_quotes = TRUE;
		}
		if (in_quotes) WRITE("'");
		int last_slash = -1;
		for (int i=0; i<Str__len(captured); i++)
			if (Str__get_at(captured, i) == '/')
				last_slash = i;
		int last_dot = Str__len(captured);
		for (int i=last_slash+1; i<Str__len(captured); i++)
			if (Str__get_at(captured, i) == '.')
				last_dot = i;
		for (int i=0; i<=last_slash; i++) PUT(Str__get_at(captured, i));
		WRITE("%S", prefix);
		for (int i=last_slash+1; i<last_dot; i++) PUT(Str__get_at(captured, i));
		WRITE("%S", suffix);
		for (int i=last_dot; i<Str__len(captured); i++) PUT(Str__get_at(captured, i));
		if (in_quotes) WRITE("'");
		Str__clear(captured);
		WRITE(" ");
	}

}
#line 151 "inweb/Chapter 6/Makefiles.w"

	DISCARD_TEXT(captured)
}

#line 186 "inweb/Chapter 6/Makefiles.w"
void Makefiles__component_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	makefile_specifics *specifics = RETRIEVE_POINTER_makefile_specifics(PPS->specifics);
	text_stream *OUT = PPS->dest;

	text_stream *symbol = parameter_values[0];
	text_stream *webname = parameter_values[1];
	text_stream *path = parameter_values[2];
	text_stream *set = parameter_values[3];
	text_stream *category = parameter_values[4];

	if (Str__eq(category, TL_IS_3130)) {
		int marker = MAKEFILE_TOOL_MOM;
		dictionary *D = specifics->tools_dictionary;
		
{
#line 219 "inweb/Chapter 6/Makefiles.w"
	web_md *Wm = Reader__load_web_md(Pathnames__from_text(path), NULL,
		specifics->search_path, TRUE);
	Wm->as_module->module_name = Str__duplicate(symbol);
	Wm->as_module->module_tag = Str__duplicate(set);
	Wm->as_module->origin_marker = marker;
	Dictionaries__create(D, symbol);
	Dictionaries__write_value(D, symbol, Wm);

}
#line 200 "inweb/Chapter 6/Makefiles.w"
;
		
{
#line 228 "inweb/Chapter 6/Makefiles.w"
	WRITE("%SLEAF = %S\n", symbol, webname);
	WRITE("%SWEB = %S\n", symbol, path);
	WRITE("%SMAKER = $(%SWEB)/%S.mk\n", symbol, symbol, webname);
	WRITE("%SX = $(%SWEB)/Tangled/%S\n", symbol, symbol, webname);

}
#line 201 "inweb/Chapter 6/Makefiles.w"
;
	} else if (Str__eq(category, TL_IS_3131)) {
		int marker = MAKEFILE_WEB_MOM;
		dictionary *D = specifics->webs_dictionary;
		
{
#line 219 "inweb/Chapter 6/Makefiles.w"
	web_md *Wm = Reader__load_web_md(Pathnames__from_text(path), NULL,
		specifics->search_path, TRUE);
	Wm->as_module->module_name = Str__duplicate(symbol);
	Wm->as_module->module_tag = Str__duplicate(set);
	Wm->as_module->origin_marker = marker;
	Dictionaries__create(D, symbol);
	Dictionaries__write_value(D, symbol, Wm);

}
#line 205 "inweb/Chapter 6/Makefiles.w"
;
		
{
#line 228 "inweb/Chapter 6/Makefiles.w"
	WRITE("%SLEAF = %S\n", symbol, webname);
	WRITE("%SWEB = %S\n", symbol, path);
	WRITE("%SMAKER = $(%SWEB)/%S.mk\n", symbol, symbol, webname);
	WRITE("%SX = $(%SWEB)/Tangled/%S\n", symbol, symbol, webname);

}
#line 206 "inweb/Chapter 6/Makefiles.w"
;
	} else if (Str__eq(category, TL_IS_3132)) {
		int marker = MAKEFILE_MODULE_MOM;
		dictionary *D = specifics->modules_dictionary;
		
{
#line 219 "inweb/Chapter 6/Makefiles.w"
	web_md *Wm = Reader__load_web_md(Pathnames__from_text(path), NULL,
		specifics->search_path, TRUE);
	Wm->as_module->module_name = Str__duplicate(symbol);
	Wm->as_module->module_tag = Str__duplicate(set);
	Wm->as_module->origin_marker = marker;
	Dictionaries__create(D, symbol);
	Dictionaries__write_value(D, symbol, Wm);

}
#line 210 "inweb/Chapter 6/Makefiles.w"
;
		
{
#line 228 "inweb/Chapter 6/Makefiles.w"
	WRITE("%SLEAF = %S\n", symbol, webname);
	WRITE("%SWEB = %S\n", symbol, path);
	WRITE("%SMAKER = $(%SWEB)/%S.mk\n", symbol, symbol, webname);
	WRITE("%SX = $(%SWEB)/Tangled/%S\n", symbol, symbol, webname);

}
#line 211 "inweb/Chapter 6/Makefiles.w"
;
	} else {
		Errors__in_text_file("category should be 'tool', 'module' or 'web'", tfp);
	}
	PPS->last_line_was_blank = FALSE;
}

#line 236 "inweb/Chapter 6/Makefiles.w"
void Makefiles__components_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	Preprocessor__set_loop_var_name(loop, TL_IS_3133);
	text_stream *category = parameter_values[0];
	text_stream *set = parameter_values[1];
	if (Str__len(set) == 0) set = TL_IS_3134;
	if (Str__eq(category, TL_IS_3135)) {
		int marker = MAKEFILE_TOOL_MOM;
		
{
#line 257 "inweb/Chapter 6/Makefiles.w"
	module *M;
	LOOP_OVER(M, module) {
		if ((M->origin_marker == marker) &&
			((Str__eq(set, TL_IS_3138)) || (Str__eq(set, M->module_tag)))) {
			text_stream *value = M->module_name;
			Preprocessor__add_loop_iteration(loop, value);
		}
	}

}
#line 244 "inweb/Chapter 6/Makefiles.w"
;
	} else if (Str__eq(category, TL_IS_3136)) {
		int marker = MAKEFILE_WEB_MOM;
		
{
#line 257 "inweb/Chapter 6/Makefiles.w"
	module *M;
	LOOP_OVER(M, module) {
		if ((M->origin_marker == marker) &&
			((Str__eq(set, TL_IS_3138)) || (Str__eq(set, M->module_tag)))) {
			text_stream *value = M->module_name;
			Preprocessor__add_loop_iteration(loop, value);
		}
	}

}
#line 247 "inweb/Chapter 6/Makefiles.w"
;
	} else if (Str__eq(category, TL_IS_3137)) {
		int marker = MAKEFILE_MODULE_MOM;
		
{
#line 257 "inweb/Chapter 6/Makefiles.w"
	module *M;
	LOOP_OVER(M, module) {
		if ((M->origin_marker == marker) &&
			((Str__eq(set, TL_IS_3138)) || (Str__eq(set, M->module_tag)))) {
			text_stream *value = M->module_name;
			Preprocessor__add_loop_iteration(loop, value);
		}
	}

}
#line 250 "inweb/Chapter 6/Makefiles.w"
;
	} else {
		Errors__in_text_file("category should be 'tool', 'module' or 'web'", tfp);
	}
}

#line 269 "inweb/Chapter 6/Makefiles.w"
void Makefiles__dependent_files_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	makefile_specifics *specifics = RETRIEVE_POINTER_makefile_specifics(PPS->specifics);
	text_stream *OUT = PPS->dest;

	text_stream *tool = parameter_values[0];
	text_stream *modules = parameter_values[1];
	text_stream *both = parameter_values[2];
	if (Str__len(tool) > 0) {
		if (Dictionaries__find(specifics->tools_dictionary, tool)) {
			web_md *Wm = Dictionaries__read_value(specifics->tools_dictionary, tool);
			Makefiles__pattern(OUT, Wm->as_module->sections_md, Wm->contents_filename);
		} else if (Dictionaries__find(specifics->webs_dictionary, tool)) {
			web_md *Wm = Dictionaries__read_value(specifics->webs_dictionary, tool);
			Makefiles__pattern(OUT, Wm->as_module->sections_md, Wm->contents_filename);
		} else {
			TEMPORARY_TEXT(erm)
			WRITE_TO(erm, "unknown tool '%S' to find dependencies for", tool);
			Errors__in_text_file_S(erm, tfp);
			DISCARD_TEXT(erm)
		}
	} else if (Str__len(modules) > 0) {
		if (Dictionaries__find(specifics->modules_dictionary, modules)) {
			web_md *Wm = Dictionaries__read_value(specifics->modules_dictionary, modules);
			Makefiles__pattern(OUT, Wm->sections_md, Wm->contents_filename);
		} else {
			TEMPORARY_TEXT(erm)
			WRITE_TO(erm, "unknown module '%S' to find dependencies for", modules);
			Errors__in_text_file_S(erm, tfp);
			DISCARD_TEXT(erm)
		}
	} else if (Str__len(both) > 0) {
		if (Dictionaries__find(specifics->tools_dictionary, both)) {
			web_md *Wm = Dictionaries__read_value(specifics->tools_dictionary, both);
			Makefiles__pattern(OUT, Wm->sections_md, Wm->contents_filename);
		} else if (Dictionaries__find(specifics->webs_dictionary, both)) {
			web_md *Wm = Dictionaries__read_value(specifics->webs_dictionary, both);
			Makefiles__pattern(OUT, Wm->sections_md, Wm->contents_filename);
		} else {
			TEMPORARY_TEXT(erm)
			WRITE_TO(erm, "unknown tool '%S' to find dependencies for", both);
			Errors__in_text_file_S(erm, tfp);
			DISCARD_TEXT(erm)
		}
	} else {
		Makefiles__pattern(OUT, specifics->for_web->md->sections_md,
			specifics->for_web->md->contents_filename);
	}
	WRITE("\n");
	PPS->last_line_was_blank = FALSE;
}

#line 325 "inweb/Chapter 6/Makefiles.w"
void Makefiles__pattern(OUTPUT_STREAM, linked_list *L, filename *F) {
	dictionary *patterns_done = Dictionaries__new(16, TRUE);
	if (F) 
{
#line 336 "inweb/Chapter 6/Makefiles.w"
	pathname *P = Filenames__up(F);
	TEMPORARY_TEXT(leaf_pattern)
	WRITE_TO(leaf_pattern, "%S", Pathnames__directory_name(P));
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, leaf_pattern, U"Chapter %d*")) {
		Str__clear(leaf_pattern); WRITE_TO(leaf_pattern, "Chapter*");
	} else if (Regexp__match(&mr, leaf_pattern, U"Appendix %C")) {
		Str__clear(leaf_pattern); WRITE_TO(leaf_pattern, "Appendix*");
	}
	Regexp__dispose_of(&mr);
	TEMPORARY_TEXT(tester)
	WRITE_TO(tester, "%p/%S/*", Pathnames__up(P), leaf_pattern);
	DISCARD_TEXT(leaf_pattern)
	Filenames__write_extension(tester, F);
	if (Dictionaries__find(patterns_done, tester) == NULL) {
		WRITE_TO(Dictionaries__create_text(patterns_done, tester), "got this");
		WRITE(" ");
		LOOP_THROUGH_TEXT(pos, tester) {
			inchar32_t c = Str__get(pos);
			if (c == ' ') PUT('\\');
			PUT(c);
		}
	}
	DISCARD_TEXT(tester)

}
#line 327 "inweb/Chapter 6/Makefiles.w"
;
	section_md *Sm;
	LOOP_OVER_LINKED_LIST(Sm, section_md, L) {
		filename *F = Sm->source_file_for_section;
		
{
#line 336 "inweb/Chapter 6/Makefiles.w"
	pathname *P = Filenames__up(F);
	TEMPORARY_TEXT(leaf_pattern)
	WRITE_TO(leaf_pattern, "%S", Pathnames__directory_name(P));
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, leaf_pattern, U"Chapter %d*")) {
		Str__clear(leaf_pattern); WRITE_TO(leaf_pattern, "Chapter*");
	} else if (Regexp__match(&mr, leaf_pattern, U"Appendix %C")) {
		Str__clear(leaf_pattern); WRITE_TO(leaf_pattern, "Appendix*");
	}
	Regexp__dispose_of(&mr);
	TEMPORARY_TEXT(tester)
	WRITE_TO(tester, "%p/%S/*", Pathnames__up(P), leaf_pattern);
	DISCARD_TEXT(leaf_pattern)
	Filenames__write_extension(tester, F);
	if (Dictionaries__find(patterns_done, tester) == NULL) {
		WRITE_TO(Dictionaries__create_text(patterns_done, tester), "got this");
		WRITE(" ");
		LOOP_THROUGH_TEXT(pos, tester) {
			inchar32_t c = Str__get(pos);
			if (c == ' ') PUT('\\');
			PUT(c);
		}
	}
	DISCARD_TEXT(tester)

}
#line 331 "inweb/Chapter 6/Makefiles.w"
;
	}
}

#line 366 "inweb/Chapter 6/Makefiles.w"
void Makefiles__pathname_slashed(OUTPUT_STREAM, pathname *P) {
	TEMPORARY_TEXT(PT)
	WRITE_TO(PT, "%p", P);
	LOOP_THROUGH_TEXT(pos, PT) {
		inchar32_t c = Str__get(pos);
		if (c == ' ') WRITE("\\ ");
		else PUT(c);
	}
	DISCARD_TEXT(PT)
}

#line 8 "inweb/Chapter 6/Git Support.w"
void Git__write_gitignore(web *W, filename *prototype, filename *F) {
	linked_list *L = NEW_LINKED_LIST(preprocessor_macro);
	Preprocessor__new_macro(L, TL_IS_3139, NULL, Git__basics_expander, NULL);
	text_stream *header = Str__new();
	WRITE_TO(header, "# This gitignore was automatically written by inweb -gitignore\n");
	WRITE_TO(header, "# and is not intended for human editing\n\n");
	WRITE_TO(STDOUT, "(Read script from %f)\n", prototype);
	Preprocessor__preprocess(prototype, F, header, L, NULL_GENERAL_POINTER, '#', ISO_ENC);
}

#line 22 "inweb/Chapter 6/Git Support.w"
void Git__basics_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	filename *prototype = Filenames__in(path_to_inweb_materials, TL_IS_3140);
	TextFiles__read(prototype, FALSE, "can't open basic .gitignore file",
		TRUE, Preprocessor__scan_line, NULL, PPS);
	WRITE_TO(STDOUT, "(Read basics.giscript from inweb/");
	Pathnames__to_text_relative(STDOUT, path_to_inweb, path_to_inweb_materials);
	WRITE_TO(STDOUT, ")\n");
}

#line 35 "inweb/Chapter 6/Ctags Support.w"
void Ctags__write(web *W, filename *F) {
	text_stream ctags_file;
	pathname *P = NULL;
	if (F) {
		P = Filenames__up(F);
	} else {
		P = W->md->path_to_web;
		F = Filenames__in(P, TL_IS_3141);
	}
	text_stream *OUT = &ctags_file;
	if (STREAM_OPEN_TO_FILE(OUT, F, UTF8_ENC) == FALSE)
		Errors__fatal_with_file("unable to write ctags file", F);
	
{
#line 82 "inweb/Chapter 6/Ctags Support.w"
	WRITE("!_TAG_FILE_FORMAT\t2\t/extended format; --format=1 will not append ;\" to lines/\n");
	WRITE("!_TAG_FILE_SORTED\t0\t/0=unsorted, 1=sorted, 2=foldcase/\n");
	WRITE("!_TAG_PROGRAM_AUTHOR\tGraham Nelson\t/graham.nelson@mod-langs.ox.ac.uk/\n");
	WRITE("!_TAG_PROGRAM_NAME\tinweb\t//\n");
	WRITE("!_TAG_PROGRAM_VERSION\t7.2.1-beta+1B45\t/built 1 September 2023/\n");

}
#line 47 "inweb/Chapter 6/Ctags Support.w"
;
	
{
#line 94 "inweb/Chapter 6/Ctags Support.w"
	defined_constant *str;
	LOOP_OVER(str, defined_constant)
		if (str->at->owning_section->owning_web == W) {
			WRITE("%S\t", str->name);
			Ctags__write_line_ref(OUT, str->at, P);
			WRITE(";\"\t");
			WRITE("d");
			WRITE("\n");
		}

}
#line 48 "inweb/Chapter 6/Ctags Support.w"
;
	
{
#line 109 "inweb/Chapter 6/Ctags Support.w"
	language_type *str;
	LOOP_OVER(str, language_type)
		if (str->structure_header_at->owning_section->owning_web == W) {
			WRITE("%S\t", str->structure_name);
			Ctags__write_line_ref(OUT, str->structure_header_at, P);
			WRITE(";\"\t");
			WRITE("t\ttyperef:struct:%S", str->structure_name);
			WRITE("\n");
		}

}
#line 49 "inweb/Chapter 6/Ctags Support.w"
;
	
{
#line 122 "inweb/Chapter 6/Ctags Support.w"
	language_function *fn;
	LOOP_OVER(fn, language_function)
		if (fn->function_header_at->owning_section->owning_web == W) {
			WRITE("%S\t", fn->function_name);
			Ctags__write_line_ref(OUT, fn->function_header_at, P);
			WRITE(";\"\t");
			WRITE("f");
			WRITE("\n");
		}

}
#line 50 "inweb/Chapter 6/Ctags Support.w"
;
	STREAM_CLOSE(OUT);
}

#line 146 "inweb/Chapter 6/Ctags Support.w"
void Ctags__write_line_ref(OUTPUT_STREAM, source_line *L, pathname *P) {
	TEMPORARY_TEXT(fn)
	WRITE_TO(fn, "%f", L->owning_section->md->source_file_for_section);
	if (Platform__is_folder_separator(Str__get_first_char(fn)) == FALSE) {
		Str__clear(fn);
		Filenames__to_text_relative(fn, L->owning_section->md->source_file_for_section, P);
	}
	WRITE("%S\t/^", fn);
	DISCARD_TEXT(fn)
	for (int i = 0; i < Str__len(L->text); i++) {
		inchar32_t c = Str__get_at(L->text, i);
		switch (c) {
			case '/': PUT('\\'); PUT(c); break;
			case '^': if (i == 0) PUT('\\'); PUT(c); break;
			case '$': if (i < Str__len(L->text) - 1) PUT('\\'); PUT(c); break;
			default: PUT(c); break;
		}
	}
	WRITE("$/");
}

#line 178 "inweb/Chapter 6/Ctags Support.w"

#line 182 "inweb/Chapter 6/Ctags Support.w"
void Ctags__note_defined_constant(source_line *L, text_stream *name) {
	defined_constant *dc = CREATE(defined_constant);
	dc->name = Str__duplicate(name);
	dc->at = L;
}

#line 10 "inweb/Chapter 6/Readme Writeme.w"
void Readme__write(filename *prototype, filename *F) {
	linked_list *L = NEW_LINKED_LIST(preprocessor_macro);
	preprocessor_macro *mm = Preprocessor__new_macro(L,
		TL_IS_3142, TL_IS_3143,
		Readme__bibliographic_expander, NULL);
	Preprocessor__do_not_suppress_whitespace(mm);
	WRITE_TO(STDOUT, "(Read script from %f)\n", prototype);
	Preprocessor__preprocess(prototype, F, NULL, L, NULL_GENERAL_POINTER, '/', ISO_ENC);
}

#line 23 "inweb/Chapter 6/Readme Writeme.w"
void Readme__bibliographic_expander(preprocessor_macro *mm, preprocessor_state *PPS,
	text_stream **parameter_values, preprocessor_loop *loop, text_file_position *tfp) {
	text_stream *datum = parameter_values[0];
	text_stream *asset_name = parameter_values[1];
	text_stream *OUT = PPS->dest;
	writeme_asset *A = Readme__find_asset(asset_name);
	if (A->if_web) WRITE("%S", Bibliographic__get_datum(A->if_web, datum));
	else if (Str__eq(datum, TL_IS_3144)) WRITE("%S", A->date);
	else if (Str__eq(datum, TL_IS_3145)) WRITE("%S", A->version);
}

#line 49 "inweb/Chapter 6/Readme Writeme.w"

void Readme__write_var(text_stream *OUT, text_stream *program, text_stream *datum) {
	writeme_asset *A = Readme__find_asset(program);
	if (A->if_web) WRITE("%S", Bibliographic__get_datum(A->if_web, datum));
	else if (Str__eq(datum, TL_IS_3146)) WRITE("%S", A->date);
	else if (Str__eq(datum, TL_IS_3147)) WRITE("%S", A->version);
}

#line 60 "inweb/Chapter 6/Readme Writeme.w"
writeme_asset *Readme__find_asset(text_stream *program) {
	writeme_asset *A;
	LOOP_OVER(A, writeme_asset) if (Str__eq(program, A->name)) return A;
	A = CREATE(writeme_asset);
	A->name = Str__duplicate(program);
	A->if_web = NULL;
	A->date = Str__new();
	A->version = Str__new();
	A->next_is_version = FALSE;
	
{
#line 74 "inweb/Chapter 6/Readme Writeme.w"
	if (Str__ends_with_wide_string(program, U".i7x")) {
		
{
#line 93 "inweb/Chapter 6/Readme Writeme.w"
	TextFiles__read(Filenames__from_text(program), FALSE, "unable to read extension", TRUE,
		&Readme__extension_harvester, NULL, A);

}
#line 75 "inweb/Chapter 6/Readme Writeme.w"
;
	} else {
		if (WebMetadata__directory_looks_like_a_web(Pathnames__from_text(program))) {
			A->if_web = WebMetadata__get_without_modules(Pathnames__from_text(program), NULL);
		} else {
			filename *I6_vn = Filenames__in(
				Pathnames__down(Pathnames__from_text(program), TL_IS_3148), TL_IS_3149);
			if (TextFiles__exists(I6_vn)) 
{
#line 97 "inweb/Chapter 6/Readme Writeme.w"
	TextFiles__read(I6_vn, FALSE, "unable to read header file from I6 source", TRUE,
		&Readme__header_harvester, NULL, A);

}
#line 82 "inweb/Chapter 6/Readme Writeme.w"
;
			filename *template_vn = Filenames__in(Pathnames__from_text(program), TL_IS_3150);
			if (TextFiles__exists(template_vn)) 
{
#line 101 "inweb/Chapter 6/Readme Writeme.w"
	TextFiles__read(template_vn, FALSE, "unable to read manifest file from website template", TRUE,
		&Readme__template_harvester, NULL, A);

}
#line 84 "inweb/Chapter 6/Readme Writeme.w"
;
			filename *rmt_vn = Filenames__in(Pathnames__from_text(program), TL_IS_3151);
			if (TextFiles__exists(rmt_vn)) 
{
#line 105 "inweb/Chapter 6/Readme Writeme.w"
	TextFiles__read(rmt_vn, FALSE, "unable to read README file from website template", TRUE,
		&Readme__readme_harvester, NULL, A);

}
#line 86 "inweb/Chapter 6/Readme Writeme.w"
;
			rmt_vn = Filenames__in(Pathnames__from_text(program), TL_IS_3152);
			if (TextFiles__exists(rmt_vn)) 
{
#line 105 "inweb/Chapter 6/Readme Writeme.w"
	TextFiles__read(rmt_vn, FALSE, "unable to read README file from website template", TRUE,
		&Readme__readme_harvester, NULL, A);

}
#line 88 "inweb/Chapter 6/Readme Writeme.w"
;
		}
	}

}
#line 69 "inweb/Chapter 6/Readme Writeme.w"
;
	return A;
}

#line 111 "inweb/Chapter 6/Readme Writeme.w"
void Readme__extension_harvester(text_stream *text, text_file_position *tfp, void *state) {
	writeme_asset *A = (writeme_asset *) state;
	match_results mr = Regexp__create_mr();
	if (Str__len(text) == 0) return;
	if (Regexp__match(&mr, text, U" *Version (%c*?) of %c*begins here. *"))
		A->version = Str__duplicate(mr.exp[0]);
	Regexp__dispose_of(&mr);
}

#line 123 "inweb/Chapter 6/Readme Writeme.w"
void Readme__header_harvester(text_stream *text, text_file_position *tfp, void *state) {
	writeme_asset *A = (writeme_asset *) state;
	match_results mr = Regexp__create_mr();
	if (Str__len(text) == 0) return;
	if (Regexp__match(&mr, text, U"#define RELEASE_NUMBER (%c*?) *"))
		A->version = Str__duplicate(mr.exp[0]);
	if (Regexp__match(&mr, text, U"#define RELEASE_DATE \"(%c*?)\" *"))
		A->date = Str__duplicate(mr.exp[0]);
	Regexp__dispose_of(&mr);
}

#line 137 "inweb/Chapter 6/Readme Writeme.w"
void Readme__template_harvester(text_stream *text, text_file_position *tfp, void *state) {
	writeme_asset *A = (writeme_asset *) state;
	match_results mr = Regexp__create_mr();
	if (Str__len(text) == 0) return;
	if (Regexp__match(&mr, text, U"%[INTERPRETERVERSION%]")) {
		A->next_is_version = TRUE;
	} else if (A->next_is_version) {
		A->version = Str__duplicate(text);
		A->next_is_version = FALSE;
	}
	Regexp__dispose_of(&mr);
}

#line 153 "inweb/Chapter 6/Readme Writeme.w"
void Readme__readme_harvester(text_stream *text, text_file_position *tfp, void *state) {
	writeme_asset *A = (writeme_asset *) state;
	match_results mr = Regexp__create_mr();
	if (Str__len(text) == 0) return;
	if ((Regexp__match(&mr, text, U"CheapGlk Library: version (%c*?) *")) ||
		(Regexp__match(&mr, text, U"- Version (%c*?) *")))
		A->version = Str__duplicate(mr.exp[0]);
	Regexp__dispose_of(&mr);
}

#line 28 "inweb/Chapter 6/Colonies.w"

#line 52 "inweb/Chapter 6/Colonies.w"

#line 65 "inweb/Chapter 6/Colonies.w"

void Colonies__load(filename *F) {
	colony *C = CREATE(colony);
	C->members = NEW_LINKED_LIST(colony_member);
	C->home = TL_IS_3153;
	C->assets_path = NULL;
	C->patterns_path = NULL;
	colony_reader_state crs;
	crs.province = C;
	crs.nav = NULL;
	crs.crumbs = NEW_LINKED_LIST(breadcrumb_request);
	crs.pattern = NULL;
	TextFiles__read(F, FALSE, "can't open colony file",
		TRUE, Colonies__read_line, NULL, (void *) &crs);
}

#line 84 "inweb/Chapter 6/Colonies.w"
void Colonies__read_line(text_stream *line, text_file_position *tfp, void *v_crs) {
	colony_reader_state *crs = (colony_reader_state *) v_crs;
	colony *C = crs->province;

	Str__trim_white_space(line); /* ignore trailing space */
	if (Str__len(line) == 0) return; /* ignore blank lines */
	if (Str__get_first_char(line) == '#') return; /* lines opening with |#| are comments */

	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, line, U"(%c*?): \"*(%C+)\" at \"(%c*)\" in \"(%c*)\"")) {
		colony_member *CM = CREATE(colony_member);
		if (Str__eq(mr.exp[0], TL_IS_3154)) CM->web_rather_than_module = TRUE;
		else if (Str__eq(mr.exp[0], TL_IS_3155)) CM->web_rather_than_module = FALSE;
		else {
			CM->web_rather_than_module = FALSE;
			Errors__in_text_file("text before ':' must be 'web' or 'module'", tfp);
		}
		CM->name = Str__duplicate(mr.exp[1]);
		CM->path = Str__duplicate(mr.exp[2]);
		CM->home_leaf = Str__new();
		if (Str__suffix_eq(CM->path, TL_IS_3156, 6)) {
			filename *F = Filenames__from_text(CM->path);
			Filenames__write_unextended_leafname(CM->home_leaf, F);
			WRITE_TO(CM->home_leaf, ".html");
		} else {
			WRITE_TO(CM->home_leaf, "index.html");
		}
		CM->weave_path = Pathnames__from_text(mr.exp[3]);
		CM->loaded = NULL;
		CM->navigation = crs->nav;
		CM->breadcrumb_tail = crs->crumbs;
		CM->default_weave_pattern = Str__duplicate(crs->pattern);
		ADD_TO_LINKED_LIST(CM, colony_member, C->members);
	} else if (Regexp__match(&mr, line, U"home: *(%c*)")) {
		C->home = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, line, U"assets: *(%c*)")) {
		C->assets_path = Pathnames__from_text(mr.exp[0]);
	} else if (Regexp__match(&mr, line, U"patterns: *(%c*)")) {
		C->patterns_path = Pathnames__from_text(mr.exp[0]);
	} else if (Regexp__match(&mr, line, U"pattern: none")) {
		crs->pattern = NULL;
	} else if (Regexp__match(&mr, line, U"pattern: *(%c*)")) {
		crs->pattern = Str__duplicate(mr.exp[0]);
	} else if (Regexp__match(&mr, line, U"navigation: none")) {
		crs->nav = NULL;
	} else if (Regexp__match(&mr, line, U"navigation: *(%c*)")) {
		crs->nav = Filenames__from_text(mr.exp[0]);
	} else if (Regexp__match(&mr, line, U"breadcrumbs: none")) {
		crs->crumbs = NEW_LINKED_LIST(breadcrumb_request);
	} else if (Regexp__match(&mr, line, U"breadcrumbs: *(%c*)")) {
		crs->crumbs = NEW_LINKED_LIST(breadcrumb_request);
		match_results mr2 = Regexp__create_mr();
		while (Regexp__match(&mr2, mr.exp[0], U"(\"%c*?\") > (%c*)")) {
			Colonies__add_crumb(crs->crumbs, mr2.exp[0], tfp);
			Str__clear(mr.exp[0]); Str__copy(mr.exp[0], mr2.exp[1]);
		}
		Colonies__add_crumb(crs->crumbs, mr.exp[0], tfp);
	} else {
		Errors__in_text_file("unable to read colony member", tfp);
	}
	Regexp__dispose_of(&mr);
}

#line 151 "inweb/Chapter 6/Colonies.w"
void Colonies__add_crumb(linked_list *L, text_stream *spec, text_file_position *tfp) {
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, spec, U"\"(%c*?)\"") == FALSE) {
		Errors__in_text_file("each crumb must be in double-quotes", tfp);
		return;
	}
	spec = mr.exp[0];
	breadcrumb_request *br = Colonies__request_breadcrumb(spec);
	ADD_TO_LINKED_LIST(br, breadcrumb_request, L);
	Regexp__dispose_of(&mr);
}

#line 168 "inweb/Chapter 6/Colonies.w"

breadcrumb_request *Colonies__request_breadcrumb(text_stream *arg) {
	breadcrumb_request *BR = CREATE(breadcrumb_request);
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, arg, U"(%c*?): *(%c*)")) {
		BR->breadcrumb_text = Str__duplicate(mr.exp[0]);
		BR->breadcrumb_link = Str__duplicate(mr.exp[1]);
	} else {
		BR->breadcrumb_text = Str__duplicate(arg);
		BR->breadcrumb_link = Str__duplicate(arg);
		WRITE_TO(BR->breadcrumb_link, ".html");
	}
	Regexp__dispose_of(&mr);
	return BR;
}

void Colonies__drop_initial_breadcrumbs(OUTPUT_STREAM, filename *F, linked_list *crumbs) {
	breadcrumb_request *BR;
	LOOP_OVER_LINKED_LIST(BR, breadcrumb_request, crumbs) {
		TEMPORARY_TEXT(url)
		Colonies__link_URL(url, BR->breadcrumb_link, F);
		Colonies__write_breadcrumb(OUT, BR->breadcrumb_text, url);
		DISCARD_TEXT(url)
	}
}

void Colonies__write_breadcrumb(OUTPUT_STREAM, text_stream *text, text_stream *link) {
	if (link) {
		HTML_OPEN("li");
		HTML__begin_link(OUT, link);
		WRITE("%S", text);
		HTML__end_link(OUT);
		HTML_CLOSE("li");
	} else {
		HTML_OPEN("li");
		HTML_OPEN("b");
		WRITE("%S", text);
		HTML_CLOSE("b");
		HTML_CLOSE("li");
	}
}

#line 215 "inweb/Chapter 6/Colonies.w"
colony_member *Colonies__find(text_stream *T) {
	colony *C;
	LOOP_OVER(C, colony) {
		colony_member *CM;
		LOOP_OVER_LINKED_LIST(CM, colony_member, C->members)
			if (Str__eq_insensitive(T, CM->name))
				return CM;
	}
	return NULL;
}

#line 233 "inweb/Chapter 6/Colonies.w"
module *Colonies__as_module(colony_member *CM, source_line *L, web_md *Wm) {
	if (CM->loaded == NULL) 
{
#line 242 "inweb/Chapter 6/Colonies.w"
	if ((Wm) && (Str__eq_insensitive(Wm->as_module->module_name, CM->name)))
		CM->loaded = Wm;

}
#line 234 "inweb/Chapter 6/Colonies.w"
;
	if (CM->loaded == NULL) 
{
#line 246 "inweb/Chapter 6/Colonies.w"
	if (Wm) {
		module *M;
		LOOP_OVER_LINKED_LIST(M, module, Wm->as_module->dependencies)
			if (Str__eq_insensitive(M->module_name, CM->name))
				CM->loaded = Wm;
	}

}
#line 235 "inweb/Chapter 6/Colonies.w"
;
	if (CM->loaded == NULL) 
{
#line 254 "inweb/Chapter 6/Colonies.w"
	filename *F = NULL;
	pathname *P = NULL;
	if (Str__suffix_eq(CM->path, TL_IS_3157, 6))
		F = Filenames__from_text(CM->path);
	else
		P = Pathnames__from_text(CM->path);
	CM->loaded = WebMetadata__get_without_modules(P, F);

}
#line 236 "inweb/Chapter 6/Colonies.w"
;
	if (CM->loaded == NULL) 
{
#line 263 "inweb/Chapter 6/Colonies.w"
	TEMPORARY_TEXT(err)
	WRITE_TO(err, "unable to load '%S'", CM->name);
	Main__error_in_web(err, L);

}
#line 237 "inweb/Chapter 6/Colonies.w"
;
	return CM->loaded->as_module;
}

#line 270 "inweb/Chapter 6/Colonies.w"
text_stream *Colonies__home(void) {
	colony *C;
	LOOP_OVER(C, colony)
		return C->home;
	return TL_IS_3158;
}

pathname *Colonies__assets_path(void) {
	colony *C;
	LOOP_OVER(C, colony)
		return C->assets_path;
	return NULL;
}

pathname *Colonies__patterns_path(void) {
	colony *C;
	LOOP_OVER(C, colony)
		return C->patterns_path;
	return NULL;
}

#line 310 "inweb/Chapter 6/Colonies.w"
int Colonies__resolve_reference_in_weave(text_stream *url, text_stream *title,
	filename *for_HTML_file, text_stream *text, web_md *Wm, source_line *L, int *ext) {
	int r = 0;
	if (ext) *ext = FALSE;
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, text, U"(%c+?) -> (%c+)")) {
		r = Colonies__resolve_reference_in_weave_inner(url, NULL,
			for_HTML_file, mr.exp[1], Wm, L, ext);
		WRITE_TO(title, "%S", mr.exp[0]);
	} else {
		r = Colonies__resolve_reference_in_weave_inner(url, title,
			for_HTML_file, text, Wm, L, ext);
	}
	Regexp__dispose_of(&mr);
	return r;
}

int Colonies__resolve_reference_in_weave_inner(text_stream *url, text_stream *title,
	filename *for_HTML_file, text_stream *text, web_md *Wm, source_line *L, int *ext) {
	module *from_M = (Wm)?(Wm->as_module):NULL;
	module *search_M = from_M;
	colony_member *search_CM = NULL;
	int external = FALSE;

	
{
#line 378 "inweb/Chapter 6/Colonies.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, text, U"https*://%c*")) {
		WRITE_TO(url, "%S", text);
		WRITE_TO(title, "%S", text);
		Regexp__dispose_of(&mr);
		if (ext) *ext = TRUE;
		return TRUE;
	}
	Regexp__dispose_of(&mr);

}
#line 334 "inweb/Chapter 6/Colonies.w"
;
	
{
#line 389 "inweb/Chapter 6/Colonies.w"
	search_CM = Colonies__find(text);
	if (search_CM) {
		module *found_M = Colonies__as_module(search_CM, L, Wm);
		section_md *found_Sm = FIRST_IN_LINKED_LIST(section_md, found_M->sections_md);
		int bare_module_name = TRUE;
		WRITE_TO(title, "%S", search_CM->name);
		
{
#line 437 "inweb/Chapter 6/Colonies.w"
	if (found_M == NULL) internal_error("could not locate M");
	if (search_CM) 
{
#line 443 "inweb/Chapter 6/Colonies.w"
	pathname *from = Filenames__up(for_HTML_file);
	pathname *to = search_CM->weave_path;
	Pathnames__relative_URL(url, from, to);
	if (bare_module_name) WRITE_TO(url, "%S", search_CM->home_leaf);
	else if (found_Sm) Colonies__section_URL(url, found_Sm);
	if (bare_module_name == FALSE)
		WRITE_TO(title, " (in %S)", search_CM->name);

}
#line 438 "inweb/Chapter 6/Colonies.w"

	else 
{
#line 456 "inweb/Chapter 6/Colonies.w"
	if (found_M == from_M) {
		Colonies__section_URL(url, found_Sm);
	} else {
		WRITE_TO(url, "../%S-module/", found_M->module_name);
		Colonies__section_URL(url, found_Sm);
		if (bare_module_name == FALSE)
			WRITE_TO(title, " (in %S)", found_M->module_name);
	}

}
#line 439 "inweb/Chapter 6/Colonies.w"
;
	return TRUE;

}
#line 395 "inweb/Chapter 6/Colonies.w"
;
	}

}
#line 335 "inweb/Chapter 6/Colonies.w"
;
	
{
#line 399 "inweb/Chapter 6/Colonies.w"
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, text, U"(%c*?): (%c*)")) {
		search_CM = Colonies__find(mr.exp[0]);
		if (search_CM) {
			module *found_M = Colonies__as_module(search_CM, L, Wm);
			if (found_M) {
				search_M = found_M;
				if (LinkedLists__len(found_M->dependencies) == 0)
					text = Str__duplicate(mr.exp[1]);
				external = TRUE;
			}
		}
	}
	Regexp__dispose_of(&mr);

}
#line 336 "inweb/Chapter 6/Colonies.w"
;

	module *found_M = NULL;
	section_md *found_Sm = NULL;
	int bare_module_name = FALSE;

	/* find how many hits (N), and how many which are sections (NS) */
	int N = WebModules__named_reference(&found_M, &found_Sm, &bare_module_name,
		NULL, search_M, text, FALSE, FALSE);
	found_M = NULL; found_Sm = NULL; bare_module_name = FALSE;
	int NS = WebModules__named_reference(&found_M, &found_Sm, &bare_module_name,
		NULL, search_M, text, FALSE, TRUE);
	int sections_only = FALSE;
	if ((N > 1) && (NS == 1)) sections_only = TRUE;

	/* now perform the definitive search */
	found_M = NULL; found_Sm = NULL; bare_module_name = FALSE;
	N = WebModules__named_reference(&found_M, &found_Sm, &bare_module_name,
		title, search_M, text, FALSE, sections_only);

	if (N == 0) {
		if ((L) && (external == FALSE)) {
			
{
#line 415 "inweb/Chapter 6/Colonies.w"
	language_function *fn;
	LOOP_OVER(fn, language_function) {
		if (Str__eq_insensitive(fn->function_name, text)) {
			Colonies__paragraph_URL(url, fn->function_header_at->owning_paragraph,
				for_HTML_file);
			WRITE_TO(title, "%S", fn->function_name);
			return TRUE;
		}
	}

}
#line 358 "inweb/Chapter 6/Colonies.w"
;
			
{
#line 426 "inweb/Chapter 6/Colonies.w"
	language_type *str;
	LOOP_OVER(str, language_type) {
		if (Str__eq_insensitive(str->structure_name, text)) {
			Colonies__paragraph_URL(url, str->structure_header_at->owning_paragraph,
				for_HTML_file);
			WRITE_TO(title, "%S", str->structure_name);
			return TRUE;
		}
	}

}
#line 359 "inweb/Chapter 6/Colonies.w"
;
		}
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "Can't find the cross-reference '%S'", text);
		Main__error_in_web(err, L);
		DISCARD_TEXT(err)
		return FALSE;
	}
	if (N > 1) {
		Main__error_in_web(TL_IS_3159, L);
		WebModules__named_reference(&found_M, &found_Sm, &bare_module_name,
			title, search_M, text, TRUE, FALSE);
		return FALSE;
	}
	
{
#line 437 "inweb/Chapter 6/Colonies.w"
	if (found_M == NULL) internal_error("could not locate M");
	if (search_CM) 
{
#line 443 "inweb/Chapter 6/Colonies.w"
	pathname *from = Filenames__up(for_HTML_file);
	pathname *to = search_CM->weave_path;
	Pathnames__relative_URL(url, from, to);
	if (bare_module_name) WRITE_TO(url, "%S", search_CM->home_leaf);
	else if (found_Sm) Colonies__section_URL(url, found_Sm);
	if (bare_module_name == FALSE)
		WRITE_TO(title, " (in %S)", search_CM->name);

}
#line 438 "inweb/Chapter 6/Colonies.w"

	else 
{
#line 456 "inweb/Chapter 6/Colonies.w"
	if (found_M == from_M) {
		Colonies__section_URL(url, found_Sm);
	} else {
		WRITE_TO(url, "../%S-module/", found_M->module_name);
		Colonies__section_URL(url, found_Sm);
		if (bare_module_name == FALSE)
			WRITE_TO(title, " (in %S)", found_M->module_name);
	}

}
#line 439 "inweb/Chapter 6/Colonies.w"
;
	return TRUE;

}
#line 373 "inweb/Chapter 6/Colonies.w"
;
	return TRUE;
}

#line 468 "inweb/Chapter 6/Colonies.w"
void Colonies__link_URL(OUTPUT_STREAM, text_stream *link_text, filename *F) {
	match_results mr = Regexp__create_mr();
	if (Regexp__match(&mr, link_text, U" *//(%c+)// *"))
		Colonies__reference_URL(OUT, mr.exp[0], F);
	else
		WRITE("%S", link_text);
	Regexp__dispose_of(&mr);
}

void Colonies__reference_URL(OUTPUT_STREAM, text_stream *link_text, filename *F) {
	TEMPORARY_TEXT(title)
	TEMPORARY_TEXT(url)
	if (Colonies__resolve_reference_in_weave(url, title, F, link_text, NULL, NULL, NULL))
		WRITE("%S", url);
	else
		PRINT("Warning: unable to resolve reference '%S' in navigation\n", link_text);
	DISCARD_TEXT(title)
	DISCARD_TEXT(url)
}

void Colonies__section_URL(OUTPUT_STREAM, section_md *Sm) {
	if (Sm == NULL) internal_error("unwoven section");
	LOOP_THROUGH_TEXT(pos, Sm->sect_range)
		if ((Str__get(pos) == '/') || (Str__get(pos) == ' '))
			PUT('-');
		else
			PUT(Str__get(pos));
	WRITE(".html");
}

void Colonies__paragraph_URL(OUTPUT_STREAM, paragraph *P, filename *from) {
	if (from == NULL) internal_error("no from file");
	if (P == NULL) internal_error("no para");
	section *to_S = P->under_section;
	module *to_M = to_S->md->owning_module;
	if (Str__ne(to_M->module_name, TL_IS_3160)) {
		colony_member *to_C = Colonies__find(to_M->module_name);
		if (to_C) {
			pathname *from_path = Filenames__up(from);
			pathname *to_path = to_C->weave_path;
			Pathnames__relative_URL(OUT, from_path, to_path);
		} else {
			PRINT("Warning: a link in the weave will work only if '%S' appears in the colony file\n",
				to_M->module_name);
		}
	}
	Colonies__section_URL(OUT, to_S->md);
	WRITE("#");
	Colonies__paragraph_anchor(OUT, P);
}

void Colonies__paragraph_anchor(OUTPUT_STREAM, paragraph *P) {
	if (P == NULL) internal_error("no para");
	WRITE("%S", P->ornament);
	WRITE("P");
	text_stream *N = P->paragraph_number;
	LOOP_THROUGH_TEXT(pos, N)
		if (Str__get(pos) == '.') WRITE("_");
		else PUT(Str__get(pos));
}

void register_tangled_nonterminals(void) {
}
void register_tangled_text_literals(void) {
    TL_IS_0 = Str__literal(U"INVOCATION");
    TL_IS_1 = Str__literal(U"debug-log.txt");
    TL_IS_2 = Str__literal(U"Tangled");
    TL_IS_3 = Str__literal(U"NAME");
    TL_IS_4 = Str__literal(U"");
    TL_IS_5 = Str__literal(U"repeat");
    TL_IS_6 = Str__literal(U"with: WITH in: IN");
    TL_IS_7 = Str__literal(U"set");
    TL_IS_8 = Str__literal(U"name: NAME value: VALUE");
    TL_IS_9 = Str__literal(U"mismatched '[' ... ']'");
    TL_IS_10 = Str__literal(U"mismatched '{' ... '}'");
    TL_IS_11 = Str__literal(U"mismatched quotation marks");
    TL_IS_12 = Str__literal(U"true");
    TL_IS_13 = Str__literal(U"false");
    TL_IS_14 = Str__literal(U"null");
    TL_IS_15 = Str__literal(U"unknown JSON value");
    TL_IS_16 = Str__literal(U"whitespace where JSON value expected");
    TL_IS_17 = Str__literal(U"object body ends with comma");
    TL_IS_18 = Str__literal(U"key does not begin with quotation mark");
    TL_IS_19 = Str__literal(U"key does not end with quotation mark");
    TL_IS_20 = Str__literal(U"key is not followed by ':'");
    TL_IS_21 = Str__literal(U"duplicate key");
    TL_IS_22 = Str__literal(U"whitespace where number expected");
    TL_IS_23 = Str__literal(U"number is not a decimal integer");
    TL_IS_24 = Str__literal(U"number is not allowed to be NaN");
    TL_IS_25 = Str__literal(U"unescaped control character");
    TL_IS_26 = Str__literal(U"bad '\\' escape in string");
    TL_IS_27 = Str__literal(U"incomplete '\\u' escape");
    TL_IS_28 = Str__literal(U"garbled '\\u' escape");
    TL_IS_29 = Str__literal(U"array");
    TL_IS_30 = Str__literal(U"object");
    TL_IS_31 = Str__literal(U"erroneous JSON value from parsing bad text");
    TL_IS_32 = Str__literal(U"unexpected array entry");
    TL_IS_33 = Str__literal(U"mismatched '(' ... ')'");
    TL_IS_34 = Str__literal(U"whitespace where requirement expected");
    TL_IS_35 = Str__literal(U"mismatched '[' ... ']'");
    TL_IS_36 = Str__literal(U"mismatched '{' ... '}'");
    TL_IS_37 = Str__literal(U"mismatched '<' ... '>'");
    TL_IS_38 = Str__literal(U"unknown '<name>'");
    TL_IS_39 = Str__literal(U"'<' ... '>' not allowed");
    TL_IS_40 = Str__literal(U"true");
    TL_IS_41 = Str__literal(U"false");
    TL_IS_42 = Str__literal(U"null");
    TL_IS_43 = Str__literal(U"number");
    TL_IS_44 = Str__literal(U"double");
    TL_IS_45 = Str__literal(U"string");
    TL_IS_46 = Str__literal(U"boolean");
    TL_IS_47 = Str__literal(U"key does not begin with quotation mark");
    TL_IS_48 = Str__literal(U"key does not end with quotation mark");
    TL_IS_49 = Str__literal(U"key is not followed by ':'");
    TL_IS_50 = Str__literal(U"duplicate key");
    TL_IS_51 = Str__literal(U"spurious text before first requirement");
    TL_IS_52 = Str__literal(U"CONTENT BEGINS");
    TL_IS_53 = Str__literal(U"CONTENT ENDS");
    TL_IS_54 = Str__literal(U"inform:/doc_images/ornament_flower.png");
    TL_IS_55 = Str__literal(U"&AElig");
    TL_IS_56 = Str__literal(U"&AElig;");
    TL_IS_57 = Str__literal(U"&AMP");
    TL_IS_58 = Str__literal(U"&AMP;");
    TL_IS_59 = Str__literal(U"&Aacute");
    TL_IS_60 = Str__literal(U"&Aacute;");
    TL_IS_61 = Str__literal(U"&Abreve;");
    TL_IS_62 = Str__literal(U"&Acirc");
    TL_IS_63 = Str__literal(U"&Acirc;");
    TL_IS_64 = Str__literal(U"&Acy;");
    TL_IS_65 = Str__literal(U"&Afr;");
    TL_IS_66 = Str__literal(U"&Agrave");
    TL_IS_67 = Str__literal(U"&Agrave;");
    TL_IS_68 = Str__literal(U"&Alpha;");
    TL_IS_69 = Str__literal(U"&Amacr;");
    TL_IS_70 = Str__literal(U"&And;");
    TL_IS_71 = Str__literal(U"&Aogon;");
    TL_IS_72 = Str__literal(U"&Aopf;");
    TL_IS_73 = Str__literal(U"&ApplyFunction;");
    TL_IS_74 = Str__literal(U"&Aring");
    TL_IS_75 = Str__literal(U"&Aring;");
    TL_IS_76 = Str__literal(U"&Ascr;");
    TL_IS_77 = Str__literal(U"&Assign;");
    TL_IS_78 = Str__literal(U"&Atilde");
    TL_IS_79 = Str__literal(U"&Atilde;");
    TL_IS_80 = Str__literal(U"&Auml");
    TL_IS_81 = Str__literal(U"&Auml;");
    TL_IS_82 = Str__literal(U"&Backslash;");
    TL_IS_83 = Str__literal(U"&Barv;");
    TL_IS_84 = Str__literal(U"&Barwed;");
    TL_IS_85 = Str__literal(U"&Bcy;");
    TL_IS_86 = Str__literal(U"&Because;");
    TL_IS_87 = Str__literal(U"&Bernoullis;");
    TL_IS_88 = Str__literal(U"&Beta;");
    TL_IS_89 = Str__literal(U"&Bfr;");
    TL_IS_90 = Str__literal(U"&Bopf;");
    TL_IS_91 = Str__literal(U"&Breve;");
    TL_IS_92 = Str__literal(U"&Bscr;");
    TL_IS_93 = Str__literal(U"&Bumpeq;");
    TL_IS_94 = Str__literal(U"&CHcy;");
    TL_IS_95 = Str__literal(U"&COPY");
    TL_IS_96 = Str__literal(U"&COPY;");
    TL_IS_97 = Str__literal(U"&Cacute;");
    TL_IS_98 = Str__literal(U"&Cap;");
    TL_IS_99 = Str__literal(U"&CapitalDifferentialD;");
    TL_IS_100 = Str__literal(U"&Cayleys;");
    TL_IS_101 = Str__literal(U"&Ccaron;");
    TL_IS_102 = Str__literal(U"&Ccedil");
    TL_IS_103 = Str__literal(U"&Ccedil;");
    TL_IS_104 = Str__literal(U"&Ccirc;");
    TL_IS_105 = Str__literal(U"&Cconint;");
    TL_IS_106 = Str__literal(U"&Cdot;");
    TL_IS_107 = Str__literal(U"&Cedilla;");
    TL_IS_108 = Str__literal(U"&CenterDot;");
    TL_IS_109 = Str__literal(U"&Cfr;");
    TL_IS_110 = Str__literal(U"&Chi;");
    TL_IS_111 = Str__literal(U"&CircleDot;");
    TL_IS_112 = Str__literal(U"&CircleMinus;");
    TL_IS_113 = Str__literal(U"&CirclePlus;");
    TL_IS_114 = Str__literal(U"&CircleTimes;");
    TL_IS_115 = Str__literal(U"&ClockwiseContourIntegral;");
    TL_IS_116 = Str__literal(U"&CloseCurlyDoubleQuote;");
    TL_IS_117 = Str__literal(U"&CloseCurlyQuote;");
    TL_IS_118 = Str__literal(U"&Colon;");
    TL_IS_119 = Str__literal(U"&Colone;");
    TL_IS_120 = Str__literal(U"&Congruent;");
    TL_IS_121 = Str__literal(U"&Conint;");
    TL_IS_122 = Str__literal(U"&ContourIntegral;");
    TL_IS_123 = Str__literal(U"&Copf;");
    TL_IS_124 = Str__literal(U"&Coproduct;");
    TL_IS_125 = Str__literal(U"&CounterClockwiseContourIntegral;");
    TL_IS_126 = Str__literal(U"&Cross;");
    TL_IS_127 = Str__literal(U"&Cscr;");
    TL_IS_128 = Str__literal(U"&Cup;");
    TL_IS_129 = Str__literal(U"&CupCap;");
    TL_IS_130 = Str__literal(U"&DD;");
    TL_IS_131 = Str__literal(U"&DDotrahd;");
    TL_IS_132 = Str__literal(U"&DJcy;");
    TL_IS_133 = Str__literal(U"&DScy;");
    TL_IS_134 = Str__literal(U"&DZcy;");
    TL_IS_135 = Str__literal(U"&Dagger;");
    TL_IS_136 = Str__literal(U"&Darr;");
    TL_IS_137 = Str__literal(U"&Dashv;");
    TL_IS_138 = Str__literal(U"&Dcaron;");
    TL_IS_139 = Str__literal(U"&Dcy;");
    TL_IS_140 = Str__literal(U"&Del;");
    TL_IS_141 = Str__literal(U"&Delta;");
    TL_IS_142 = Str__literal(U"&Dfr;");
    TL_IS_143 = Str__literal(U"&DiacriticalAcute;");
    TL_IS_144 = Str__literal(U"&DiacriticalDot;");
    TL_IS_145 = Str__literal(U"&DiacriticalDoubleAcute;");
    TL_IS_146 = Str__literal(U"&DiacriticalGrave;");
    TL_IS_147 = Str__literal(U"&DiacriticalTilde;");
    TL_IS_148 = Str__literal(U"&Diamond;");
    TL_IS_149 = Str__literal(U"&DifferentialD;");
    TL_IS_150 = Str__literal(U"&Dopf;");
    TL_IS_151 = Str__literal(U"&Dot;");
    TL_IS_152 = Str__literal(U"&DotDot;");
    TL_IS_153 = Str__literal(U"&DotEqual;");
    TL_IS_154 = Str__literal(U"&DoubleContourIntegral;");
    TL_IS_155 = Str__literal(U"&DoubleDot;");
    TL_IS_156 = Str__literal(U"&DoubleDownArrow;");
    TL_IS_157 = Str__literal(U"&DoubleLeftArrow;");
    TL_IS_158 = Str__literal(U"&DoubleLeftRightArrow;");
    TL_IS_159 = Str__literal(U"&DoubleLeftTee;");
    TL_IS_160 = Str__literal(U"&DoubleLongLeftArrow;");
    TL_IS_161 = Str__literal(U"&DoubleLongLeftRightArrow;");
    TL_IS_162 = Str__literal(U"&DoubleLongRightArrow;");
    TL_IS_163 = Str__literal(U"&DoubleRightArrow;");
    TL_IS_164 = Str__literal(U"&DoubleRightTee;");
    TL_IS_165 = Str__literal(U"&DoubleUpArrow;");
    TL_IS_166 = Str__literal(U"&DoubleUpDownArrow;");
    TL_IS_167 = Str__literal(U"&DoubleVerticalBar;");
    TL_IS_168 = Str__literal(U"&DownArrow;");
    TL_IS_169 = Str__literal(U"&DownArrowBar;");
    TL_IS_170 = Str__literal(U"&DownArrowUpArrow;");
    TL_IS_171 = Str__literal(U"&DownBreve;");
    TL_IS_172 = Str__literal(U"&DownLeftRightVector;");
    TL_IS_173 = Str__literal(U"&DownLeftTeeVector;");
    TL_IS_174 = Str__literal(U"&DownLeftVector;");
    TL_IS_175 = Str__literal(U"&DownLeftVectorBar;");
    TL_IS_176 = Str__literal(U"&DownRightTeeVector;");
    TL_IS_177 = Str__literal(U"&DownRightVector;");
    TL_IS_178 = Str__literal(U"&DownRightVectorBar;");
    TL_IS_179 = Str__literal(U"&DownTee;");
    TL_IS_180 = Str__literal(U"&DownTeeArrow;");
    TL_IS_181 = Str__literal(U"&Downarrow;");
    TL_IS_182 = Str__literal(U"&Dscr;");
    TL_IS_183 = Str__literal(U"&Dstrok;");
    TL_IS_184 = Str__literal(U"&ENG;");
    TL_IS_185 = Str__literal(U"&ETH");
    TL_IS_186 = Str__literal(U"&ETH;");
    TL_IS_187 = Str__literal(U"&Eacute");
    TL_IS_188 = Str__literal(U"&Eacute;");
    TL_IS_189 = Str__literal(U"&Ecaron;");
    TL_IS_190 = Str__literal(U"&Ecirc");
    TL_IS_191 = Str__literal(U"&Ecirc;");
    TL_IS_192 = Str__literal(U"&Ecy;");
    TL_IS_193 = Str__literal(U"&Edot;");
    TL_IS_194 = Str__literal(U"&Efr;");
    TL_IS_195 = Str__literal(U"&Egrave");
    TL_IS_196 = Str__literal(U"&Egrave;");
    TL_IS_197 = Str__literal(U"&Element;");
    TL_IS_198 = Str__literal(U"&Emacr;");
    TL_IS_199 = Str__literal(U"&EmptySmallSquare;");
    TL_IS_200 = Str__literal(U"&EmptyVerySmallSquare;");
    TL_IS_201 = Str__literal(U"&Eogon;");
    TL_IS_202 = Str__literal(U"&Eopf;");
    TL_IS_203 = Str__literal(U"&Epsilon;");
    TL_IS_204 = Str__literal(U"&Equal;");
    TL_IS_205 = Str__literal(U"&EqualTilde;");
    TL_IS_206 = Str__literal(U"&Equilibrium;");
    TL_IS_207 = Str__literal(U"&Escr;");
    TL_IS_208 = Str__literal(U"&Esim;");
    TL_IS_209 = Str__literal(U"&Eta;");
    TL_IS_210 = Str__literal(U"&Euml");
    TL_IS_211 = Str__literal(U"&Euml;");
    TL_IS_212 = Str__literal(U"&Exists;");
    TL_IS_213 = Str__literal(U"&ExponentialE;");
    TL_IS_214 = Str__literal(U"&Fcy;");
    TL_IS_215 = Str__literal(U"&Ffr;");
    TL_IS_216 = Str__literal(U"&FilledSmallSquare;");
    TL_IS_217 = Str__literal(U"&FilledVerySmallSquare;");
    TL_IS_218 = Str__literal(U"&Fopf;");
    TL_IS_219 = Str__literal(U"&ForAll;");
    TL_IS_220 = Str__literal(U"&Fouriertrf;");
    TL_IS_221 = Str__literal(U"&Fscr;");
    TL_IS_222 = Str__literal(U"&GJcy;");
    TL_IS_223 = Str__literal(U"&GT");
    TL_IS_224 = Str__literal(U"&GT;");
    TL_IS_225 = Str__literal(U"&Gamma;");
    TL_IS_226 = Str__literal(U"&Gammad;");
    TL_IS_227 = Str__literal(U"&Gbreve;");
    TL_IS_228 = Str__literal(U"&Gcedil;");
    TL_IS_229 = Str__literal(U"&Gcirc;");
    TL_IS_230 = Str__literal(U"&Gcy;");
    TL_IS_231 = Str__literal(U"&Gdot;");
    TL_IS_232 = Str__literal(U"&Gfr;");
    TL_IS_233 = Str__literal(U"&Gg;");
    TL_IS_234 = Str__literal(U"&Gopf;");
    TL_IS_235 = Str__literal(U"&GreaterEqual;");
    TL_IS_236 = Str__literal(U"&GreaterEqualLess;");
    TL_IS_237 = Str__literal(U"&GreaterFullEqual;");
    TL_IS_238 = Str__literal(U"&GreaterGreater;");
    TL_IS_239 = Str__literal(U"&GreaterLess;");
    TL_IS_240 = Str__literal(U"&GreaterSlantEqual;");
    TL_IS_241 = Str__literal(U"&GreaterTilde;");
    TL_IS_242 = Str__literal(U"&Gscr;");
    TL_IS_243 = Str__literal(U"&Gt;");
    TL_IS_244 = Str__literal(U"&HARDcy;");
    TL_IS_245 = Str__literal(U"&Hacek;");
    TL_IS_246 = Str__literal(U"&Hat;");
    TL_IS_247 = Str__literal(U"&Hcirc;");
    TL_IS_248 = Str__literal(U"&Hfr;");
    TL_IS_249 = Str__literal(U"&HilbertSpace;");
    TL_IS_250 = Str__literal(U"&Hopf;");
    TL_IS_251 = Str__literal(U"&HorizontalLine;");
    TL_IS_252 = Str__literal(U"&Hscr;");
    TL_IS_253 = Str__literal(U"&Hstrok;");
    TL_IS_254 = Str__literal(U"&HumpDownHump;");
    TL_IS_255 = Str__literal(U"&HumpEqual;");
    TL_IS_256 = Str__literal(U"&IEcy;");
    TL_IS_257 = Str__literal(U"&IJlig;");
    TL_IS_258 = Str__literal(U"&IOcy;");
    TL_IS_259 = Str__literal(U"&Iacute");
    TL_IS_260 = Str__literal(U"&Iacute;");
    TL_IS_261 = Str__literal(U"&Icirc");
    TL_IS_262 = Str__literal(U"&Icirc;");
    TL_IS_263 = Str__literal(U"&Icy;");
    TL_IS_264 = Str__literal(U"&Idot;");
    TL_IS_265 = Str__literal(U"&Ifr;");
    TL_IS_266 = Str__literal(U"&Igrave");
    TL_IS_267 = Str__literal(U"&Igrave;");
    TL_IS_268 = Str__literal(U"&Im;");
    TL_IS_269 = Str__literal(U"&Imacr;");
    TL_IS_270 = Str__literal(U"&ImaginaryI;");
    TL_IS_271 = Str__literal(U"&Implies;");
    TL_IS_272 = Str__literal(U"&Int;");
    TL_IS_273 = Str__literal(U"&Integral;");
    TL_IS_274 = Str__literal(U"&Intersection;");
    TL_IS_275 = Str__literal(U"&InvisibleComma;");
    TL_IS_276 = Str__literal(U"&InvisibleTimes;");
    TL_IS_277 = Str__literal(U"&Iogon;");
    TL_IS_278 = Str__literal(U"&Iopf;");
    TL_IS_279 = Str__literal(U"&Iota;");
    TL_IS_280 = Str__literal(U"&Iscr;");
    TL_IS_281 = Str__literal(U"&Itilde;");
    TL_IS_282 = Str__literal(U"&Iukcy;");
    TL_IS_283 = Str__literal(U"&Iuml");
    TL_IS_284 = Str__literal(U"&Iuml;");
    TL_IS_285 = Str__literal(U"&Jcirc;");
    TL_IS_286 = Str__literal(U"&Jcy;");
    TL_IS_287 = Str__literal(U"&Jfr;");
    TL_IS_288 = Str__literal(U"&Jopf;");
    TL_IS_289 = Str__literal(U"&Jscr;");
    TL_IS_290 = Str__literal(U"&Jsercy;");
    TL_IS_291 = Str__literal(U"&Jukcy;");
    TL_IS_292 = Str__literal(U"&KHcy;");
    TL_IS_293 = Str__literal(U"&KJcy;");
    TL_IS_294 = Str__literal(U"&Kappa;");
    TL_IS_295 = Str__literal(U"&Kcedil;");
    TL_IS_296 = Str__literal(U"&Kcy;");
    TL_IS_297 = Str__literal(U"&Kfr;");
    TL_IS_298 = Str__literal(U"&Kopf;");
    TL_IS_299 = Str__literal(U"&Kscr;");
    TL_IS_300 = Str__literal(U"&LJcy;");
    TL_IS_301 = Str__literal(U"&LT");
    TL_IS_302 = Str__literal(U"&LT;");
    TL_IS_303 = Str__literal(U"&Lacute;");
    TL_IS_304 = Str__literal(U"&Lambda;");
    TL_IS_305 = Str__literal(U"&Lang;");
    TL_IS_306 = Str__literal(U"&Laplacetrf;");
    TL_IS_307 = Str__literal(U"&Larr;");
    TL_IS_308 = Str__literal(U"&Lcaron;");
    TL_IS_309 = Str__literal(U"&Lcedil;");
    TL_IS_310 = Str__literal(U"&Lcy;");
    TL_IS_311 = Str__literal(U"&LeftAngleBracket;");
    TL_IS_312 = Str__literal(U"&LeftArrow;");
    TL_IS_313 = Str__literal(U"&LeftArrowBar;");
    TL_IS_314 = Str__literal(U"&LeftArrowRightArrow;");
    TL_IS_315 = Str__literal(U"&LeftCeiling;");
    TL_IS_316 = Str__literal(U"&LeftDoubleBracket;");
    TL_IS_317 = Str__literal(U"&LeftDownTeeVector;");
    TL_IS_318 = Str__literal(U"&LeftDownVector;");
    TL_IS_319 = Str__literal(U"&LeftDownVectorBar;");
    TL_IS_320 = Str__literal(U"&LeftFloor;");
    TL_IS_321 = Str__literal(U"&LeftRightArrow;");
    TL_IS_322 = Str__literal(U"&LeftRightVector;");
    TL_IS_323 = Str__literal(U"&LeftTee;");
    TL_IS_324 = Str__literal(U"&LeftTeeArrow;");
    TL_IS_325 = Str__literal(U"&LeftTeeVector;");
    TL_IS_326 = Str__literal(U"&LeftTriangle;");
    TL_IS_327 = Str__literal(U"&LeftTriangleBar;");
    TL_IS_328 = Str__literal(U"&LeftTriangleEqual;");
    TL_IS_329 = Str__literal(U"&LeftUpDownVector;");
    TL_IS_330 = Str__literal(U"&LeftUpTeeVector;");
    TL_IS_331 = Str__literal(U"&LeftUpVector;");
    TL_IS_332 = Str__literal(U"&LeftUpVectorBar;");
    TL_IS_333 = Str__literal(U"&LeftVector;");
    TL_IS_334 = Str__literal(U"&LeftVectorBar;");
    TL_IS_335 = Str__literal(U"&Leftarrow;");
    TL_IS_336 = Str__literal(U"&Leftrightarrow;");
    TL_IS_337 = Str__literal(U"&LessEqualGreater;");
    TL_IS_338 = Str__literal(U"&LessFullEqual;");
    TL_IS_339 = Str__literal(U"&LessGreater;");
    TL_IS_340 = Str__literal(U"&LessLess;");
    TL_IS_341 = Str__literal(U"&LessSlantEqual;");
    TL_IS_342 = Str__literal(U"&LessTilde;");
    TL_IS_343 = Str__literal(U"&Lfr;");
    TL_IS_344 = Str__literal(U"&Ll;");
    TL_IS_345 = Str__literal(U"&Lleftarrow;");
    TL_IS_346 = Str__literal(U"&Lmidot;");
    TL_IS_347 = Str__literal(U"&LongLeftArrow;");
    TL_IS_348 = Str__literal(U"&LongLeftRightArrow;");
    TL_IS_349 = Str__literal(U"&LongRightArrow;");
    TL_IS_350 = Str__literal(U"&Longleftarrow;");
    TL_IS_351 = Str__literal(U"&Longleftrightarrow;");
    TL_IS_352 = Str__literal(U"&Longrightarrow;");
    TL_IS_353 = Str__literal(U"&Lopf;");
    TL_IS_354 = Str__literal(U"&LowerLeftArrow;");
    TL_IS_355 = Str__literal(U"&LowerRightArrow;");
    TL_IS_356 = Str__literal(U"&Lscr;");
    TL_IS_357 = Str__literal(U"&Lsh;");
    TL_IS_358 = Str__literal(U"&Lstrok;");
    TL_IS_359 = Str__literal(U"&Lt;");
    TL_IS_360 = Str__literal(U"&Map;");
    TL_IS_361 = Str__literal(U"&Mcy;");
    TL_IS_362 = Str__literal(U"&MediumSpace;");
    TL_IS_363 = Str__literal(U"&Mellintrf;");
    TL_IS_364 = Str__literal(U"&Mfr;");
    TL_IS_365 = Str__literal(U"&MinusPlus;");
    TL_IS_366 = Str__literal(U"&Mopf;");
    TL_IS_367 = Str__literal(U"&Mscr;");
    TL_IS_368 = Str__literal(U"&Mu;");
    TL_IS_369 = Str__literal(U"&NJcy;");
    TL_IS_370 = Str__literal(U"&Nacute;");
    TL_IS_371 = Str__literal(U"&Ncaron;");
    TL_IS_372 = Str__literal(U"&Ncedil;");
    TL_IS_373 = Str__literal(U"&Ncy;");
    TL_IS_374 = Str__literal(U"&NegativeMediumSpace;");
    TL_IS_375 = Str__literal(U"&NegativeThickSpace;");
    TL_IS_376 = Str__literal(U"&NegativeThinSpace;");
    TL_IS_377 = Str__literal(U"&NegativeVeryThinSpace;");
    TL_IS_378 = Str__literal(U"&NestedGreaterGreater;");
    TL_IS_379 = Str__literal(U"&NestedLessLess;");
    TL_IS_380 = Str__literal(U"&NewLine;");
    TL_IS_381 = Str__literal(U"&Nfr;");
    TL_IS_382 = Str__literal(U"&NoBreak;");
    TL_IS_383 = Str__literal(U"&NonBreakingSpace;");
    TL_IS_384 = Str__literal(U"&Nopf;");
    TL_IS_385 = Str__literal(U"&Not;");
    TL_IS_386 = Str__literal(U"&NotCongruent;");
    TL_IS_387 = Str__literal(U"&NotCupCap;");
    TL_IS_388 = Str__literal(U"&NotDoubleVerticalBar;");
    TL_IS_389 = Str__literal(U"&NotElement;");
    TL_IS_390 = Str__literal(U"&NotEqual;");
    TL_IS_391 = Str__literal(U"&NotEqualTilde;");
    TL_IS_392 = Str__literal(U"&NotExists;");
    TL_IS_393 = Str__literal(U"&NotGreater;");
    TL_IS_394 = Str__literal(U"&NotGreaterEqual;");
    TL_IS_395 = Str__literal(U"&NotGreaterFullEqual;");
    TL_IS_396 = Str__literal(U"&NotGreaterGreater;");
    TL_IS_397 = Str__literal(U"&NotGreaterLess;");
    TL_IS_398 = Str__literal(U"&NotGreaterSlantEqual;");
    TL_IS_399 = Str__literal(U"&NotGreaterTilde;");
    TL_IS_400 = Str__literal(U"&NotHumpDownHump;");
    TL_IS_401 = Str__literal(U"&NotHumpEqual;");
    TL_IS_402 = Str__literal(U"&NotLeftTriangle;");
    TL_IS_403 = Str__literal(U"&NotLeftTriangleBar;");
    TL_IS_404 = Str__literal(U"&NotLeftTriangleEqual;");
    TL_IS_405 = Str__literal(U"&NotLess;");
    TL_IS_406 = Str__literal(U"&NotLessEqual;");
    TL_IS_407 = Str__literal(U"&NotLessGreater;");
    TL_IS_408 = Str__literal(U"&NotLessLess;");
    TL_IS_409 = Str__literal(U"&NotLessSlantEqual;");
    TL_IS_410 = Str__literal(U"&NotLessTilde;");
    TL_IS_411 = Str__literal(U"&NotNestedGreaterGreater;");
    TL_IS_412 = Str__literal(U"&NotNestedLessLess;");
    TL_IS_413 = Str__literal(U"&NotPrecedes;");
    TL_IS_414 = Str__literal(U"&NotPrecedesEqual;");
    TL_IS_415 = Str__literal(U"&NotPrecedesSlantEqual;");
    TL_IS_416 = Str__literal(U"&NotReverseElement;");
    TL_IS_417 = Str__literal(U"&NotRightTriangle;");
    TL_IS_418 = Str__literal(U"&NotRightTriangleBar;");
    TL_IS_419 = Str__literal(U"&NotRightTriangleEqual;");
    TL_IS_420 = Str__literal(U"&NotSquareSubset;");
    TL_IS_421 = Str__literal(U"&NotSquareSubsetEqual;");
    TL_IS_422 = Str__literal(U"&NotSquareSuperset;");
    TL_IS_423 = Str__literal(U"&NotSquareSupersetEqual;");
    TL_IS_424 = Str__literal(U"&NotSubset;");
    TL_IS_425 = Str__literal(U"&NotSubsetEqual;");
    TL_IS_426 = Str__literal(U"&NotSucceeds;");
    TL_IS_427 = Str__literal(U"&NotSucceedsEqual;");
    TL_IS_428 = Str__literal(U"&NotSucceedsSlantEqual;");
    TL_IS_429 = Str__literal(U"&NotSucceedsTilde;");
    TL_IS_430 = Str__literal(U"&NotSuperset;");
    TL_IS_431 = Str__literal(U"&NotSupersetEqual;");
    TL_IS_432 = Str__literal(U"&NotTilde;");
    TL_IS_433 = Str__literal(U"&NotTildeEqual;");
    TL_IS_434 = Str__literal(U"&NotTildeFullEqual;");
    TL_IS_435 = Str__literal(U"&NotTildeTilde;");
    TL_IS_436 = Str__literal(U"&NotVerticalBar;");
    TL_IS_437 = Str__literal(U"&Nscr;");
    TL_IS_438 = Str__literal(U"&Ntilde");
    TL_IS_439 = Str__literal(U"&Ntilde;");
    TL_IS_440 = Str__literal(U"&Nu;");
    TL_IS_441 = Str__literal(U"&OElig;");
    TL_IS_442 = Str__literal(U"&Oacute");
    TL_IS_443 = Str__literal(U"&Oacute;");
    TL_IS_444 = Str__literal(U"&Ocirc");
    TL_IS_445 = Str__literal(U"&Ocirc;");
    TL_IS_446 = Str__literal(U"&Ocy;");
    TL_IS_447 = Str__literal(U"&Odblac;");
    TL_IS_448 = Str__literal(U"&Ofr;");
    TL_IS_449 = Str__literal(U"&Ograve");
    TL_IS_450 = Str__literal(U"&Ograve;");
    TL_IS_451 = Str__literal(U"&Omacr;");
    TL_IS_452 = Str__literal(U"&Omega;");
    TL_IS_453 = Str__literal(U"&Omicron;");
    TL_IS_454 = Str__literal(U"&Oopf;");
    TL_IS_455 = Str__literal(U"&OpenCurlyDoubleQuote;");
    TL_IS_456 = Str__literal(U"&OpenCurlyQuote;");
    TL_IS_457 = Str__literal(U"&Or;");
    TL_IS_458 = Str__literal(U"&Oscr;");
    TL_IS_459 = Str__literal(U"&Oslash");
    TL_IS_460 = Str__literal(U"&Oslash;");
    TL_IS_461 = Str__literal(U"&Otilde");
    TL_IS_462 = Str__literal(U"&Otilde;");
    TL_IS_463 = Str__literal(U"&Otimes;");
    TL_IS_464 = Str__literal(U"&Ouml");
    TL_IS_465 = Str__literal(U"&Ouml;");
    TL_IS_466 = Str__literal(U"&OverBar;");
    TL_IS_467 = Str__literal(U"&OverBrace;");
    TL_IS_468 = Str__literal(U"&OverBracket;");
    TL_IS_469 = Str__literal(U"&OverParenthesis;");
    TL_IS_470 = Str__literal(U"&PartialD;");
    TL_IS_471 = Str__literal(U"&Pcy;");
    TL_IS_472 = Str__literal(U"&Pfr;");
    TL_IS_473 = Str__literal(U"&Phi;");
    TL_IS_474 = Str__literal(U"&Pi;");
    TL_IS_475 = Str__literal(U"&PlusMinus;");
    TL_IS_476 = Str__literal(U"&Poincareplane;");
    TL_IS_477 = Str__literal(U"&Popf;");
    TL_IS_478 = Str__literal(U"&Pr;");
    TL_IS_479 = Str__literal(U"&Precedes;");
    TL_IS_480 = Str__literal(U"&PrecedesEqual;");
    TL_IS_481 = Str__literal(U"&PrecedesSlantEqual;");
    TL_IS_482 = Str__literal(U"&PrecedesTilde;");
    TL_IS_483 = Str__literal(U"&Prime;");
    TL_IS_484 = Str__literal(U"&Product;");
    TL_IS_485 = Str__literal(U"&Proportion;");
    TL_IS_486 = Str__literal(U"&Proportional;");
    TL_IS_487 = Str__literal(U"&Pscr;");
    TL_IS_488 = Str__literal(U"&Psi;");
    TL_IS_489 = Str__literal(U"&QUOT");
    TL_IS_490 = Str__literal(U"&QUOT;");
    TL_IS_491 = Str__literal(U"&Qfr;");
    TL_IS_492 = Str__literal(U"&Qopf;");
    TL_IS_493 = Str__literal(U"&Qscr;");
    TL_IS_494 = Str__literal(U"&RBarr;");
    TL_IS_495 = Str__literal(U"&REG");
    TL_IS_496 = Str__literal(U"&REG;");
    TL_IS_497 = Str__literal(U"&Racute;");
    TL_IS_498 = Str__literal(U"&Rang;");
    TL_IS_499 = Str__literal(U"&Rarr;");
    TL_IS_500 = Str__literal(U"&Rarrtl;");
    TL_IS_501 = Str__literal(U"&Rcaron;");
    TL_IS_502 = Str__literal(U"&Rcedil;");
    TL_IS_503 = Str__literal(U"&Rcy;");
    TL_IS_504 = Str__literal(U"&Re;");
    TL_IS_505 = Str__literal(U"&ReverseElement;");
    TL_IS_506 = Str__literal(U"&ReverseEquilibrium;");
    TL_IS_507 = Str__literal(U"&ReverseUpEquilibrium;");
    TL_IS_508 = Str__literal(U"&Rfr;");
    TL_IS_509 = Str__literal(U"&Rho;");
    TL_IS_510 = Str__literal(U"&RightAngleBracket;");
    TL_IS_511 = Str__literal(U"&RightArrow;");
    TL_IS_512 = Str__literal(U"&RightArrowBar;");
    TL_IS_513 = Str__literal(U"&RightArrowLeftArrow;");
    TL_IS_514 = Str__literal(U"&RightCeiling;");
    TL_IS_515 = Str__literal(U"&RightDoubleBracket;");
    TL_IS_516 = Str__literal(U"&RightDownTeeVector;");
    TL_IS_517 = Str__literal(U"&RightDownVector;");
    TL_IS_518 = Str__literal(U"&RightDownVectorBar;");
    TL_IS_519 = Str__literal(U"&RightFloor;");
    TL_IS_520 = Str__literal(U"&RightTee;");
    TL_IS_521 = Str__literal(U"&RightTeeArrow;");
    TL_IS_522 = Str__literal(U"&RightTeeVector;");
    TL_IS_523 = Str__literal(U"&RightTriangle;");
    TL_IS_524 = Str__literal(U"&RightTriangleBar;");
    TL_IS_525 = Str__literal(U"&RightTriangleEqual;");
    TL_IS_526 = Str__literal(U"&RightUpDownVector;");
    TL_IS_527 = Str__literal(U"&RightUpTeeVector;");
    TL_IS_528 = Str__literal(U"&RightUpVector;");
    TL_IS_529 = Str__literal(U"&RightUpVectorBar;");
    TL_IS_530 = Str__literal(U"&RightVector;");
    TL_IS_531 = Str__literal(U"&RightVectorBar;");
    TL_IS_532 = Str__literal(U"&Rightarrow;");
    TL_IS_533 = Str__literal(U"&Ropf;");
    TL_IS_534 = Str__literal(U"&RoundImplies;");
    TL_IS_535 = Str__literal(U"&Rrightarrow;");
    TL_IS_536 = Str__literal(U"&Rscr;");
    TL_IS_537 = Str__literal(U"&Rsh;");
    TL_IS_538 = Str__literal(U"&RuleDelayed;");
    TL_IS_539 = Str__literal(U"&SHCHcy;");
    TL_IS_540 = Str__literal(U"&SHcy;");
    TL_IS_541 = Str__literal(U"&SOFTcy;");
    TL_IS_542 = Str__literal(U"&Sacute;");
    TL_IS_543 = Str__literal(U"&Sc;");
    TL_IS_544 = Str__literal(U"&Scaron;");
    TL_IS_545 = Str__literal(U"&Scedil;");
    TL_IS_546 = Str__literal(U"&Scirc;");
    TL_IS_547 = Str__literal(U"&Scy;");
    TL_IS_548 = Str__literal(U"&Sfr;");
    TL_IS_549 = Str__literal(U"&ShortDownArrow;");
    TL_IS_550 = Str__literal(U"&ShortLeftArrow;");
    TL_IS_551 = Str__literal(U"&ShortRightArrow;");
    TL_IS_552 = Str__literal(U"&ShortUpArrow;");
    TL_IS_553 = Str__literal(U"&Sigma;");
    TL_IS_554 = Str__literal(U"&SmallCircle;");
    TL_IS_555 = Str__literal(U"&Sopf;");
    TL_IS_556 = Str__literal(U"&Sqrt;");
    TL_IS_557 = Str__literal(U"&Square;");
    TL_IS_558 = Str__literal(U"&SquareIntersection;");
    TL_IS_559 = Str__literal(U"&SquareSubset;");
    TL_IS_560 = Str__literal(U"&SquareSubsetEqual;");
    TL_IS_561 = Str__literal(U"&SquareSuperset;");
    TL_IS_562 = Str__literal(U"&SquareSupersetEqual;");
    TL_IS_563 = Str__literal(U"&SquareUnion;");
    TL_IS_564 = Str__literal(U"&Sscr;");
    TL_IS_565 = Str__literal(U"&Star;");
    TL_IS_566 = Str__literal(U"&Sub;");
    TL_IS_567 = Str__literal(U"&Subset;");
    TL_IS_568 = Str__literal(U"&SubsetEqual;");
    TL_IS_569 = Str__literal(U"&Succeeds;");
    TL_IS_570 = Str__literal(U"&SucceedsEqual;");
    TL_IS_571 = Str__literal(U"&SucceedsSlantEqual;");
    TL_IS_572 = Str__literal(U"&SucceedsTilde;");
    TL_IS_573 = Str__literal(U"&SuchThat;");
    TL_IS_574 = Str__literal(U"&Sum;");
    TL_IS_575 = Str__literal(U"&Sup;");
    TL_IS_576 = Str__literal(U"&Superset;");
    TL_IS_577 = Str__literal(U"&SupersetEqual;");
    TL_IS_578 = Str__literal(U"&Supset;");
    TL_IS_579 = Str__literal(U"&THORN");
    TL_IS_580 = Str__literal(U"&THORN;");
    TL_IS_581 = Str__literal(U"&TRADE;");
    TL_IS_582 = Str__literal(U"&TSHcy;");
    TL_IS_583 = Str__literal(U"&TScy;");
    TL_IS_584 = Str__literal(U"&Tab;");
    TL_IS_585 = Str__literal(U"&Tau;");
    TL_IS_586 = Str__literal(U"&Tcaron;");
    TL_IS_587 = Str__literal(U"&Tcedil;");
    TL_IS_588 = Str__literal(U"&Tcy;");
    TL_IS_589 = Str__literal(U"&Tfr;");
    TL_IS_590 = Str__literal(U"&Therefore;");
    TL_IS_591 = Str__literal(U"&Theta;");
    TL_IS_592 = Str__literal(U"&ThickSpace;");
    TL_IS_593 = Str__literal(U"&ThinSpace;");
    TL_IS_594 = Str__literal(U"&Tilde;");
    TL_IS_595 = Str__literal(U"&TildeEqual;");
    TL_IS_596 = Str__literal(U"&TildeFullEqual;");
    TL_IS_597 = Str__literal(U"&TildeTilde;");
    TL_IS_598 = Str__literal(U"&Topf;");
    TL_IS_599 = Str__literal(U"&TripleDot;");
    TL_IS_600 = Str__literal(U"&Tscr;");
    TL_IS_601 = Str__literal(U"&Tstrok;");
    TL_IS_602 = Str__literal(U"&Uacute");
    TL_IS_603 = Str__literal(U"&Uacute;");
    TL_IS_604 = Str__literal(U"&Uarr;");
    TL_IS_605 = Str__literal(U"&Uarrocir;");
    TL_IS_606 = Str__literal(U"&Ubrcy;");
    TL_IS_607 = Str__literal(U"&Ubreve;");
    TL_IS_608 = Str__literal(U"&Ucirc");
    TL_IS_609 = Str__literal(U"&Ucirc;");
    TL_IS_610 = Str__literal(U"&Ucy;");
    TL_IS_611 = Str__literal(U"&Udblac;");
    TL_IS_612 = Str__literal(U"&Ufr;");
    TL_IS_613 = Str__literal(U"&Ugrave");
    TL_IS_614 = Str__literal(U"&Ugrave;");
    TL_IS_615 = Str__literal(U"&Umacr;");
    TL_IS_616 = Str__literal(U"&UnderBar;");
    TL_IS_617 = Str__literal(U"&UnderBrace;");
    TL_IS_618 = Str__literal(U"&UnderBracket;");
    TL_IS_619 = Str__literal(U"&UnderParenthesis;");
    TL_IS_620 = Str__literal(U"&Union;");
    TL_IS_621 = Str__literal(U"&UnionPlus;");
    TL_IS_622 = Str__literal(U"&Uogon;");
    TL_IS_623 = Str__literal(U"&Uopf;");
    TL_IS_624 = Str__literal(U"&UpArrow;");
    TL_IS_625 = Str__literal(U"&UpArrowBar;");
    TL_IS_626 = Str__literal(U"&UpArrowDownArrow;");
    TL_IS_627 = Str__literal(U"&UpDownArrow;");
    TL_IS_628 = Str__literal(U"&UpEquilibrium;");
    TL_IS_629 = Str__literal(U"&UpTee;");
    TL_IS_630 = Str__literal(U"&UpTeeArrow;");
    TL_IS_631 = Str__literal(U"&Uparrow;");
    TL_IS_632 = Str__literal(U"&Updownarrow;");
    TL_IS_633 = Str__literal(U"&UpperLeftArrow;");
    TL_IS_634 = Str__literal(U"&UpperRightArrow;");
    TL_IS_635 = Str__literal(U"&Upsi;");
    TL_IS_636 = Str__literal(U"&Upsilon;");
    TL_IS_637 = Str__literal(U"&Uring;");
    TL_IS_638 = Str__literal(U"&Uscr;");
    TL_IS_639 = Str__literal(U"&Utilde;");
    TL_IS_640 = Str__literal(U"&Uuml");
    TL_IS_641 = Str__literal(U"&Uuml;");
    TL_IS_642 = Str__literal(U"&VDash;");
    TL_IS_643 = Str__literal(U"&Vbar;");
    TL_IS_644 = Str__literal(U"&Vcy;");
    TL_IS_645 = Str__literal(U"&Vdash;");
    TL_IS_646 = Str__literal(U"&Vdashl;");
    TL_IS_647 = Str__literal(U"&Vee;");
    TL_IS_648 = Str__literal(U"&Verbar;");
    TL_IS_649 = Str__literal(U"&Vert;");
    TL_IS_650 = Str__literal(U"&VerticalBar;");
    TL_IS_651 = Str__literal(U"&VerticalLine;");
    TL_IS_652 = Str__literal(U"&VerticalSeparator;");
    TL_IS_653 = Str__literal(U"&VerticalTilde;");
    TL_IS_654 = Str__literal(U"&VeryThinSpace;");
    TL_IS_655 = Str__literal(U"&Vfr;");
    TL_IS_656 = Str__literal(U"&Vopf;");
    TL_IS_657 = Str__literal(U"&Vscr;");
    TL_IS_658 = Str__literal(U"&Vvdash;");
    TL_IS_659 = Str__literal(U"&Wcirc;");
    TL_IS_660 = Str__literal(U"&Wedge;");
    TL_IS_661 = Str__literal(U"&Wfr;");
    TL_IS_662 = Str__literal(U"&Wopf;");
    TL_IS_663 = Str__literal(U"&Wscr;");
    TL_IS_664 = Str__literal(U"&Xfr;");
    TL_IS_665 = Str__literal(U"&Xi;");
    TL_IS_666 = Str__literal(U"&Xopf;");
    TL_IS_667 = Str__literal(U"&Xscr;");
    TL_IS_668 = Str__literal(U"&YAcy;");
    TL_IS_669 = Str__literal(U"&YIcy;");
    TL_IS_670 = Str__literal(U"&YUcy;");
    TL_IS_671 = Str__literal(U"&Yacute");
    TL_IS_672 = Str__literal(U"&Yacute;");
    TL_IS_673 = Str__literal(U"&Ycirc;");
    TL_IS_674 = Str__literal(U"&Ycy;");
    TL_IS_675 = Str__literal(U"&Yfr;");
    TL_IS_676 = Str__literal(U"&Yopf;");
    TL_IS_677 = Str__literal(U"&Yscr;");
    TL_IS_678 = Str__literal(U"&Yuml;");
    TL_IS_679 = Str__literal(U"&ZHcy;");
    TL_IS_680 = Str__literal(U"&Zacute;");
    TL_IS_681 = Str__literal(U"&Zcaron;");
    TL_IS_682 = Str__literal(U"&Zcy;");
    TL_IS_683 = Str__literal(U"&Zdot;");
    TL_IS_684 = Str__literal(U"&ZeroWidthSpace;");
    TL_IS_685 = Str__literal(U"&Zeta;");
    TL_IS_686 = Str__literal(U"&Zfr;");
    TL_IS_687 = Str__literal(U"&Zopf;");
    TL_IS_688 = Str__literal(U"&Zscr;");
    TL_IS_689 = Str__literal(U"&aacute");
    TL_IS_690 = Str__literal(U"&aacute;");
    TL_IS_691 = Str__literal(U"&abreve;");
    TL_IS_692 = Str__literal(U"&ac;");
    TL_IS_693 = Str__literal(U"&acE;");
    TL_IS_694 = Str__literal(U"&acd;");
    TL_IS_695 = Str__literal(U"&acirc");
    TL_IS_696 = Str__literal(U"&acirc;");
    TL_IS_697 = Str__literal(U"&acute");
    TL_IS_698 = Str__literal(U"&acute;");
    TL_IS_699 = Str__literal(U"&acy;");
    TL_IS_700 = Str__literal(U"&aelig");
    TL_IS_701 = Str__literal(U"&aelig;");
    TL_IS_702 = Str__literal(U"&af;");
    TL_IS_703 = Str__literal(U"&afr;");
    TL_IS_704 = Str__literal(U"&agrave");
    TL_IS_705 = Str__literal(U"&agrave;");
    TL_IS_706 = Str__literal(U"&alefsym;");
    TL_IS_707 = Str__literal(U"&aleph;");
    TL_IS_708 = Str__literal(U"&alpha;");
    TL_IS_709 = Str__literal(U"&amacr;");
    TL_IS_710 = Str__literal(U"&amalg;");
    TL_IS_711 = Str__literal(U"&amp");
    TL_IS_712 = Str__literal(U"&amp;");
    TL_IS_713 = Str__literal(U"&and;");
    TL_IS_714 = Str__literal(U"&andand;");
    TL_IS_715 = Str__literal(U"&andd;");
    TL_IS_716 = Str__literal(U"&andslope;");
    TL_IS_717 = Str__literal(U"&andv;");
    TL_IS_718 = Str__literal(U"&ang;");
    TL_IS_719 = Str__literal(U"&ange;");
    TL_IS_720 = Str__literal(U"&angle;");
    TL_IS_721 = Str__literal(U"&angmsd;");
    TL_IS_722 = Str__literal(U"&angmsdaa;");
    TL_IS_723 = Str__literal(U"&angmsdab;");
    TL_IS_724 = Str__literal(U"&angmsdac;");
    TL_IS_725 = Str__literal(U"&angmsdad;");
    TL_IS_726 = Str__literal(U"&angmsdae;");
    TL_IS_727 = Str__literal(U"&angmsdaf;");
    TL_IS_728 = Str__literal(U"&angmsdag;");
    TL_IS_729 = Str__literal(U"&angmsdah;");
    TL_IS_730 = Str__literal(U"&angrt;");
    TL_IS_731 = Str__literal(U"&angrtvb;");
    TL_IS_732 = Str__literal(U"&angrtvbd;");
    TL_IS_733 = Str__literal(U"&angsph;");
    TL_IS_734 = Str__literal(U"&angst;");
    TL_IS_735 = Str__literal(U"&angzarr;");
    TL_IS_736 = Str__literal(U"&aogon;");
    TL_IS_737 = Str__literal(U"&aopf;");
    TL_IS_738 = Str__literal(U"&ap;");
    TL_IS_739 = Str__literal(U"&apE;");
    TL_IS_740 = Str__literal(U"&apacir;");
    TL_IS_741 = Str__literal(U"&ape;");
    TL_IS_742 = Str__literal(U"&apid;");
    TL_IS_743 = Str__literal(U"&apos;");
    TL_IS_744 = Str__literal(U"&approx;");
    TL_IS_745 = Str__literal(U"&approxeq;");
    TL_IS_746 = Str__literal(U"&aring");
    TL_IS_747 = Str__literal(U"&aring;");
    TL_IS_748 = Str__literal(U"&ascr;");
    TL_IS_749 = Str__literal(U"&ast;");
    TL_IS_750 = Str__literal(U"&asymp;");
    TL_IS_751 = Str__literal(U"&asympeq;");
    TL_IS_752 = Str__literal(U"&atilde");
    TL_IS_753 = Str__literal(U"&atilde;");
    TL_IS_754 = Str__literal(U"&auml");
    TL_IS_755 = Str__literal(U"&auml;");
    TL_IS_756 = Str__literal(U"&awconint;");
    TL_IS_757 = Str__literal(U"&awint;");
    TL_IS_758 = Str__literal(U"&bNot;");
    TL_IS_759 = Str__literal(U"&backcong;");
    TL_IS_760 = Str__literal(U"&backepsilon;");
    TL_IS_761 = Str__literal(U"&backprime;");
    TL_IS_762 = Str__literal(U"&backsim;");
    TL_IS_763 = Str__literal(U"&backsimeq;");
    TL_IS_764 = Str__literal(U"&barvee;");
    TL_IS_765 = Str__literal(U"&barwed;");
    TL_IS_766 = Str__literal(U"&barwedge;");
    TL_IS_767 = Str__literal(U"&bbrk;");
    TL_IS_768 = Str__literal(U"&bbrktbrk;");
    TL_IS_769 = Str__literal(U"&bcong;");
    TL_IS_770 = Str__literal(U"&bcy;");
    TL_IS_771 = Str__literal(U"&bdquo;");
    TL_IS_772 = Str__literal(U"&becaus;");
    TL_IS_773 = Str__literal(U"&because;");
    TL_IS_774 = Str__literal(U"&bemptyv;");
    TL_IS_775 = Str__literal(U"&bepsi;");
    TL_IS_776 = Str__literal(U"&bernou;");
    TL_IS_777 = Str__literal(U"&beta;");
    TL_IS_778 = Str__literal(U"&beth;");
    TL_IS_779 = Str__literal(U"&between;");
    TL_IS_780 = Str__literal(U"&bfr;");
    TL_IS_781 = Str__literal(U"&bigcap;");
    TL_IS_782 = Str__literal(U"&bigcirc;");
    TL_IS_783 = Str__literal(U"&bigcup;");
    TL_IS_784 = Str__literal(U"&bigodot;");
    TL_IS_785 = Str__literal(U"&bigoplus;");
    TL_IS_786 = Str__literal(U"&bigotimes;");
    TL_IS_787 = Str__literal(U"&bigsqcup;");
    TL_IS_788 = Str__literal(U"&bigstar;");
    TL_IS_789 = Str__literal(U"&bigtriangledown;");
    TL_IS_790 = Str__literal(U"&bigtriangleup;");
    TL_IS_791 = Str__literal(U"&biguplus;");
    TL_IS_792 = Str__literal(U"&bigvee;");
    TL_IS_793 = Str__literal(U"&bigwedge;");
    TL_IS_794 = Str__literal(U"&bkarow;");
    TL_IS_795 = Str__literal(U"&blacklozenge;");
    TL_IS_796 = Str__literal(U"&blacksquare;");
    TL_IS_797 = Str__literal(U"&blacktriangle;");
    TL_IS_798 = Str__literal(U"&blacktriangledown;");
    TL_IS_799 = Str__literal(U"&blacktriangleleft;");
    TL_IS_800 = Str__literal(U"&blacktriangleright;");
    TL_IS_801 = Str__literal(U"&blank;");
    TL_IS_802 = Str__literal(U"&blk12;");
    TL_IS_803 = Str__literal(U"&blk14;");
    TL_IS_804 = Str__literal(U"&blk34;");
    TL_IS_805 = Str__literal(U"&block;");
    TL_IS_806 = Str__literal(U"&bne;");
    TL_IS_807 = Str__literal(U"&bnequiv;");
    TL_IS_808 = Str__literal(U"&bnot;");
    TL_IS_809 = Str__literal(U"&bopf;");
    TL_IS_810 = Str__literal(U"&bot;");
    TL_IS_811 = Str__literal(U"&bottom;");
    TL_IS_812 = Str__literal(U"&bowtie;");
    TL_IS_813 = Str__literal(U"&boxDL;");
    TL_IS_814 = Str__literal(U"&boxDR;");
    TL_IS_815 = Str__literal(U"&boxDl;");
    TL_IS_816 = Str__literal(U"&boxDr;");
    TL_IS_817 = Str__literal(U"&boxH;");
    TL_IS_818 = Str__literal(U"&boxHD;");
    TL_IS_819 = Str__literal(U"&boxHU;");
    TL_IS_820 = Str__literal(U"&boxHd;");
    TL_IS_821 = Str__literal(U"&boxHu;");
    TL_IS_822 = Str__literal(U"&boxUL;");
    TL_IS_823 = Str__literal(U"&boxUR;");
    TL_IS_824 = Str__literal(U"&boxUl;");
    TL_IS_825 = Str__literal(U"&boxUr;");
    TL_IS_826 = Str__literal(U"&boxV;");
    TL_IS_827 = Str__literal(U"&boxVH;");
    TL_IS_828 = Str__literal(U"&boxVL;");
    TL_IS_829 = Str__literal(U"&boxVR;");
    TL_IS_830 = Str__literal(U"&boxVh;");
    TL_IS_831 = Str__literal(U"&boxVl;");
    TL_IS_832 = Str__literal(U"&boxVr;");
    TL_IS_833 = Str__literal(U"&boxbox;");
    TL_IS_834 = Str__literal(U"&boxdL;");
    TL_IS_835 = Str__literal(U"&boxdR;");
    TL_IS_836 = Str__literal(U"&boxdl;");
    TL_IS_837 = Str__literal(U"&boxdr;");
    TL_IS_838 = Str__literal(U"&boxh;");
    TL_IS_839 = Str__literal(U"&boxhD;");
    TL_IS_840 = Str__literal(U"&boxhU;");
    TL_IS_841 = Str__literal(U"&boxhd;");
    TL_IS_842 = Str__literal(U"&boxhu;");
    TL_IS_843 = Str__literal(U"&boxminus;");
    TL_IS_844 = Str__literal(U"&boxplus;");
    TL_IS_845 = Str__literal(U"&boxtimes;");
    TL_IS_846 = Str__literal(U"&boxuL;");
    TL_IS_847 = Str__literal(U"&boxuR;");
    TL_IS_848 = Str__literal(U"&boxul;");
    TL_IS_849 = Str__literal(U"&boxur;");
    TL_IS_850 = Str__literal(U"&boxv;");
    TL_IS_851 = Str__literal(U"&boxvH;");
    TL_IS_852 = Str__literal(U"&boxvL;");
    TL_IS_853 = Str__literal(U"&boxvR;");
    TL_IS_854 = Str__literal(U"&boxvh;");
    TL_IS_855 = Str__literal(U"&boxvl;");
    TL_IS_856 = Str__literal(U"&boxvr;");
    TL_IS_857 = Str__literal(U"&bprime;");
    TL_IS_858 = Str__literal(U"&breve;");
    TL_IS_859 = Str__literal(U"&brvbar");
    TL_IS_860 = Str__literal(U"&brvbar;");
    TL_IS_861 = Str__literal(U"&bscr;");
    TL_IS_862 = Str__literal(U"&bsemi;");
    TL_IS_863 = Str__literal(U"&bsim;");
    TL_IS_864 = Str__literal(U"&bsime;");
    TL_IS_865 = Str__literal(U"&bsol;");
    TL_IS_866 = Str__literal(U"&bsolb;");
    TL_IS_867 = Str__literal(U"&bsolhsub;");
    TL_IS_868 = Str__literal(U"&bull;");
    TL_IS_869 = Str__literal(U"&bullet;");
    TL_IS_870 = Str__literal(U"&bump;");
    TL_IS_871 = Str__literal(U"&bumpE;");
    TL_IS_872 = Str__literal(U"&bumpe;");
    TL_IS_873 = Str__literal(U"&bumpeq;");
    TL_IS_874 = Str__literal(U"&cacute;");
    TL_IS_875 = Str__literal(U"&cap;");
    TL_IS_876 = Str__literal(U"&capand;");
    TL_IS_877 = Str__literal(U"&capbrcup;");
    TL_IS_878 = Str__literal(U"&capcap;");
    TL_IS_879 = Str__literal(U"&capcup;");
    TL_IS_880 = Str__literal(U"&capdot;");
    TL_IS_881 = Str__literal(U"&caps;");
    TL_IS_882 = Str__literal(U"&caret;");
    TL_IS_883 = Str__literal(U"&caron;");
    TL_IS_884 = Str__literal(U"&ccaps;");
    TL_IS_885 = Str__literal(U"&ccaron;");
    TL_IS_886 = Str__literal(U"&ccedil");
    TL_IS_887 = Str__literal(U"&ccedil;");
    TL_IS_888 = Str__literal(U"&ccirc;");
    TL_IS_889 = Str__literal(U"&ccups;");
    TL_IS_890 = Str__literal(U"&ccupssm;");
    TL_IS_891 = Str__literal(U"&cdot;");
    TL_IS_892 = Str__literal(U"&cedil");
    TL_IS_893 = Str__literal(U"&cedil;");
    TL_IS_894 = Str__literal(U"&cemptyv;");
    TL_IS_895 = Str__literal(U"&cent");
    TL_IS_896 = Str__literal(U"&cent;");
    TL_IS_897 = Str__literal(U"&centerdot;");
    TL_IS_898 = Str__literal(U"&cfr;");
    TL_IS_899 = Str__literal(U"&chcy;");
    TL_IS_900 = Str__literal(U"&check;");
    TL_IS_901 = Str__literal(U"&checkmark;");
    TL_IS_902 = Str__literal(U"&chi;");
    TL_IS_903 = Str__literal(U"&cir;");
    TL_IS_904 = Str__literal(U"&cirE;");
    TL_IS_905 = Str__literal(U"&circ;");
    TL_IS_906 = Str__literal(U"&circeq;");
    TL_IS_907 = Str__literal(U"&circlearrowleft;");
    TL_IS_908 = Str__literal(U"&circlearrowright;");
    TL_IS_909 = Str__literal(U"&circledR;");
    TL_IS_910 = Str__literal(U"&circledS;");
    TL_IS_911 = Str__literal(U"&circledast;");
    TL_IS_912 = Str__literal(U"&circledcirc;");
    TL_IS_913 = Str__literal(U"&circleddash;");
    TL_IS_914 = Str__literal(U"&cire;");
    TL_IS_915 = Str__literal(U"&cirfnint;");
    TL_IS_916 = Str__literal(U"&cirmid;");
    TL_IS_917 = Str__literal(U"&cirscir;");
    TL_IS_918 = Str__literal(U"&clubs;");
    TL_IS_919 = Str__literal(U"&clubsuit;");
    TL_IS_920 = Str__literal(U"&colon;");
    TL_IS_921 = Str__literal(U"&colone;");
    TL_IS_922 = Str__literal(U"&coloneq;");
    TL_IS_923 = Str__literal(U"&comma;");
    TL_IS_924 = Str__literal(U"&commat;");
    TL_IS_925 = Str__literal(U"&comp;");
    TL_IS_926 = Str__literal(U"&compfn;");
    TL_IS_927 = Str__literal(U"&complement;");
    TL_IS_928 = Str__literal(U"&complexes;");
    TL_IS_929 = Str__literal(U"&cong;");
    TL_IS_930 = Str__literal(U"&congdot;");
    TL_IS_931 = Str__literal(U"&conint;");
    TL_IS_932 = Str__literal(U"&copf;");
    TL_IS_933 = Str__literal(U"&coprod;");
    TL_IS_934 = Str__literal(U"&copy");
    TL_IS_935 = Str__literal(U"&copy;");
    TL_IS_936 = Str__literal(U"&copysr;");
    TL_IS_937 = Str__literal(U"&crarr;");
    TL_IS_938 = Str__literal(U"&cross;");
    TL_IS_939 = Str__literal(U"&cscr;");
    TL_IS_940 = Str__literal(U"&csub;");
    TL_IS_941 = Str__literal(U"&csube;");
    TL_IS_942 = Str__literal(U"&csup;");
    TL_IS_943 = Str__literal(U"&csupe;");
    TL_IS_944 = Str__literal(U"&ctdot;");
    TL_IS_945 = Str__literal(U"&cudarrl;");
    TL_IS_946 = Str__literal(U"&cudarrr;");
    TL_IS_947 = Str__literal(U"&cuepr;");
    TL_IS_948 = Str__literal(U"&cuesc;");
    TL_IS_949 = Str__literal(U"&cularr;");
    TL_IS_950 = Str__literal(U"&cularrp;");
    TL_IS_951 = Str__literal(U"&cup;");
    TL_IS_952 = Str__literal(U"&cupbrcap;");
    TL_IS_953 = Str__literal(U"&cupcap;");
    TL_IS_954 = Str__literal(U"&cupcup;");
    TL_IS_955 = Str__literal(U"&cupdot;");
    TL_IS_956 = Str__literal(U"&cupor;");
    TL_IS_957 = Str__literal(U"&cups;");
    TL_IS_958 = Str__literal(U"&curarr;");
    TL_IS_959 = Str__literal(U"&curarrm;");
    TL_IS_960 = Str__literal(U"&curlyeqprec;");
    TL_IS_961 = Str__literal(U"&curlyeqsucc;");
    TL_IS_962 = Str__literal(U"&curlyvee;");
    TL_IS_963 = Str__literal(U"&curlywedge;");
    TL_IS_964 = Str__literal(U"&curren");
    TL_IS_965 = Str__literal(U"&curren;");
    TL_IS_966 = Str__literal(U"&curvearrowleft;");
    TL_IS_967 = Str__literal(U"&curvearrowright;");
    TL_IS_968 = Str__literal(U"&cuvee;");
    TL_IS_969 = Str__literal(U"&cuwed;");
    TL_IS_970 = Str__literal(U"&cwconint;");
    TL_IS_971 = Str__literal(U"&cwint;");
    TL_IS_972 = Str__literal(U"&cylcty;");
    TL_IS_973 = Str__literal(U"&dArr;");
    TL_IS_974 = Str__literal(U"&dHar;");
    TL_IS_975 = Str__literal(U"&dagger;");
    TL_IS_976 = Str__literal(U"&daleth;");
    TL_IS_977 = Str__literal(U"&darr;");
    TL_IS_978 = Str__literal(U"&dash;");
    TL_IS_979 = Str__literal(U"&dashv;");
    TL_IS_980 = Str__literal(U"&dbkarow;");
    TL_IS_981 = Str__literal(U"&dblac;");
    TL_IS_982 = Str__literal(U"&dcaron;");
    TL_IS_983 = Str__literal(U"&dcy;");
    TL_IS_984 = Str__literal(U"&dd;");
    TL_IS_985 = Str__literal(U"&ddagger;");
    TL_IS_986 = Str__literal(U"&ddarr;");
    TL_IS_987 = Str__literal(U"&ddotseq;");
    TL_IS_988 = Str__literal(U"&deg");
    TL_IS_989 = Str__literal(U"&deg;");
    TL_IS_990 = Str__literal(U"&delta;");
    TL_IS_991 = Str__literal(U"&demptyv;");
    TL_IS_992 = Str__literal(U"&dfisht;");
    TL_IS_993 = Str__literal(U"&dfr;");
    TL_IS_994 = Str__literal(U"&dharl;");
    TL_IS_995 = Str__literal(U"&dharr;");
    TL_IS_996 = Str__literal(U"&diam;");
    TL_IS_997 = Str__literal(U"&diamond;");
    TL_IS_998 = Str__literal(U"&diamondsuit;");
    TL_IS_999 = Str__literal(U"&diams;");
    TL_IS_1000 = Str__literal(U"&die;");
    TL_IS_1001 = Str__literal(U"&digamma;");
    TL_IS_1002 = Str__literal(U"&disin;");
    TL_IS_1003 = Str__literal(U"&div;");
    TL_IS_1004 = Str__literal(U"&divide");
    TL_IS_1005 = Str__literal(U"&divide;");
    TL_IS_1006 = Str__literal(U"&divideontimes;");
    TL_IS_1007 = Str__literal(U"&divonx;");
    TL_IS_1008 = Str__literal(U"&djcy;");
    TL_IS_1009 = Str__literal(U"&dlcorn;");
    TL_IS_1010 = Str__literal(U"&dlcrop;");
    TL_IS_1011 = Str__literal(U"&dollar;");
    TL_IS_1012 = Str__literal(U"&dopf;");
    TL_IS_1013 = Str__literal(U"&dot;");
    TL_IS_1014 = Str__literal(U"&doteq;");
    TL_IS_1015 = Str__literal(U"&doteqdot;");
    TL_IS_1016 = Str__literal(U"&dotminus;");
    TL_IS_1017 = Str__literal(U"&dotplus;");
    TL_IS_1018 = Str__literal(U"&dotsquare;");
    TL_IS_1019 = Str__literal(U"&doublebarwedge;");
    TL_IS_1020 = Str__literal(U"&downarrow;");
    TL_IS_1021 = Str__literal(U"&downdownarrows;");
    TL_IS_1022 = Str__literal(U"&downharpoonleft;");
    TL_IS_1023 = Str__literal(U"&downharpoonright;");
    TL_IS_1024 = Str__literal(U"&drbkarow;");
    TL_IS_1025 = Str__literal(U"&drcorn;");
    TL_IS_1026 = Str__literal(U"&drcrop;");
    TL_IS_1027 = Str__literal(U"&dscr;");
    TL_IS_1028 = Str__literal(U"&dscy;");
    TL_IS_1029 = Str__literal(U"&dsol;");
    TL_IS_1030 = Str__literal(U"&dstrok;");
    TL_IS_1031 = Str__literal(U"&dtdot;");
    TL_IS_1032 = Str__literal(U"&dtri;");
    TL_IS_1033 = Str__literal(U"&dtrif;");
    TL_IS_1034 = Str__literal(U"&duarr;");
    TL_IS_1035 = Str__literal(U"&duhar;");
    TL_IS_1036 = Str__literal(U"&dwangle;");
    TL_IS_1037 = Str__literal(U"&dzcy;");
    TL_IS_1038 = Str__literal(U"&dzigrarr;");
    TL_IS_1039 = Str__literal(U"&eDDot;");
    TL_IS_1040 = Str__literal(U"&eDot;");
    TL_IS_1041 = Str__literal(U"&eacute");
    TL_IS_1042 = Str__literal(U"&eacute;");
    TL_IS_1043 = Str__literal(U"&easter;");
    TL_IS_1044 = Str__literal(U"&ecaron;");
    TL_IS_1045 = Str__literal(U"&ecir;");
    TL_IS_1046 = Str__literal(U"&ecirc");
    TL_IS_1047 = Str__literal(U"&ecirc;");
    TL_IS_1048 = Str__literal(U"&ecolon;");
    TL_IS_1049 = Str__literal(U"&ecy;");
    TL_IS_1050 = Str__literal(U"&edot;");
    TL_IS_1051 = Str__literal(U"&ee;");
    TL_IS_1052 = Str__literal(U"&efDot;");
    TL_IS_1053 = Str__literal(U"&efr;");
    TL_IS_1054 = Str__literal(U"&eg;");
    TL_IS_1055 = Str__literal(U"&egrave");
    TL_IS_1056 = Str__literal(U"&egrave;");
    TL_IS_1057 = Str__literal(U"&egs;");
    TL_IS_1058 = Str__literal(U"&egsdot;");
    TL_IS_1059 = Str__literal(U"&el;");
    TL_IS_1060 = Str__literal(U"&elinters;");
    TL_IS_1061 = Str__literal(U"&ell;");
    TL_IS_1062 = Str__literal(U"&els;");
    TL_IS_1063 = Str__literal(U"&elsdot;");
    TL_IS_1064 = Str__literal(U"&emacr;");
    TL_IS_1065 = Str__literal(U"&empty;");
    TL_IS_1066 = Str__literal(U"&emptyset;");
    TL_IS_1067 = Str__literal(U"&emptyv;");
    TL_IS_1068 = Str__literal(U"&emsp13;");
    TL_IS_1069 = Str__literal(U"&emsp14;");
    TL_IS_1070 = Str__literal(U"&emsp;");
    TL_IS_1071 = Str__literal(U"&eng;");
    TL_IS_1072 = Str__literal(U"&ensp;");
    TL_IS_1073 = Str__literal(U"&eogon;");
    TL_IS_1074 = Str__literal(U"&eopf;");
    TL_IS_1075 = Str__literal(U"&epar;");
    TL_IS_1076 = Str__literal(U"&eparsl;");
    TL_IS_1077 = Str__literal(U"&eplus;");
    TL_IS_1078 = Str__literal(U"&epsi;");
    TL_IS_1079 = Str__literal(U"&epsilon;");
    TL_IS_1080 = Str__literal(U"&epsiv;");
    TL_IS_1081 = Str__literal(U"&eqcirc;");
    TL_IS_1082 = Str__literal(U"&eqcolon;");
    TL_IS_1083 = Str__literal(U"&eqsim;");
    TL_IS_1084 = Str__literal(U"&eqslantgtr;");
    TL_IS_1085 = Str__literal(U"&eqslantless;");
    TL_IS_1086 = Str__literal(U"&equals;");
    TL_IS_1087 = Str__literal(U"&equest;");
    TL_IS_1088 = Str__literal(U"&equiv;");
    TL_IS_1089 = Str__literal(U"&equivDD;");
    TL_IS_1090 = Str__literal(U"&eqvparsl;");
    TL_IS_1091 = Str__literal(U"&erDot;");
    TL_IS_1092 = Str__literal(U"&erarr;");
    TL_IS_1093 = Str__literal(U"&escr;");
    TL_IS_1094 = Str__literal(U"&esdot;");
    TL_IS_1095 = Str__literal(U"&esim;");
    TL_IS_1096 = Str__literal(U"&eta;");
    TL_IS_1097 = Str__literal(U"&eth");
    TL_IS_1098 = Str__literal(U"&eth;");
    TL_IS_1099 = Str__literal(U"&euml");
    TL_IS_1100 = Str__literal(U"&euml;");
    TL_IS_1101 = Str__literal(U"&euro;");
    TL_IS_1102 = Str__literal(U"&excl;");
    TL_IS_1103 = Str__literal(U"&exist;");
    TL_IS_1104 = Str__literal(U"&expectation;");
    TL_IS_1105 = Str__literal(U"&exponentiale;");
    TL_IS_1106 = Str__literal(U"&fallingdotseq;");
    TL_IS_1107 = Str__literal(U"&fcy;");
    TL_IS_1108 = Str__literal(U"&female;");
    TL_IS_1109 = Str__literal(U"&ffilig;");
    TL_IS_1110 = Str__literal(U"&fflig;");
    TL_IS_1111 = Str__literal(U"&ffllig;");
    TL_IS_1112 = Str__literal(U"&ffr;");
    TL_IS_1113 = Str__literal(U"&filig;");
    TL_IS_1114 = Str__literal(U"&fjlig;");
    TL_IS_1115 = Str__literal(U"&flat;");
    TL_IS_1116 = Str__literal(U"&fllig;");
    TL_IS_1117 = Str__literal(U"&fltns;");
    TL_IS_1118 = Str__literal(U"&fnof;");
    TL_IS_1119 = Str__literal(U"&fopf;");
    TL_IS_1120 = Str__literal(U"&forall;");
    TL_IS_1121 = Str__literal(U"&fork;");
    TL_IS_1122 = Str__literal(U"&forkv;");
    TL_IS_1123 = Str__literal(U"&fpartint;");
    TL_IS_1124 = Str__literal(U"&frac12");
    TL_IS_1125 = Str__literal(U"&frac12;");
    TL_IS_1126 = Str__literal(U"&frac13;");
    TL_IS_1127 = Str__literal(U"&frac14");
    TL_IS_1128 = Str__literal(U"&frac14;");
    TL_IS_1129 = Str__literal(U"&frac15;");
    TL_IS_1130 = Str__literal(U"&frac16;");
    TL_IS_1131 = Str__literal(U"&frac18;");
    TL_IS_1132 = Str__literal(U"&frac23;");
    TL_IS_1133 = Str__literal(U"&frac25;");
    TL_IS_1134 = Str__literal(U"&frac34");
    TL_IS_1135 = Str__literal(U"&frac34;");
    TL_IS_1136 = Str__literal(U"&frac35;");
    TL_IS_1137 = Str__literal(U"&frac38;");
    TL_IS_1138 = Str__literal(U"&frac45;");
    TL_IS_1139 = Str__literal(U"&frac56;");
    TL_IS_1140 = Str__literal(U"&frac58;");
    TL_IS_1141 = Str__literal(U"&frac78;");
    TL_IS_1142 = Str__literal(U"&frasl;");
    TL_IS_1143 = Str__literal(U"&frown;");
    TL_IS_1144 = Str__literal(U"&fscr;");
    TL_IS_1145 = Str__literal(U"&gE;");
    TL_IS_1146 = Str__literal(U"&gEl;");
    TL_IS_1147 = Str__literal(U"&gacute;");
    TL_IS_1148 = Str__literal(U"&gamma;");
    TL_IS_1149 = Str__literal(U"&gammad;");
    TL_IS_1150 = Str__literal(U"&gap;");
    TL_IS_1151 = Str__literal(U"&gbreve;");
    TL_IS_1152 = Str__literal(U"&gcirc;");
    TL_IS_1153 = Str__literal(U"&gcy;");
    TL_IS_1154 = Str__literal(U"&gdot;");
    TL_IS_1155 = Str__literal(U"&ge;");
    TL_IS_1156 = Str__literal(U"&gel;");
    TL_IS_1157 = Str__literal(U"&geq;");
    TL_IS_1158 = Str__literal(U"&geqq;");
    TL_IS_1159 = Str__literal(U"&geqslant;");
    TL_IS_1160 = Str__literal(U"&ges;");
    TL_IS_1161 = Str__literal(U"&gescc;");
    TL_IS_1162 = Str__literal(U"&gesdot;");
    TL_IS_1163 = Str__literal(U"&gesdoto;");
    TL_IS_1164 = Str__literal(U"&gesdotol;");
    TL_IS_1165 = Str__literal(U"&gesl;");
    TL_IS_1166 = Str__literal(U"&gesles;");
    TL_IS_1167 = Str__literal(U"&gfr;");
    TL_IS_1168 = Str__literal(U"&gg;");
    TL_IS_1169 = Str__literal(U"&ggg;");
    TL_IS_1170 = Str__literal(U"&gimel;");
    TL_IS_1171 = Str__literal(U"&gjcy;");
    TL_IS_1172 = Str__literal(U"&gl;");
    TL_IS_1173 = Str__literal(U"&glE;");
    TL_IS_1174 = Str__literal(U"&gla;");
    TL_IS_1175 = Str__literal(U"&glj;");
    TL_IS_1176 = Str__literal(U"&gnE;");
    TL_IS_1177 = Str__literal(U"&gnap;");
    TL_IS_1178 = Str__literal(U"&gnapprox;");
    TL_IS_1179 = Str__literal(U"&gne;");
    TL_IS_1180 = Str__literal(U"&gneq;");
    TL_IS_1181 = Str__literal(U"&gneqq;");
    TL_IS_1182 = Str__literal(U"&gnsim;");
    TL_IS_1183 = Str__literal(U"&gopf;");
    TL_IS_1184 = Str__literal(U"&grave;");
    TL_IS_1185 = Str__literal(U"&gscr;");
    TL_IS_1186 = Str__literal(U"&gsim;");
    TL_IS_1187 = Str__literal(U"&gsime;");
    TL_IS_1188 = Str__literal(U"&gsiml;");
    TL_IS_1189 = Str__literal(U"&gt");
    TL_IS_1190 = Str__literal(U"&gt;");
    TL_IS_1191 = Str__literal(U"&gtcc;");
    TL_IS_1192 = Str__literal(U"&gtcir;");
    TL_IS_1193 = Str__literal(U"&gtdot;");
    TL_IS_1194 = Str__literal(U"&gtlPar;");
    TL_IS_1195 = Str__literal(U"&gtquest;");
    TL_IS_1196 = Str__literal(U"&gtrapprox;");
    TL_IS_1197 = Str__literal(U"&gtrarr;");
    TL_IS_1198 = Str__literal(U"&gtrdot;");
    TL_IS_1199 = Str__literal(U"&gtreqless;");
    TL_IS_1200 = Str__literal(U"&gtreqqless;");
    TL_IS_1201 = Str__literal(U"&gtrless;");
    TL_IS_1202 = Str__literal(U"&gtrsim;");
    TL_IS_1203 = Str__literal(U"&gvertneqq;");
    TL_IS_1204 = Str__literal(U"&gvnE;");
    TL_IS_1205 = Str__literal(U"&hArr;");
    TL_IS_1206 = Str__literal(U"&hairsp;");
    TL_IS_1207 = Str__literal(U"&half;");
    TL_IS_1208 = Str__literal(U"&hamilt;");
    TL_IS_1209 = Str__literal(U"&hardcy;");
    TL_IS_1210 = Str__literal(U"&harr;");
    TL_IS_1211 = Str__literal(U"&harrcir;");
    TL_IS_1212 = Str__literal(U"&harrw;");
    TL_IS_1213 = Str__literal(U"&hbar;");
    TL_IS_1214 = Str__literal(U"&hcirc;");
    TL_IS_1215 = Str__literal(U"&hearts;");
    TL_IS_1216 = Str__literal(U"&heartsuit;");
    TL_IS_1217 = Str__literal(U"&hellip;");
    TL_IS_1218 = Str__literal(U"&hercon;");
    TL_IS_1219 = Str__literal(U"&hfr;");
    TL_IS_1220 = Str__literal(U"&hksearow;");
    TL_IS_1221 = Str__literal(U"&hkswarow;");
    TL_IS_1222 = Str__literal(U"&hoarr;");
    TL_IS_1223 = Str__literal(U"&homtht;");
    TL_IS_1224 = Str__literal(U"&hookleftarrow;");
    TL_IS_1225 = Str__literal(U"&hookrightarrow;");
    TL_IS_1226 = Str__literal(U"&hopf;");
    TL_IS_1227 = Str__literal(U"&horbar;");
    TL_IS_1228 = Str__literal(U"&hscr;");
    TL_IS_1229 = Str__literal(U"&hslash;");
    TL_IS_1230 = Str__literal(U"&hstrok;");
    TL_IS_1231 = Str__literal(U"&hybull;");
    TL_IS_1232 = Str__literal(U"&hyphen;");
    TL_IS_1233 = Str__literal(U"&iacute");
    TL_IS_1234 = Str__literal(U"&iacute;");
    TL_IS_1235 = Str__literal(U"&ic;");
    TL_IS_1236 = Str__literal(U"&icirc");
    TL_IS_1237 = Str__literal(U"&icirc;");
    TL_IS_1238 = Str__literal(U"&icy;");
    TL_IS_1239 = Str__literal(U"&iecy;");
    TL_IS_1240 = Str__literal(U"&iexcl");
    TL_IS_1241 = Str__literal(U"&iexcl;");
    TL_IS_1242 = Str__literal(U"&iff;");
    TL_IS_1243 = Str__literal(U"&ifr;");
    TL_IS_1244 = Str__literal(U"&igrave");
    TL_IS_1245 = Str__literal(U"&igrave;");
    TL_IS_1246 = Str__literal(U"&ii;");
    TL_IS_1247 = Str__literal(U"&iiiint;");
    TL_IS_1248 = Str__literal(U"&iiint;");
    TL_IS_1249 = Str__literal(U"&iinfin;");
    TL_IS_1250 = Str__literal(U"&iiota;");
    TL_IS_1251 = Str__literal(U"&ijlig;");
    TL_IS_1252 = Str__literal(U"&imacr;");
    TL_IS_1253 = Str__literal(U"&image;");
    TL_IS_1254 = Str__literal(U"&imagline;");
    TL_IS_1255 = Str__literal(U"&imagpart;");
    TL_IS_1256 = Str__literal(U"&imath;");
    TL_IS_1257 = Str__literal(U"&imof;");
    TL_IS_1258 = Str__literal(U"&imped;");
    TL_IS_1259 = Str__literal(U"&in;");
    TL_IS_1260 = Str__literal(U"&incare;");
    TL_IS_1261 = Str__literal(U"&infin;");
    TL_IS_1262 = Str__literal(U"&infintie;");
    TL_IS_1263 = Str__literal(U"&inodot;");
    TL_IS_1264 = Str__literal(U"&int;");
    TL_IS_1265 = Str__literal(U"&intcal;");
    TL_IS_1266 = Str__literal(U"&integers;");
    TL_IS_1267 = Str__literal(U"&intercal;");
    TL_IS_1268 = Str__literal(U"&intlarhk;");
    TL_IS_1269 = Str__literal(U"&intprod;");
    TL_IS_1270 = Str__literal(U"&iocy;");
    TL_IS_1271 = Str__literal(U"&iogon;");
    TL_IS_1272 = Str__literal(U"&iopf;");
    TL_IS_1273 = Str__literal(U"&iota;");
    TL_IS_1274 = Str__literal(U"&iprod;");
    TL_IS_1275 = Str__literal(U"&iquest");
    TL_IS_1276 = Str__literal(U"&iquest;");
    TL_IS_1277 = Str__literal(U"&iscr;");
    TL_IS_1278 = Str__literal(U"&isin;");
    TL_IS_1279 = Str__literal(U"&isinE;");
    TL_IS_1280 = Str__literal(U"&isindot;");
    TL_IS_1281 = Str__literal(U"&isins;");
    TL_IS_1282 = Str__literal(U"&isinsv;");
    TL_IS_1283 = Str__literal(U"&isinv;");
    TL_IS_1284 = Str__literal(U"&it;");
    TL_IS_1285 = Str__literal(U"&itilde;");
    TL_IS_1286 = Str__literal(U"&iukcy;");
    TL_IS_1287 = Str__literal(U"&iuml");
    TL_IS_1288 = Str__literal(U"&iuml;");
    TL_IS_1289 = Str__literal(U"&jcirc;");
    TL_IS_1290 = Str__literal(U"&jcy;");
    TL_IS_1291 = Str__literal(U"&jfr;");
    TL_IS_1292 = Str__literal(U"&jmath;");
    TL_IS_1293 = Str__literal(U"&jopf;");
    TL_IS_1294 = Str__literal(U"&jscr;");
    TL_IS_1295 = Str__literal(U"&jsercy;");
    TL_IS_1296 = Str__literal(U"&jukcy;");
    TL_IS_1297 = Str__literal(U"&kappa;");
    TL_IS_1298 = Str__literal(U"&kappav;");
    TL_IS_1299 = Str__literal(U"&kcedil;");
    TL_IS_1300 = Str__literal(U"&kcy;");
    TL_IS_1301 = Str__literal(U"&kfr;");
    TL_IS_1302 = Str__literal(U"&kgreen;");
    TL_IS_1303 = Str__literal(U"&khcy;");
    TL_IS_1304 = Str__literal(U"&kjcy;");
    TL_IS_1305 = Str__literal(U"&kopf;");
    TL_IS_1306 = Str__literal(U"&kscr;");
    TL_IS_1307 = Str__literal(U"&lAarr;");
    TL_IS_1308 = Str__literal(U"&lArr;");
    TL_IS_1309 = Str__literal(U"&lAtail;");
    TL_IS_1310 = Str__literal(U"&lBarr;");
    TL_IS_1311 = Str__literal(U"&lE;");
    TL_IS_1312 = Str__literal(U"&lEg;");
    TL_IS_1313 = Str__literal(U"&lHar;");
    TL_IS_1314 = Str__literal(U"&lacute;");
    TL_IS_1315 = Str__literal(U"&laemptyv;");
    TL_IS_1316 = Str__literal(U"&lagran;");
    TL_IS_1317 = Str__literal(U"&lambda;");
    TL_IS_1318 = Str__literal(U"&lang;");
    TL_IS_1319 = Str__literal(U"&langd;");
    TL_IS_1320 = Str__literal(U"&langle;");
    TL_IS_1321 = Str__literal(U"&lap;");
    TL_IS_1322 = Str__literal(U"&laquo");
    TL_IS_1323 = Str__literal(U"&laquo;");
    TL_IS_1324 = Str__literal(U"&larr;");
    TL_IS_1325 = Str__literal(U"&larrb;");
    TL_IS_1326 = Str__literal(U"&larrbfs;");
    TL_IS_1327 = Str__literal(U"&larrfs;");
    TL_IS_1328 = Str__literal(U"&larrhk;");
    TL_IS_1329 = Str__literal(U"&larrlp;");
    TL_IS_1330 = Str__literal(U"&larrpl;");
    TL_IS_1331 = Str__literal(U"&larrsim;");
    TL_IS_1332 = Str__literal(U"&larrtl;");
    TL_IS_1333 = Str__literal(U"&lat;");
    TL_IS_1334 = Str__literal(U"&latail;");
    TL_IS_1335 = Str__literal(U"&late;");
    TL_IS_1336 = Str__literal(U"&lates;");
    TL_IS_1337 = Str__literal(U"&lbarr;");
    TL_IS_1338 = Str__literal(U"&lbbrk;");
    TL_IS_1339 = Str__literal(U"&lbrace;");
    TL_IS_1340 = Str__literal(U"&lbrack;");
    TL_IS_1341 = Str__literal(U"&lbrke;");
    TL_IS_1342 = Str__literal(U"&lbrksld;");
    TL_IS_1343 = Str__literal(U"&lbrkslu;");
    TL_IS_1344 = Str__literal(U"&lcaron;");
    TL_IS_1345 = Str__literal(U"&lcedil;");
    TL_IS_1346 = Str__literal(U"&lceil;");
    TL_IS_1347 = Str__literal(U"&lcub;");
    TL_IS_1348 = Str__literal(U"&lcy;");
    TL_IS_1349 = Str__literal(U"&ldca;");
    TL_IS_1350 = Str__literal(U"&ldquo;");
    TL_IS_1351 = Str__literal(U"&ldquor;");
    TL_IS_1352 = Str__literal(U"&ldrdhar;");
    TL_IS_1353 = Str__literal(U"&ldrushar;");
    TL_IS_1354 = Str__literal(U"&ldsh;");
    TL_IS_1355 = Str__literal(U"&le;");
    TL_IS_1356 = Str__literal(U"&leftarrow;");
    TL_IS_1357 = Str__literal(U"&leftarrowtail;");
    TL_IS_1358 = Str__literal(U"&leftharpoondown;");
    TL_IS_1359 = Str__literal(U"&leftharpoonup;");
    TL_IS_1360 = Str__literal(U"&leftleftarrows;");
    TL_IS_1361 = Str__literal(U"&leftrightarrow;");
    TL_IS_1362 = Str__literal(U"&leftrightarrows;");
    TL_IS_1363 = Str__literal(U"&leftrightharpoons;");
    TL_IS_1364 = Str__literal(U"&leftrightsquigarrow;");
    TL_IS_1365 = Str__literal(U"&leftthreetimes;");
    TL_IS_1366 = Str__literal(U"&leg;");
    TL_IS_1367 = Str__literal(U"&leq;");
    TL_IS_1368 = Str__literal(U"&leqq;");
    TL_IS_1369 = Str__literal(U"&leqslant;");
    TL_IS_1370 = Str__literal(U"&les;");
    TL_IS_1371 = Str__literal(U"&lescc;");
    TL_IS_1372 = Str__literal(U"&lesdot;");
    TL_IS_1373 = Str__literal(U"&lesdoto;");
    TL_IS_1374 = Str__literal(U"&lesdotor;");
    TL_IS_1375 = Str__literal(U"&lesg;");
    TL_IS_1376 = Str__literal(U"&lesges;");
    TL_IS_1377 = Str__literal(U"&lessapprox;");
    TL_IS_1378 = Str__literal(U"&lessdot;");
    TL_IS_1379 = Str__literal(U"&lesseqgtr;");
    TL_IS_1380 = Str__literal(U"&lesseqqgtr;");
    TL_IS_1381 = Str__literal(U"&lessgtr;");
    TL_IS_1382 = Str__literal(U"&lesssim;");
    TL_IS_1383 = Str__literal(U"&lfisht;");
    TL_IS_1384 = Str__literal(U"&lfloor;");
    TL_IS_1385 = Str__literal(U"&lfr;");
    TL_IS_1386 = Str__literal(U"&lg;");
    TL_IS_1387 = Str__literal(U"&lgE;");
    TL_IS_1388 = Str__literal(U"&lhard;");
    TL_IS_1389 = Str__literal(U"&lharu;");
    TL_IS_1390 = Str__literal(U"&lharul;");
    TL_IS_1391 = Str__literal(U"&lhblk;");
    TL_IS_1392 = Str__literal(U"&ljcy;");
    TL_IS_1393 = Str__literal(U"&ll;");
    TL_IS_1394 = Str__literal(U"&llarr;");
    TL_IS_1395 = Str__literal(U"&llcorner;");
    TL_IS_1396 = Str__literal(U"&llhard;");
    TL_IS_1397 = Str__literal(U"&lltri;");
    TL_IS_1398 = Str__literal(U"&lmidot;");
    TL_IS_1399 = Str__literal(U"&lmoust;");
    TL_IS_1400 = Str__literal(U"&lmoustache;");
    TL_IS_1401 = Str__literal(U"&lnE;");
    TL_IS_1402 = Str__literal(U"&lnap;");
    TL_IS_1403 = Str__literal(U"&lnapprox;");
    TL_IS_1404 = Str__literal(U"&lne;");
    TL_IS_1405 = Str__literal(U"&lneq;");
    TL_IS_1406 = Str__literal(U"&lneqq;");
    TL_IS_1407 = Str__literal(U"&lnsim;");
    TL_IS_1408 = Str__literal(U"&loang;");
    TL_IS_1409 = Str__literal(U"&loarr;");
    TL_IS_1410 = Str__literal(U"&lobrk;");
    TL_IS_1411 = Str__literal(U"&longleftarrow;");
    TL_IS_1412 = Str__literal(U"&longleftrightarrow;");
    TL_IS_1413 = Str__literal(U"&longmapsto;");
    TL_IS_1414 = Str__literal(U"&longrightarrow;");
    TL_IS_1415 = Str__literal(U"&looparrowleft;");
    TL_IS_1416 = Str__literal(U"&looparrowright;");
    TL_IS_1417 = Str__literal(U"&lopar;");
    TL_IS_1418 = Str__literal(U"&lopf;");
    TL_IS_1419 = Str__literal(U"&loplus;");
    TL_IS_1420 = Str__literal(U"&lotimes;");
    TL_IS_1421 = Str__literal(U"&lowast;");
    TL_IS_1422 = Str__literal(U"&lowbar;");
    TL_IS_1423 = Str__literal(U"&loz;");
    TL_IS_1424 = Str__literal(U"&lozenge;");
    TL_IS_1425 = Str__literal(U"&lozf;");
    TL_IS_1426 = Str__literal(U"&lpar;");
    TL_IS_1427 = Str__literal(U"&lparlt;");
    TL_IS_1428 = Str__literal(U"&lrarr;");
    TL_IS_1429 = Str__literal(U"&lrcorner;");
    TL_IS_1430 = Str__literal(U"&lrhar;");
    TL_IS_1431 = Str__literal(U"&lrhard;");
    TL_IS_1432 = Str__literal(U"&lrm;");
    TL_IS_1433 = Str__literal(U"&lrtri;");
    TL_IS_1434 = Str__literal(U"&lsaquo;");
    TL_IS_1435 = Str__literal(U"&lscr;");
    TL_IS_1436 = Str__literal(U"&lsh;");
    TL_IS_1437 = Str__literal(U"&lsim;");
    TL_IS_1438 = Str__literal(U"&lsime;");
    TL_IS_1439 = Str__literal(U"&lsimg;");
    TL_IS_1440 = Str__literal(U"&lsqb;");
    TL_IS_1441 = Str__literal(U"&lsquo;");
    TL_IS_1442 = Str__literal(U"&lsquor;");
    TL_IS_1443 = Str__literal(U"&lstrok;");
    TL_IS_1444 = Str__literal(U"&lt");
    TL_IS_1445 = Str__literal(U"&lt;");
    TL_IS_1446 = Str__literal(U"&ltcc;");
    TL_IS_1447 = Str__literal(U"&ltcir;");
    TL_IS_1448 = Str__literal(U"&ltdot;");
    TL_IS_1449 = Str__literal(U"&lthree;");
    TL_IS_1450 = Str__literal(U"&ltimes;");
    TL_IS_1451 = Str__literal(U"&ltlarr;");
    TL_IS_1452 = Str__literal(U"&ltquest;");
    TL_IS_1453 = Str__literal(U"&ltrPar;");
    TL_IS_1454 = Str__literal(U"&ltri;");
    TL_IS_1455 = Str__literal(U"&ltrie;");
    TL_IS_1456 = Str__literal(U"&ltrif;");
    TL_IS_1457 = Str__literal(U"&lurdshar;");
    TL_IS_1458 = Str__literal(U"&luruhar;");
    TL_IS_1459 = Str__literal(U"&lvertneqq;");
    TL_IS_1460 = Str__literal(U"&lvnE;");
    TL_IS_1461 = Str__literal(U"&mDDot;");
    TL_IS_1462 = Str__literal(U"&macr");
    TL_IS_1463 = Str__literal(U"&macr;");
    TL_IS_1464 = Str__literal(U"&male;");
    TL_IS_1465 = Str__literal(U"&malt;");
    TL_IS_1466 = Str__literal(U"&maltese;");
    TL_IS_1467 = Str__literal(U"&map;");
    TL_IS_1468 = Str__literal(U"&mapsto;");
    TL_IS_1469 = Str__literal(U"&mapstodown;");
    TL_IS_1470 = Str__literal(U"&mapstoleft;");
    TL_IS_1471 = Str__literal(U"&mapstoup;");
    TL_IS_1472 = Str__literal(U"&marker;");
    TL_IS_1473 = Str__literal(U"&mcomma;");
    TL_IS_1474 = Str__literal(U"&mcy;");
    TL_IS_1475 = Str__literal(U"&mdash;");
    TL_IS_1476 = Str__literal(U"&measuredangle;");
    TL_IS_1477 = Str__literal(U"&mfr;");
    TL_IS_1478 = Str__literal(U"&mho;");
    TL_IS_1479 = Str__literal(U"&micro");
    TL_IS_1480 = Str__literal(U"&micro;");
    TL_IS_1481 = Str__literal(U"&mid;");
    TL_IS_1482 = Str__literal(U"&midast;");
    TL_IS_1483 = Str__literal(U"&midcir;");
    TL_IS_1484 = Str__literal(U"&middot");
    TL_IS_1485 = Str__literal(U"&middot;");
    TL_IS_1486 = Str__literal(U"&minus;");
    TL_IS_1487 = Str__literal(U"&minusb;");
    TL_IS_1488 = Str__literal(U"&minusd;");
    TL_IS_1489 = Str__literal(U"&minusdu;");
    TL_IS_1490 = Str__literal(U"&mlcp;");
    TL_IS_1491 = Str__literal(U"&mldr;");
    TL_IS_1492 = Str__literal(U"&mnplus;");
    TL_IS_1493 = Str__literal(U"&models;");
    TL_IS_1494 = Str__literal(U"&mopf;");
    TL_IS_1495 = Str__literal(U"&mp;");
    TL_IS_1496 = Str__literal(U"&mscr;");
    TL_IS_1497 = Str__literal(U"&mstpos;");
    TL_IS_1498 = Str__literal(U"&mu;");
    TL_IS_1499 = Str__literal(U"&multimap;");
    TL_IS_1500 = Str__literal(U"&mumap;");
    TL_IS_1501 = Str__literal(U"&nGg;");
    TL_IS_1502 = Str__literal(U"&nGt;");
    TL_IS_1503 = Str__literal(U"&nGtv;");
    TL_IS_1504 = Str__literal(U"&nLeftarrow;");
    TL_IS_1505 = Str__literal(U"&nLeftrightarrow;");
    TL_IS_1506 = Str__literal(U"&nLl;");
    TL_IS_1507 = Str__literal(U"&nLt;");
    TL_IS_1508 = Str__literal(U"&nLtv;");
    TL_IS_1509 = Str__literal(U"&nRightarrow;");
    TL_IS_1510 = Str__literal(U"&nVDash;");
    TL_IS_1511 = Str__literal(U"&nVdash;");
    TL_IS_1512 = Str__literal(U"&nabla;");
    TL_IS_1513 = Str__literal(U"&nacute;");
    TL_IS_1514 = Str__literal(U"&nang;");
    TL_IS_1515 = Str__literal(U"&nap;");
    TL_IS_1516 = Str__literal(U"&napE;");
    TL_IS_1517 = Str__literal(U"&napid;");
    TL_IS_1518 = Str__literal(U"&napos;");
    TL_IS_1519 = Str__literal(U"&napprox;");
    TL_IS_1520 = Str__literal(U"&natur;");
    TL_IS_1521 = Str__literal(U"&natural;");
    TL_IS_1522 = Str__literal(U"&naturals;");
    TL_IS_1523 = Str__literal(U"&nbsp");
    TL_IS_1524 = Str__literal(U"&nbsp;");
    TL_IS_1525 = Str__literal(U"&nbump;");
    TL_IS_1526 = Str__literal(U"&nbumpe;");
    TL_IS_1527 = Str__literal(U"&ncap;");
    TL_IS_1528 = Str__literal(U"&ncaron;");
    TL_IS_1529 = Str__literal(U"&ncedil;");
    TL_IS_1530 = Str__literal(U"&ncong;");
    TL_IS_1531 = Str__literal(U"&ncongdot;");
    TL_IS_1532 = Str__literal(U"&ncup;");
    TL_IS_1533 = Str__literal(U"&ncy;");
    TL_IS_1534 = Str__literal(U"&ndash;");
    TL_IS_1535 = Str__literal(U"&ne;");
    TL_IS_1536 = Str__literal(U"&neArr;");
    TL_IS_1537 = Str__literal(U"&nearhk;");
    TL_IS_1538 = Str__literal(U"&nearr;");
    TL_IS_1539 = Str__literal(U"&nearrow;");
    TL_IS_1540 = Str__literal(U"&nedot;");
    TL_IS_1541 = Str__literal(U"&nequiv;");
    TL_IS_1542 = Str__literal(U"&nesear;");
    TL_IS_1543 = Str__literal(U"&nesim;");
    TL_IS_1544 = Str__literal(U"&nexist;");
    TL_IS_1545 = Str__literal(U"&nexists;");
    TL_IS_1546 = Str__literal(U"&nfr;");
    TL_IS_1547 = Str__literal(U"&ngE;");
    TL_IS_1548 = Str__literal(U"&nge;");
    TL_IS_1549 = Str__literal(U"&ngeq;");
    TL_IS_1550 = Str__literal(U"&ngeqq;");
    TL_IS_1551 = Str__literal(U"&ngeqslant;");
    TL_IS_1552 = Str__literal(U"&nges;");
    TL_IS_1553 = Str__literal(U"&ngsim;");
    TL_IS_1554 = Str__literal(U"&ngt;");
    TL_IS_1555 = Str__literal(U"&ngtr;");
    TL_IS_1556 = Str__literal(U"&nhArr;");
    TL_IS_1557 = Str__literal(U"&nharr;");
    TL_IS_1558 = Str__literal(U"&nhpar;");
    TL_IS_1559 = Str__literal(U"&ni;");
    TL_IS_1560 = Str__literal(U"&nis;");
    TL_IS_1561 = Str__literal(U"&nisd;");
    TL_IS_1562 = Str__literal(U"&niv;");
    TL_IS_1563 = Str__literal(U"&njcy;");
    TL_IS_1564 = Str__literal(U"&nlArr;");
    TL_IS_1565 = Str__literal(U"&nlE;");
    TL_IS_1566 = Str__literal(U"&nlarr;");
    TL_IS_1567 = Str__literal(U"&nldr;");
    TL_IS_1568 = Str__literal(U"&nle;");
    TL_IS_1569 = Str__literal(U"&nleftarrow;");
    TL_IS_1570 = Str__literal(U"&nleftrightarrow;");
    TL_IS_1571 = Str__literal(U"&nleq;");
    TL_IS_1572 = Str__literal(U"&nleqq;");
    TL_IS_1573 = Str__literal(U"&nleqslant;");
    TL_IS_1574 = Str__literal(U"&nles;");
    TL_IS_1575 = Str__literal(U"&nless;");
    TL_IS_1576 = Str__literal(U"&nlsim;");
    TL_IS_1577 = Str__literal(U"&nlt;");
    TL_IS_1578 = Str__literal(U"&nltri;");
    TL_IS_1579 = Str__literal(U"&nltrie;");
    TL_IS_1580 = Str__literal(U"&nmid;");
    TL_IS_1581 = Str__literal(U"&nopf;");
    TL_IS_1582 = Str__literal(U"&not");
    TL_IS_1583 = Str__literal(U"&not;");
    TL_IS_1584 = Str__literal(U"&notin;");
    TL_IS_1585 = Str__literal(U"&notinE;");
    TL_IS_1586 = Str__literal(U"&notindot;");
    TL_IS_1587 = Str__literal(U"&notinva;");
    TL_IS_1588 = Str__literal(U"&notinvb;");
    TL_IS_1589 = Str__literal(U"&notinvc;");
    TL_IS_1590 = Str__literal(U"&notni;");
    TL_IS_1591 = Str__literal(U"&notniva;");
    TL_IS_1592 = Str__literal(U"&notnivb;");
    TL_IS_1593 = Str__literal(U"&notnivc;");
    TL_IS_1594 = Str__literal(U"&npar;");
    TL_IS_1595 = Str__literal(U"&nparallel;");
    TL_IS_1596 = Str__literal(U"&nparsl;");
    TL_IS_1597 = Str__literal(U"&npart;");
    TL_IS_1598 = Str__literal(U"&npolint;");
    TL_IS_1599 = Str__literal(U"&npr;");
    TL_IS_1600 = Str__literal(U"&nprcue;");
    TL_IS_1601 = Str__literal(U"&npre;");
    TL_IS_1602 = Str__literal(U"&nprec;");
    TL_IS_1603 = Str__literal(U"&npreceq;");
    TL_IS_1604 = Str__literal(U"&nrArr;");
    TL_IS_1605 = Str__literal(U"&nrarr;");
    TL_IS_1606 = Str__literal(U"&nrarrc;");
    TL_IS_1607 = Str__literal(U"&nrarrw;");
    TL_IS_1608 = Str__literal(U"&nrightarrow;");
    TL_IS_1609 = Str__literal(U"&nrtri;");
    TL_IS_1610 = Str__literal(U"&nrtrie;");
    TL_IS_1611 = Str__literal(U"&nsc;");
    TL_IS_1612 = Str__literal(U"&nsccue;");
    TL_IS_1613 = Str__literal(U"&nsce;");
    TL_IS_1614 = Str__literal(U"&nscr;");
    TL_IS_1615 = Str__literal(U"&nshortmid;");
    TL_IS_1616 = Str__literal(U"&nshortparallel;");
    TL_IS_1617 = Str__literal(U"&nsim;");
    TL_IS_1618 = Str__literal(U"&nsime;");
    TL_IS_1619 = Str__literal(U"&nsimeq;");
    TL_IS_1620 = Str__literal(U"&nsmid;");
    TL_IS_1621 = Str__literal(U"&nspar;");
    TL_IS_1622 = Str__literal(U"&nsqsube;");
    TL_IS_1623 = Str__literal(U"&nsqsupe;");
    TL_IS_1624 = Str__literal(U"&nsub;");
    TL_IS_1625 = Str__literal(U"&nsubE;");
    TL_IS_1626 = Str__literal(U"&nsube;");
    TL_IS_1627 = Str__literal(U"&nsubset;");
    TL_IS_1628 = Str__literal(U"&nsubseteq;");
    TL_IS_1629 = Str__literal(U"&nsubseteqq;");
    TL_IS_1630 = Str__literal(U"&nsucc;");
    TL_IS_1631 = Str__literal(U"&nsucceq;");
    TL_IS_1632 = Str__literal(U"&nsup;");
    TL_IS_1633 = Str__literal(U"&nsupE;");
    TL_IS_1634 = Str__literal(U"&nsupe;");
    TL_IS_1635 = Str__literal(U"&nsupset;");
    TL_IS_1636 = Str__literal(U"&nsupseteq;");
    TL_IS_1637 = Str__literal(U"&nsupseteqq;");
    TL_IS_1638 = Str__literal(U"&ntgl;");
    TL_IS_1639 = Str__literal(U"&ntilde");
    TL_IS_1640 = Str__literal(U"&ntilde;");
    TL_IS_1641 = Str__literal(U"&ntlg;");
    TL_IS_1642 = Str__literal(U"&ntriangleleft;");
    TL_IS_1643 = Str__literal(U"&ntrianglelefteq;");
    TL_IS_1644 = Str__literal(U"&ntriangleright;");
    TL_IS_1645 = Str__literal(U"&ntrianglerighteq;");
    TL_IS_1646 = Str__literal(U"&nu;");
    TL_IS_1647 = Str__literal(U"&num;");
    TL_IS_1648 = Str__literal(U"&numero;");
    TL_IS_1649 = Str__literal(U"&numsp;");
    TL_IS_1650 = Str__literal(U"&nvDash;");
    TL_IS_1651 = Str__literal(U"&nvHarr;");
    TL_IS_1652 = Str__literal(U"&nvap;");
    TL_IS_1653 = Str__literal(U"&nvdash;");
    TL_IS_1654 = Str__literal(U"&nvge;");
    TL_IS_1655 = Str__literal(U"&nvgt;");
    TL_IS_1656 = Str__literal(U"&nvinfin;");
    TL_IS_1657 = Str__literal(U"&nvlArr;");
    TL_IS_1658 = Str__literal(U"&nvle;");
    TL_IS_1659 = Str__literal(U"&nvlt;");
    TL_IS_1660 = Str__literal(U"&nvltrie;");
    TL_IS_1661 = Str__literal(U"&nvrArr;");
    TL_IS_1662 = Str__literal(U"&nvrtrie;");
    TL_IS_1663 = Str__literal(U"&nvsim;");
    TL_IS_1664 = Str__literal(U"&nwArr;");
    TL_IS_1665 = Str__literal(U"&nwarhk;");
    TL_IS_1666 = Str__literal(U"&nwarr;");
    TL_IS_1667 = Str__literal(U"&nwarrow;");
    TL_IS_1668 = Str__literal(U"&nwnear;");
    TL_IS_1669 = Str__literal(U"&oS;");
    TL_IS_1670 = Str__literal(U"&oacute");
    TL_IS_1671 = Str__literal(U"&oacute;");
    TL_IS_1672 = Str__literal(U"&oast;");
    TL_IS_1673 = Str__literal(U"&ocir;");
    TL_IS_1674 = Str__literal(U"&ocirc");
    TL_IS_1675 = Str__literal(U"&ocirc;");
    TL_IS_1676 = Str__literal(U"&ocy;");
    TL_IS_1677 = Str__literal(U"&odash;");
    TL_IS_1678 = Str__literal(U"&odblac;");
    TL_IS_1679 = Str__literal(U"&odiv;");
    TL_IS_1680 = Str__literal(U"&odot;");
    TL_IS_1681 = Str__literal(U"&odsold;");
    TL_IS_1682 = Str__literal(U"&oelig;");
    TL_IS_1683 = Str__literal(U"&ofcir;");
    TL_IS_1684 = Str__literal(U"&ofr;");
    TL_IS_1685 = Str__literal(U"&ogon;");
    TL_IS_1686 = Str__literal(U"&ograve");
    TL_IS_1687 = Str__literal(U"&ograve;");
    TL_IS_1688 = Str__literal(U"&ogt;");
    TL_IS_1689 = Str__literal(U"&ohbar;");
    TL_IS_1690 = Str__literal(U"&ohm;");
    TL_IS_1691 = Str__literal(U"&oint;");
    TL_IS_1692 = Str__literal(U"&olarr;");
    TL_IS_1693 = Str__literal(U"&olcir;");
    TL_IS_1694 = Str__literal(U"&olcross;");
    TL_IS_1695 = Str__literal(U"&oline;");
    TL_IS_1696 = Str__literal(U"&olt;");
    TL_IS_1697 = Str__literal(U"&omacr;");
    TL_IS_1698 = Str__literal(U"&omega;");
    TL_IS_1699 = Str__literal(U"&omicron;");
    TL_IS_1700 = Str__literal(U"&omid;");
    TL_IS_1701 = Str__literal(U"&ominus;");
    TL_IS_1702 = Str__literal(U"&oopf;");
    TL_IS_1703 = Str__literal(U"&opar;");
    TL_IS_1704 = Str__literal(U"&operp;");
    TL_IS_1705 = Str__literal(U"&oplus;");
    TL_IS_1706 = Str__literal(U"&or;");
    TL_IS_1707 = Str__literal(U"&orarr;");
    TL_IS_1708 = Str__literal(U"&ord;");
    TL_IS_1709 = Str__literal(U"&order;");
    TL_IS_1710 = Str__literal(U"&orderof;");
    TL_IS_1711 = Str__literal(U"&ordf");
    TL_IS_1712 = Str__literal(U"&ordf;");
    TL_IS_1713 = Str__literal(U"&ordm");
    TL_IS_1714 = Str__literal(U"&ordm;");
    TL_IS_1715 = Str__literal(U"&origof;");
    TL_IS_1716 = Str__literal(U"&oror;");
    TL_IS_1717 = Str__literal(U"&orslope;");
    TL_IS_1718 = Str__literal(U"&orv;");
    TL_IS_1719 = Str__literal(U"&oscr;");
    TL_IS_1720 = Str__literal(U"&oslash");
    TL_IS_1721 = Str__literal(U"&oslash;");
    TL_IS_1722 = Str__literal(U"&osol;");
    TL_IS_1723 = Str__literal(U"&otilde");
    TL_IS_1724 = Str__literal(U"&otilde;");
    TL_IS_1725 = Str__literal(U"&otimes;");
    TL_IS_1726 = Str__literal(U"&otimesas;");
    TL_IS_1727 = Str__literal(U"&ouml");
    TL_IS_1728 = Str__literal(U"&ouml;");
    TL_IS_1729 = Str__literal(U"&ovbar;");
    TL_IS_1730 = Str__literal(U"&par;");
    TL_IS_1731 = Str__literal(U"&para");
    TL_IS_1732 = Str__literal(U"&para;");
    TL_IS_1733 = Str__literal(U"&parallel;");
    TL_IS_1734 = Str__literal(U"&parsim;");
    TL_IS_1735 = Str__literal(U"&parsl;");
    TL_IS_1736 = Str__literal(U"&part;");
    TL_IS_1737 = Str__literal(U"&pcy;");
    TL_IS_1738 = Str__literal(U"&percnt;");
    TL_IS_1739 = Str__literal(U"&period;");
    TL_IS_1740 = Str__literal(U"&permil;");
    TL_IS_1741 = Str__literal(U"&perp;");
    TL_IS_1742 = Str__literal(U"&pertenk;");
    TL_IS_1743 = Str__literal(U"&pfr;");
    TL_IS_1744 = Str__literal(U"&phi;");
    TL_IS_1745 = Str__literal(U"&phiv;");
    TL_IS_1746 = Str__literal(U"&phmmat;");
    TL_IS_1747 = Str__literal(U"&phone;");
    TL_IS_1748 = Str__literal(U"&pi;");
    TL_IS_1749 = Str__literal(U"&pitchfork;");
    TL_IS_1750 = Str__literal(U"&piv;");
    TL_IS_1751 = Str__literal(U"&planck;");
    TL_IS_1752 = Str__literal(U"&planckh;");
    TL_IS_1753 = Str__literal(U"&plankv;");
    TL_IS_1754 = Str__literal(U"&plus;");
    TL_IS_1755 = Str__literal(U"&plusacir;");
    TL_IS_1756 = Str__literal(U"&plusb;");
    TL_IS_1757 = Str__literal(U"&pluscir;");
    TL_IS_1758 = Str__literal(U"&plusdo;");
    TL_IS_1759 = Str__literal(U"&plusdu;");
    TL_IS_1760 = Str__literal(U"&pluse;");
    TL_IS_1761 = Str__literal(U"&plusmn");
    TL_IS_1762 = Str__literal(U"&plusmn;");
    TL_IS_1763 = Str__literal(U"&plussim;");
    TL_IS_1764 = Str__literal(U"&plustwo;");
    TL_IS_1765 = Str__literal(U"&pm;");
    TL_IS_1766 = Str__literal(U"&pointint;");
    TL_IS_1767 = Str__literal(U"&popf;");
    TL_IS_1768 = Str__literal(U"&pound");
    TL_IS_1769 = Str__literal(U"&pound;");
    TL_IS_1770 = Str__literal(U"&pr;");
    TL_IS_1771 = Str__literal(U"&prE;");
    TL_IS_1772 = Str__literal(U"&prap;");
    TL_IS_1773 = Str__literal(U"&prcue;");
    TL_IS_1774 = Str__literal(U"&pre;");
    TL_IS_1775 = Str__literal(U"&prec;");
    TL_IS_1776 = Str__literal(U"&precapprox;");
    TL_IS_1777 = Str__literal(U"&preccurlyeq;");
    TL_IS_1778 = Str__literal(U"&preceq;");
    TL_IS_1779 = Str__literal(U"&precnapprox;");
    TL_IS_1780 = Str__literal(U"&precneqq;");
    TL_IS_1781 = Str__literal(U"&precnsim;");
    TL_IS_1782 = Str__literal(U"&precsim;");
    TL_IS_1783 = Str__literal(U"&prime;");
    TL_IS_1784 = Str__literal(U"&primes;");
    TL_IS_1785 = Str__literal(U"&prnE;");
    TL_IS_1786 = Str__literal(U"&prnap;");
    TL_IS_1787 = Str__literal(U"&prnsim;");
    TL_IS_1788 = Str__literal(U"&prod;");
    TL_IS_1789 = Str__literal(U"&profalar;");
    TL_IS_1790 = Str__literal(U"&profline;");
    TL_IS_1791 = Str__literal(U"&profsurf;");
    TL_IS_1792 = Str__literal(U"&prop;");
    TL_IS_1793 = Str__literal(U"&propto;");
    TL_IS_1794 = Str__literal(U"&prsim;");
    TL_IS_1795 = Str__literal(U"&prurel;");
    TL_IS_1796 = Str__literal(U"&pscr;");
    TL_IS_1797 = Str__literal(U"&psi;");
    TL_IS_1798 = Str__literal(U"&puncsp;");
    TL_IS_1799 = Str__literal(U"&qfr;");
    TL_IS_1800 = Str__literal(U"&qint;");
    TL_IS_1801 = Str__literal(U"&qopf;");
    TL_IS_1802 = Str__literal(U"&qprime;");
    TL_IS_1803 = Str__literal(U"&qscr;");
    TL_IS_1804 = Str__literal(U"&quaternions;");
    TL_IS_1805 = Str__literal(U"&quatint;");
    TL_IS_1806 = Str__literal(U"&quest;");
    TL_IS_1807 = Str__literal(U"&questeq;");
    TL_IS_1808 = Str__literal(U"&quot");
    TL_IS_1809 = Str__literal(U"&quot;");
    TL_IS_1810 = Str__literal(U"&rAarr;");
    TL_IS_1811 = Str__literal(U"&rArr;");
    TL_IS_1812 = Str__literal(U"&rAtail;");
    TL_IS_1813 = Str__literal(U"&rBarr;");
    TL_IS_1814 = Str__literal(U"&rHar;");
    TL_IS_1815 = Str__literal(U"&race;");
    TL_IS_1816 = Str__literal(U"&racute;");
    TL_IS_1817 = Str__literal(U"&radic;");
    TL_IS_1818 = Str__literal(U"&raemptyv;");
    TL_IS_1819 = Str__literal(U"&rang;");
    TL_IS_1820 = Str__literal(U"&rangd;");
    TL_IS_1821 = Str__literal(U"&range;");
    TL_IS_1822 = Str__literal(U"&rangle;");
    TL_IS_1823 = Str__literal(U"&raquo");
    TL_IS_1824 = Str__literal(U"&raquo;");
    TL_IS_1825 = Str__literal(U"&rarr;");
    TL_IS_1826 = Str__literal(U"&rarrap;");
    TL_IS_1827 = Str__literal(U"&rarrb;");
    TL_IS_1828 = Str__literal(U"&rarrbfs;");
    TL_IS_1829 = Str__literal(U"&rarrc;");
    TL_IS_1830 = Str__literal(U"&rarrfs;");
    TL_IS_1831 = Str__literal(U"&rarrhk;");
    TL_IS_1832 = Str__literal(U"&rarrlp;");
    TL_IS_1833 = Str__literal(U"&rarrpl;");
    TL_IS_1834 = Str__literal(U"&rarrsim;");
    TL_IS_1835 = Str__literal(U"&rarrtl;");
    TL_IS_1836 = Str__literal(U"&rarrw;");
    TL_IS_1837 = Str__literal(U"&ratail;");
    TL_IS_1838 = Str__literal(U"&ratio;");
    TL_IS_1839 = Str__literal(U"&rationals;");
    TL_IS_1840 = Str__literal(U"&rbarr;");
    TL_IS_1841 = Str__literal(U"&rbbrk;");
    TL_IS_1842 = Str__literal(U"&rbrace;");
    TL_IS_1843 = Str__literal(U"&rbrack;");
    TL_IS_1844 = Str__literal(U"&rbrke;");
    TL_IS_1845 = Str__literal(U"&rbrksld;");
    TL_IS_1846 = Str__literal(U"&rbrkslu;");
    TL_IS_1847 = Str__literal(U"&rcaron;");
    TL_IS_1848 = Str__literal(U"&rcedil;");
    TL_IS_1849 = Str__literal(U"&rceil;");
    TL_IS_1850 = Str__literal(U"&rcub;");
    TL_IS_1851 = Str__literal(U"&rcy;");
    TL_IS_1852 = Str__literal(U"&rdca;");
    TL_IS_1853 = Str__literal(U"&rdldhar;");
    TL_IS_1854 = Str__literal(U"&rdquo;");
    TL_IS_1855 = Str__literal(U"&rdquor;");
    TL_IS_1856 = Str__literal(U"&rdsh;");
    TL_IS_1857 = Str__literal(U"&real;");
    TL_IS_1858 = Str__literal(U"&realine;");
    TL_IS_1859 = Str__literal(U"&realpart;");
    TL_IS_1860 = Str__literal(U"&reals;");
    TL_IS_1861 = Str__literal(U"&rect;");
    TL_IS_1862 = Str__literal(U"&reg");
    TL_IS_1863 = Str__literal(U"&reg;");
    TL_IS_1864 = Str__literal(U"&rfisht;");
    TL_IS_1865 = Str__literal(U"&rfloor;");
    TL_IS_1866 = Str__literal(U"&rfr;");
    TL_IS_1867 = Str__literal(U"&rhard;");
    TL_IS_1868 = Str__literal(U"&rharu;");
    TL_IS_1869 = Str__literal(U"&rharul;");
    TL_IS_1870 = Str__literal(U"&rho;");
    TL_IS_1871 = Str__literal(U"&rhov;");
    TL_IS_1872 = Str__literal(U"&rightarrow;");
    TL_IS_1873 = Str__literal(U"&rightarrowtail;");
    TL_IS_1874 = Str__literal(U"&rightharpoondown;");
    TL_IS_1875 = Str__literal(U"&rightharpoonup;");
    TL_IS_1876 = Str__literal(U"&rightleftarrows;");
    TL_IS_1877 = Str__literal(U"&rightleftharpoons;");
    TL_IS_1878 = Str__literal(U"&rightrightarrows;");
    TL_IS_1879 = Str__literal(U"&rightsquigarrow;");
    TL_IS_1880 = Str__literal(U"&rightthreetimes;");
    TL_IS_1881 = Str__literal(U"&ring;");
    TL_IS_1882 = Str__literal(U"&risingdotseq;");
    TL_IS_1883 = Str__literal(U"&rlarr;");
    TL_IS_1884 = Str__literal(U"&rlhar;");
    TL_IS_1885 = Str__literal(U"&rlm;");
    TL_IS_1886 = Str__literal(U"&rmoust;");
    TL_IS_1887 = Str__literal(U"&rmoustache;");
    TL_IS_1888 = Str__literal(U"&rnmid;");
    TL_IS_1889 = Str__literal(U"&roang;");
    TL_IS_1890 = Str__literal(U"&roarr;");
    TL_IS_1891 = Str__literal(U"&robrk;");
    TL_IS_1892 = Str__literal(U"&ropar;");
    TL_IS_1893 = Str__literal(U"&ropf;");
    TL_IS_1894 = Str__literal(U"&roplus;");
    TL_IS_1895 = Str__literal(U"&rotimes;");
    TL_IS_1896 = Str__literal(U"&rpar;");
    TL_IS_1897 = Str__literal(U"&rpargt;");
    TL_IS_1898 = Str__literal(U"&rppolint;");
    TL_IS_1899 = Str__literal(U"&rrarr;");
    TL_IS_1900 = Str__literal(U"&rsaquo;");
    TL_IS_1901 = Str__literal(U"&rscr;");
    TL_IS_1902 = Str__literal(U"&rsh;");
    TL_IS_1903 = Str__literal(U"&rsqb;");
    TL_IS_1904 = Str__literal(U"&rsquo;");
    TL_IS_1905 = Str__literal(U"&rsquor;");
    TL_IS_1906 = Str__literal(U"&rthree;");
    TL_IS_1907 = Str__literal(U"&rtimes;");
    TL_IS_1908 = Str__literal(U"&rtri;");
    TL_IS_1909 = Str__literal(U"&rtrie;");
    TL_IS_1910 = Str__literal(U"&rtrif;");
    TL_IS_1911 = Str__literal(U"&rtriltri;");
    TL_IS_1912 = Str__literal(U"&ruluhar;");
    TL_IS_1913 = Str__literal(U"&rx;");
    TL_IS_1914 = Str__literal(U"&sacute;");
    TL_IS_1915 = Str__literal(U"&sbquo;");
    TL_IS_1916 = Str__literal(U"&sc;");
    TL_IS_1917 = Str__literal(U"&scE;");
    TL_IS_1918 = Str__literal(U"&scap;");
    TL_IS_1919 = Str__literal(U"&scaron;");
    TL_IS_1920 = Str__literal(U"&sccue;");
    TL_IS_1921 = Str__literal(U"&sce;");
    TL_IS_1922 = Str__literal(U"&scedil;");
    TL_IS_1923 = Str__literal(U"&scirc;");
    TL_IS_1924 = Str__literal(U"&scnE;");
    TL_IS_1925 = Str__literal(U"&scnap;");
    TL_IS_1926 = Str__literal(U"&scnsim;");
    TL_IS_1927 = Str__literal(U"&scpolint;");
    TL_IS_1928 = Str__literal(U"&scsim;");
    TL_IS_1929 = Str__literal(U"&scy;");
    TL_IS_1930 = Str__literal(U"&sdot;");
    TL_IS_1931 = Str__literal(U"&sdotb;");
    TL_IS_1932 = Str__literal(U"&sdote;");
    TL_IS_1933 = Str__literal(U"&seArr;");
    TL_IS_1934 = Str__literal(U"&searhk;");
    TL_IS_1935 = Str__literal(U"&searr;");
    TL_IS_1936 = Str__literal(U"&searrow;");
    TL_IS_1937 = Str__literal(U"&sect");
    TL_IS_1938 = Str__literal(U"&sect;");
    TL_IS_1939 = Str__literal(U"&semi;");
    TL_IS_1940 = Str__literal(U"&seswar;");
    TL_IS_1941 = Str__literal(U"&setminus;");
    TL_IS_1942 = Str__literal(U"&setmn;");
    TL_IS_1943 = Str__literal(U"&sext;");
    TL_IS_1944 = Str__literal(U"&sfr;");
    TL_IS_1945 = Str__literal(U"&sfrown;");
    TL_IS_1946 = Str__literal(U"&sharp;");
    TL_IS_1947 = Str__literal(U"&shchcy;");
    TL_IS_1948 = Str__literal(U"&shcy;");
    TL_IS_1949 = Str__literal(U"&shortmid;");
    TL_IS_1950 = Str__literal(U"&shortparallel;");
    TL_IS_1951 = Str__literal(U"&shy");
    TL_IS_1952 = Str__literal(U"&shy;");
    TL_IS_1953 = Str__literal(U"&sigma;");
    TL_IS_1954 = Str__literal(U"&sigmaf;");
    TL_IS_1955 = Str__literal(U"&sigmav;");
    TL_IS_1956 = Str__literal(U"&sim;");
    TL_IS_1957 = Str__literal(U"&simdot;");
    TL_IS_1958 = Str__literal(U"&sime;");
    TL_IS_1959 = Str__literal(U"&simeq;");
    TL_IS_1960 = Str__literal(U"&simg;");
    TL_IS_1961 = Str__literal(U"&simgE;");
    TL_IS_1962 = Str__literal(U"&siml;");
    TL_IS_1963 = Str__literal(U"&simlE;");
    TL_IS_1964 = Str__literal(U"&simne;");
    TL_IS_1965 = Str__literal(U"&simplus;");
    TL_IS_1966 = Str__literal(U"&simrarr;");
    TL_IS_1967 = Str__literal(U"&slarr;");
    TL_IS_1968 = Str__literal(U"&smallsetminus;");
    TL_IS_1969 = Str__literal(U"&smashp;");
    TL_IS_1970 = Str__literal(U"&smeparsl;");
    TL_IS_1971 = Str__literal(U"&smid;");
    TL_IS_1972 = Str__literal(U"&smile;");
    TL_IS_1973 = Str__literal(U"&smt;");
    TL_IS_1974 = Str__literal(U"&smte;");
    TL_IS_1975 = Str__literal(U"&smtes;");
    TL_IS_1976 = Str__literal(U"&softcy;");
    TL_IS_1977 = Str__literal(U"&sol;");
    TL_IS_1978 = Str__literal(U"&solb;");
    TL_IS_1979 = Str__literal(U"&solbar;");
    TL_IS_1980 = Str__literal(U"&sopf;");
    TL_IS_1981 = Str__literal(U"&spades;");
    TL_IS_1982 = Str__literal(U"&spadesuit;");
    TL_IS_1983 = Str__literal(U"&spar;");
    TL_IS_1984 = Str__literal(U"&sqcap;");
    TL_IS_1985 = Str__literal(U"&sqcaps;");
    TL_IS_1986 = Str__literal(U"&sqcup;");
    TL_IS_1987 = Str__literal(U"&sqcups;");
    TL_IS_1988 = Str__literal(U"&sqsub;");
    TL_IS_1989 = Str__literal(U"&sqsube;");
    TL_IS_1990 = Str__literal(U"&sqsubset;");
    TL_IS_1991 = Str__literal(U"&sqsubseteq;");
    TL_IS_1992 = Str__literal(U"&sqsup;");
    TL_IS_1993 = Str__literal(U"&sqsupe;");
    TL_IS_1994 = Str__literal(U"&sqsupset;");
    TL_IS_1995 = Str__literal(U"&sqsupseteq;");
    TL_IS_1996 = Str__literal(U"&squ;");
    TL_IS_1997 = Str__literal(U"&square;");
    TL_IS_1998 = Str__literal(U"&squarf;");
    TL_IS_1999 = Str__literal(U"&squf;");
    TL_IS_2000 = Str__literal(U"&srarr;");
    TL_IS_2001 = Str__literal(U"&sscr;");
    TL_IS_2002 = Str__literal(U"&ssetmn;");
    TL_IS_2003 = Str__literal(U"&ssmile;");
    TL_IS_2004 = Str__literal(U"&sstarf;");
    TL_IS_2005 = Str__literal(U"&star;");
    TL_IS_2006 = Str__literal(U"&starf;");
    TL_IS_2007 = Str__literal(U"&straightepsilon;");
    TL_IS_2008 = Str__literal(U"&straightphi;");
    TL_IS_2009 = Str__literal(U"&strns;");
    TL_IS_2010 = Str__literal(U"&sub;");
    TL_IS_2011 = Str__literal(U"&subE;");
    TL_IS_2012 = Str__literal(U"&subdot;");
    TL_IS_2013 = Str__literal(U"&sube;");
    TL_IS_2014 = Str__literal(U"&subedot;");
    TL_IS_2015 = Str__literal(U"&submult;");
    TL_IS_2016 = Str__literal(U"&subnE;");
    TL_IS_2017 = Str__literal(U"&subne;");
    TL_IS_2018 = Str__literal(U"&subplus;");
    TL_IS_2019 = Str__literal(U"&subrarr;");
    TL_IS_2020 = Str__literal(U"&subset;");
    TL_IS_2021 = Str__literal(U"&subseteq;");
    TL_IS_2022 = Str__literal(U"&subseteqq;");
    TL_IS_2023 = Str__literal(U"&subsetneq;");
    TL_IS_2024 = Str__literal(U"&subsetneqq;");
    TL_IS_2025 = Str__literal(U"&subsim;");
    TL_IS_2026 = Str__literal(U"&subsub;");
    TL_IS_2027 = Str__literal(U"&subsup;");
    TL_IS_2028 = Str__literal(U"&succ;");
    TL_IS_2029 = Str__literal(U"&succapprox;");
    TL_IS_2030 = Str__literal(U"&succcurlyeq;");
    TL_IS_2031 = Str__literal(U"&succeq;");
    TL_IS_2032 = Str__literal(U"&succnapprox;");
    TL_IS_2033 = Str__literal(U"&succneqq;");
    TL_IS_2034 = Str__literal(U"&succnsim;");
    TL_IS_2035 = Str__literal(U"&succsim;");
    TL_IS_2036 = Str__literal(U"&sum;");
    TL_IS_2037 = Str__literal(U"&sung;");
    TL_IS_2038 = Str__literal(U"&sup1");
    TL_IS_2039 = Str__literal(U"&sup1;");
    TL_IS_2040 = Str__literal(U"&sup2");
    TL_IS_2041 = Str__literal(U"&sup2;");
    TL_IS_2042 = Str__literal(U"&sup3");
    TL_IS_2043 = Str__literal(U"&sup3;");
    TL_IS_2044 = Str__literal(U"&sup;");
    TL_IS_2045 = Str__literal(U"&supE;");
    TL_IS_2046 = Str__literal(U"&supdot;");
    TL_IS_2047 = Str__literal(U"&supdsub;");
    TL_IS_2048 = Str__literal(U"&supe;");
    TL_IS_2049 = Str__literal(U"&supedot;");
    TL_IS_2050 = Str__literal(U"&suphsol;");
    TL_IS_2051 = Str__literal(U"&suphsub;");
    TL_IS_2052 = Str__literal(U"&suplarr;");
    TL_IS_2053 = Str__literal(U"&supmult;");
    TL_IS_2054 = Str__literal(U"&supnE;");
    TL_IS_2055 = Str__literal(U"&supne;");
    TL_IS_2056 = Str__literal(U"&supplus;");
    TL_IS_2057 = Str__literal(U"&supset;");
    TL_IS_2058 = Str__literal(U"&supseteq;");
    TL_IS_2059 = Str__literal(U"&supseteqq;");
    TL_IS_2060 = Str__literal(U"&supsetneq;");
    TL_IS_2061 = Str__literal(U"&supsetneqq;");
    TL_IS_2062 = Str__literal(U"&supsim;");
    TL_IS_2063 = Str__literal(U"&supsub;");
    TL_IS_2064 = Str__literal(U"&supsup;");
    TL_IS_2065 = Str__literal(U"&swArr;");
    TL_IS_2066 = Str__literal(U"&swarhk;");
    TL_IS_2067 = Str__literal(U"&swarr;");
    TL_IS_2068 = Str__literal(U"&swarrow;");
    TL_IS_2069 = Str__literal(U"&swnwar;");
    TL_IS_2070 = Str__literal(U"&szlig");
    TL_IS_2071 = Str__literal(U"&szlig;");
    TL_IS_2072 = Str__literal(U"&target;");
    TL_IS_2073 = Str__literal(U"&tau;");
    TL_IS_2074 = Str__literal(U"&tbrk;");
    TL_IS_2075 = Str__literal(U"&tcaron;");
    TL_IS_2076 = Str__literal(U"&tcedil;");
    TL_IS_2077 = Str__literal(U"&tcy;");
    TL_IS_2078 = Str__literal(U"&tdot;");
    TL_IS_2079 = Str__literal(U"&telrec;");
    TL_IS_2080 = Str__literal(U"&tfr;");
    TL_IS_2081 = Str__literal(U"&there4;");
    TL_IS_2082 = Str__literal(U"&therefore;");
    TL_IS_2083 = Str__literal(U"&theta;");
    TL_IS_2084 = Str__literal(U"&thetasym;");
    TL_IS_2085 = Str__literal(U"&thetav;");
    TL_IS_2086 = Str__literal(U"&thickapprox;");
    TL_IS_2087 = Str__literal(U"&thicksim;");
    TL_IS_2088 = Str__literal(U"&thinsp;");
    TL_IS_2089 = Str__literal(U"&thkap;");
    TL_IS_2090 = Str__literal(U"&thksim;");
    TL_IS_2091 = Str__literal(U"&thorn");
    TL_IS_2092 = Str__literal(U"&thorn;");
    TL_IS_2093 = Str__literal(U"&tilde;");
    TL_IS_2094 = Str__literal(U"&times");
    TL_IS_2095 = Str__literal(U"&times;");
    TL_IS_2096 = Str__literal(U"&timesb;");
    TL_IS_2097 = Str__literal(U"&timesbar;");
    TL_IS_2098 = Str__literal(U"&timesd;");
    TL_IS_2099 = Str__literal(U"&tint;");
    TL_IS_2100 = Str__literal(U"&toea;");
    TL_IS_2101 = Str__literal(U"&top;");
    TL_IS_2102 = Str__literal(U"&topbot;");
    TL_IS_2103 = Str__literal(U"&topcir;");
    TL_IS_2104 = Str__literal(U"&topf;");
    TL_IS_2105 = Str__literal(U"&topfork;");
    TL_IS_2106 = Str__literal(U"&tosa;");
    TL_IS_2107 = Str__literal(U"&tprime;");
    TL_IS_2108 = Str__literal(U"&trade;");
    TL_IS_2109 = Str__literal(U"&triangle;");
    TL_IS_2110 = Str__literal(U"&triangledown;");
    TL_IS_2111 = Str__literal(U"&triangleleft;");
    TL_IS_2112 = Str__literal(U"&trianglelefteq;");
    TL_IS_2113 = Str__literal(U"&triangleq;");
    TL_IS_2114 = Str__literal(U"&triangleright;");
    TL_IS_2115 = Str__literal(U"&trianglerighteq;");
    TL_IS_2116 = Str__literal(U"&tridot;");
    TL_IS_2117 = Str__literal(U"&trie;");
    TL_IS_2118 = Str__literal(U"&triminus;");
    TL_IS_2119 = Str__literal(U"&triplus;");
    TL_IS_2120 = Str__literal(U"&trisb;");
    TL_IS_2121 = Str__literal(U"&tritime;");
    TL_IS_2122 = Str__literal(U"&trpezium;");
    TL_IS_2123 = Str__literal(U"&tscr;");
    TL_IS_2124 = Str__literal(U"&tscy;");
    TL_IS_2125 = Str__literal(U"&tshcy;");
    TL_IS_2126 = Str__literal(U"&tstrok;");
    TL_IS_2127 = Str__literal(U"&twixt;");
    TL_IS_2128 = Str__literal(U"&twoheadleftarrow;");
    TL_IS_2129 = Str__literal(U"&twoheadrightarrow;");
    TL_IS_2130 = Str__literal(U"&uArr;");
    TL_IS_2131 = Str__literal(U"&uHar;");
    TL_IS_2132 = Str__literal(U"&uacute");
    TL_IS_2133 = Str__literal(U"&uacute;");
    TL_IS_2134 = Str__literal(U"&uarr;");
    TL_IS_2135 = Str__literal(U"&ubrcy;");
    TL_IS_2136 = Str__literal(U"&ubreve;");
    TL_IS_2137 = Str__literal(U"&ucirc");
    TL_IS_2138 = Str__literal(U"&ucirc;");
    TL_IS_2139 = Str__literal(U"&ucy;");
    TL_IS_2140 = Str__literal(U"&udarr;");
    TL_IS_2141 = Str__literal(U"&udblac;");
    TL_IS_2142 = Str__literal(U"&udhar;");
    TL_IS_2143 = Str__literal(U"&ufisht;");
    TL_IS_2144 = Str__literal(U"&ufr;");
    TL_IS_2145 = Str__literal(U"&ugrave");
    TL_IS_2146 = Str__literal(U"&ugrave;");
    TL_IS_2147 = Str__literal(U"&uharl;");
    TL_IS_2148 = Str__literal(U"&uharr;");
    TL_IS_2149 = Str__literal(U"&uhblk;");
    TL_IS_2150 = Str__literal(U"&ulcorn;");
    TL_IS_2151 = Str__literal(U"&ulcorner;");
    TL_IS_2152 = Str__literal(U"&ulcrop;");
    TL_IS_2153 = Str__literal(U"&ultri;");
    TL_IS_2154 = Str__literal(U"&umacr;");
    TL_IS_2155 = Str__literal(U"&uml");
    TL_IS_2156 = Str__literal(U"&uml;");
    TL_IS_2157 = Str__literal(U"&uogon;");
    TL_IS_2158 = Str__literal(U"&uopf;");
    TL_IS_2159 = Str__literal(U"&uparrow;");
    TL_IS_2160 = Str__literal(U"&updownarrow;");
    TL_IS_2161 = Str__literal(U"&upharpoonleft;");
    TL_IS_2162 = Str__literal(U"&upharpoonright;");
    TL_IS_2163 = Str__literal(U"&uplus;");
    TL_IS_2164 = Str__literal(U"&upsi;");
    TL_IS_2165 = Str__literal(U"&upsih;");
    TL_IS_2166 = Str__literal(U"&upsilon;");
    TL_IS_2167 = Str__literal(U"&upuparrows;");
    TL_IS_2168 = Str__literal(U"&urcorn;");
    TL_IS_2169 = Str__literal(U"&urcorner;");
    TL_IS_2170 = Str__literal(U"&urcrop;");
    TL_IS_2171 = Str__literal(U"&uring;");
    TL_IS_2172 = Str__literal(U"&urtri;");
    TL_IS_2173 = Str__literal(U"&uscr;");
    TL_IS_2174 = Str__literal(U"&utdot;");
    TL_IS_2175 = Str__literal(U"&utilde;");
    TL_IS_2176 = Str__literal(U"&utri;");
    TL_IS_2177 = Str__literal(U"&utrif;");
    TL_IS_2178 = Str__literal(U"&uuarr;");
    TL_IS_2179 = Str__literal(U"&uuml");
    TL_IS_2180 = Str__literal(U"&uuml;");
    TL_IS_2181 = Str__literal(U"&uwangle;");
    TL_IS_2182 = Str__literal(U"&vArr;");
    TL_IS_2183 = Str__literal(U"&vBar;");
    TL_IS_2184 = Str__literal(U"&vBarv;");
    TL_IS_2185 = Str__literal(U"&vDash;");
    TL_IS_2186 = Str__literal(U"&vangrt;");
    TL_IS_2187 = Str__literal(U"&varepsilon;");
    TL_IS_2188 = Str__literal(U"&varkappa;");
    TL_IS_2189 = Str__literal(U"&varnothing;");
    TL_IS_2190 = Str__literal(U"&varphi;");
    TL_IS_2191 = Str__literal(U"&varpi;");
    TL_IS_2192 = Str__literal(U"&varpropto;");
    TL_IS_2193 = Str__literal(U"&varr;");
    TL_IS_2194 = Str__literal(U"&varrho;");
    TL_IS_2195 = Str__literal(U"&varsigma;");
    TL_IS_2196 = Str__literal(U"&varsubsetneq;");
    TL_IS_2197 = Str__literal(U"&varsubsetneqq;");
    TL_IS_2198 = Str__literal(U"&varsupsetneq;");
    TL_IS_2199 = Str__literal(U"&varsupsetneqq;");
    TL_IS_2200 = Str__literal(U"&vartheta;");
    TL_IS_2201 = Str__literal(U"&vartriangleleft;");
    TL_IS_2202 = Str__literal(U"&vartriangleright;");
    TL_IS_2203 = Str__literal(U"&vcy;");
    TL_IS_2204 = Str__literal(U"&vdash;");
    TL_IS_2205 = Str__literal(U"&vee;");
    TL_IS_2206 = Str__literal(U"&veebar;");
    TL_IS_2207 = Str__literal(U"&veeeq;");
    TL_IS_2208 = Str__literal(U"&vellip;");
    TL_IS_2209 = Str__literal(U"&verbar;");
    TL_IS_2210 = Str__literal(U"&vert;");
    TL_IS_2211 = Str__literal(U"&vfr;");
    TL_IS_2212 = Str__literal(U"&vltri;");
    TL_IS_2213 = Str__literal(U"&vnsub;");
    TL_IS_2214 = Str__literal(U"&vnsup;");
    TL_IS_2215 = Str__literal(U"&vopf;");
    TL_IS_2216 = Str__literal(U"&vprop;");
    TL_IS_2217 = Str__literal(U"&vrtri;");
    TL_IS_2218 = Str__literal(U"&vscr;");
    TL_IS_2219 = Str__literal(U"&vsubnE;");
    TL_IS_2220 = Str__literal(U"&vsubne;");
    TL_IS_2221 = Str__literal(U"&vsupnE;");
    TL_IS_2222 = Str__literal(U"&vsupne;");
    TL_IS_2223 = Str__literal(U"&vzigzag;");
    TL_IS_2224 = Str__literal(U"&wcirc;");
    TL_IS_2225 = Str__literal(U"&wedbar;");
    TL_IS_2226 = Str__literal(U"&wedge;");
    TL_IS_2227 = Str__literal(U"&wedgeq;");
    TL_IS_2228 = Str__literal(U"&weierp;");
    TL_IS_2229 = Str__literal(U"&wfr;");
    TL_IS_2230 = Str__literal(U"&wopf;");
    TL_IS_2231 = Str__literal(U"&wp;");
    TL_IS_2232 = Str__literal(U"&wr;");
    TL_IS_2233 = Str__literal(U"&wreath;");
    TL_IS_2234 = Str__literal(U"&wscr;");
    TL_IS_2235 = Str__literal(U"&xcap;");
    TL_IS_2236 = Str__literal(U"&xcirc;");
    TL_IS_2237 = Str__literal(U"&xcup;");
    TL_IS_2238 = Str__literal(U"&xdtri;");
    TL_IS_2239 = Str__literal(U"&xfr;");
    TL_IS_2240 = Str__literal(U"&xhArr;");
    TL_IS_2241 = Str__literal(U"&xharr;");
    TL_IS_2242 = Str__literal(U"&xi;");
    TL_IS_2243 = Str__literal(U"&xlArr;");
    TL_IS_2244 = Str__literal(U"&xlarr;");
    TL_IS_2245 = Str__literal(U"&xmap;");
    TL_IS_2246 = Str__literal(U"&xnis;");
    TL_IS_2247 = Str__literal(U"&xodot;");
    TL_IS_2248 = Str__literal(U"&xopf;");
    TL_IS_2249 = Str__literal(U"&xoplus;");
    TL_IS_2250 = Str__literal(U"&xotime;");
    TL_IS_2251 = Str__literal(U"&xrArr;");
    TL_IS_2252 = Str__literal(U"&xrarr;");
    TL_IS_2253 = Str__literal(U"&xscr;");
    TL_IS_2254 = Str__literal(U"&xsqcup;");
    TL_IS_2255 = Str__literal(U"&xuplus;");
    TL_IS_2256 = Str__literal(U"&xutri;");
    TL_IS_2257 = Str__literal(U"&xvee;");
    TL_IS_2258 = Str__literal(U"&xwedge;");
    TL_IS_2259 = Str__literal(U"&yacute");
    TL_IS_2260 = Str__literal(U"&yacute;");
    TL_IS_2261 = Str__literal(U"&yacy;");
    TL_IS_2262 = Str__literal(U"&ycirc;");
    TL_IS_2263 = Str__literal(U"&ycy;");
    TL_IS_2264 = Str__literal(U"&yen");
    TL_IS_2265 = Str__literal(U"&yen;");
    TL_IS_2266 = Str__literal(U"&yfr;");
    TL_IS_2267 = Str__literal(U"&yicy;");
    TL_IS_2268 = Str__literal(U"&yopf;");
    TL_IS_2269 = Str__literal(U"&yscr;");
    TL_IS_2270 = Str__literal(U"&yucy;");
    TL_IS_2271 = Str__literal(U"&yuml");
    TL_IS_2272 = Str__literal(U"&yuml;");
    TL_IS_2273 = Str__literal(U"&zacute;");
    TL_IS_2274 = Str__literal(U"&zcaron;");
    TL_IS_2275 = Str__literal(U"&zcy;");
    TL_IS_2276 = Str__literal(U"&zdot;");
    TL_IS_2277 = Str__literal(U"&zeetrf;");
    TL_IS_2278 = Str__literal(U"&zeta;");
    TL_IS_2279 = Str__literal(U"&zfr;");
    TL_IS_2280 = Str__literal(U"&zhcy;");
    TL_IS_2281 = Str__literal(U"&zigrarr;");
    TL_IS_2282 = Str__literal(U"&zopf;");
    TL_IS_2283 = Str__literal(U"&zscr;");
    TL_IS_2284 = Str__literal(U"&zwj;");
    TL_IS_2285 = Str__literal(U"&zwnj;");
    TL_IS_2286 = Str__literal(U"?UNDEFINED");
    TL_IS_2287 = Str__literal(U"DOCUMENT");
    TL_IS_2288 = Str__literal(U"FILE");
    TL_IS_2289 = Str__literal(U"BLOCK_QUOTE");
    TL_IS_2290 = Str__literal(U"UNORDERED_LIST");
    TL_IS_2291 = Str__literal(U"ORDERED_LIST");
    TL_IS_2292 = Str__literal(U"UNORDERED_LIST_ITEM");
    TL_IS_2293 = Str__literal(U"ORDERED_LIST_ITEM");
    TL_IS_2294 = Str__literal(U"PARAGRAPH");
    TL_IS_2295 = Str__literal(U"THEMATIC");
    TL_IS_2296 = Str__literal(U"HEADING");
    TL_IS_2297 = Str__literal(U"CODE_BLOCK");
    TL_IS_2298 = Str__literal(U"HTML");
    TL_IS_2299 = Str__literal(U"EMPTY");
    TL_IS_2300 = Str__literal(U"MATERIAL");
    TL_IS_2301 = Str__literal(U"PLAIN");
    TL_IS_2302 = Str__literal(U"LINE_BREAK");
    TL_IS_2303 = Str__literal(U"SOFT_BREAK");
    TL_IS_2304 = Str__literal(U"INLINE_HTML");
    TL_IS_2305 = Str__literal(U"EMPHASIS");
    TL_IS_2306 = Str__literal(U"STRONG");
    TL_IS_2307 = Str__literal(U"CODE");
    TL_IS_2308 = Str__literal(U"URI_AUTOLINK");
    TL_IS_2309 = Str__literal(U"EMAIL_AUTOLINK");
    TL_IS_2310 = Str__literal(U"LINK");
    TL_IS_2311 = Str__literal(U"IMAGE");
    TL_IS_2312 = Str__literal(U"LINK_DEST");
    TL_IS_2313 = Str__literal(U"LINK_TITLE");
    TL_IS_2314 = Str__literal(U"TABLE");
    TL_IS_2315 = Str__literal(U"TABLE_COLUMN");
    TL_IS_2316 = Str__literal(U"TABLE_ROW");
    TL_IS_2317 = Str__literal(U"STRIKETHROUGH");
    TL_IS_2318 = Str__literal(U"TICKBOX");
    TL_IS_2319 = Str__literal(U"XMPP_AUTOLINK");
    TL_IS_2320 = Str__literal(U"<UNKNOWN>");
    TL_IS_2321 = Str__literal(U"title");
    TL_IS_2322 = Str__literal(U"textarea");
    TL_IS_2323 = Str__literal(U"style");
    TL_IS_2324 = Str__literal(U"xmp");
    TL_IS_2325 = Str__literal(U"iframe");
    TL_IS_2326 = Str__literal(U"noembed");
    TL_IS_2327 = Str__literal(U"noframes");
    TL_IS_2328 = Str__literal(U"script");
    TL_IS_2329 = Str__literal(U"plaintext");
    TL_IS_2330 = Str__literal(U"CHAIN");
    TL_IS_2331 = Str__literal(U"</pre>");
    TL_IS_2332 = Str__literal(U"</script>");
    TL_IS_2333 = Str__literal(U"</style>");
    TL_IS_2334 = Str__literal(U"</textarea>");
    TL_IS_2335 = Str__literal(U"-->");
    TL_IS_2336 = Str__literal(U"?>");
    TL_IS_2337 = Str__literal(U"!>");
    TL_IS_2338 = Str__literal(U"]]>");
    TL_IS_2339 = Str__literal(U"pre");
    TL_IS_2340 = Str__literal(U"script");
    TL_IS_2341 = Str__literal(U"style");
    TL_IS_2342 = Str__literal(U"textarea");
    TL_IS_2343 = Str__literal(U"!--");
    TL_IS_2344 = Str__literal(U"?");
    TL_IS_2345 = Str__literal(U"![CDATA[");
    TL_IS_2346 = Str__literal(U"!");
    TL_IS_2347 = Str__literal(U"address");
    TL_IS_2348 = Str__literal(U"article");
    TL_IS_2349 = Str__literal(U"aside");
    TL_IS_2350 = Str__literal(U"base");
    TL_IS_2351 = Str__literal(U"basefont");
    TL_IS_2352 = Str__literal(U"blockquote");
    TL_IS_2353 = Str__literal(U"body");
    TL_IS_2354 = Str__literal(U"caption");
    TL_IS_2355 = Str__literal(U"center");
    TL_IS_2356 = Str__literal(U"col");
    TL_IS_2357 = Str__literal(U"colgroup");
    TL_IS_2358 = Str__literal(U"dd");
    TL_IS_2359 = Str__literal(U"details");
    TL_IS_2360 = Str__literal(U"dialog");
    TL_IS_2361 = Str__literal(U"dir");
    TL_IS_2362 = Str__literal(U"div");
    TL_IS_2363 = Str__literal(U"dl");
    TL_IS_2364 = Str__literal(U"dt");
    TL_IS_2365 = Str__literal(U"fieldset");
    TL_IS_2366 = Str__literal(U"figcaption");
    TL_IS_2367 = Str__literal(U"figure");
    TL_IS_2368 = Str__literal(U"footer");
    TL_IS_2369 = Str__literal(U"form");
    TL_IS_2370 = Str__literal(U"frame");
    TL_IS_2371 = Str__literal(U"frameset");
    TL_IS_2372 = Str__literal(U"h1");
    TL_IS_2373 = Str__literal(U"h2");
    TL_IS_2374 = Str__literal(U"h3");
    TL_IS_2375 = Str__literal(U"h4");
    TL_IS_2376 = Str__literal(U"h5");
    TL_IS_2377 = Str__literal(U"h6");
    TL_IS_2378 = Str__literal(U"head");
    TL_IS_2379 = Str__literal(U"header");
    TL_IS_2380 = Str__literal(U"hr");
    TL_IS_2381 = Str__literal(U"html");
    TL_IS_2382 = Str__literal(U"iframe");
    TL_IS_2383 = Str__literal(U"legend");
    TL_IS_2384 = Str__literal(U"li");
    TL_IS_2385 = Str__literal(U"link");
    TL_IS_2386 = Str__literal(U"main");
    TL_IS_2387 = Str__literal(U"menu");
    TL_IS_2388 = Str__literal(U"menuitem");
    TL_IS_2389 = Str__literal(U"nav");
    TL_IS_2390 = Str__literal(U"noframes");
    TL_IS_2391 = Str__literal(U"ol");
    TL_IS_2392 = Str__literal(U"optgroup");
    TL_IS_2393 = Str__literal(U"option");
    TL_IS_2394 = Str__literal(U"p");
    TL_IS_2395 = Str__literal(U"param");
    TL_IS_2396 = Str__literal(U"section");
    TL_IS_2397 = Str__literal(U"source");
    TL_IS_2398 = Str__literal(U"summary");
    TL_IS_2399 = Str__literal(U"table");
    TL_IS_2400 = Str__literal(U"tbody");
    TL_IS_2401 = Str__literal(U"td");
    TL_IS_2402 = Str__literal(U"tfoot");
    TL_IS_2403 = Str__literal(U"th");
    TL_IS_2404 = Str__literal(U"thead");
    TL_IS_2405 = Str__literal(U"title");
    TL_IS_2406 = Str__literal(U"tr");
    TL_IS_2407 = Str__literal(U"track");
    TL_IS_2408 = Str__literal(U"ul");
    TL_IS_2409 = Str__literal(U"pre");
    TL_IS_2410 = Str__literal(U"script");
    TL_IS_2411 = Str__literal(U"style");
    TL_IS_2412 = Str__literal(U"textarea");
    TL_IS_2413 = Str__literal(U"\n\n");
    TL_IS_2414 = Str__literal(U"\n");
    TL_IS_2415 = Str__literal(U"Before surgery");
    TL_IS_2416 = Str__literal(U"Before emphasis");
    TL_IS_2417 = Str__literal(U"Emphasis");
    TL_IS_2418 = Str__literal(U"After emphasis");
    TL_IS_2419 = Str__literal(U"mailto:");
    TL_IS_2420 = Str__literal(U"xmpp:");
    TL_IS_2421 = Str__literal(U"http://");
    TL_IS_2422 = Str__literal(U"block quotes");
    TL_IS_2423 = Str__literal(U"ordered lists");
    TL_IS_2424 = Str__literal(U"unordered lists");
    TL_IS_2425 = Str__literal(U"indented code blocks");
    TL_IS_2426 = Str__literal(U"fenced code blocks");
    TL_IS_2427 = Str__literal(U"HTML blocks");
    TL_IS_2428 = Str__literal(U"thematic markers");
    TL_IS_2429 = Str__literal(U"ATX headings");
    TL_IS_2430 = Str__literal(U"setext headings");
    TL_IS_2431 = Str__literal(U"web autolinks");
    TL_IS_2432 = Str__literal(U"email autolinks");
    TL_IS_2433 = Str__literal(U"inline HTML");
    TL_IS_2434 = Str__literal(U"backticked code");
    TL_IS_2435 = Str__literal(U"links");
    TL_IS_2436 = Str__literal(U"images");
    TL_IS_2437 = Str__literal(U"emphasis");
    TL_IS_2438 = Str__literal(U"emphasis");
    TL_IS_2439 = Str__literal(U"entities");
    TL_IS_2440 = Str__literal(U"CommonMark 0.30");
    TL_IS_2441 = Str__literal(U"strikethrough");
    TL_IS_2442 = Str__literal(U"tables");
    TL_IS_2443 = Str__literal(U"task list items");
    TL_IS_2444 = Str__literal(U"extended autolinks");
    TL_IS_2445 = Str__literal(U"disallowed raw HTML");
    TL_IS_2446 = Str__literal(U"GitHub-flavored Markdown 0.29");
    TL_IS_2447 = Str__literal(U"index.html");
    TL_IS_2448 = Str__literal(U"Inform-flavoured Markdown");
    TL_IS_2449 = Str__literal(U"formatting errors");
    TL_IS_2450 = Str__literal(U"INFORM_ERROR_MARKER");
    TL_IS_2451 = Str__literal(U"documentationerror");
    TL_IS_2452 = Str__literal(U"old Indoc headings");
    TL_IS_2453 = Str__literal(U"descriptive headings");
    TL_IS_2454 = Str__literal(U"embedded examples");
    TL_IS_2455 = Str__literal(U"INFORM_EXAMPLE_HEADING");
    TL_IS_2456 = Str__literal(U"this example should be marked (before the title) '*', '**', '***' or '****' for difficulty");
    TL_IS_2457 = Str__literal(U"four stars '****' is the maximum difficulty rating allowed");
    TL_IS_2458 = Str__literal(U"extensionexampleletter");
    TL_IS_2459 = Str__literal(U"indexdarkgrey");
    TL_IS_2460 = Str__literal(U"indexblack");
    TL_IS_2461 = Str__literal(U"paste buttons");
    TL_IS_2462 = Str__literal(U"{*}");
    TL_IS_2463 = Str__literal(U"{**}");
    TL_IS_2464 = Str__literal(U"phrase defn boxes");
    TL_IS_2465 = Str__literal(U"indexing marks");
    TL_IS_2466 = Str__literal(U"INDEX_MARKER");
    TL_IS_2467 = Str__literal(U"heading markers");
    TL_IS_2468 = Str__literal(U"HEADING_MARKER");
    TL_IS_2469 = Str__literal(U"paragraph gating");
    TL_IS_2470 = Str__literal(U"GATE");
    TL_IS_2471 = Str__literal(U"indoc file divisions");
    TL_IS_2472 = Str__literal(U"Inform syntax-colouring");
    TL_IS_2473 = Str__literal(U"inform");
    TL_IS_2474 = Str__literal(U"inform7");
    TL_IS_2475 = Str__literal(U"problems");
    TL_IS_2476 = Str__literal(U"Inform");
    TL_IS_2477 = Str__literal(U"Inform");
    TL_IS_2478 = Str__literal(U"indexdullblue");
    TL_IS_2479 = Str__literal(U"indexdullblue");
    TL_IS_2480 = Str__literal(U"indexdullblue");
    TL_IS_2481 = Str__literal(U"syntaxdefinition");
    TL_IS_2482 = Str__literal(U"syntaxfunction");
    TL_IS_2483 = Str__literal(U"syntaxreserved");
    TL_IS_2484 = Str__literal(U"syntaxelement");
    TL_IS_2485 = Str__literal(U"syntaxidentifier");
    TL_IS_2486 = Str__literal(U"syntaxcharacter");
    TL_IS_2487 = Str__literal(U"syntaxconstant");
    TL_IS_2488 = Str__literal(U"syntaxstring");
    TL_IS_2489 = Str__literal(U"syntaxplain");
    TL_IS_2490 = Str__literal(U"syntaxextract");
    TL_IS_2491 = Str__literal(U"syntaxcomment");
    TL_IS_2492 = Str__literal(U"ePub");
    TL_IS_2493 = Str__literal(U"OEBPS");
    TL_IS_2494 = Str__literal(U"mimetype");
    TL_IS_2495 = Str__literal(U"META-INF");
    TL_IS_2496 = Str__literal(U"container.xml");
    TL_IS_2497 = Str__literal(U"cover.html");
    TL_IS_2498 = Str__literal(U"Cover");
    TL_IS_2499 = Str__literal(U"cover");
    TL_IS_2500 = Str__literal(U"content.opf");
    TL_IS_2501 = Str__literal(U"toc.ncx");
    TL_IS_2502 = Str__literal(U"..");
    TL_IS_2503 = Str__literal(U"A");
    TL_IS_2504 = Str__literal(U"Sequential Section Ranges");
    TL_IS_2505 = Str__literal(U"On");
    TL_IS_2506 = Str__literal(U"Web Syntax Version: 1");
    TL_IS_2507 = Str__literal(U"Web Syntax Version: 2");
    TL_IS_2508 = Str__literal(U"S");
    TL_IS_2509 = Str__literal(U"Sections");
    TL_IS_2510 = Str__literal(U"All");
    TL_IS_2511 = Str__literal(U"Headers");
    TL_IS_2512 = Str__literal(U"single-file webs cannot Import modules");
    TL_IS_2513 = Str__literal(U"Language");
    TL_IS_2514 = Str__literal(U"Language");
    TL_IS_2515 = Str__literal(U"Contents.w");
    TL_IS_2516 = Str__literal(U"Title");
    TL_IS_2517 = Str__literal(U"Author");
    TL_IS_2518 = Str__literal(U"Language");
    TL_IS_2519 = Str__literal(U"None");
    TL_IS_2520 = Str__literal(U"Purpose");
    TL_IS_2521 = Str__literal(U"");
    TL_IS_2522 = Str__literal(U"License");
    TL_IS_2523 = Str__literal(U"Licence");
    TL_IS_2524 = Str__literal(U"Short Title");
    TL_IS_2525 = Str__literal(U"Capitalized Title");
    TL_IS_2526 = Str__literal(U"Build Date");
    TL_IS_2527 = Str__literal(U"Build Number");
    TL_IS_2528 = Str__literal(U"Prerelease");
    TL_IS_2529 = Str__literal(U"Semantic Version Number");
    TL_IS_2530 = Str__literal(U"Version Number");
    TL_IS_2531 = Str__literal(U"1");
    TL_IS_2532 = Str__literal(U"Version Name");
    TL_IS_2533 = Str__literal(U"Index Template");
    TL_IS_2534 = Str__literal(U"Preform Language");
    TL_IS_2535 = Str__literal(U"Declare Section Usage");
    TL_IS_2536 = Str__literal(U"Off");
    TL_IS_2537 = Str__literal(U"Namespaces");
    TL_IS_2538 = Str__literal(U"Off");
    TL_IS_2539 = Str__literal(U"Sequential Section Ranges");
    TL_IS_2540 = Str__literal(U"Off");
    TL_IS_2541 = Str__literal(U"Strict Usage Rules");
    TL_IS_2542 = Str__literal(U"Off");
    TL_IS_2543 = Str__literal(U"TeX Mathematics Notation");
    TL_IS_2544 = Str__literal(U"$");
    TL_IS_2545 = Str__literal(U"TeX Mathematics Displayed Notation");
    TL_IS_2546 = Str__literal(U"$$");
    TL_IS_2547 = Str__literal(U"Footnote Begins Notation");
    TL_IS_2548 = Str__literal(U"[");
    TL_IS_2549 = Str__literal(U"Footnote Ends Notation");
    TL_IS_2550 = Str__literal(U"]");
    TL_IS_2551 = Str__literal(U"Code In Commentary Notation");
    TL_IS_2552 = Str__literal(U"|");
    TL_IS_2553 = Str__literal(U"Code In Code Comments Notation");
    TL_IS_2554 = Str__literal(U"|");
    TL_IS_2555 = Str__literal(U"Cross-References Notation");
    TL_IS_2556 = Str__literal(U"//");
    TL_IS_2557 = Str__literal(U"Web Syntax Version");
    TL_IS_2558 = Str__literal(U"Paragraph Numbers Visibility");
    TL_IS_2559 = Str__literal(U"On");
    TL_IS_2560 = Str__literal(U"Capitalized Title");
    TL_IS_2561 = Str__literal(U"miscellaneous");
    TL_IS_2562 = Str__literal(U"(main)");
    TL_IS_2563 = Str__literal(U"build.txt");
    TL_IS_2564 = Str__literal(U"build.txt");
    TL_IS_2565 = Str__literal(U"Prerelease");
    TL_IS_2566 = Str__literal(U"Build Number");
    TL_IS_2567 = Str__literal(U"Build Date");
    TL_IS_2568 = Str__literal(U"Semantic Version Number");
    TL_IS_2569 = Str__literal(U"Version Number");
    TL_IS_2570 = Str__literal(U"Prerelease");
    TL_IS_2571 = Str__literal(U"Build Number");
    TL_IS_2572 = Str__literal(U"Semantic Version Number");
    TL_IS_2573 = Str__literal(U"Sections");
    TL_IS_2574 = Str__literal(U"InC");
    TL_IS_2575 = Str__literal(U"Name");
    TL_IS_2576 = Str__literal(U"Details");
    TL_IS_2577 = Str__literal(U"Extension");
    TL_IS_2578 = Str__literal(U"Line Comment");
    TL_IS_2579 = Str__literal(U"Whole Line Comment");
    TL_IS_2580 = Str__literal(U"Multiline Comment Open");
    TL_IS_2581 = Str__literal(U"Multiline Comment Close");
    TL_IS_2582 = Str__literal(U"String Literal");
    TL_IS_2583 = Str__literal(U"String Literal Escape");
    TL_IS_2584 = Str__literal(U"Character Literal");
    TL_IS_2585 = Str__literal(U"Character Literal Escape");
    TL_IS_2586 = Str__literal(U"Binary Literal Prefix");
    TL_IS_2587 = Str__literal(U"Octal Literal Prefix");
    TL_IS_2588 = Str__literal(U"Hexadecimal Literal Prefix");
    TL_IS_2589 = Str__literal(U"Negative Literal Prefix");
    TL_IS_2590 = Str__literal(U"Shebang");
    TL_IS_2591 = Str__literal(U"Line Marker");
    TL_IS_2592 = Str__literal(U"Before Named Paragraph Expansion");
    TL_IS_2593 = Str__literal(U"After Named Paragraph Expansion");
    TL_IS_2594 = Str__literal(U"Start Definition");
    TL_IS_2595 = Str__literal(U"Prolong Definition");
    TL_IS_2596 = Str__literal(U"End Definition");
    TL_IS_2597 = Str__literal(U"Start Ifdef");
    TL_IS_2598 = Str__literal(U"Start Ifndef");
    TL_IS_2599 = Str__literal(U"End Ifdef");
    TL_IS_2600 = Str__literal(U"End Ifndef");
    TL_IS_2601 = Str__literal(U"C-Like");
    TL_IS_2602 = Str__literal(U"Suppress Disclaimer");
    TL_IS_2603 = Str__literal(U"Supports Namespaces");
    TL_IS_2604 = Str__literal(U"Function Declaration Notation");
    TL_IS_2605 = Str__literal(U"Type Declaration Notation");
    TL_IS_2606 = Str__literal(U"}");
    TL_IS_2607 = Str__literal(U"unquoted");
    TL_IS_2608 = Str__literal(U"{");
    TL_IS_2609 = Str__literal(U"debug");
    TL_IS_2610 = Str__literal(U"!string");
    TL_IS_2611 = Str__literal(U"!function");
    TL_IS_2612 = Str__literal(U"!definition");
    TL_IS_2613 = Str__literal(U"!reserved");
    TL_IS_2614 = Str__literal(U"!element");
    TL_IS_2615 = Str__literal(U"!identifier");
    TL_IS_2616 = Str__literal(U"!character");
    TL_IS_2617 = Str__literal(U"!constant");
    TL_IS_2618 = Str__literal(U"!plain");
    TL_IS_2619 = Str__literal(U"!extract");
    TL_IS_2620 = Str__literal(U"!comment");
    TL_IS_2621 = Str__literal(U"true");
    TL_IS_2622 = Str__literal(U"false");
    TL_IS_2623 = Str__literal(U"both");
    TL_IS_2624 = Str__literal(U"brackets");
    TL_IS_2625 = Str__literal(U"characters");
    TL_IS_2626 = Str__literal(U"coloured");
    TL_IS_2627 = Str__literal(U"colouring");
    TL_IS_2628 = Str__literal(U"debug");
    TL_IS_2629 = Str__literal(U"false");
    TL_IS_2630 = Str__literal(U"in");
    TL_IS_2631 = Str__literal(U"instances");
    TL_IS_2632 = Str__literal(U"keyword");
    TL_IS_2633 = Str__literal(U"matches");
    TL_IS_2634 = Str__literal(U"matching");
    TL_IS_2635 = Str__literal(U"not");
    TL_IS_2636 = Str__literal(U"of");
    TL_IS_2637 = Str__literal(U"on");
    TL_IS_2638 = Str__literal(U"optionally");
    TL_IS_2639 = Str__literal(U"prefix");
    TL_IS_2640 = Str__literal(U"runs");
    TL_IS_2641 = Str__literal(U"spaced");
    TL_IS_2642 = Str__literal(U"suffix");
    TL_IS_2643 = Str__literal(U"true");
    TL_IS_2644 = Str__literal(U"unquoted");
    TL_IS_2645 = Str__literal(U"inweb");
    TL_IS_2646 = Str__literal(U"Patterns");
    TL_IS_2647 = Str__literal(U"Materials");
    TL_IS_2648 = Str__literal(U"Languages");
    TL_IS_2649 = Str__literal(U"script.mkscript");
    TL_IS_2650 = Str__literal(U"script.giscript");
    TL_IS_2651 = Str__literal(U"script.rmscript");
    TL_IS_2652 = Str__literal(U"Short Title");
    TL_IS_2653 = Str__literal(U"Short Title");
    TL_IS_2654 = Str__literal(U"Title");
    TL_IS_2655 = Str__literal(U"0");
    TL_IS_2656 = Str__literal(U"for locating programming language definitions");
    TL_IS_2657 = Str__literal(U"for analysing a web");
    TL_IS_2658 = Str__literal(U"for weaving a web");
    TL_IS_2659 = Str__literal(U"for tangling a web");
    TL_IS_2660 = Str__literal(U"for dealing with colonies of webs together");
    TL_IS_2661 = Str__literal(U".inweb");
    TL_IS_2662 = Str__literal(U"0");
    TL_IS_2663 = Str__literal(U"Title");
    TL_IS_2664 = Str__literal(U"Booklet Title");
    TL_IS_2665 = Str__literal(U"Colours");
    TL_IS_2666 = Str__literal(U"Colours");
    TL_IS_2667 = Str__literal(U"");
    TL_IS_2668 = Str__literal(U"Version Number");
    TL_IS_2669 = Str__literal(U"Version Number");
    TL_IS_2670 = Str__literal(U" ");
    TL_IS_2671 = Str__literal(U"template-index.html");
    TL_IS_2672 = Str__literal(U"index.html");
    TL_IS_2673 = Str__literal(U"Index");
    TL_IS_2674 = Str__literal(U"index");
    TL_IS_2675 = Str__literal(U"0");
    TL_IS_2676 = Str__literal(U"pattern.txt");
    TL_IS_2677 = Str__literal(U"Patterns");
    TL_IS_2678 = Str__literal(U"pattern.txt");
    TL_IS_2679 = Str__literal(U"pattern.txt");
    TL_IS_2680 = Str__literal(U"name");
    TL_IS_2681 = Str__literal(U"plugin");
    TL_IS_2682 = Str__literal(U"format");
    TL_IS_2683 = Str__literal(U"number sections");
    TL_IS_2684 = Str__literal(U"default range");
    TL_IS_2685 = Str__literal(U"initial extension");
    TL_IS_2686 = Str__literal(U"mathematics plugin");
    TL_IS_2687 = Str__literal(U"footnotes plugin");
    TL_IS_2688 = Str__literal(U"block template");
    TL_IS_2689 = Str__literal(U"command");
    TL_IS_2690 = Str__literal(U"bibliographic data");
    TL_IS_2691 = Str__literal(U"assets");
    TL_IS_2692 = Str__literal(U"yes");
    TL_IS_2693 = Str__literal(U"no");
    TL_IS_2694 = Str__literal(U"none");
    TL_IS_2695 = Str__literal(U"WOVENPATH");
    TL_IS_2696 = Str__literal(U"WOVEN");
    TL_IS_2697 = Str__literal(U"PROCESS ");
    TL_IS_2698 = Str__literal(U"Colouring");
    TL_IS_2699 = Str__literal(U"Coloring");
    TL_IS_2700 = Str__literal(U"Colouring");
    TL_IS_2701 = Str__literal(U"Coloring");
    TL_IS_2702 = Str__literal(U"");
    TL_IS_2703 = Str__literal(U"copy");
    TL_IS_2704 = Str__literal(U"copy");
    TL_IS_2705 = Str__literal(U"private copy");
    TL_IS_2706 = Str__literal(U"embed");
    TL_IS_2707 = Str__literal(U"collate");
    TL_IS_2708 = Str__literal(U"prefix");
    TL_IS_2709 = Str__literal(U"suffix");
    TL_IS_2710 = Str__literal(U"transform names");
    TL_IS_2711 = Str__literal(U"");
    TL_IS_2712 = Str__literal(U"URL");
    TL_IS_2713 = Str__literal(U"URL");
    TL_IS_2714 = Str__literal(U"Inweb Version");
    TL_IS_2715 = Str__literal(U"Language");
    TL_IS_2716 = Str__literal(U"Purpose");
    TL_IS_2717 = Str__literal(U"Woven");
    TL_IS_2718 = Str__literal(U"Tangled");
    TL_IS_2719 = Str__literal(U"Title");
    TL_IS_2720 = Str__literal(U"");
    TL_IS_2721 = Str__literal(U"=");
    TL_IS_2722 = Str__literal(U"@");
    TL_IS_2723 = Str__literal(U"Figures");
    TL_IS_2724 = Str__literal(U"unknown [[command]]");
    TL_IS_2725 = Str__literal(U"<...> definition begins outside of a paragraph");
    TL_IS_2726 = Str__literal(U"(very early code)");
    TL_IS_2727 = Str__literal(U"(early code)");
    TL_IS_2728 = Str__literal(U"Extracts");
    TL_IS_2729 = Str__literal(U"Figures");
    TL_IS_2730 = Str__literal(U"HTML");
    TL_IS_2731 = Str__literal(U"Audio");
    TL_IS_2732 = Str__literal(U"Video");
    TL_IS_2733 = Str__literal(U"Download");
    TL_IS_2734 = Str__literal(U"Download");
    TL_IS_2735 = Str__literal(U"Carousels");
    TL_IS_2736 = Str__literal(U"Carousels");
    TL_IS_2737 = Str__literal(U"Carousels");
    TL_IS_2738 = Str__literal(U"Carousels");
    TL_IS_2739 = Str__literal(U"Carousels");
    TL_IS_2740 = Str__literal(U"Videos");
    TL_IS_2741 = Str__literal(U"unknown bracketed annotation");
    TL_IS_2742 = Str__literal(U"unknown material after '='");
    TL_IS_2743 = Str__literal(U"undisplayed");
    TL_IS_2744 = Str__literal(U"hyperlinked");
    TL_IS_2745 = Str__literal(U"only 'undisplayed' and/or 'hyperlinked' can precede 'text' here");
    TL_IS_2746 = Str__literal(U"=");
    TL_IS_2747 = Str__literal(U"don't understand @command");
    TL_IS_2748 = Str__literal(U"Purpose used after bar");
    TL_IS_2749 = Str__literal(U"Interface used after bar");
    TL_IS_2750 = Str__literal(U"Definitions used after bar");
    TL_IS_2751 = Str__literal(U"second bar in the same section");
    TL_IS_2752 = Str__literal(U"enumeration constants can't supply a value");
    TL_IS_2753 = Str__literal(U"Paragraph Numbers Visibility");
    TL_IS_2754 = Str__literal(U"Off");
    TL_IS_2755 = Str__literal(U"P");
    TL_IS_2756 = Str__literal(U"S");
    TL_IS_2757 = Str__literal(U"Footnote Begins Notation");
    TL_IS_2758 = Str__literal(U"Footnote Ends Notation");
    TL_IS_2759 = Str__literal(U"Off");
    TL_IS_2760 = Str__literal(U"ifdef-");
    TL_IS_2761 = Str__literal(U"ifndef-");
    TL_IS_2762 = Str__literal(U".");
    TL_IS_2763 = Str__literal(U"This paragraph is used only if ");
    TL_IS_2764 = Str__literal(U" and if ");
    TL_IS_2765 = Str__literal(U" and ");
    TL_IS_2766 = Str__literal(U" is");
    TL_IS_2767 = Str__literal(U" are");
    TL_IS_2768 = Str__literal(U" defined");
    TL_IS_2769 = Str__literal(U" undefined");
    TL_IS_2770 = Str__literal(U"enumeration constants must belong to a _FAMILY");
    TL_IS_2771 = Str__literal(U"this enumeration _FAMILY is unknown");
    TL_IS_2772 = Str__literal(U"this enumeration _FAMILY already exists");
    TL_IS_2773 = Str__literal(U"unrecognised interface line");
    TL_IS_2774 = Str__literal(U".");
    TL_IS_2775 = Str__literal(U"..");
    TL_IS_2776 = Str__literal(U"web");
    TL_IS_2777 = Str__literal(U"default.mkscript");
    TL_IS_2778 = Str__literal(U".");
    TL_IS_2779 = Str__literal(U"..");
    TL_IS_2780 = Str__literal(U"web");
    TL_IS_2781 = Str__literal(U"default.giscript");
    TL_IS_2782 = Str__literal(U"C");
    TL_IS_2783 = Str__literal(U"Dialects");
    TL_IS_2784 = Str__literal(U"");
    TL_IS_2785 = Str__literal(U"Chapters");
    TL_IS_2786 = Str__literal(U"Modules");
    TL_IS_2787 = Str__literal(U"Module Page");
    TL_IS_2788 = Str__literal(U"Module Purpose");
    TL_IS_2789 = Str__literal(U"Purpose");
    TL_IS_2790 = Str__literal(U"Chapter Purpose");
    TL_IS_2791 = Str__literal(U"Section Purpose");
    TL_IS_2792 = Str__literal(U"Purpose");
    TL_IS_2793 = Str__literal(U"index.html");
    TL_IS_2794 = Str__literal(U"inweb");
    TL_IS_2795 = Str__literal(U"inweb");
    TL_IS_2796 = Str__literal(U"inweb");
    TL_IS_2797 = Str__literal(U"End of weave");
    TL_IS_2798 = Str__literal(U"Definitions");
    TL_IS_2799 = Str__literal(U"bad start to paragraph");
    TL_IS_2800 = Str__literal(U"");
    TL_IS_2801 = Str__literal(U"");
    TL_IS_2802 = Str__literal(U"footnote never cued");
    TL_IS_2803 = Str__literal(U"Preform");
    TL_IS_2804 = Str__literal(U"Preform");
    TL_IS_2805 = Str__literal(U"define");
    TL_IS_2806 = Str__literal(U"default");
    TL_IS_2807 = Str__literal(U"enum");
    TL_IS_2808 = Str__literal(U"Preform");
    TL_IS_2809 = Str__literal(U"This is ");
    TL_IS_2810 = Str__literal(U"words: About Preform");
    TL_IS_2811 = Str__literal(U"Preform grammar");
    TL_IS_2812 = Str__literal(U"Preform grammar");
    TL_IS_2813 = Str__literal(U", not regular C code.");
    TL_IS_2814 = Str__literal(U"This code is ");
    TL_IS_2815 = Str__literal(U"never used");
    TL_IS_2816 = Str__literal(U", ");
    TL_IS_2817 = Str__literal(U" and ");
    TL_IS_2818 = Str__literal(U"used in ");
    TL_IS_2819 = Str__literal(U" (twice)");
    TL_IS_2820 = Str__literal(U" (three times)");
    TL_IS_2821 = Str__literal(U" (four times)");
    TL_IS_2822 = Str__literal(U" (five times)");
    TL_IS_2823 = Str__literal(U".");
    TL_IS_2824 = Str__literal(U"The structure ");
    TL_IS_2825 = Str__literal(U" is private to this section");
    TL_IS_2826 = Str__literal(U" is accessed in ");
    TL_IS_2827 = Str__literal(U", ");
    TL_IS_2828 = Str__literal(U" and here");
    TL_IS_2829 = Str__literal(U".");
    TL_IS_2830 = Str__literal(U"The function ");
    TL_IS_2831 = Str__literal(U" appears nowhere else");
    TL_IS_2832 = Str__literal(U"none");
    TL_IS_2833 = Str__literal(U")");
    TL_IS_2834 = Str__literal(U".");
    TL_IS_2835 = Str__literal(U" is used in ");
    TL_IS_2836 = Str__literal(U"), ");
    TL_IS_2837 = Str__literal(U", ");
    TL_IS_2838 = Str__literal(U" (");
    TL_IS_2839 = Str__literal(U" - ");
    TL_IS_2840 = Str__literal(U", ");
    TL_IS_2841 = Str__literal(U"Code In Code Comments Notation");
    TL_IS_2842 = Str__literal(U"Code In Commentary Notation");
    TL_IS_2843 = Str__literal(U"Off");
    TL_IS_2844 = Str__literal(U"TeX Mathematics Displayed Notation");
    TL_IS_2845 = Str__literal(U"Off");
    TL_IS_2846 = Str__literal(U"TeX Mathematics Notation");
    TL_IS_2847 = Str__literal(U"Off");
    TL_IS_2848 = Str__literal(U"Cross-References Notation");
    TL_IS_2849 = Str__literal(U"Off");
    TL_IS_2850 = Str__literal(U"http://");
    TL_IS_2851 = Str__literal(U"https://");
    TL_IS_2852 = Str__literal(U"this is a cue for a missing note");
    TL_IS_2853 = Str__literal(U"Cross-References Notation");
    TL_IS_2854 = Str__literal(U"Off");
    TL_IS_2855 = Str__literal(U"http://");
    TL_IS_2856 = Str__literal(U"https://");
    TL_IS_2857 = Str__literal(U"misplaced definition");
    TL_IS_2858 = Str__literal(U"unknown macro");
    TL_IS_2859 = Str__literal(U"Structures");
    TL_IS_2860 = Str__literal(U"Main::");
    TL_IS_2861 = Str__literal(U"Tangled output generated by inweb: do not edit");
    TL_IS_2862 = Str__literal(U"this programming language does not support @d");
    TL_IS_2863 = Str__literal(U"this programming language does not support multiline @d");
    TL_IS_2864 = Str__literal(U"Preform");
    TL_IS_2865 = Str__literal(U"Preform");
    TL_IS_2866 = Str__literal(U"Namespaces");
    TL_IS_2867 = Str__literal(U"Being internally called, this function mustn't belong to a :: namespace");
    TL_IS_2868 = Str__literal(U"Being externally called, this function must belong to a :: namespace");
    TL_IS_2869 = Str__literal(U"Structures");
    TL_IS_2870 = Str__literal(U"program ended with conditional compilation open");
    TL_IS_2871 = Str__literal(U"conditional compilation too deeply nested");
    TL_IS_2872 = Str__literal(U"found #endif without #ifdef or #ifndef");
    TL_IS_2873 = Str__literal(U"Preform");
    TL_IS_2874 = Str__literal(U"'WR[...]' notation unavailable");
    TL_IS_2875 = Str__literal(U"malformed '{ , }' formula");
    TL_IS_2876 = Str__literal(U"fail");
    TL_IS_2877 = Str__literal(U"fail production");
    TL_IS_2878 = Str__literal(U"fail nonterminal");
    TL_IS_2879 = Str__literal(U"advance ");
    TL_IS_2880 = Str__literal(U"pass ");
    TL_IS_2881 = Str__literal(U"lookahead");
    TL_IS_2882 = Str__literal(U"-");
    TL_IS_2883 = Str__literal(U"-");
    TL_IS_2884 = Str__literal(U"most_recent_result");
    TL_IS_2885 = Str__literal(U"most_recent_result_p");
    TL_IS_2886 = Str__literal(U"Syntax.preform");
    TL_IS_2887 = Str__literal(U"Preform Language");
    TL_IS_2888 = Str__literal(U"Preform Language");
    TL_IS_2889 = Str__literal(U"weave tree");
    TL_IS_2890 = Str__literal(U"document");
    TL_IS_2891 = Str__literal(U"head");
    TL_IS_2892 = Str__literal(U"body");
    TL_IS_2893 = Str__literal(U"tail");
    TL_IS_2894 = Str__literal(U"chapter footer");
    TL_IS_2895 = Str__literal(U"chapter header");
    TL_IS_2896 = Str__literal(U"section footer");
    TL_IS_2897 = Str__literal(U"section header");
    TL_IS_2898 = Str__literal(U"section purpose");
    TL_IS_2899 = Str__literal(U"subheading");
    TL_IS_2900 = Str__literal(U"bar");
    TL_IS_2901 = Str__literal(U"pagebreak");
    TL_IS_2902 = Str__literal(U"linebreak");
    TL_IS_2903 = Str__literal(U"paragraph");
    TL_IS_2904 = Str__literal(U"endnote");
    TL_IS_2905 = Str__literal(U"figure");
    TL_IS_2906 = Str__literal(U"extract");
    TL_IS_2907 = Str__literal(U"audio");
    TL_IS_2908 = Str__literal(U"video");
    TL_IS_2909 = Str__literal(U"download");
    TL_IS_2910 = Str__literal(U"material");
    TL_IS_2911 = Str__literal(U"embed");
    TL_IS_2912 = Str__literal(U"pmac");
    TL_IS_2913 = Str__literal(U"vskip");
    TL_IS_2914 = Str__literal(U"chapter");
    TL_IS_2915 = Str__literal(U"section");
    TL_IS_2916 = Str__literal(U"code line");
    TL_IS_2917 = Str__literal(U"function usage");
    TL_IS_2918 = Str__literal(U"commentary");
    TL_IS_2919 = Str__literal(U"carousel slide");
    TL_IS_2920 = Str__literal(U"toc");
    TL_IS_2921 = Str__literal(U"toc line");
    TL_IS_2922 = Str__literal(U"chapter_title_page");
    TL_IS_2923 = Str__literal(U"defn");
    TL_IS_2924 = Str__literal(U"source_code");
    TL_IS_2925 = Str__literal(U"url");
    TL_IS_2926 = Str__literal(U"footnote_cue");
    TL_IS_2927 = Str__literal(U"footnote");
    TL_IS_2928 = Str__literal(U"display line");
    TL_IS_2929 = Str__literal(U"function defn");
    TL_IS_2930 = Str__literal(U"item");
    TL_IS_2931 = Str__literal(U"grammar index");
    TL_IS_2932 = Str__literal(U"inline");
    TL_IS_2933 = Str__literal(U"locale");
    TL_IS_2934 = Str__literal(U"mathematics");
    TL_IS_2935 = Str__literal(U"verbatim");
    TL_IS_2936 = Str__literal(U"Weave Content");
    TL_IS_2937 = Str__literal(U"plain");
    TL_IS_2938 = Str__literal(U".txt");
    TL_IS_2939 = Str__literal(U"TeX");
    TL_IS_2940 = Str__literal(U".tex");
    TL_IS_2941 = Str__literal(U"S");
    TL_IS_2942 = Str__literal(U"");
    TL_IS_2943 = Str__literal(U"Figures");
    TL_IS_2944 = Str__literal(U"weavesection");
    TL_IS_2945 = Str__literal(U"weavesections");
    TL_IS_2946 = Str__literal(U"weavesectionss");
    TL_IS_2947 = Str__literal(U"weavesectionsss");
    TL_IS_2948 = Str__literal(U"tweavesection");
    TL_IS_2949 = Str__literal(U"tweavesections");
    TL_IS_2950 = Str__literal(U"tweavesectionss");
    TL_IS_2951 = Str__literal(U"tweavesectionsss");
    TL_IS_2952 = Str__literal(U"nsweavesection");
    TL_IS_2953 = Str__literal(U"nsweavesections");
    TL_IS_2954 = Str__literal(U"HTML");
    TL_IS_2955 = Str__literal(U".html");
    TL_IS_2956 = Str__literal(U"ePub");
    TL_IS_2957 = Str__literal(U".html");
    TL_IS_2958 = Str__literal(U"");
    TL_IS_2959 = Str__literal(U"private copy");
    TL_IS_2960 = Str__literal(U"Base");
    TL_IS_2961 = Str__literal(U"Colours");
    TL_IS_2962 = Str__literal(U"");
    TL_IS_2963 = Str__literal(U"");
    TL_IS_2964 = Str__literal(U"Breadcrumbs");
    TL_IS_2965 = Str__literal(U"Title");
    TL_IS_2966 = Str__literal(U"Short Title");
    TL_IS_2967 = Str__literal(U"Short Title");
    TL_IS_2968 = Str__literal(U"index.html");
    TL_IS_2969 = Str__literal(U"S");
    TL_IS_2970 = Str__literal(U"Sequential Section Ranges");
    TL_IS_2971 = Str__literal(U"On");
    TL_IS_2972 = Str__literal(U"Figures");
    TL_IS_2973 = Str__literal(U"HTML");
    TL_IS_2974 = Str__literal(U"Unable to find this HTML extract");
    TL_IS_2975 = Str__literal(U"Audio");
    TL_IS_2976 = Str__literal(U"Video");
    TL_IS_2977 = Str__literal(U"Downloads");
    TL_IS_2978 = Str__literal(U"Embedding");
    TL_IS_2979 = Str__literal(U"Download.html");
    TL_IS_2980 = Str__literal(U"Downloads are not supported");
    TL_IS_2981 = Str__literal(U"Downloads");
    TL_IS_2982 = Str__literal(U"Download file missing or empty");
    TL_IS_2983 = Str__literal(U"File Name");
    TL_IS_2984 = Str__literal(U"File URL");
    TL_IS_2985 = Str__literal(U"File Details");
    TL_IS_2986 = Str__literal(U" byte");
    TL_IS_2987 = Str__literal(U" bytes");
    TL_IS_2988 = Str__literal(U"kB");
    TL_IS_2989 = Str__literal(U"MB");
    TL_IS_2990 = Str__literal(U"GB");
    TL_IS_2991 = Str__literal(U"405");
    TL_IS_2992 = Str__literal(U"720");
    TL_IS_2993 = Str__literal(U"Embedding");
    TL_IS_2994 = Str__literal(U"This is not a supported service");
    TL_IS_2995 = Str__literal(U"Content ID");
    TL_IS_2996 = Str__literal(U"Content Width");
    TL_IS_2997 = Str__literal(U"Content Height");
    TL_IS_2998 = Str__literal(U"named-paragraph-link");
    TL_IS_2999 = Str__literal(U"function-link");
    TL_IS_3000 = Str__literal(U"Carousel");
    TL_IS_3001 = Str__literal(U"carousel-number");
    TL_IS_3002 = Str__literal(U"carousel-caption");
    TL_IS_3003 = Str__literal(U"carousel-caption-above");
    TL_IS_3004 = Str__literal(U"carousel-number-above");
    TL_IS_3005 = Str__literal(U"carousel-caption-below");
    TL_IS_3006 = Str__literal(U"carousel-number-below");
    TL_IS_3007 = Str__literal(U"external");
    TL_IS_3008 = Str__literal(U"internal");
    TL_IS_3009 = Str__literal(U"Popups");
    TL_IS_3010 = Str__literal(U"*");
    TL_IS_3011 = Str__literal(U"paragraph-anchor");
    TL_IS_3012 = Str__literal(U"Title");
    TL_IS_3013 = Str__literal(U"Base");
    TL_IS_3014 = Str__literal(U"Base.css");
    TL_IS_3015 = Str__literal(U"TestingInweb");
    TL_IS_3016 = Str__literal(U".txt");
    TL_IS_3017 = Str__literal(U".pdf");
    TL_IS_3018 = Str__literal(U"not");
    TL_IS_3019 = Str__literal(U"leq");
    TL_IS_3020 = Str__literal(U"geq");
    TL_IS_3021 = Str__literal(U"sim");
    TL_IS_3022 = Str__literal(U"hbox");
    TL_IS_3023 = Str__literal(U"left");
    TL_IS_3024 = Str__literal(U"right");
    TL_IS_3025 = Str__literal(U"Rightarrow");
    TL_IS_3026 = Str__literal(U"Leftrightarrow");
    TL_IS_3027 = Str__literal(U"to");
    TL_IS_3028 = Str__literal(U"rightarrow");
    TL_IS_3029 = Str__literal(U"longrightarrow");
    TL_IS_3030 = Str__literal(U"leftarrow");
    TL_IS_3031 = Str__literal(U"longleftarrow");
    TL_IS_3032 = Str__literal(U"lbrace");
    TL_IS_3033 = Str__literal(U"mid");
    TL_IS_3034 = Str__literal(U"rbrace");
    TL_IS_3035 = Str__literal(U"cdot");
    TL_IS_3036 = Str__literal(U"cdots");
    TL_IS_3037 = Str__literal(U"dots");
    TL_IS_3038 = Str__literal(U"times");
    TL_IS_3039 = Str__literal(U"quad");
    TL_IS_3040 = Str__literal(U"qquad");
    TL_IS_3041 = Str__literal(U"TeX");
    TL_IS_3042 = Str__literal(U"neq");
    TL_IS_3043 = Str__literal(U"noteq");
    TL_IS_3044 = Str__literal(U"ell");
    TL_IS_3045 = Str__literal(U"log");
    TL_IS_3046 = Str__literal(U"exp");
    TL_IS_3047 = Str__literal(U"sin");
    TL_IS_3048 = Str__literal(U"cos");
    TL_IS_3049 = Str__literal(U"tan");
    TL_IS_3050 = Str__literal(U"top");
    TL_IS_3051 = Str__literal(U"Alpha");
    TL_IS_3052 = Str__literal(U"Beta");
    TL_IS_3053 = Str__literal(U"Gamma");
    TL_IS_3054 = Str__literal(U"Delta");
    TL_IS_3055 = Str__literal(U"Epsilon");
    TL_IS_3056 = Str__literal(U"Zeta");
    TL_IS_3057 = Str__literal(U"Eta");
    TL_IS_3058 = Str__literal(U"Theta");
    TL_IS_3059 = Str__literal(U"Iota");
    TL_IS_3060 = Str__literal(U"Kappa");
    TL_IS_3061 = Str__literal(U"Lambda");
    TL_IS_3062 = Str__literal(U"Mu");
    TL_IS_3063 = Str__literal(U"Nu");
    TL_IS_3064 = Str__literal(U"Xi");
    TL_IS_3065 = Str__literal(U"Omicron");
    TL_IS_3066 = Str__literal(U"Pi");
    TL_IS_3067 = Str__literal(U"Rho");
    TL_IS_3068 = Str__literal(U"Varsigma");
    TL_IS_3069 = Str__literal(U"Sigma");
    TL_IS_3070 = Str__literal(U"Tau");
    TL_IS_3071 = Str__literal(U"Upsilon");
    TL_IS_3072 = Str__literal(U"Phi");
    TL_IS_3073 = Str__literal(U"Chi");
    TL_IS_3074 = Str__literal(U"Psi");
    TL_IS_3075 = Str__literal(U"Omega");
    TL_IS_3076 = Str__literal(U"alpha");
    TL_IS_3077 = Str__literal(U"beta");
    TL_IS_3078 = Str__literal(U"gamma");
    TL_IS_3079 = Str__literal(U"delta");
    TL_IS_3080 = Str__literal(U"epsilon");
    TL_IS_3081 = Str__literal(U"zeta");
    TL_IS_3082 = Str__literal(U"eta");
    TL_IS_3083 = Str__literal(U"theta");
    TL_IS_3084 = Str__literal(U"iota");
    TL_IS_3085 = Str__literal(U"kappa");
    TL_IS_3086 = Str__literal(U"lambda");
    TL_IS_3087 = Str__literal(U"mu");
    TL_IS_3088 = Str__literal(U"nu");
    TL_IS_3089 = Str__literal(U"xi");
    TL_IS_3090 = Str__literal(U"omicron");
    TL_IS_3091 = Str__literal(U"pi");
    TL_IS_3092 = Str__literal(U"rho");
    TL_IS_3093 = Str__literal(U"varsigma");
    TL_IS_3094 = Str__literal(U"sigma");
    TL_IS_3095 = Str__literal(U"tau");
    TL_IS_3096 = Str__literal(U"upsilon");
    TL_IS_3097 = Str__literal(U"phi");
    TL_IS_3098 = Str__literal(U"chi");
    TL_IS_3099 = Str__literal(U"psi");
    TL_IS_3100 = Str__literal(U"omega");
    TL_IS_3101 = Str__literal(U"exists");
    TL_IS_3102 = Str__literal(U"in");
    TL_IS_3103 = Str__literal(U"forall");
    TL_IS_3104 = Str__literal(U"cap");
    TL_IS_3105 = Str__literal(U"emptyset");
    TL_IS_3106 = Str__literal(U"subseteq");
    TL_IS_3107 = Str__literal(U"land");
    TL_IS_3108 = Str__literal(U"lor");
    TL_IS_3109 = Str__literal(U"lnot");
    TL_IS_3110 = Str__literal(U"sum");
    TL_IS_3111 = Str__literal(U"prod");
    TL_IS_3112 = Str__literal(U"n");
    TL_IS_3113 = Str__literal(U"t");
    TL_IS_3114 = Str__literal(U"exists");
    TL_IS_3115 = Str__literal(U"forall");
    TL_IS_3116 = Str__literal(U"platform-settings");
    TL_IS_3117 = Str__literal(U"identity-settings");
    TL_IS_3118 = Str__literal(U"modify-filenames");
    TL_IS_3119 = Str__literal(U"original: ORIGINAL ?suffix: SUFFIX ?prefix: PREFIX");
    TL_IS_3120 = Str__literal(U"component");
    TL_IS_3121 = Str__literal(U"symbol: SYMBOL webname: WEBNAME path: PATH set: SET type: TYPE");
    TL_IS_3122 = Str__literal(U"dependent-files");
    TL_IS_3123 = Str__literal(U"?tool: TOOL ?module: MODULES ?tool-and-modules: BOTH");
    TL_IS_3124 = Str__literal(U"components");
    TL_IS_3125 = Str__literal(U"type: TYPE ?set: SET");
    TL_IS_3126 = Str__literal(U"intest");
    TL_IS_3127 = Str__literal(U"platform-settings.mk");
    TL_IS_3128 = Str__literal(U"Materials");
    TL_IS_3129 = Str__literal(U"platforms");
    TL_IS_3130 = Str__literal(U"tool");
    TL_IS_3131 = Str__literal(U"web");
    TL_IS_3132 = Str__literal(U"module");
    TL_IS_3133 = Str__literal(U"SYMBOL");
    TL_IS_3134 = Str__literal(U"all");
    TL_IS_3135 = Str__literal(U"tool");
    TL_IS_3136 = Str__literal(U"web");
    TL_IS_3137 = Str__literal(U"module");
    TL_IS_3138 = Str__literal(U"all");
    TL_IS_3139 = Str__literal(U"basics");
    TL_IS_3140 = Str__literal(U"default.giscript");
    TL_IS_3141 = Str__literal(U"tags");
    TL_IS_3142 = Str__literal(U"bibliographic");
    TL_IS_3143 = Str__literal(U"datum: DATUM of: ASSET");
    TL_IS_3144 = Str__literal(U"Build Date");
    TL_IS_3145 = Str__literal(U"Version Number");
    TL_IS_3146 = Str__literal(U"Build Date");
    TL_IS_3147 = Str__literal(U"Version Number");
    TL_IS_3148 = Str__literal(U"inform6");
    TL_IS_3149 = Str__literal(U"header.h");
    TL_IS_3150 = Str__literal(U"(manifest).txt");
    TL_IS_3151 = Str__literal(U"README.txt");
    TL_IS_3152 = Str__literal(U"README.md");
    TL_IS_3153 = Str__literal(U"docs");
    TL_IS_3154 = Str__literal(U"web");
    TL_IS_3155 = Str__literal(U"module");
    TL_IS_3156 = Str__literal(U".inweb");
    TL_IS_3157 = Str__literal(U".inweb");
    TL_IS_3158 = Str__literal(U"docs");
    TL_IS_3159 = Str__literal(U"Multiple cross-references might be meant here");
    TL_IS_3160 = Str__literal(U"(main)");
}
