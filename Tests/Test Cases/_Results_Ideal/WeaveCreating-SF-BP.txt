begin
directory: countsort2-assets
opaque file: countsort2-assets/Base.css
opaque file: countsort2-assets/Bigfoot.css
opaque file: countsort2-assets/Bigfoot.js
opaque file: countsort2-assets/Breadcrumbs.css
opaque file: countsort2-assets/Colours.css
opaque file: countsort2-assets/Contents.css
opaque file: countsort2-assets/crumbs.gif
opaque file: countsort2-assets/Fonts.css
opaque file: countsort2-assets/Navigation.css
opaque file: countsort2-assets/Progress.css
file: countsort2.html
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    <html>
    	<head>
    		<title>Counting Sort</title>
    		<meta name="viewport" content="width=device-width initial-scale=1">
    		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    		<meta http-equiv="Content-Language" content="en-gb">

    <link href="countsort2-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <link href="countsort2-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <link href="countsort2-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <link href="countsort2-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <link href="countsort2-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <link href="countsort2-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <script>
    MathJax = {
        options: {
        	skipHtmlTags: {'[-]': ['pre']},
        	processHtmlClass: 'mathjax_process'
        },
    	loader: {load: ['[tex]/texhtml']},
      	tex: {
    		inlineMath: [ ['\\INWEBMATH(', '\\INWEBMATH)'] ],
        	packages: {'[+]': ['texhtml']},
        	allowTexHTML: true
    	},
    	svg: {
    		fontCache: 'global'
    	}
    };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-svg.js"></script>

    <script src="http://code.jquery.com/jquery-1.12.4.min.js"
    	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

    <script src="countsort2-assets/Bigfoot.js"></script>
    <link href="countsort2-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
    <link href="countsort2-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
    		
    	</head>
    	<body class="commentary-font">
    <!-- Weave of 'Counting Sort' generated by inweb -->
    <div class="breadcrumbs">
        <ul class="crumbs"><li><b>Counting Sort</b></li></ul></div>
    <p class="purpose">An implementation of the 1954 sort algorithm.</p>

    <ul class="toc"><li><a href="countsort2.html#SP3">&#167;3. Verdict</a></li></ul><hr class="tocbar">

    <div class="lsmarkdown">
    <p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. </b>  This algorithm was found in 1954 by <a href="https://en.wikipedia.org/wiki/Harold_H._Seward">Harold H. Seward</a>,
    who also devised radix sort. They differ from most sorting techniques because they do
    not make comparisons between items in the unsorted array. Indeed, there are no
    comparisons in the following function, only iteration.</p>
    <p>This function takes an array of non-negative integers, sorts it, and returns
    the result. The test <code>if unsorted</code> means &quot;if the unsorted array is not empty&quot;,
    and is needed because Python would otherwise handle this case badly: of course,
    if <code>unsorted</code> does equal <code>[]</code>, then so should <code>sorted</code>, and so the right answer
    is returned.</p>
    </div>
    <pre class="displayed-code all-displayed-code code-font">
    <span class="identifier-syntax">def</span><span class="plain-syntax"> </span><span class="identifier-syntax">countingSort</span><span class="plain-syntax">(</span><span class="identifier-syntax">unsorted</span><span class="plain-syntax">):</span>
    <span class="plain-syntax">    </span><span class="identifier-syntax">sorted</span><span class="plain-syntax"> = []</span>
    <span class="plain-syntax">    </span><span class="identifier-syntax">if</span><span class="plain-syntax"> </span><span class="identifier-syntax">unsorted</span><span class="plain-syntax">:</span>
    <span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="countsort2.html#SP1_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">initialise the incidence counts to zero</span></span><span class="named-paragraph-number">1.1</span></a></span>
    <span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="countsort2.html#SP1_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">tally how many times each value occurs in the unsorted array</span></span><span class="named-paragraph-number">1.2</span></a></span>
    <span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="countsort2.html#SP1_3" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">construct the sorted array with the right number of each value</span></span><span class="named-paragraph-number">1.3</span></a></span>
    <span class="plain-syntax">    </span><span class="identifier-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">sorted</span>
    </pre>
    <div class="lsmarkdown">
    <p class="commentary firstcommentary"><a id="SP1_1" class="paragraph-anchor"></a><b>&#167;1.1. </b>  For example, suppose the array is initially <code>[4, 2, 2, 6, 3, 3, 1, 6, 5, 2, 3]</code>.
    Then the maximum value is 6. Python arrays index from 0, so we need an incidence
    counts array of size 7, and we create it as <code>[0, 0, 0, 0, 0, 0, 0]</code>.</p>
    </div>
    <p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">initialise the incidence counts to zero</span><span class="named-paragraph-number">1.1</span></span> =</p>

    <pre class="displayed-code all-displayed-code code-font">
    <span class="identifier-syntax">max_val</span><span class="plain-syntax"> = </span><span class="identifier-syntax">max</span><span class="plain-syntax">(</span><span class="identifier-syntax">unsorted</span><span class="plain-syntax">)</span>
    <span class="identifier-syntax">counts</span><span class="plain-syntax"> = [0] * (</span><span class="identifier-syntax">max_val</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">)</span>
    </pre>
    <ul class="endnotetexts"><li>This code is used in <a href="countsort2.html#SP1">&#167;1</a>.</li></ul>
    <div class="lsmarkdown">
    <p class="commentary firstcommentary"><a id="SP1_2" class="paragraph-anchor"></a><b>&#167;1.2. </b>  In the unsorted array we will observe no 0s, one 1, three 2s, and so on. The
    following produces the counts <code>[0, 1, 3, 3, 1, 1, 2]</code>.</p>
    </div>
    <p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">tally how many times each value occurs in the unsorted array</span><span class="named-paragraph-number">1.2</span></span> =</p>

    <pre class="displayed-code all-displayed-code code-font">
    <span class="identifier-syntax">for</span><span class="plain-syntax"> </span><span class="identifier-syntax">value</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">unsorted</span><span class="plain-syntax">:</span>
    <span class="plain-syntax">    </span><span class="identifier-syntax">counts</span><span class="plain-syntax">[</span><span class="identifier-syntax">value</span><span class="plain-syntax">] += </span><span class="constant-syntax">1</span>
    </pre>
    <ul class="endnotetexts"><li>This code is used in <a href="countsort2.html#SP1">&#167;1</a>.</li></ul>
    <div class="lsmarkdown">
    <p class="commentary firstcommentary"><a id="SP1_3" class="paragraph-anchor"></a><b>&#167;1.3. </b>  Unusually for a sorting algorithm, an entirely new sorted array is created,
    using only the incidence counts as a sort of program. We fill <code>sorted</code>
    with no <code>0</code>s, one <code>1</code>, three <code>2</code>s, and so on, producing <code>[1, 2, 2, 2, 3, 3, 3, 4, 5, 6, 6]</code>.<sup id="fnred:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
    <ul class="inwebfootnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
    The unsorted array is no longer needed, in fact, and so we could easily make this
    algorithm &quot;sort in place&quot; by simply rewriting <code>unsorted</code>, rather than making
    a new array.<a href="#fnref:1" title="return to text"> &#x21A9;</a></p>
    </li></ul>
    </div>
    <p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">construct the sorted array with the right number of each value</span><span class="named-paragraph-number">1.3</span></span> =</p>

    <pre class="displayed-code all-displayed-code code-font">
    <span class="identifier-syntax">for</span><span class="plain-syntax"> </span><span class="identifier-syntax">value</span><span class="plain-syntax">, </span><span class="identifier-syntax">count</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">enumerate</span><span class="plain-syntax">(</span><span class="identifier-syntax">counts</span><span class="plain-syntax">):</span>
    <span class="plain-syntax">    </span><span class="identifier-syntax">sorted</span><span class="plain-syntax">.</span><span class="identifier-syntax">extend</span><span class="plain-syntax">([</span><span class="identifier-syntax">value</span><span class="plain-syntax">] * </span><span class="identifier-syntax">count</span><span class="plain-syntax">)</span>
    </pre>
    <ul class="endnotetexts"><li>This code is used in <a href="countsort2.html#SP1">&#167;1</a>.</li></ul>
    <div class="lsmarkdown">
    <p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. </b>  And this code tests the function:</p>
    </div>
    <pre class="displayed-code all-displayed-code code-font">
    <span class="identifier-syntax">A</span><span class="plain-syntax"> = [4, </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="constant-syntax">6</span><span class="plain-syntax">, </span><span class="constant-syntax">3</span><span class="plain-syntax">, </span><span class="constant-syntax">3</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">, </span><span class="constant-syntax">6</span><span class="plain-syntax">, </span><span class="constant-syntax">5</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="constant-syntax">3</span><span class="plain-syntax">]</span>
    <span class="identifier-syntax">print</span><span class="plain-syntax">(</span><span class="string-syntax">"Unsorted:"</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">)</span>
    <span class="identifier-syntax">print</span><span class="plain-syntax">(</span><span class="string-syntax">"Sorted:"</span><span class="plain-syntax">, </span><span class="identifier-syntax">countingSort</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">))</span>
    </pre>
    <div class="lsmarkdown">
    <p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. Verdict.</b>  So how did we do? What makes count sort interesting is that it is not doomed
    to run at \INWEBMATH(O(n\log n)\INWEBMATH) or worse speed, where \INWEBMATH(n\INWEBMATH) is the size of the data set:
    counting sort runs at \INWEBMATH(O(n+k)\INWEBMATH), where \INWEBMATH(k\INWEBMATH) is the size of the largest value in
    the data (called <code>max_val</code> above). With most data, \INWEBMATH(k\INWEBMATH) is either enormous or
    at least unpredictable, so that speed and memory usage both spike. But for just
    a few applications, where \INWEBMATH(k\INWEBMATH) is known to be within tight bounds, count sort
    is still used today and is exceptionally fast.</p>
    </div>
    <!-- End of weave -->

    	</body>
    </html>


file: countsort2.py.md
    # Counting Sort by Harold H. Seward

    _An implementation of the 1954 sort algorithm._

    This algorithm was found in 1954 by [Harold H. Seward](https://en.wikipedia.org/wiki/Harold_H._Seward),
    who also devised radix sort. They differ from most sorting techniques because they do
    not make comparisons between items in the unsorted array. Indeed, there are no
    comparisons in the following function, only iteration.

    This function takes an array of non-negative integers, sorts it, and returns
    the result. The test `if unsorted` means "if the unsorted array is not empty",
    and is needed because Python would otherwise handle this case badly: of course,
    if `unsorted` does equal `[]`, then so should `sorted`, and so the right answer
    is returned.

    	def countingSort(unsorted):
    		sorted = []
    		if unsorted:
    			{{initialise...}}
    			{{tally how many times each value occurs in the unsorted array}}
    			{{construct the sorted array with the right number of each value}}
    		return sorted

    For example, suppose the array is initially `[4, 2, 2, 6, 3, 3, 1, 6, 5, 2, 3]`.
    Then the maximum value is 6. Python arrays index from 0, so we need an incidence
    counts array of size 7, and we create it as `[0, 0, 0, 0, 0, 0, 0]`.

    {{initialise the incidence counts to zero}} =

    	max_val = max(unsorted)
    	counts = [0] * (max_val + 1)

    In the unsorted array we will observe no 0s, one 1, three 2s, and so on. The
    following produces the counts `[0, 1, 3, 3, 1, 1, 2]`.

    {{tally how many times each value occurs in the unsorted array}} =

    	for value in unsorted:
    		counts[value] += 1

    Unusually for a sorting algorithm, an entirely new sorted array is created,
    using only the incidence counts as a sort of program. We fill `sorted`
    with no `0`s, one `1`, three `2`s, and so on, producing `[1, 2, 2, 2, 3, 3, 3, 4, 5, 6, 6]`.[1]

    [1] The unsorted array is no longer needed, in fact, and so we could easily make this
    algorithm "sort in place" by simply rewriting `unsorted`, rather than making
    a new array.

    {{construct the sorted array with the right number of each value}} =

    	for value, count in enumerate(counts):
    		sorted.extend([value] * count)	

    And this code tests the function:

    	A = [4, 2, 2, 6, 3, 3, 1, 6, 5, 2, 3]
    	print("Unsorted:", A)
    	print("Sorted:", countingSort(A))

    ## Verdict ^"verdicts"

    So how did we do? What makes count sort interesting is that it is not doomed
    to run at $O(n\log n)$ or worse speed, where $n$ is the size of the data set:
    counting sort runs at $O(n+k)$, where $k$ is the size of the largest value in
    the data (called `max_val` above). With most data, $k$ is either enormous or
    at least unpredictable, so that speed and memory usage both spike. But for just
    a few applications, where $k$ is known to be within tight bounds, count sort
    is still used today and is exceptionally fast.

end
