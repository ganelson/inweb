<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Syntax Colouring Programs</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html"><img src="../docs-assets/Octagram.png" height=72> </a></h1>
<ul><li><a href="../inweb/index.html">inweb</a></li>
</ul><h2>Foundation Modules</h2><ul>
<li><a href="../foundation-module/index.html">foundation</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
<li><a href="../literate-module/index.html">literate</a></li>
<li><a href="../literate-test/index.html">literate-test</a></li>
</ul><h2>Documentation</h2><ul>
<li><a href="index.html"><span class="selectedlink">guide</span></a></li>
</ul><h2>Example Webs</h2><ul>
<li><a href="../goldbach/index.html">goldbach</a></li>
<li><a href="../twinprimes/twinprimes.html">twinprimes</a></li>
<li><a href="../eastertide/index.html">eastertide</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> inform</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Syntax Colouring Programs' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">The Inweb Guide</a></li><li><a href="index.html#5">Chapter 5: Languages</a></li><li><b>Syntax Colouring Programs</b></li></ul></div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a> This section is about how to write the <code>colouring</code> (or if you prefer <code>coloring</code>)
part of a language definition. In <a href="5-cl.html" class="internal">Creating Languages</a> we saw that a <code>colouring</code>
block improved the syntax-colouring for code in the Rust language, but as an
earlier example showed, these blocks can also be used for &quot;languages&quot; which are
really just ways to mark up textual displays or diagrams:</p>
<pre><code>Language &quot;VowelsExample&quot; {
	colour !vowel like !function
	colouring
		=&gt; !plain
		characters in &quot;AEIOUaeiou&quot; {
			=&gt; !vowel
		}
	end
}
</code></pre>
<p>Thus:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">A</span><span class="plain-syntax"> n</span><span class="function-syntax">oi</span><span class="plain-syntax">r, </span><span class="function-syntax">E</span><span class="plain-syntax"> bl</span><span class="function-syntax">a</span><span class="plain-syntax">nc, </span><span class="function-syntax">I</span><span class="plain-syntax"> r</span><span class="function-syntax">ou</span><span class="plain-syntax">g</span><span class="function-syntax">e</span><span class="plain-syntax">, </span><span class="function-syntax">U</span><span class="plain-syntax"> v</span><span class="function-syntax">e</span><span class="plain-syntax">rt, </span><span class="function-syntax">O</span><span class="plain-syntax"> bl</span><span class="function-syntax">eu</span><span class="plain-syntax"> : v</span><span class="function-syntax">o</span><span class="plain-syntax">y</span><span class="function-syntax">e</span><span class="plain-syntax">ll</span><span class="function-syntax">e</span><span class="plain-syntax">s,</span>
<span class="plain-syntax">J</span><span class="function-syntax">e</span><span class="plain-syntax"> d</span><span class="function-syntax">i</span><span class="plain-syntax">r</span><span class="function-syntax">ai</span><span class="plain-syntax"> q</span><span class="function-syntax">ue</span><span class="plain-syntax">lq</span><span class="function-syntax">ue</span><span class="plain-syntax"> j</span><span class="function-syntax">ou</span><span class="plain-syntax">r v</span><span class="function-syntax">o</span><span class="plain-syntax">s n</span><span class="function-syntax">ai</span><span class="plain-syntax">ss</span><span class="function-syntax">a</span><span class="plain-syntax">nc</span><span class="function-syntax">e</span><span class="plain-syntax">s l</span><span class="function-syntax">a</span><span class="plain-syntax">t</span><span class="function-syntax">e</span><span class="plain-syntax">nt</span><span class="function-syntax">e</span><span class="plain-syntax">s :</span>
<span class="function-syntax">A</span><span class="plain-syntax">, n</span><span class="function-syntax">oi</span><span class="plain-syntax">r c</span><span class="function-syntax">o</span><span class="plain-syntax">rs</span><span class="function-syntax">e</span><span class="plain-syntax">t v</span><span class="function-syntax">e</span><span class="plain-syntax">l</span><span class="function-syntax">u</span><span class="plain-syntax"> d</span><span class="function-syntax">e</span><span class="plain-syntax">s m</span><span class="function-syntax">ou</span><span class="plain-syntax">ch</span><span class="function-syntax">e</span><span class="plain-syntax">s écl</span><span class="function-syntax">a</span><span class="plain-syntax">t</span><span class="function-syntax">a</span><span class="plain-syntax">nt</span><span class="function-syntax">e</span><span class="plain-syntax">s</span>
<span class="plain-syntax">Q</span><span class="function-syntax">ui</span><span class="plain-syntax"> b</span><span class="function-syntax">o</span><span class="plain-syntax">mb</span><span class="function-syntax">i</span><span class="plain-syntax">n</span><span class="function-syntax">e</span><span class="plain-syntax">nt </span><span class="function-syntax">au</span><span class="plain-syntax">t</span><span class="function-syntax">ou</span><span class="plain-syntax">r d</span><span class="function-syntax">e</span><span class="plain-syntax">s p</span><span class="function-syntax">ua</span><span class="plain-syntax">nt</span><span class="function-syntax">eu</span><span class="plain-syntax">rs cr</span><span class="function-syntax">ue</span><span class="plain-syntax">ll</span><span class="function-syntax">e</span><span class="plain-syntax">s,</span>
</pre>
<div class="lsmarkdown">
<p>If you're reading this in a woven form which can display coloured text, then
each example of a <code>colouring</code> program will be followed by a demonstration,
like that one. Here for example is some Rust code, using the definition
drawn up in <a href="5-cl.html" class="internal">Creating Languages</a>:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">fn</span><span class="plain-syntax"> </span><span class="identifier-syntax">main</span><span class="plain-syntax">() {</span>
<span class="plain-syntax">    </span><span class="comment-syntax">// Iterate over all integers from 1 to 10</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">let</span><span class="plain-syntax"> </span><span class="reserved-syntax">mut</span><span class="plain-syntax"> </span><span class="identifier-syntax">n</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">while</span><span class="plain-syntax"> </span><span class="identifier-syntax">n</span><span class="plain-syntax"> &lt;= </span><span class="constant-syntax">10</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">         </span><span class="element-syntax">println!</span><span class="plain-syntax">(</span><span class="string-syntax">"n = {n} of 10"</span><span class="plain-syntax">); </span><span class="comment-syntax">/* note use of a macro, not a function */</span>
<span class="plain-syntax">         </span><span class="identifier-syntax">n</span><span class="plain-syntax"> += </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="element-syntax">println!</span><span class="plain-syntax">(</span><span class="string-syntax">"1e4 is {}, -2.5e-3 is {}"</span><span class="plain-syntax">, </span><span class="constant-syntax">1e4</span><span class="plain-syntax">, </span><span class="constant-syntax">-2.5e-3</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="element-syntax">println!</span><span class="plain-syntax">(</span><span class="string-syntax">"true is {}, false is {}"</span><span class="plain-syntax">, </span><span class="constant-syntax">true</span><span class="plain-syntax">, </span><span class="constant-syntax">false</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="element-syntax">println!</span><span class="plain-syntax">(</span><span class="string-syntax">"4.5_f64 is {}, 0x3ef5u128 is {}"</span><span class="plain-syntax">, </span><span class="constant-syntax">4.5_f64</span><span class="plain-syntax">, </span><span class="constant-syntax">0x3ef5u128</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<h2>Colours</h2>
<p>Inweb supports the following &quot;colours&quot;. How they correspond to actual colours
or styles visible to the eventual reader is not something that a language
definition can control: that's done with, say, CSS files in weave patterns
(see <a href="6-ap.html" class="internal">About Patterns</a>). So rather than &quot;green&quot; or &quot;blue&quot;, Inweb colours
are named semantically, from the following palette of possibilities:</p>
<table>
<thead>
<tr>
<th>Inweb colour</th>
<th>Letter</th>
<th>CSS class name</th>
<th>Suggested use</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>!character</code></td>
<td><code>c</code></td>
<td><code>character-syntax</code></td>
<td>character literals, e.g., <code>'c'</code></td>
</tr>
<tr>
<td><code>!comment</code></td>
<td><code>!</code></td>
<td><code>comment-syntax</code></td>
<td>comments, e.g. <code>/* thus */</code></td>
</tr>
<tr>
<td><code>!constant</code></td>
<td><code>n</code></td>
<td><code>constant-syntax</code></td>
<td>literal numbers, e.g., <code>-130</code></td>
</tr>
<tr>
<td><code>!definition</code></td>
<td><code>d</code></td>
<td><code>definition-syntax</code></td>
<td>definitions, e.g., <code>#define THIS</code></td>
</tr>
<tr>
<td><code>!element</code></td>
<td><code>e</code></td>
<td><code>element-syntax</code></td>
<td>structure elements, e.g., <code>.ID_number</code></td>
</tr>
<tr>
<td><code>!extract</code></td>
<td><code>x</code></td>
<td><code>extract-syntax</code></td>
<td>backticked Markdown code in commentary</td>
</tr>
<tr>
<td><code>!function</code></td>
<td><code>f</code></td>
<td><code>function-syntax</code></td>
<td>function names, e.g., <code>main</code></td>
</tr>
<tr>
<td><code>!type</code></td>
<td><code>t</code></td>
<td><code>type-syntax</code></td>
<td>type names, e.g., <code>u32</code></td>
</tr>
<tr>
<td><code>!identifier</code></td>
<td><code>i</code></td>
<td><code>identifier-syntax</code></td>
<td>variable names</td>
</tr>
<tr>
<td><code>!plain</code></td>
<td><code>p</code></td>
<td><code>plain-syntax</code></td>
<td>punctuation and white space, e.g., <code>&amp;</code></td>
</tr>
<tr>
<td><code>!reserved</code></td>
<td><code>r</code></td>
<td><code>reserved-syntax</code></td>
<td>reserved words, e.g., <code>while</code></td>
</tr>
<tr>
<td><code>!string</code></td>
<td><code>s</code></td>
<td><code>string-syntax</code></td>
<td>string literals, e.g., <code>&quot;blue dot&quot;</code></td>
</tr>
</tbody>
</table>
<p>The examples in the suggested use column are all from the C language; but
colouring programs give a language definition a lot of freedom in assigning
these colours to different globs of characters.</p>
<h2>If there is no colouring program...</h2>
<p>Note that a simple text display, like this one:</p>
<pre><code>My memory takes me back across the interval of fifty years to a little
ill-lit room with a sash window open to a starry sky, and instantly
there returns to me the characteristic smell of that room, the
penetrating odor of an ill-trimmed lamp, burning cheap paraffin.
</code></pre>
<p>will be coloured <code>!plain</code> throughout. This effect could be duplicated by:</p>
<pre><code>Language &quot;Colourless&quot; {
	colouring
		=&gt; !plain
	end
}
</code></pre>
<p>Code for a completely bare language like:</p>
<pre><code>Language &quot;Bland&quot; {
}
</code></pre>
<p>will get a little fancier treatment, but only a little. The following is
rendered as <code>Bland</code>:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">let</span><span class="plain-syntax"> </span><span class="identifier-syntax">individualScores</span><span class="plain-syntax"> = [75, </span><span class="constant-syntax">43</span><span class="plain-syntax">, </span><span class="constant-syntax">103</span><span class="plain-syntax">, </span><span class="constant-syntax">87</span><span class="plain-syntax">, </span><span class="constant-syntax">12</span><span class="plain-syntax">]</span>
<span class="identifier-syntax">var</span><span class="plain-syntax"> </span><span class="identifier-syntax">teamScore</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span>
<span class="identifier-syntax">for</span><span class="plain-syntax"> </span><span class="identifier-syntax">score</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">individualScores</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">teamScore</span><span class="plain-syntax"> += </span><span class="identifier-syntax">score</span>
<span class="plain-syntax">}</span>
<span class="plain-syntax">// </span><span class="identifier-syntax">sums</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">individual</span><span class="plain-syntax"> </span><span class="identifier-syntax">scores</span>
</pre>
<div class="lsmarkdown">
<p>and uses only a few colours: <code>!constant</code> on the decimal numbers, <code>!identifier</code> on
the things looking like words, and <code>!plain</code> on everything else. The result is
better than nothing, but not very much better.</p>
<h2>How Inweb colours code</h2>
<p>This works in three stages:</p>
<ol>
<li>
<p>Inweb uses the language's comment syntax to work out what part of the code is
commentary, and what part is &quot;live&quot;. Only the live part goes forward into stage
two. Live material is coloured <code>!plain</code>, and comment material is coloured <code>!comment</code>.</p>
</li>
<li>
<p>Inweb tries to read literal constants. Character literals are painted in
<code>!character</code>, string literals in <code>!string</code>, identifiers in <code>!identifier</code>, and
numeric literals as <code>!constant</code>. The live material can now have up to five
colours: these four and <code>!plain</code>.</p>
</li>
<li>
<p>Inweb runs the <code>colouring</code> program for the language (if one is provided):
this has the opportunity to apply some polish. Note that this runs only on
the live material; it cannot affect the commented-out matter identified by stage 1.
When the program finishes, every colour can appear in the live material (including,
if the program really insists, <code>!comment</code>).</p>
</li>
</ol>
<h2>Colouring programs</h2>
<p>These always begin with a line reading just <code>colouring</code>, and end with a line
reading just <code>end</code>. The empty colouring program is legal:</p>
<pre><code>colouring
end
</code></pre>
<p>This makes stage 3 ineffective, and thus is equivalent to not to having a
colouring program at all.</p>
<p>The material in between is called a <em>block</em>. Each block runs on a
given stretch of contiguous text, called the <em>snippet</em>. For the outermost
block, that's a line of source code. Blocks normally contain one or more
<em>rules</em>:</p>
<pre><code>colouring
    marble =&gt; !function
end
</code></pre>
<p>Rules take the form of &quot;if X, then Y&quot;, and the <code>=&gt;</code> divides the X from the Y.
This one says that if the snippet consists of the word &quot;marble&quot;, then colour
it <code>!function</code>. Of course this is not very useful, since it would only catch
lines containing only that one word. So we really want to narrow in on smaller
snippets. This, for example, applies its rule to each individual character
in turn:</p>
<pre><code>colouring
    characters {
        K =&gt; !identifier
    }
end
</code></pre>
<p>In the above examples, <code>K</code> and <code>marble</code> appeared without quotation marks,
but they were only allowed to do that because (a) they were single words,
(b) those words had no other meaning, and (c) they didn't contain any
awkward characters. For any more complicated texts, always use quotation
marks. For example, in</p>
<pre><code>&quot;=&gt;&quot; =&gt; !reserved
</code></pre>
<p>the <code>=&gt;</code> in quotes is just text, whereas the one outside quotes is being
used to divide a rule.</p>
<p>If you need a literal double quote inside the double-quotes, use <code>\&quot;</code>; and
use <code>\\</code> for a literal backslash. For example:</p>
<pre><code>&quot;\\\&quot;&quot; =&gt; !reserved
</code></pre>
<p>actually matches the text <code>\&quot;</code>.</p>
<h3>The six splits</h3>
<p><code>characters</code> is an example of a <em>split</em>, which splits up the original snippet
of text — say, the line <code>let K = 2</code> — into smaller, non-overlapping snippets
— in this case, nine of them: <code>l</code>, <code>e</code>, <code>t</code>, <code> </code>, <code>K</code>, <code> </code>, <code>=</code>, <code> </code>, and <code>2</code>.</p>
<p>Every split is followed by a block of rules, which is applied to each of the
pieces in turn. Inweb works sideways-first: thus, if the block contains rules
R1, R2, ..., then R1 is applied to each piece first, then R2 to each piece,
and so on.</p>
<p>There are several different ways to split, all of them written in the
plural, to emphasize that they work on what are usually multiple things.
Rules, on the other hand, are written in the singular. Splits are not allowed
to be followed by <code>=&gt;</code>: they always begin a block.</p>
<ol>
<li>
<p><code>characters</code> splits the snippet into each of its characters.</p>
</li>
<li>
<p><code>characters in T</code> splits the snippet into each of its characters which
lie inside the text <code>T</code>.</p>
</li>
<li>
<p><code>instances of X</code> narrows in on each usage of the text <code>X</code> inside the snippet.</p>
</li>
<li>
<p><code>runs of !C</code>, where <code>!C</code> describes a colour, splits the snippet
into non-overlapping contiguous pieces which currently have that colour.
As a special form, <code>runs of unquoted</code> means &quot;runs of characters not painted
either with <code>!string</code> or <code>!character</code>&quot;.</p>
</li>
<li>
<p><code>matches of /E/</code>, where <code>/E/</code> is a regular expression (see below),
splits the snippet up into non-overlapping pieces which match it. (If
there is no match, nothing happens.)</p>
</li>
<li>
<p><code>brackets in /E/</code> matches the snippet against the regular expression <code>E</code>,
and then runs the rules on each bracketed subexpression in turn. (If there
is no match, or there are no bracketed terms in <code>E</code>, nothing happens.)</p>
</li>
</ol>
<p>Demonstrations are probably clearer than elaborate descriptions. <code>characters</code>
was shown above, and <code>characters in T</code> has also been seen before in this chapter:</p>
<pre><code>colouring
	=&gt; !plain
	characters in &quot;AEIOUaeiou&quot; {
		=&gt; !function
	}
end
</code></pre>
<p>Note that it splits the line up into characters, but ignores all those characters
not found in the text, i.e., all the non-vowels. That doesn't destroy them, because
the next rule could always split the line differently:</p>
<pre><code>colouring
	=&gt; !plain
	characters in &quot;AEIOUaeiou&quot; {
		=&gt; !function
	}
	characters in &quot;Yy&quot; {
		=&gt; !element
	}
end
</code></pre>
<p><code>instances of X</code> splits into potentially larger snippets. For example,</p>
<pre><code>colouring
	=&gt; !plain
	instances of &quot;son&quot; {
		=&gt; !function
	}
end
</code></pre>
<p>might produce:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">Jacob first appears in Genesis chapter 25, the </span><span class="function-syntax">son</span><span class="plain-syntax"> of Isaac and Rebecca, the</span>
<span class="plain-syntax">grand</span><span class="function-syntax">son</span><span class="plain-syntax"> of Abraham, Sarah and Bethuel, the nephew of Ishmael.</span>
</pre>
<div class="lsmarkdown">
<p>The first rule makes everything <code>!plain</code>, wiping the slate clean from anything
done by Stage 2 (and in particular preventing the <code>25</code> from being coloured
as <code>!constant</code>). The second rule says that all instances of <code>son</code>, including
in the word <code>grandson</code>, should be coloured <code>!function</code>.</p>
<p>Note that <code>instances of</code> never runs in an overlapping way: the snippet <code>===</code> would be
considered as having only one instance of <code>==</code> (the first two characters),
while <code>====</code> would have two.</p>
<p>As an example of <code>runs of !C</code>, where <code>!C</code> describes a colour, consider:</p>
<pre><code>colouring
	=&gt; !plain
	characters in &quot;0123456789&quot; {
		=&gt; !function
	}
	runs of !plain {
		&quot;-&quot; =&gt; !function
	}
end
</code></pre>
<p>which has this effect:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">Napoleon Bonaparte (</span><span class="function-syntax">1769-1821</span><span class="plain-syntax">) took </span><span class="function-syntax">167</span><span class="plain-syntax"> scientists to Egypt in </span><span class="function-syntax">1798</span><span class="plain-syntax">,</span>
<span class="plain-syntax">who published their so-called Memoirs over the period </span><span class="function-syntax">1798-1801</span><span class="plain-syntax">.</span>
</pre>
<div class="lsmarkdown">
<p>Here the hyphens in number ranges have been coloured, but not the hyphen
in &quot;so-called&quot;. That's because the runs in this text (at the time the <code>runs of</code>
rule is reached) are:</p>
<ul>
<li><code>Napoleon Bonaparte (</code> of <code>!plain</code></li>
<li><code>1769</code> of <code>!function</code></li>
<li><code>-</code> of <code>!plain</code></li>
<li><code>1821</code> of <code>!function</code></li>
<li><code>) took </code> of <code>!plain</code></li>
<li><code>167</code> of <code>!function</code></li>
<li><code>scientists to Egypt in</code> of <code>!plain</code></li>
<li><code>1798</code> of <code>!function</code></li>
<li><code>,</code> of <code>!plain</code></li>
<li><code>who published their so-called Memoirs over the period </code> of <code>!plain</code></li>
<li><code>1798</code> of <code>!function</code></li>
<li><code>-</code> of <code>!plain</code></li>
<li><code>1801</code> of <code>!function</code></li>
<li><code>.</code> of <code>!plain</code></li>
</ul>
<p>Thus the two hyphens occurring in the date ranges occupy entire runs, but
the one in &quot;so-called&quot; does not.</p>
<p>A more computer-science sort of example would be:</p>
<pre><code>colouring
	runs of !identifier {
		printf =&gt; !function
		sscanf =&gt; !function
	}
end
</code></pre>
<p>which might produce:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">x</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) </span><span class="function-syntax">printf</span><span class="plain-syntax">("</span><span class="identifier-syntax">Hello</span><span class="plain-syntax">!");</span>
</pre>
<div class="lsmarkdown">
<p>The split finds three runs of identifiers: <code>if</code>, then <code>x</code>, then <code>printf</code>. Only
the third is coloured as <code>!function</code>, because only the third matches one of the
rules inside the <code>runs of</code> block.</p>
<p>The split <code>matches of /E/</code> brings in regular expressions for the first time.
For example:</p>
<pre><code>colouring
	matches of /\.[A-Za-z_][A-Za-z_0-9]*/ {
		=&gt; !function
	}
end
</code></pre>
<p>says that a literal full stop, followed by a letter or underscore, and then
any number (including 0) of letters, digits or underscores, should be painted
as <code>!function</code>. As it happens, that's customary notation for labels in some
forms of assembly language:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">JSR</span><span class="plain-syntax"> </span><span class="function-syntax">.initialise</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LDR</span><span class="plain-syntax"> </span><span class="identifier-syntax">A</span><span class="plain-syntax">, #</span><span class="function-syntax">.data</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">RTS</span>
<span class="function-syntax">.initialise</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TAX</span>
</pre>
<div class="lsmarkdown">
<p>Regular expressions are beloved by many programmers for their extreme
conciseness, and are despaired of by others for the same reason. Unpacking
<code>/\.[A-Za-z_][A-Za-z_0-9]*/</code> as a human reader, one must first remove the
<code>/</code> at start and end <code>/</code>. These are delimiters, that is, they say when the
expression starts and finishes, but they are not part of it, in the same way
that the quotation marks around &quot;brass&quot; there are not part of the word brass.
That leaves:</p>
<ol>
<li><code>\.</code> means &quot;match only a literal <code>.</code>&quot; — the backslash <code>\</code> is needed because
<code>.</code> has a special meaning for regular expressions (it matches any character,
and we certainly don't want that here); then</li>
<li><code>[A-Za-z_]</code> means &quot;match any character between <code>A</code> and <code>Z</code> inclusive, or
any character between <code>a</code> and <code>z</code> inclusive, or an underscore <code>_</code>; then</li>
<li><code>[A-Za-z_0-9]*</code> is similar, but also allowing the digits <code>0</code> to <code>9</code>, except
that it has the magic <code>*</code> star at the end: this means &quot;repeated 0 or more times&quot;.</li>
</ol>
<p>So for example <code>.check_6845_registers</code> matches: <code>.</code> matches (1), then <code>c</code> matches (2),
then <code>heck_6845_registers</code> matches (3), with the <code>*</code> operator counting up to 19.</p>
<p>Lastly, <code>brackets in /E/</code>:</p>
<pre><code>colouring
	=&gt; !plain
	brackets in /.*?([A-Z])\s*=\s*(\d+).*/ {
		=&gt; !function
	}
end
</code></pre>
<p>producing:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">A</span><span class="plain-syntax"> = </span><span class="function-syntax">2716</span>
<span class="plain-syntax">    </span><span class="function-syntax">B</span><span class="plain-syntax">=</span><span class="function-syntax">3</span>
<span class="plain-syntax">    </span><span class="function-syntax">C</span><span class="plain-syntax"> =</span><span class="function-syntax">715</span><span class="plain-syntax"> + B</span>
<span class="plain-syntax">    D &lt; 14</span>
</pre>
<div class="lsmarkdown">
<p>The regexp here, <code>/.*?([A-Z])\s*=\s*(\d+).*/</code>, involves further hieroglyphics:</p>
<ol>
<li><code>.*?</code> means any character at all (<code>.</code>), repeated 0 or more times (<code>*</code>), but
taking as few repeats as possible consistent with matching everything (<code>?</code>).</li>
<li><code>([A-Z])</code> is in round brackets <code>(</code> and <code>)</code>, which means it is a subexpression.
Anything matched in it is one of the <code>brackets</code> we referred to above. What
does match? Any single upper-case letter between <code>A</code> and <code>Z</code> inclusive.</li>
<li><code>\s*</code> means 0 or more repetitions of <code>\s</code>, which means any space or tab.</li>
<li><code>=</code> is easy for once: it matches a literal equals sign <code>=</code>.</li>
<li><code>\s*</code>: see (3).</li>
<li><code>(\d+)</code> is our second subexpression. Inside must be 1 more repetitions
(this is what <code>+</code> means: it is like <code>*</code> but does not allow 0) of <code>\d</code>,
which means the same thing as <code>[0-9]</code>: that is, a decimal digit.</li>
<li><code>.*</code> means 0 or more repetitions of any character: which effectively means
&quot;any text at all&quot;, including the empty text.</li>
</ol>
<p>So for example <code>C =715 + B</code> matches because: the empty text matches (1);
<code>C</code> matches (2); <code> </code> matches (3); <code>=</code> matches (4); the empty text matches (5);
<code>715</code> matches (6); and <code> + B</code> matches (7). Thus we fully match the regexp
against the source text.</p>
<p>Partly for reasons of speed, the regular expression engine used by Inweb here
is a limited one, compared to some of the behemoths available in many modern
programming languages. It's probably wise to stick to the features used in
these two examples. Note that Inweb does not have <code>^</code> (start of text marker)
and <code>$</code> (end of text marker), because Inweb always requires the match to be
from the start of the snippet to the end of the snippet. The text <code>red beachball</code>
does <em>not</em> match the regular expression <code>/beach/</code>. Only <code>beach</code> matches <code>/beach/</code>.</p>
<h3>The seven ways rules can apply</h3>
<p>Rules are the lines with a <code>=&gt;</code> in. As noted, they take the form &quot;if X, then
Y&quot;. The following are the possibilities for X, the condition.</p>
<p>(1) The easiest thing is to give nothing at all, and then the rule always
applies. As we've seen, this nihilistic program gets rid of colouring entirely:</p>
<pre><code>colouring
    =&gt; !plain
end
</code></pre>
<p>(2) If X is a piece of literal text, the rule applies when the snippet is
exactly that text. For example,</p>
<pre><code>printf =&gt; !function
</code></pre>
<p>(3) X can require the whole snippet to be of a particular colour, by writing
<code>coloured !C</code> (or <code>colored !C</code>). For example:</p>
<pre><code>colouring
    characters {
        coloured !character =&gt; !plain
    }
end
</code></pre>
<p>removes the syntax colouring on character literals.</p>
<p>(4) X can require the snippet to be one of the language's known keywords, as
declared earlier in the ILD by a <code>keyword</code> command. The syntax here is
<code>keyword of !C</code>, where <code>!C</code> is a colour. For example:</p>
<pre><code>keyword of !element =&gt; !element
</code></pre>
<p>says: if the snippet is a keyword declared as being of colour <code>!element</code>,
then actually colour it that way. (This is much faster than making many
comparison rules in a row, one for each keyword in the language; Inweb has
put all of the registered keywords into a hash table for rapid lookup.)</p>
<p>(5) X can look at a little context before or after the snippet, testing it
with one of the following: <code>prefix P</code>, <code>spaced prefix P</code>,
<code>optionally spaced prefix P</code>. For example, consider this:</p>
<pre><code>runs of !identifier {
    prefix % =&gt; !element
}
</code></pre>
<p>applied to the text <code>%total += %price</code>. The two runs of <code>!identifier</code> here
are <code>total</code> and <code>price</code>, but the condition <code>prefix %</code> is able to look at
the character occurring in the original line <em>before</em> the snippet, to see
if it is <code>%</code> or not. In both cases it is, so the colour is applied... but
only to the words <code>total</code> and <code>price</code>, not to the percentage signs as well.
Changing the rule to:</p>
<pre><code>    prefix % =&gt; !element on both
</code></pre>
<p>would colour the percentage signs (i.e., the prefixes) as well.</p>
<p>Another variation of this is to do with whether white space must appear
between the prefix and the snippet. For example,</p>
<pre><code>    spaced prefix £ =&gt; !element
</code></pre>
<p><em>requires</em> white space, and means that <code>£ discount</code> matches, but that
<code>£discount</code> does not. This is not the same thing as</p>
<pre><code>    prefix &quot;£ &quot; =&gt; !element
</code></pre>
<p>because that would not match <code>£      discount</code>. The white space implied by
<code>spaced</code> can be any run of 1 or more spaces and tabs.</p>
<pre><code>    optionally spaced prefix £ =&gt; !element
</code></pre>
<p>makes that &quot;0 or more&quot;, and matches <code>£ discount</code> or <code>£discount</code> equally.</p>
<p>And of course all of these work analogously for <code>suffix</code>. Note that these
cannot see the line before or after the current line: only material also
appearing on the same original line.</p>
<p>(6) X can test the snippet against a regular expression, with <code>matching /E/</code>.
For example:</p>
<pre><code>runs of !identifier {
    matching /.*x.*/ =&gt; !element
}
</code></pre>
<p>...turns any identifier containing a lower-case <code>x</code> into <code>!element</code> colour.
Note that <code>matching /x/</code> would not have worked, because our regular expression
is required to match the entire snippet, not just somewhere inside.</p>
<pre><code>characters in &quot;0123456789&quot; {
	=&gt; !element
}
runs of !element {
	=&gt; !plain
    matching /\d\d\d\d/ =&gt; !element
}
</code></pre>
<p>...colours all four-digit numbers <code>!element</code>, and all other decimal digits <code>!plain</code>.</p>
<p>(7) Whenever a split takes place, Inweb keeps count of how many pieces there are,
and different rules can apply to differently numbered pieces. The notation
is <code>number N</code>, where <code>N</code> is the number, counting from 1. For example,</p>
<pre><code>colour !emphasised like !function
colouring
	=&gt; !plain
	matches of /\S+/ {
		number 3 =&gt; !emphasised
	}
end
</code></pre>
<p>applies colour to every third word (where by word we mean &quot;run of non-whitespace
characters&quot;, since that's what <code>\S</code> means in regexp language). For example:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">With how </span><span class="function-syntax">sad</span><span class="plain-syntax"> steps, O Moon, thou climb'st the skies!</span>
<span class="plain-syntax">How silently, </span><span class="function-syntax">and</span><span class="plain-syntax"> with how wan a face!</span>
<span class="plain-syntax">What, may </span><span class="function-syntax">it</span><span class="plain-syntax"> be that even in heav'nly place</span>
<span class="plain-syntax">That busy </span><span class="function-syntax">archer</span><span class="plain-syntax"> his sharp arrows tries!</span>
<span class="plain-syntax">Sure, if </span><span class="function-syntax">that</span><span class="plain-syntax"> long-with love-acquainted eyes</span>
<span class="plain-syntax">Can judge </span><span class="function-syntax">of</span><span class="plain-syntax"> love, thou feel'st a lover's case,</span>
<span class="plain-syntax">I read </span><span class="function-syntax">it</span><span class="plain-syntax"> in thy looks; thy languish'd grace</span>
<span class="plain-syntax">To me, </span><span class="function-syntax">that</span><span class="plain-syntax"> feel the like, thy state descries.</span>
<span class="plain-syntax">Then, ev'n </span><span class="function-syntax">of</span><span class="plain-syntax"> fellowship, O Moon, tell me,</span>
<span class="plain-syntax">Is constant </span><span class="function-syntax">love</span><span class="plain-syntax"> deem'd there but want of wit?</span>
<span class="plain-syntax">Are beauties </span><span class="function-syntax">there</span><span class="plain-syntax"> as proud as here they be?</span>
<span class="plain-syntax">Do they </span><span class="function-syntax">above</span><span class="plain-syntax"> love to be lov'd, and yet</span>
<span class="plain-syntax">Those lovers </span><span class="function-syntax">scorn</span><span class="plain-syntax"> whom that love doth possess?</span>
<span class="plain-syntax">Do they </span><span class="function-syntax">call</span><span class="plain-syntax"> virtue there ungratefulness?</span>
</pre>
<div class="lsmarkdown">
<p>We can also cycle through a set of possibilities with <code>number N of M</code>,
where this time the count runs 1, 2, ..., <code>M</code>, 1, 2, ..., <code>M</code>, 1, ... and
so on. Thus <code>number 1 of 3</code> would work on the 1st, 4th, 7th, ... times;
<code>number 2 of 3</code> on the 2nd, 5th, 8th, ...; <code>number 3 of 3</code> on the 3rd, 6th,
9th, and so on. This, for example, paints the output from the painting
algorithm in Inweb:</p>
<pre><code>colouring
	number 1 of 2 =&gt; !plain
	number 2 of 2 =&gt; {
		characters {
			&quot;!&quot; =&gt; !comment
			&quot;c&quot; =&gt; !character
			&quot;d&quot; =&gt; !definition
			&quot;e&quot; =&gt; !element
			&quot;f&quot; =&gt; !function
			&quot;i&quot; =&gt; !identifier
			&quot;n&quot; =&gt; !constant
			&quot;p&quot; =&gt; !plain
			&quot;r&quot; =&gt; !reserved
			&quot;s&quot; =&gt; !string
			&quot;x&quot; =&gt; !extract
		}
	}
end
</code></pre>
<p>The result is that lines 1, 3, 5, ... are run through <code>=&gt; !plain</code>, while
lines 2, 4, 6, ... are run through a more complicated colouring.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    int x = 55; /* a magic number */</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">rrr</span><span class="plain-syntax">p</span><span class="identifier-syntax">i</span><span class="plain-syntax">ppp</span><span class="constant-syntax">nn</span><span class="plain-syntax">pp</span><span class="comment-syntax">!!!!!!!!!!!!!!!!!!!!</span>
<span class="plain-syntax">    Imaginary::function(x, beta);</span>
<span class="plain-syntax">    </span><span class="function-syntax">fffffffffffffffffff</span><span class="plain-syntax">p</span><span class="identifier-syntax">i</span><span class="plain-syntax">pp</span><span class="identifier-syntax">iiii</span><span class="plain-syntax">pp</span>
</pre>
<div class="lsmarkdown">
<p>Any condition can be reversed by preceding it with <code>not</code>. For example,</p>
<pre><code>not coloured !string =&gt; !plain
</code></pre>
<h3>The three ways rules can take effect</h3>
<p>Now let's look at the conclusion Y of a rule. Here the possibilities are
simpler:</p>
<p>(1) If Y is the name of a colour, the snippet is painted in that colour.
For prefix or suffix rules (see above), it can also be applied to the
prefix or suffix as well: use the notation <code>=&gt; C on both</code> or <code>=&gt; C on suffix</code>
or <code>=&gt; C on prefix</code>.</p>
<p>(2) If Y is an open brace <code>{</code>, then it introduces a block of rules which are
applied to the snippet only if this rule has matched. For example,</p>
<pre><code>keyword !element =&gt; {
    optionally spaced prefix . =&gt; !element
    optionally spaced prefix -&gt; =&gt; !element
}
</code></pre>
<p>means that if the original condition <code>keyword !element</code> applies, then two
further rules are applied.</p>
<p>(3) If Y is the word <code>debug</code>, then the current snippet and its colouring
are printed out on the command line. Thus:</p>
<pre><code>colouring
    matches of /\d\S+/ {
        =&gt; debug
    }
end
</code></pre>
<p>The rule <code>=&gt; debug</code> is unconditional, and will print whenever it's reached.</p>
</div>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="5-hacb.html">&#10094;</a></li><li class="progresschapter"><a href="1-gs.html">1</a></li><li class="progresschapter"><a href="2-cp.html">2</a></li><li class="progresschapter"><a href="3-cln.html">3</a></li><li class="progresschapter"><a href="4-an.html">4</a></li><li class="progresscurrentchapter">5</li><li class="progresssection"><a href="5-al.html">al</a></li><li class="progresssection"><a href="5-cl.html">cl</a></li><li class="progresssection"><a href="5-hacb.html">hacb</a></li><li class="progresscurrent">scp</li><li class="progresssection"><a href="5-rfat.html">rfat</a></li><li class="progresssection"><a href="5-scf.html">scf</a></li><li class="progresssection"><a href="5-sol.html">sol</a></li><li class="progresschapter"><a href="6-ap.html">6</a></li><li class="progresschapter"><a href="7-bn.html">7</a></li><li class="progressnext"><a href="5-rfat.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

