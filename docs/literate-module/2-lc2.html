<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Line Classifiers</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html"><img src="../docs-assets/Octagram.png" height=72> </a></h1>
<ul><li><a href="../inweb/index.html">inweb</a></li>
</ul><h2>Foundation Modules</h2><ul>
<li><a href="../foundation-module/index.html">foundation</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
<li><a href="index.html"><span class="selectedlink">literate</span></a></li>
<li><a href="../literate-test/index.html">literate-test</a></li>
</ul><h2>Documentation</h2><ul>
<li><a href="../guide/index.html">guide</a></li>
</ul><h2>Example Webs</h2><ul>
<li><a href="../goldbach/index.html">goldbach</a></li>
<li><a href="../twinprimes/twinprimes.html">twinprimes</a></li>
<li><a href="../eastertide/index.html">eastertide</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> inform</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Line Classifiers' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">literate</a></li><li><a href="index.html#2">Chapter 2: Literate Code</a></li><li><b>Line Classifiers</b></li></ul></div>
<p class="purpose">Simple matching grammars to decide what LP content is present in a given text.</p>

<ul class="toc"><li><a href="2-lc2.html#SP1">&#167;1. Classifiers</a></li><li><a href="2-lc2.html#SP2">&#167;2. Rules</a></li><li><a href="2-lc2.html#SP3">&#167;3. Parsing</a></li><li><a href="2-lc2.html#SP5">&#167;5. Matching</a></li><li><a href="2-lc2.html#SP6">&#167;6. Conditions</a></li><li><a href="2-lc2.html#SP9">&#167;9. Patterns</a></li><li><a href="2-lc2.html#SP13">&#167;13. Outcomes and their options</a></li></ul><hr class="tocbar">

<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Classifiers.</b>  A line classifier is really just a list of rules:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_classifier</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">linked_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">rules</span><span class="plain-syntax">; </span><span class="comment-syntax">/* of |ls_notation_rule| */</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_classifier</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_classifier</span><span class="plain-syntax"> *</span><span class="function-syntax">LineClassifiers::new</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::new</span></span>:<br/>Web Notations - <a href="2-wn.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_classifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="type-syntax">ls_classifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">lc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">rules</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NEW_LINKED_LIST</span><span class="plain-syntax">(</span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">lc</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::add_rule</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::add_rule</span></span>:<br/><a href="2-lc2.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_classifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lc</span><span class="plain-syntax">, </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ADD_TO_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">R</span><span class="plain-syntax">, </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax">, </span><span class="identifier-syntax">lc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">rules</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_classifier is accessed in 3/pl, 3/tp and here.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Rules.</b>  Each rule consists of three pieces: a condition, which has to hold for the match
to be allowed at all; a textual pattern which the line has to match; and then
the result if the rule should succeed.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax">; </span><span class="comment-syntax">/* provided this is met... */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;     </span><span class="comment-syntax">/* and the line matches this... */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">;     </span><span class="comment-syntax">/* then we classify like so */</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="function-syntax">LineClassifiers::new_rule</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::new_rule</span></span>:<br/><a href="2-lc2.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">, </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">condition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">outcome</span><span class="plain-syntax"> = </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">pattern</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_notation_rule is accessed in 1/cln, 2/lc, 5/ts, 5/tc, 5/fm, 5/hf and here.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. Parsing.</b>  The following takes pattern text <code>pt</code> and tail text <code>tail</code>, and either adds
a valid rule to the classifier and returns <code>NULL</code>, or does nothing and returns
a non-empty error message as text.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="function-syntax">LineClassifiers::parse_rule</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::parse_rule</span></span>:<br/>Web Notations - <a href="2-wn.html#SP14_4">&#167;14.4</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_classifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lc</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tail</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP6" class="function-link"><span class="function-syntax">LineClassifiers::truth_condition</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">tail</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(%c+) if (%c+)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">tail</span><span class="plain-syntax"> = </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0];</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">condition</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP7" class="function-link"><span class="function-syntax">LineClassifiers::parse_condition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1], &amp;</span><span class="identifier-syntax">error</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">error</span><span class="plain-syntax">) == </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP13" class="function-link"><span class="function-syntax">LineClassifiers::parse_outcome</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">tail</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">error</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">error</span><span class="plain-syntax">) == </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP11" class="function-link"><span class="function-syntax">LineClassifiers::parse_pattern</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><a href="1-cnv.html#SP10" class="function-link"><span class="function-syntax">Conventions::generic_set</span></a><span class="plain-syntax">(), &amp;</span><span class="identifier-syntax">error</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">error</span><span class="plain-syntax">) == </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP2" class="function-link"><span class="function-syntax">LineClassifiers::new_rule</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">condition</span><span class="plain-syntax">, </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">, </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><a href="2-lc2.html#SP1" class="function-link"><span class="function-syntax">LineClassifiers::add_rule</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">lc</span><span class="plain-syntax">, </span><span class="identifier-syntax">R</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">error</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. </b>  An annoying subtlety here is that the pattern part of a rule depends on the
conventions in play, and they might have changed since the classifier was first
created. So the following reparses all of the patterns in light of the conventions
currently in force. That shouldn't throw errors, because any errors should have
come up earlier; but, better safe than sorry.</p>
<p>It would be possible to rewrite the matching code so that there was no need for
this reparsing, but that would classify lines more slowly, and speed counts here.
The reparsing is done only once per weave or tangle, so it's costing us basically
nothing in overhead. What must be fast is the matching code applied to every line.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::reparse_patterns_with_new_conventions</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::reparse_patterns_with_new_conventions</span></span>:<br/>Web Notations - <a href="2-wn.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_classifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lc</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">linked_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">R</span><span class="plain-syntax">, </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax">, </span><span class="identifier-syntax">lc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">rules</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">pattern</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP11" class="function-link"><span class="function-syntax">LineClassifiers::parse_pattern</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">parsed_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">error</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">error</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><a href="2-we.html#SP2" class="function-link"><span class="function-syntax">WebErrors::issue_at</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">error</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Matching.</b>  We find the first rule in the list which applies to the given text, and return
it; if none apply, we return <code>NULL</code>. What matches may depend on what has been
classified in previous lines, which forms the <code>context</code>.</p>
<p>If a match is made, then the content of any wildcards is written into the
supplied <code>wildcards</code> array.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">TRACE_LCLASSIFIER</span> <span class="identifier-syntax">FALSE</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_classifier_context</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_class</span><span class="plain-syntax"> *</span><span class="identifier-syntax">previously</span><span class="plain-syntax">; </span><span class="comment-syntax">/* how the previous line was classified */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">single_file</span><span class="plain-syntax">;             </span><span class="comment-syntax">/* is this in a single-file web? */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">whitespace_nature</span><span class="plain-syntax">;       </span><span class="comment-syntax">/* of the current line: a |*_LINESHADE| value */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntn</span><span class="plain-syntax">;     </span><span class="comment-syntax">/* notation currently in use */</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_classifier_context</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="function-syntax">LineClassifiers::match</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::match</span></span>:<br/>Line Classification - <a href="2-lc.html#SP18_2">&#167;18.2</a>, <a href="2-lc.html#SP18_2_2">&#167;18.2.2</a>, <a href="2-lc.html#SP18_2_3">&#167;18.2.3</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_classifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lc</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">full_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_classifier_context</span><span class="plain-syntax"> *</span><span class="identifier-syntax">context</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> **</span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="constant-syntax">TRACE_LCLASSIFIER</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDERR</span><span class="plain-syntax">, </span><span class="string-syntax">"Match %S (wsn %d, pwsn %d, psft %d)\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">full_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">whitespace_nature</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">whitespace_nature</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">follows_title</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">R</span><span class="plain-syntax">, </span><span class="type-syntax">ls_notation_rule</span><span class="plain-syntax">, </span><span class="identifier-syntax">lc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">rules</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-lc2.html#SP8" class="function-link"><span class="function-syntax">LineClassifiers::condition_met</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">condition</span><span class="plain-syntax">), </span><span class="identifier-syntax">context</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-lc2.html#SP12" class="function-link"><span class="function-syntax">LineClassifiers::match_pattern</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">pattern</span><span class="plain-syntax">), </span><span class="identifier-syntax">full_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="constant-syntax">TRACE_LCLASSIFIER</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDERR</span><span class="plain-syntax">, </span><span class="string-syntax">"Success with outcome %d\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">R</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">outcome_ID</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_classifier_context is accessed in 1/cln, 1/ws, 1/sw, 2/ls, 2/lc, 2/hs, 3/pl, 5/ts, 5/apacs, 6/rw, 6/bf and here.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Conditions.</b>  The condition applied to a rule — for example, <code>if following title</code> — is
turned into one of these:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">negated</span><span class="plain-syntax">; </span><span class="comment-syntax">/* if |TRUE|, means we must be not in the given context */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">atomic_condition</span><span class="plain-syntax">; </span><span class="comment-syntax">/* one of the |*_LSNRCAC| values below */</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::truth_condition</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::truth_condition</span></span>:<br/><a href="2-lc2.html#SP3">&#167;3</a>, <a href="2-lc2.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">atomic_condition</span><span class="plain-syntax"> = </span><span class="constant-syntax">ANY_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">negated</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_notation_rule_condition is private to this section.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. </b>  The &quot;atomic conditions&quot; are as follows:</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">ANY_LSNRCAC</span> <span class="constant-syntax">0</span><span class="plain-syntax"> </span><span class="comment-syntax">/* represents "always true" */</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FIRST_LINE_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FIRST_LINE_SF_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FOLLOWING_TITLE_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">DEFINITION_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">EXTRACT_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">HOLON_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">TEXTEXTRACT_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">INDENTED_LSNRCAC</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">PTAG_SUPPORTED_LSNRCAC</span> 
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::parse_condition</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::parse_condition</span></span>:<br/><a href="2-lc2.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> **</span><span class="identifier-syntax">error</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP6" class="function-link"><span class="function-syntax">LineClassifiers::truth_condition</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"not (%c+)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">condition</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP7" class="function-link"><span class="function-syntax">LineClassifiers::parse_condition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">error</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">negated</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">negated</span><span class="plain-syntax">)?</span><span class="identifier-syntax">FALSE:TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">-1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"on first line"</span><span class="plain-syntax">))                </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">FIRST_LINE_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"on first line of only file"</span><span class="plain-syntax">))   </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">FIRST_LINE_SF_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"following title"</span><span class="plain-syntax">))              </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">FOLLOWING_TITLE_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"in definition context"</span><span class="plain-syntax">))        </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">DEFINITION_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"in extract context"</span><span class="plain-syntax">))           </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">EXTRACT_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"in textextract context"</span><span class="plain-syntax">))       </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">TEXTEXTRACT_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"in holon context"</span><span class="plain-syntax">))             </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">HOLON_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"in indented context"</span><span class="plain-syntax">))          </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">INDENTED_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ct</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"paragraph tags supported"</span><span class="plain-syntax">))     </span><span class="identifier-syntax">AC</span><span class="plain-syntax"> = </span><span class="constant-syntax">PTAG_SUPPORTED_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">atomic_condition</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(*</span><span class="identifier-syntax">error</span><span class="plain-syntax">, </span><span class="string-syntax">"unknown condition '%S'"</span><span class="plain-syntax">, </span><span class="identifier-syntax">ct</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">atomic_condition</span><span class="plain-syntax"> = </span><span class="constant-syntax">ANY_LSNRCAC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">condition</span><span class="plain-syntax">.</span><span class="element-syntax">atomic_condition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AC</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. </b>  Whether conditions hold or not depends on the surrounding context:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::condition_met</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::condition_met</span></span>:<br/><a href="2-lc2.html#SP5">&#167;5</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_notation_rule_condition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">condition</span><span class="plain-syntax">, </span><span class="type-syntax">ls_classifier_context</span><span class="plain-syntax"> *</span><span class="identifier-syntax">context</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">top_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">major</span><span class="plain-syntax"> == </span><span class="constant-syntax">UNCLASSIFIED_MAJLC</span><span class="plain-syntax">) </span><span class="identifier-syntax">top_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">condition</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">atomic_condition</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">FIRST_LINE_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">top_flag</span><span class="plain-syntax">) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">FIRST_LINE_SF_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">single_file</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">top_flag</span><span class="plain-syntax">)) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">FOLLOWING_TITLE_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">follows_title</span><span class="plain-syntax">) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">INDENTED_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">whitespace_nature</span><span class="plain-syntax"> == </span><span class="constant-syntax">WHITE_LINESHADE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                (</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">whitespace_nature</span><span class="plain-syntax"> == </span><span class="constant-syntax">BLACK_LINESHADE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">whitespace_nature</span><span class="plain-syntax"> != </span><span class="constant-syntax">BLACK_LINESHADE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                (</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">whitespace_nature</span><span class="plain-syntax"> != </span><span class="constant-syntax">BLACK_LINESHADE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DEFINITION_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-lc.html#SP14" class="function-link"><span class="function-syntax">LineClassification::definition_lines_can_follow</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">major</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">minor</span><span class="plain-syntax">)) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">EXTRACT_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-lc.html#SP14" class="function-link"><span class="function-syntax">LineClassification::extract_lines_can_follow</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">major</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">minor</span><span class="plain-syntax">)) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">TEXTEXTRACT_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="2-lc.html#SP14" class="function-link"><span class="function-syntax">LineClassification::extract_lines_can_follow</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">major</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">minor</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">                (</span><a href="2-lc.html#SP14" class="function-link"><span class="function-syntax">LineClassification::code_lines_can_follow</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">major</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">minor</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">HOLON_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-lc.html#SP14" class="function-link"><span class="function-syntax">LineClassification::code_lines_can_follow</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">major</span><span class="plain-syntax">, </span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">previously</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">minor</span><span class="plain-syntax">)) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PTAG_SUPPORTED_LSNRCAC:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-wn.html#SP8" class="function-link"><span class="function-syntax">WebNotation::supports_paragraph_tags</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">context</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntn</span><span class="plain-syntax">)) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">default:</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">condition</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated</span><span class="plain-syntax">) </span><span class="identifier-syntax">applies</span><span class="plain-syntax"> = </span><span class="identifier-syntax">applies</span><span class="plain-syntax">?</span><span class="identifier-syntax">FALSE:TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">applies</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. Patterns.</b>  Now for the textual pattern. We have a very simple model: the line must,
once trailing whitespace is removed, match a sequence of tokens, each of
which is either fixed wording or a wildcard meaning &quot;one or more characters&quot;.
The wildcards on a given line are numbered from 0, and each can only appear
once; but they need not occur in numerical order, and need not all be present.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">MAX_LSSRTOKENS</span> <span class="plain-syntax">(2*</span><span class="identifier-syntax">NO_DEFINED_LSWILDCARD_VALUES</span><span class="plain-syntax">+1)</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">strip_indents</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">no_tokens</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_srtoken</span><span class="plain-syntax"> </span><span class="identifier-syntax">tokens</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_LSSRTOKENS</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">parsed_from</span><span class="plain-syntax">;</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::new_pattern</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::new_pattern</span></span>:<br/><a href="2-lc2.html#SP11">&#167;11</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">strip_indents</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">parsed_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_notation_rule_pattern is private to this section.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. </b>  So here are the tokens:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_srtoken</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">fixed_content</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">wildcard</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">whitespace</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">nonwhitespace</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">digital</span><span class="plain-syntax">;</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_srtoken</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_srtoken</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::fixed_token</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::fixed_token</span></span>:<br/><a href="2-lc2.html#SP11">&#167;11</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">to</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_srtoken</span><span class="plain-syntax"> </span><span class="identifier-syntax">tok</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">fixed_content</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax">=</span><span class="identifier-syntax">from</span><span class="plain-syntax">; </span><span class="identifier-syntax">j</span><span class="plain-syntax">&lt;=</span><span class="identifier-syntax">to</span><span class="plain-syntax">; </span><span class="identifier-syntax">j</span><span class="plain-syntax">++) </span><span class="identifier-syntax">PUT_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">fixed_content</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> = </span><span class="constant-syntax">-1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">whitespace</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">nonwhitespace</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">digital</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">tok</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="type-syntax">ls_srtoken</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::wildcard_token</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::wildcard_token</span></span>:<br/><a href="2-lc2.html#SP11">&#167;11</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">n</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">n</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">MATERIAL_LSWILDCARD</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">n</span><span class="plain-syntax"> &gt;= </span><span class="identifier-syntax">NO_DEFINED_LSWILDCARD_VALUES</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"wildcard out of range"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_srtoken</span><span class="plain-syntax"> </span><span class="identifier-syntax">tok</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">fixed_content</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> = </span><span class="identifier-syntax">n</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">whitespace</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">nonwhitespace</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tok</span><span class="plain-syntax">.</span><span class="element-syntax">digital</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">tok</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_srtoken is private to this section.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. </b>  The following parses source code such as <code>@enum MATERIAL(NONWHITESPACE) from SECOND</code>
into a <code>ls_notation_rule_pattern</code>.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">MATERIAL_LSWILDCARD</span> <span class="constant-syntax">0</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">SECOND_LSWILDCARD</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">THIRD_LSWILDCARD</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FOURTH_LSWILDCARD</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">OPTIONS_LSWILDCARD</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">RESIDUE_LSWILDCARD</span> 
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::parse_pattern</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::parse_pattern</span></span>:<br/><a href="2-lc2.html#SP3">&#167;3</a>, <a href="2-lc2.html#SP4">&#167;4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">linked_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> **</span><span class="identifier-syntax">error</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP9" class="function-link"><span class="function-syntax">LineClassifiers::new_pattern</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">parsed_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;INDENT&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;INDENT&gt; can be used only at the start of a pattern"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">strip_indents</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;INDENT&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;OPENHOLON&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-cnv.html#SP9" class="function-link"><span class="function-syntax">Conventions::get_textual_from</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="constant-syntax">HOLON_NAME_SYNTAX_LSCONVENTION</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;OPENHOLON&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;CLOSEHOLON&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-cnv.html#SP9" class="function-link"><span class="function-syntax">Conventions::get_textual2_from</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="constant-syntax">HOLON_NAME_SYNTAX_LSCONVENTION</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;CLOSEHOLON&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;OPENFILEHOLON&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-cnv.html#SP9" class="function-link"><span class="function-syntax">Conventions::get_textual_from</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="constant-syntax">FILE_HOLON_NAME_SYNTAX_LSCONVENTION</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;OPENFILEHOLON&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;CLOSEFILEHOLON&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-cnv.html#SP9" class="function-link"><span class="function-syntax">Conventions::get_textual2_from</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="constant-syntax">FILE_HOLON_NAME_SYNTAX_LSCONVENTION</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;CLOSEFILEHOLON&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;OPENTAG&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-cnv.html#SP9" class="function-link"><span class="function-syntax">Conventions::get_textual_from</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="constant-syntax">TAGS_SYNTAX_LSCONVENTION</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;OPENTAG&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;CLOSETAG&gt;"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-cnv.html#SP9" class="function-link"><span class="function-syntax">Conventions::get_textual2_from</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">conventions</span><span class="plain-syntax">, </span><span class="constant-syntax">TAGS_SYNTAX_LSCONVENTION</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;CLOSETAG&gt;"</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PUT_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> + </span><span class="constant-syntax">2</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">MAX_LSSRTOKENS</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"MATERIAL"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">i</span><span class="plain-syntax">) </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::wildcard_token</span></a><span class="plain-syntax">(</span><span class="constant-syntax">MATERIAL_LSWILDCARD</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"MATERIAL"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"SECOND"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">i</span><span class="plain-syntax">) </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::wildcard_token</span></a><span class="plain-syntax">(</span><span class="constant-syntax">SECOND_LSWILDCARD</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"SECOND"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"THIRD"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">i</span><span class="plain-syntax">) </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::wildcard_token</span></a><span class="plain-syntax">(</span><span class="constant-syntax">THIRD_LSWILDCARD</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"THIRD"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"FOURTH"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">i</span><span class="plain-syntax">) </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::wildcard_token</span></a><span class="plain-syntax">(</span><span class="constant-syntax">FOURTH_LSWILDCARD</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"FOURTH"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"OPTIONS"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">i</span><span class="plain-syntax">) </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::wildcard_token</span></a><span class="plain-syntax">(</span><span class="constant-syntax">OPTIONS_LSWILDCARD</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"OPTIONS"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"RESIDUE"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">i</span><span class="plain-syntax">) </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::wildcard_token</span></a><span class="plain-syntax">(</span><span class="constant-syntax">RESIDUE_LSWILDCARD</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"RESIDUE"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"(WHITESPACE)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">-1].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> != </span><span class="identifier-syntax">from</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"(WHITESPACE) can be used only immediately after a wildcard"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">-1].</span><span class="element-syntax">whitespace</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"(WHITESPACE)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"(NONWHITESPACE)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">-1].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> != </span><span class="identifier-syntax">from</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"(NONWHITESPACE) can be used only immediately after a wildcard"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">-1].</span><span class="element-syntax">nonwhitespace</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"(NONWHITESPACE)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"(DIGITS)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">-1].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> != </span><span class="identifier-syntax">from</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"(DIGITS) can be used only immediately after a wildcard"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">-1].</span><span class="element-syntax">digital</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"(DIGITS)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">from</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">; </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">from</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">MAX_LSSRTOKENS</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">++] = </span><a href="2-lc2.html#SP10" class="function-link"><span class="function-syntax">LineClassifiers::fixed_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">)-1);</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">usages</span><span class="plain-syntax">[</span><span class="identifier-syntax">NO_DEFINED_LSWILDCARD_VALUES</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">NO_DEFINED_LSWILDCARD_VALUES</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) </span><span class="identifier-syntax">usages</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">] = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">usages</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">wildcard</span><span class="plain-syntax">]++;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">i</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">+1].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"two consecutive wildcards in pattern"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">NO_DEFINED_LSWILDCARD_VALUES</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">usages</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">] &gt; </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">.</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"wildcards can be used only once each in a pattern"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. </b>  So now we match text against a given pattern:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::match_pattern</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::match_pattern</span></span>:<br/><a href="2-lc2.html#SP5">&#167;5</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">ls_notation_rule_pattern</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">full_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> **</span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="2-lc2.html#SP12_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Reduce the line indentation to allow for &lt;INDENT&gt; markers</span></span><span class="named-paragraph-number">12.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="2-lc2.html#SP12_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Try to find a match against the text</span></span><span class="named-paragraph-number">12.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12_1" class="paragraph-anchor"></a><b>&#167;12.1. </b>  Each <code>&lt;INDENT&gt;</code> marker at the start of the pattern represents one tab's worth
of white space to strip from the start of the line being matched. This does that:</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reduce the line indentation to allow for &lt;INDENT&gt; markers</span><span class="named-paragraph-number">12.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">wsc</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">on</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">strip_indents</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)?</span><span class="identifier-syntax">TRUE:FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">full_text</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">inchar32_t</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">full_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">on</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">PUT_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">c</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c</span><span class="plain-syntax"> == </span><span class="character-syntax">' '</span><span class="plain-syntax">) </span><span class="identifier-syntax">wsc</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c</span><span class="plain-syntax"> == </span><span class="character-syntax">'\t'</span><span class="plain-syntax">) </span><span class="identifier-syntax">wsc</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">wsc</span><span class="plain-syntax">/4+1)*4;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">wsc</span><span class="plain-syntax"> == </span><span class="constant-syntax">4</span><span class="plain-syntax">*</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">strip_indents</span><span class="plain-syntax">) </span><span class="identifier-syntax">on</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">on</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; </span><span class="comment-syntax">/* that is, no match: insufficient indentation */</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-lc2.html#SP12">&#167;12</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12_2" class="paragraph-anchor"></a><b>&#167;12.2. </b>  And now we try to make a textual match. Note that we clear the wildcard
variables each time, since otherwise we could have results from a previous
partial but failed match lingering on into a successful one.</p>
<p>Note that an empty token list matches only a whitespace line, since the text
we are matching has already had its whitespace at each end trimmed, so that
a whitespace line leads to the empty text here.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Try to find a match against the text</span><span class="named-paragraph-number">12.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">NO_DEFINED_LSWILDCARD_VALUES</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">]) </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">]);</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">match_from</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">match_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_tokens</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">p_from</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">while</span><span class="plain-syntax"> (</span><span class="identifier-syntax">match_from</span><span class="plain-syntax"> &lt;= </span><span class="identifier-syntax">match_to</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="constant-syntax">TRACE_LCLASSIFIER</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDERR</span><span class="plain-syntax">, </span><span class="string-syntax">"Match tokens %d to %d, chars %c to %c\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">match_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">match_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_from</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_to</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-lc2.html#SP12_2_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">If the leftmost token is fixed text, check that it matches</span></span><span class="named-paragraph-number">12.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-lc2.html#SP12_2_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">If the rightmost token is fixed text, check that it matches</span></span><span class="named-paragraph-number">12.2.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-lc2.html#SP12_2_3" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">If only one token is left, it must be a wildcard, so copy the remaining text into it</span></span><span class="named-paragraph-number">12.2.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-lc2.html#SP12_2_4" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">At this point, the leftmost tokens must be a wildcard followed by fixed text, so look ahead</span></span><span class="named-paragraph-number">12.2.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">match_from</span><span class="plain-syntax"> &gt; </span><span class="identifier-syntax">match_to</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">p_from</span><span class="plain-syntax"> &gt; </span><span class="identifier-syntax">p_to</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="constant-syntax">TRACE_LCLASSIFIER</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDERR</span><span class="plain-syntax">, </span><span class="string-syntax">"Failure\n"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-lc2.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_2_1" class="paragraph-anchor"></a><b>&#167;12.2.1. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If the leftmost token is fixed text, check that it matches</span><span class="named-paragraph-number">12.2.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prefix</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">fixed_content</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">prefix</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p_from</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">prefix</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">match_from</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-lc2.html#SP12_2">&#167;12.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_2_2" class="paragraph-anchor"></a><b>&#167;12.2.2. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If the rightmost token is fixed text, check that it matches</span><span class="named-paragraph-number">12.2.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_to</span><span class="plain-syntax">].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">suffix</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_to</span><span class="plain-syntax">].</span><span class="element-syntax">fixed_content</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_to</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">suffix</span><span class="plain-syntax">) + </span><span class="constant-syntax">1</span><span class="plain-syntax">, </span><span class="identifier-syntax">suffix</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p_to</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax">= </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">suffix</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">match_to</span><span class="plain-syntax">--;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-lc2.html#SP12_2">&#167;12.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_2_3" class="paragraph-anchor"></a><b>&#167;12.2.3. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If only one token is left, it must be a wildcard, so copy the remaining text into it</span><span class="named-paragraph-number">12.2.3</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">match_from</span><span class="plain-syntax"> == </span><span class="identifier-syntax">match_to</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">WT</span><span class="plain-syntax"> = </span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">wildcard</span><span class="plain-syntax">];</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::substr</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_from</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_to</span><span class="plain-syntax">+1));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">nonwhitespace</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            ((</span><span class="identifier-syntax">Str::includes_character</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">, </span><span class="character-syntax">' '</span><span class="plain-syntax">)) || (</span><span class="identifier-syntax">Str::includes_character</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">, </span><span class="character-syntax">'\t'</span><span class="plain-syntax">))))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">whitespace</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Str::is_whitespace</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">digital</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">not_digital</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Characters::isdigit</span><span class="plain-syntax">(</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">not_digital</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">not_digital</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p_to</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">match_from</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-lc2.html#SP12_2">&#167;12.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12_2_4" class="paragraph-anchor"></a><b>&#167;12.2.4. </b>  The leftmost token must be a wildcard because if it were fixed wording then
we would have checked it already; it cannot be the only token, because we've
just handled that case; so there is a next token, which cannot be a wildcard
because we cannot have two consecutive wildcards. And therefore...</p>
<p>Note that we use a non-greedy algorithm, i.e., we make the earliest match
possible, and with no backtracking to check other possibilities. This is a
deliberately simple parser, intended to work quickly on simple unambiguous
grammars.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">At this point, the leftmost tokens must be a wildcard followed by fixed text, so look ahead</span><span class="named-paragraph-number">12.2.4</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">+1].</span><span class="element-syntax">wildcard</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"consecutive wildcard tokens"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p_from</span><span class="plain-syntax">+1, </span><span class="identifier-syntax">l_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p_to</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">+1].</span><span class="element-syntax">fixed_content</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (; </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax"> &lt;= </span><span class="identifier-syntax">l_to</span><span class="plain-syntax">; </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::includes_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax">, </span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">+1].</span><span class="element-syntax">fixed_content</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">WT</span><span class="plain-syntax"> = </span><span class="identifier-syntax">wildcards</span><span class="plain-syntax">[</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">wildcard</span><span class="plain-syntax">];</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Str::substr</span><span class="plain-syntax">(</span><span class="identifier-syntax">WT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">p_from</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">p_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax"> + </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">+1].</span><span class="element-syntax">fixed_content</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">match_from</span><span class="plain-syntax"> += </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pattern</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tokens</span><span class="plain-syntax">[</span><span class="identifier-syntax">match_from</span><span class="plain-syntax">].</span><span class="element-syntax">nonwhitespace</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Characters::is_whitespace</span><span class="plain-syntax">(</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax">))))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">lookahead</span><span class="plain-syntax"> = </span><span class="identifier-syntax">l_to</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">lookahead</span><span class="plain-syntax"> &gt; </span><span class="identifier-syntax">l_to</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-lc2.html#SP12_2">&#167;12.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. Outcomes and their options.</b>  If successful, a rule produces an &quot;outcome&quot; such as <code>namedholon</code> or <code>code</code>,
together perhaps with options such as <code>earlyholonoption</code>.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome_ID</span><span class="plain-syntax">;            </span><span class="comment-syntax">/* one of the |*_LSNROID| values below */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">options_applied</span><span class="plain-syntax">;       </span><span class="comment-syntax">/* a bitmap of |*_LSNROBIT| values below */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">new_paragraph</span><span class="plain-syntax">;         </span><span class="comment-syntax">/* does this line implicitly begin a new para? */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">error</span><span class="plain-syntax">; </span><span class="comment-syntax">/* on a match, in fact throw this error */</span>
<span class="plain-syntax">} </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax">;</span>

<span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::new_outcome</span><span class="plain-syntax">(</span><span class="type-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">outcome_ID</span><span class="plain-syntax"> = </span><span class="constant-syntax">NO_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">options_applied</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">new_paragraph</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::parse_outcome</span><button class="popup" onclick="togglePopup('usagePopup15')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup15">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::parse_outcome</span></span>:<br/><a href="2-lc2.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ot</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> **</span><span class="identifier-syntax">error</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_notation_rule_outcome</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP13" class="function-link"><span class="function-syntax">LineClassifiers::new_outcome</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">ot</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"error \"(%c+)\""</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">outcome_ID</span><span class="plain-syntax"> = </span><span class="constant-syntax">COMMENTARY_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">ot</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(%c+) in new paragraph"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">ot</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">new_paragraph</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">while</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">ot</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(%c+) with (%C+)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">ot</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">            </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">opt</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP16" class="function-link"><span class="function-syntax">LineClassifiers::outcome_by_name</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">opt</span><span class="plain-syntax"> == </span><span class="constant-syntax">NO_LSNROID</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(*</span><span class="identifier-syntax">error</span><span class="plain-syntax">, </span><span class="string-syntax">"unknown option '%S'"</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">B</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP17" class="function-link"><span class="function-syntax">LineClassifiers::option_bit</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">opt</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">B</span><span class="plain-syntax"> == </span><span class="constant-syntax">-1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(*</span><span class="identifier-syntax">error</span><span class="plain-syntax">, </span><span class="string-syntax">"an outcome, not an option: '%S'"</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">                } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">options_applied</span><span class="plain-syntax"> |= </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">outcome_ID</span><span class="plain-syntax"> = </span><a href="2-lc2.html#SP16" class="function-link"><span class="function-syntax">LineClassifiers::outcome_by_name</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">ot</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">outcome_ID</span><span class="plain-syntax"> == </span><span class="constant-syntax">NO_LSNROID</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            *</span><span class="identifier-syntax">error</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(*</span><span class="identifier-syntax">error</span><span class="plain-syntax">, </span><span class="string-syntax">"unknown outcome '%S'"</span><span class="plain-syntax">, </span><span class="identifier-syntax">ot</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">.</span><span class="element-syntax">outcome_ID</span><span class="plain-syntax"> = </span><span class="constant-syntax">COMMENTARY_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">outcome</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure ls_notation_rule_outcome is accessed in 2/ls, 2/lc and here.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. </b>  These outcome and option IDs share an enumeration; first, here are the outcomes.
Note that <code>NO_LSNROID</code> is never the outcome of any rule: it's a value
used to mean &quot;nothing matched&quot;.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">NO_LSNROID</span> <span class="constant-syntax">0</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">AUDIO_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">BEGINPARAGRAPH_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">CAROUSELEND_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">CAROUSELSLIDE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">CODE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">COMMENTARY_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">DEFINITION_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">DEFINITIONCONTINUED_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">DOWNLOAD_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">EMBEDDEDVIDEO_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">ENDEXTRACT_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">ENUMERATION_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">EXTRACT_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FIGURE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FILEHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">FORMATIDENTIFIER_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">HTML_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">INCLUDEFILE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">MAKEDEFINITIONSHERE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">NAMEDHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">NAMELESSHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">PARAGRAPHTAG_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">PARAGRAPHTITLING_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">PURPOSE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">QUOTATION_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">TEXTASCODEEXTRACT_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">TEXTEXTRACT_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">TEXTEXTRACTTO_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">TITLE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">VIDEO_LSNROID</span> 
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. </b>  And here are the options which some of the above may be given:</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">HYPERLINKED_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">UNDISPLAYED_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">WEBWIDEHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">VERYEARLYHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">EARLYHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">LATEHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">VERYLATEHOLON_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">CONTINUATION_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">SUPERHEADING_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">LEVEL1_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">LEVEL2_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">LEVEL3_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">LEVEL4_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">LEVEL5_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">SILENT_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">WITHPURPOSE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">CAPTIONABOVE_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">CAPTIONBELOW_LSNROID</span> 
</pre>
<pre class="definitions code-font"><span class="definition-keyword">enumerate</span> <span class="identifier-syntax">DEFAULT_LSNROID</span> 
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. </b>  The following converts outcome/option names to their enumerated values:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::outcome_by_name</span><button class="popup" onclick="togglePopup('usagePopup16')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup16">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::outcome_by_name</span></span>:<br/><a href="2-lc2.html#SP13">&#167;13</a><br/>Web Notations - <a href="2-wn.html#SP14_2">&#167;14.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"audio"</span><span class="plain-syntax">))                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">AUDIO_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"beginparagraph"</span><span class="plain-syntax">))       </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">BEGINPARAGRAPH_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"carouselend"</span><span class="plain-syntax">))          </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CAROUSELEND_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"carouselslide"</span><span class="plain-syntax">))        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CAROUSELSLIDE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"code"</span><span class="plain-syntax">))                 </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CODE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"commentary"</span><span class="plain-syntax">))           </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">COMMENTARY_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"definition"</span><span class="plain-syntax">))           </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">DEFINITION_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"definitioncontinued"</span><span class="plain-syntax">))  </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">DEFINITIONCONTINUED_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"download"</span><span class="plain-syntax">))             </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">DOWNLOAD_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"embeddedvideo"</span><span class="plain-syntax">))        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">EMBEDDEDVIDEO_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"endextract"</span><span class="plain-syntax">))           </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">ENDEXTRACT_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"enumeration"</span><span class="plain-syntax">))          </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">ENUMERATION_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"extract"</span><span class="plain-syntax">))              </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">EXTRACT_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"figure"</span><span class="plain-syntax">))               </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">FIGURE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"fileholon"</span><span class="plain-syntax">))            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">FILEHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"formatidentifier"</span><span class="plain-syntax">))     </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">FORMATIDENTIFIER_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"html"</span><span class="plain-syntax">))                 </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">HTML_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"includefile"</span><span class="plain-syntax">))          </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">INCLUDEFILE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"makedefinitionshere"</span><span class="plain-syntax">))  </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">MAKEDEFINITIONSHERE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"namedholon"</span><span class="plain-syntax">))           </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">NAMEDHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"namelessholon"</span><span class="plain-syntax">))        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">NAMELESSHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"paragraphtag"</span><span class="plain-syntax">))         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">PARAGRAPHTAG_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"paragraphtitling"</span><span class="plain-syntax">))     </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">PARAGRAPHTITLING_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"purpose"</span><span class="plain-syntax">))              </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">PURPOSE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"quotation"</span><span class="plain-syntax">))            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">QUOTATION_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"textascodeextract"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">TEXTASCODEEXTRACT_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"textextract"</span><span class="plain-syntax">))          </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">TEXTEXTRACT_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"textextractto"</span><span class="plain-syntax">))        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">TEXTEXTRACTTO_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"title"</span><span class="plain-syntax">))                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">TITLE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"video"</span><span class="plain-syntax">))                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">VIDEO_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"hyperlinkedoption"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">HYPERLINKED_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"undisplayedoption"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">UNDISPLAYED_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"webwideholonoption"</span><span class="plain-syntax">))   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">WEBWIDEHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"veryearlyholonoption"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">VERYEARLYHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"earlyholonoption"</span><span class="plain-syntax">))     </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">EARLYHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"lateholonoption"</span><span class="plain-syntax">))      </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LATEHOLON_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"verylateholonoption"</span><span class="plain-syntax">))  </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">VERYLATEHOLON_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"continuationoption"</span><span class="plain-syntax">))   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CONTINUATION_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"superheadingoption"</span><span class="plain-syntax">))   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">SUPERHEADING_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"subheading1option"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL1_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"subheading2option"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL2_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"subheading3option"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL3_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"subheading4option"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL4_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"subheading5option"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL5_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"silentoption"</span><span class="plain-syntax">))         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">SILENT_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"withpurposeoption"</span><span class="plain-syntax">))    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">WITHPURPOSE_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"captionaboveoption"</span><span class="plain-syntax">))   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CAPTIONABOVE_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"captionbelowoption"</span><span class="plain-syntax">))   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CAPTIONBELOW_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">outcome</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"defaultoption"</span><span class="plain-syntax">))        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">DEFAULT_LSNROID</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">NO_LSNROID</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. </b>  The following bits are high enough up that a valid options bitmap can never
equal a valid outcome ID, but at present we make no use of this fact.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">HYPERLINKED_LSNROBIT</span> <span class="constant-syntax">0x000100</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">UNDISPLAYED_LSNROBIT</span> <span class="constant-syntax">0x000200</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">WEBWIDEHOLON_LSNROBIT</span> <span class="constant-syntax">0x000400</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">VERYEARLYHOLON_LSNROBIT</span> <span class="constant-syntax">0x000800</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">EARLYHOLON_LSNROBIT</span> <span class="constant-syntax">0x001000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LATEHOLON_LSNROBIT</span> <span class="constant-syntax">0x002000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">VERYLATEHOLON_LSNROBIT</span> <span class="constant-syntax">0x004000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">CONTINUATION_LSNROBIT</span> <span class="constant-syntax">0x008000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">SUPERHEADING_LSNROBIT</span> <span class="constant-syntax">0x010000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LEVEL1_LSNROBIT</span> <span class="constant-syntax">0x020000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LEVEL2_LSNROBIT</span> <span class="constant-syntax">0x040000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LEVEL3_LSNROBIT</span> <span class="constant-syntax">0x080000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LEVEL4_LSNROBIT</span> <span class="constant-syntax">0x100000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LEVEL5_LSNROBIT</span> <span class="constant-syntax">0x200000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">SILENT_LSNROBIT</span> <span class="constant-syntax">0x400000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">WITHPURPOSE_LSNROBIT</span> <span class="constant-syntax">0x800000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">WITHPURPOSE_LSNROBIT</span> <span class="constant-syntax">0x800000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">CAPTIONABOVE_LSNROBIT</span> <span class="constant-syntax">0x1000000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">CAPTIONBELOW_LSNROBIT</span> <span class="constant-syntax">0x2000000</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">DEFAULT_LSNROBIT</span> <span class="constant-syntax">0x4000000</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">LineClassifiers::option_bit</span><button class="popup" onclick="togglePopup('usagePopup17')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup17">Usage of <span class="code-font"><span class="function-syntax">LineClassifiers::option_bit</span></span>:<br/><a href="2-lc2.html#SP13">&#167;13</a><br/>Line Classification - <a href="2-lc.html#SP18_2_3_1">&#167;18.2.3.1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">O</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">O</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">HYPERLINKED_LSNROID:</span><span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">HYPERLINKED_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">UNDISPLAYED_LSNROID:</span><span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">UNDISPLAYED_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">WEBWIDEHOLON_LSNROID:</span><span class="plain-syntax">   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">WEBWIDEHOLON_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">VERYEARLYHOLON_LSNROID:</span><span class="plain-syntax"> </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">VERYEARLYHOLON_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">EARLYHOLON_LSNROID:</span><span class="plain-syntax">     </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">EARLYHOLON_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">LATEHOLON_LSNROID:</span><span class="plain-syntax">      </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LATEHOLON_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">VERYLATEHOLON_LSNROID:</span><span class="plain-syntax">  </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">VERYLATEHOLON_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CONTINUATION_LSNROID:</span><span class="plain-syntax">   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CONTINUATION_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">SUPERHEADING_LSNROID:</span><span class="plain-syntax">   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">SUPERHEADING_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">LEVEL1_LSNROID:</span><span class="plain-syntax">         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL1_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">LEVEL2_LSNROID:</span><span class="plain-syntax">         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL2_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">LEVEL3_LSNROID:</span><span class="plain-syntax">         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL3_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">LEVEL4_LSNROID:</span><span class="plain-syntax">         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL4_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">LEVEL5_LSNROID:</span><span class="plain-syntax">         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">LEVEL5_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">SILENT_LSNROID:</span><span class="plain-syntax">         </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">SILENT_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">WITHPURPOSE_LSNROID:</span><span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">WITHPURPOSE_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CAPTIONABOVE_LSNROID:</span><span class="plain-syntax">   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CAPTIONABOVE_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CAPTIONBELOW_LSNROID:</span><span class="plain-syntax">   </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">CAPTIONBELOW_LSNROBIT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DEFAULT_LSNROID:</span><span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">DEFAULT_LSNROBIT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">-1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="2-lc.html">&#10094;</a></li><li class="progresschapter"><a href="P-abgtl.html">P</a></li><li class="progresschapter"><a href="1-lm.html">1</a></li><li class="progresscurrentchapter">2</li><li class="progresssection"><a href="2-ls.html">ls</a></li><li class="progresssection"><a href="2-pt.html">pt</a></li><li class="progresssection"><a href="2-lc.html">lc</a></li><li class="progresscurrent">lc2</li><li class="progresssection"><a href="2-we.html">we</a></li><li class="progresssection"><a href="2-wn.html">wn</a></li><li class="progresssection"><a href="2-hln.html">hln</a></li><li class="progresssection"><a href="2-hs.html">hs</a></li><li class="progresssection"><a href="2-ce.html">ce</a></li><li class="progresssection"><a href="2-wi.html">wi</a></li><li class="progresschapter"><a href="3-pl.html">3</a></li><li class="progresschapter"><a href="4-tt.html">4</a></li><li class="progresschapter"><a href="5-wd.html">5</a></li><li class="progresschapter"><a href="6-mkf.html">6</a></li><li class="progressnext"><a href="2-we.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

