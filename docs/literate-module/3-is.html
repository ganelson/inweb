<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>InC Support</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
    options: {
    	skipHtmlTags: {'[-]': ['pre']},
    	processHtmlClass: 'mathjax_process'
    },
	loader: {load: ['[tex]/texhtml']},
  	tex: {
		inlineMath: [ ['\\INWEBMATH(', '\\INWEBMATH)'] ],
    	packages: {'[+]': ['texhtml']},
    	allowTexHTML: true
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-svg.js"></script>

<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html"><img src="../docs-assets/Octagram.png" height=72> </a></h1>
<ul><li><a href="../inweb/index.html">inweb</a></li>
</ul><h2>Foundation Modules</h2><ul>
<li><a href="../foundation-module/index.html">foundation</a></li>
<li><a href="../foundation-test/index.html">foundation-test</a></li>
<li><a href="index.html"><span class="selectedlink">literate</span></a></li>
<li><a href="../literate-test/index.html">literate-test</a></li>
</ul><h2>Documentation</h2><ul>
<li><a href="../guide/index.html">guide</a></li>
</ul><h2>Example Webs</h2><ul>
<li><a href="../goldbach/index.html">goldbach</a></li>
<li><a href="../twinprimes/twinprimes.html">twinprimes</a></li>
<li><a href="../eastertide/index.html">eastertide</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> inform</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'InC Support' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">literate</a></li><li><a href="index.html#3">Chapter 3: Programming</a></li><li><b>InC Support</b></li></ul></div>
<p class="purpose">To support a modest extension of C called InC.</p>

<ul class="toc"><li><a href="3-is.html#SP1">&#167;1. Creation</a></li><li><a href="3-is.html#SP2">&#167;2. Parsing methods</a></li><li><a href="3-is.html#SP2_1">&#167;2.1. Parsing Preform grammar</a></li><li><a href="3-is.html#SP2_1_1_1">&#167;2.1.1.1. Parsing the body of Preform grammar</a></li><li><a href="3-is.html#SP5">&#167;5. Parsing I-literals</a></li><li><a href="3-is.html#SP15">&#167;15. Weaving</a></li><li><a href="3-is.html#SP16">&#167;16. Weaving methods</a></li><li><a href="3-is.html#SP18">&#167;18. Analysis methods</a></li></ul><hr class="tocbar">

<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Creation.</b>  As can be seen, InC is a basically C-like language, but in addition to having
all of those methods, it has a whole lot more of its own.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::add_features</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">InCSupport::add_features</span></span>:<br/>Programming Languages - <a href="3-pl.html#SP8_1">&#167;8.1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">FURTHER_PARSING_PAR_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP2" class="function-link"><span class="function-syntax">InCSupport::further_parsing</span></a><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">ADDITIONAL_PREDECLARATIONS_TAN_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP7" class="function-link"><span class="function-syntax">InCSupport::additional_predeclarations</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">TANGLE_EXTRA_LINE_TAN_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP9" class="function-link"><span class="function-syntax">InCSupport::insert_in_tangle</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">TANGLE_LINE_UNUSUALLY_TAN_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP11" class="function-link"><span class="function-syntax">InCSupport::tangle_line</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">GNABEHS_TAN_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP8" class="function-link"><span class="function-syntax">InCSupport::gnabehs</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">ADDITIONAL_TANGLING_TAN_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP14" class="function-link"><span class="function-syntax">InCSupport::additional_tangling</span></a><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">SKIP_IN_WEAVING_WEA_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP16" class="function-link"><span class="function-syntax">InCSupport::skip_in_weaving</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">WEAVE_CODE_LINE_WEA_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP17" class="function-link"><span class="function-syntax">InCSupport::weave_code_line</span></a><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">ANALYSIS_ANA_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP18" class="function-link"><span class="function-syntax">InCSupport::analyse_code</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">, </span><span class="constant-syntax">SHARE_ELEMENT_ANA_MTID</span><span class="plain-syntax">, </span><a href="3-is.html#SP18" class="function-link"><span class="function-syntax">InCSupport::share_element</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Parsing methods.</b>  We only provide one parsing method, but it's a big one:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::further_parsing</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">InCSupport::further_parsing</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="type-syntax">ls_web</span><span class="plain-syntax"> *</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">weaving</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_chapter</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_chunk</span><span class="plain-syntax"> *</span><span class="identifier-syntax">chunk</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_WITHIN_CODE_AND_DEFINITIONS</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><a href="4-tt.html#SP3" class="function-link"><span class="function-syntax">TangleTargets::primary_target</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *</span><span class="identifier-syntax">L</span><span class="plain-syntax"> = (</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">line</span><span class="plain-syntax"> = </span><a href="2-ce.html#SP4" class="function-link"><span class="function-syntax">CodeExcerpts::line_code</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Detect and deal with Preform grammar</span></span><span class="named-paragraph-number">2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">weaving</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">chunk</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">chunk</span><span class="plain-syntax"> != </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_chunk</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">chunk</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_chunk</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">chunk</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">holon</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="type-syntax">holon_splice</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hs</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">LOOP_OVER_HOLON_DEFINITION</span><span class="plain-syntax">(</span><span class="identifier-syntax">hs</span><span class="plain-syntax">, </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_chunk</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">holon</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">hs</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">type</span><span class="plain-syntax"> == </span><span class="constant-syntax">CODE_LSHST</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                            </span><a href="3-is.html#SP5" class="function-link"><span class="function-syntax">InCSupport::detect_I_literals</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">hs</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">texts</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">chunk</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">holon</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><a href="3-is.html#SP5" class="function-link"><span class="function-syntax">InCSupport::detect_I_literals</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1" class="paragraph-anchor"></a><b>&#167;2.1. Parsing Preform grammar.</b>  This is where we look for declarations of nonterminals. Very little about
the following code will make sense unless you've first read the Preform
section of the <code>words</code> module, which is what we're supporting, and seen
some examples of Preform being used in the Inform source code.</p>
<p>Note that we flag lines inside Preform nonterminals as <code>preform_grammar</code>,
but the lines of InC code inside an <code>internal</code> definition remain just plain code.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">NOT_A_NONTERMINAL</span> <span class="constant-syntax">-4</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">A_FLEXIBLE_NONTERMINAL</span> <span class="constant-syntax">-3</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">A_VORACIOUS_NONTERMINAL</span> <span class="constant-syntax">-2</span>
</pre>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">A_GRAMMAR_NONTERMINAL</span> <span class="constant-syntax">-1</span>
</pre>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Detect and deal with Preform grammar</span><span class="named-paragraph-number">2.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">form</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOT_A_NONTERMINAL</span><span class="plain-syntax">; </span><span class="comment-syntax">/* one of the four values above, or a non-negative word count */</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Parse a Preform nonterminal header line</span></span><span class="named-paragraph-number">2.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">form</span><span class="plain-syntax"> != </span><span class="constant-syntax">NOT_A_NONTERMINAL</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Record a Preform nonterminal here</span></span><span class="named-paragraph-number">2.1.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">)</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2">&#167;2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_1" class="paragraph-anchor"></a><b>&#167;2.1.1. </b>  The keyword <code>internal</code> can be followed by an indication of the number
of words the nonterminal will match: usually a decimal non-negative number,
but optionally a question mark <code>?</code> to indicate voracity.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse a Preform nonterminal header line</span><span class="named-paragraph-number">2.1.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(&lt;%p+&gt;) ::=%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">form</span><span class="plain-syntax"> = </span><span class="constant-syntax">A_GRAMMAR_NONTERMINAL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_1_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Parse the subsequent lines as Preform grammar</span></span><span class="named-paragraph-number">2.1.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"((&lt;%p+&gt;) internal %?) {%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">form</span><span class="plain-syntax"> = </span><span class="constant-syntax">A_VORACIOUS_NONTERMINAL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">suppress_tangling</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"((&lt;%p+&gt;) internal) {%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">form</span><span class="plain-syntax"> = </span><span class="constant-syntax">A_FLEXIBLE_NONTERMINAL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">suppress_tangling</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"((&lt;%p+&gt;) internal (%d+)) {%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">form</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::atoi</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[2], </span><span class="constant-syntax">0</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">suppress_tangling</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1">&#167;2.1</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. </b>  Each Preform nonterminal defined in the tangle will cause one of these
structures to be created:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt_name</span><span class="plain-syntax">; </span><span class="comment-syntax">/* e.g., |</span><span class="function-syntax">&lt;action-clause&gt;</span><span class="comment-syntax">| */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">unangled_name</span><span class="plain-syntax">; </span><span class="comment-syntax">/* e.g., |action-clause| */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">as_C_identifier</span><span class="plain-syntax">; </span><span class="comment-syntax">/* e.g., |action_clause_NTM| */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">as_function</span><span class="plain-syntax">; </span><span class="comment-syntax">/* defined internally, that is, parsed by a C language_function */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">voracious</span><span class="plain-syntax">; </span><span class="comment-syntax">/* a voracious nonterminal: see "The English Syntax of Inform" */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">min_word_count</span><span class="plain-syntax">; </span><span class="comment-syntax">/* for internals only */</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">max_word_count</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">takes_pointer_result</span><span class="plain-syntax">; </span><span class="comment-syntax">/* right-hand formula defines |*XP|, not |*X| */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">where_defined</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">next_pnt_alphabetically</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure preform_nonterminal is accessed in 3/ca, 3/taf, 3/rw, 5/tf and here.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_2" class="paragraph-anchor"></a><b>&#167;2.1.2. </b>  We will...</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Record a Preform nonterminal here</span><span class="named-paragraph-number">2.1.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_defined</span><span class="plain-syntax"> = </span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">unangled_name</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_2_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Apply unangling cream to name</span></span><span class="named-paragraph-number">2.1.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_2_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Compose a C identifier for the nonterminal</span></span><span class="named-paragraph-number">2.1.2.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_2_3" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Work out the parsing characteristics of the nonterminal</span></span><span class="named-paragraph-number">2.1.2.3</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_2_4" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Insertion-sort this this nonterminal into the alphabetical list</span></span><span class="named-paragraph-number">2.1.2.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_2_5" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Register the nonterminal with the line and paragraph from which it comes</span></span><span class="named-paragraph-number">2.1.2.5</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1">&#167;2.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_1_2_1" class="paragraph-anchor"></a><b>&#167;2.1.2.1. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Apply unangling cream to name</span><span class="named-paragraph-number">2.1.2.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">pntname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"%&lt;(%c*)%&gt;"</span><span class="plain-syntax">)) </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">unangled_name</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_2">&#167;2.1.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_2_2" class="paragraph-anchor"></a><b>&#167;2.1.2.2. </b>  When the program we are tangling is eventually running, each nonterminal
will be represented by a pointer to a unique data structure for it. We want
automatically to compile code to create these pointers; and here's how we
work out their names.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compose a C identifier for the nonterminal</span><span class="named-paragraph-number">2.1.2.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::delete_first_character</span><span class="plain-syntax">(</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">) == </span><span class="character-syntax">'-'</span><span class="plain-syntax">) </span><span class="identifier-syntax">Str::put</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="character-syntax">'_'</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">) == </span><span class="character-syntax">'&gt;'</span><span class="plain-syntax">) { </span><span class="identifier-syntax">Str::put</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">, </span><span class="string-syntax">"_NTM"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_2">&#167;2.1.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_2_3" class="paragraph-anchor"></a><b>&#167;2.1.2.3. </b>  &quot;Artamène ou le Grand Cyrus&quot;, by Georges or possibly his sister Madeleine
de Scudéry, published around 1650, runs to 1,954,300 words. If you can write
an Inform source text 500 times longer than that, then you may need to raise
the following definition:</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">INFINITE_WORD_COUNT</span> <span class="constant-syntax">1000000000</span>
</pre>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Work out the parsing characteristics of the nonterminal</span><span class="named-paragraph-number">2.1.2.3</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">voracious</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">form</span><span class="plain-syntax"> == </span><span class="constant-syntax">A_VORACIOUS_NONTERMINAL</span><span class="plain-syntax">) </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">voracious</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">form</span><span class="plain-syntax"> == </span><span class="constant-syntax">A_GRAMMAR_NONTERMINAL</span><span class="plain-syntax">) </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">takes_pointer_result</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"&lt;k-%c+"</span><span class="plain-syntax">)) </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">takes_pointer_result</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"&lt;s-%c+"</span><span class="plain-syntax">)) </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">takes_pointer_result</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">min</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">, </span><span class="identifier-syntax">max</span><span class="plain-syntax"> = </span><span class="identifier-syntax">form</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">form</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">max</span><span class="plain-syntax"> = </span><span class="constant-syntax">INFINITE_WORD_COUNT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">max</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">min</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">max</span><span class="plain-syntax"> != </span><span class="constant-syntax">INFINITE_WORD_COUNT</span><span class="plain-syntax">) </span><span class="identifier-syntax">min</span><span class="plain-syntax"> = </span><span class="identifier-syntax">max</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">min_word_count</span><span class="plain-syntax"> = </span><span class="identifier-syntax">min</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">max_word_count</span><span class="plain-syntax"> = </span><span class="identifier-syntax">max</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_2">&#167;2.1.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_1_2_4" class="paragraph-anchor"></a><b>&#167;2.1.2.4. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Insertion-sort this this nonterminal into the alphabetical list</span><span class="named-paragraph-number">2.1.2.4</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">placed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">last</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">seq</span><span class="plain-syntax"> = </span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax">; </span><span class="identifier-syntax">seq</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">seq</span><span class="plain-syntax"> = </span><span class="identifier-syntax">seq</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::cmp</span><span class="plain-syntax">(</span><span class="identifier-syntax">pntname</span><span class="plain-syntax">, </span><span class="identifier-syntax">seq</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">) &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">seq</span><span class="plain-syntax"> == </span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax"> = </span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">last</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax"> = </span><span class="identifier-syntax">seq</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">placed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">last</span><span class="plain-syntax"> = </span><span class="identifier-syntax">seq</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">placed</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="identifier-syntax">last</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_2">&#167;2.1.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_1_2_5" class="paragraph-anchor"></a><b>&#167;2.1.2.5. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Register the nonterminal with the line and paragraph from which it comes</span><span class="named-paragraph-number">2.1.2.5</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="2-pt.html#SP1" class="function-link"><span class="function-syntax">ParagraphTags::tag_with_caption</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">L_par</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Preform"</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">header</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_2">&#167;2.1.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_1_1" class="paragraph-anchor"></a><b>&#167;2.1.1.1. Parsing the body of Preform grammar.</b>  After a line like <code>&lt;action-clause&gt; ::=</code>, Preform grammar follows on subsequent
lines until we hit the end of the paragraph, or a white-space line, whichever
comes first. If we have a line with an arrow, like so:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">porcupine</span><span class="plain-syntax"> </span><span class="identifier-syntax">tree</span><span class="plain-syntax">  ==&gt;  { </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="constant-syntax">-</span><span class="plain-syntax"> }{}</span>
</pre>
<div class="lsmarkdown">
<p>then the text on the left goes into <code>text_operand</code> and the right into
<code>text_operand2</code>, with the arrow itself (and white space around it) cut out.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse the subsequent lines as Preform grammar</span><span class="named-paragraph-number">2.1.1.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="2-pt.html#SP2" class="function-link"><span class="function-syntax">ParagraphTags::tag</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">L_par</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Preform"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lst</span><span class="plain-syntax">; </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">; </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *</span><span class="identifier-syntax">AL</span><span class="plain-syntax"> = (</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::string_is_white_space</span><span class="plain-syntax">(</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text</span><span class="plain-syntax">)) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">AL</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_grammar</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">suppress_tangling</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(%c+?) ==&gt; (%c*)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_1_1_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Remove any C comment from the left side of the arrow</span></span><span class="named-paragraph-number">2.1.1.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_1_1_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Detect any nonterminal variables being set on the right side of the arrow</span></span><span class="named-paragraph-number">2.1.1.1.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_1">&#167;2.1.1</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_1_1_1" class="paragraph-anchor"></a><b>&#167;2.1.1.1.1. </b>  In case we have a comment at the end of the grammar, like this:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">porcupine</span><span class="plain-syntax"> </span><span class="identifier-syntax">tree</span><span class="plain-syntax">  </span><span class="comment-syntax">/* what happens now? */</span>
</pre>
<div class="lsmarkdown">
<p>we want to remove it. The regular expression here isn't terribly legible, but
trust me, it's correct.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Remove any C comment from the left side of the arrow</span><span class="named-paragraph-number">2.1.1.1.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(%c*)%/%*%c*%*%/ *"</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_1_1">&#167;2.1.1.1</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2_1_1_1_2" class="paragraph-anchor"></a><b>&#167;2.1.1.1.2. </b>  Note that nonterminal variables are, by default, integers. If their names
are divided internally with a colon, however, as <code>&lt;&lt;structure:name&gt;&gt;</code>, then
they have the type <code>structure *</code>.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Detect any nonterminal variables being set on the right side of the arrow</span><span class="named-paragraph-number">2.1.1.1.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">to_scan</span><span class="plain-syntax">) </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">to_scan</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">while</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">to_scan</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"%c*?&lt;&lt;(%P+?)&gt;&gt; =(%c*)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">var_given</span><span class="plain-syntax">) </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">var_given</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">type_given</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">type_given</span><span class="plain-syntax">, </span><span class="string-syntax">"int"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">to_scan</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">var_given</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(%p+):%p+"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">type_given</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">type_given</span><span class="plain-syntax">, </span><span class="string-syntax">"%S *"</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">, </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">var_given</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ntv</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP2_1_1_1_2_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">This one's new, so create a new nonterminal variable</span></span><span class="named-paragraph-number">2.1.1.1.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">var_given</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">type_given</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">to_scan</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_1_1">&#167;2.1.1.1</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. </b>  Nonterminal variables are actually just global C variables, and their C
identifiers need to avoid hyphens and colons. For example, <code>&lt;&lt;kind:ref&gt;&gt;</code>
has identifier <code>&quot;kind_ref_NTMV&quot;</code>. Each one is recorded in a structure thus:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntv_name</span><span class="plain-syntax">; </span><span class="comment-syntax">/* e.g., |"num"| */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntv_type</span><span class="plain-syntax">; </span><span class="comment-syntax">/* e.g., |"int"| */</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntv_identifier</span><span class="plain-syntax">; </span><span class="comment-syntax">/* e.g., |"num_NTMV"| */</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure nonterminal_variable is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_1_1_1_2_1" class="paragraph-anchor"></a><b>&#167;2.1.1.1.2.1. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">This one's new, so create a new nonterminal variable</span><span class="named-paragraph-number">2.1.1.1.2.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">ntv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_name</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">var_given</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_type</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">type_given</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">P</span><span class="plain-syntax">, </span><span class="identifier-syntax">var_given</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Str::get</span><span class="plain-syntax">(</span><span class="identifier-syntax">P</span><span class="plain-syntax">) == </span><span class="character-syntax">'-'</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">Str::get</span><span class="plain-syntax">(</span><span class="identifier-syntax">P</span><span class="plain-syntax">) == </span><span class="character-syntax">':'</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Str::put</span><span class="plain-syntax">(</span><span class="identifier-syntax">P</span><span class="plain-syntax">, </span><span class="character-syntax">'_'</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_identifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_identifier</span><span class="plain-syntax">, </span><span class="string-syntax">"%S_NTMV"</span><span class="plain-syntax">, </span><span class="identifier-syntax">var_given</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP2_1_1_1_2">&#167;2.1.1.1.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Parsing I-literals.</b>  A simpler but useful further addition to C is that we recognise a new form
of string literal: <code>I&quot;quartz&quot;</code> makes a constant text stream with the content
&quot;quartz&quot;.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::detect_I_literals</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">InCSupport::detect_I_literals</span></span>:<br/><a href="3-is.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">line</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">quoted</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">'"'</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1) != </span><span class="character-syntax">'\\'</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                ((</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1) != </span><span class="character-syntax">'\''</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) != </span><span class="character-syntax">'\''</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">quoted</span><span class="plain-syntax"> = </span><span class="identifier-syntax">quoted</span><span class="plain-syntax">?</span><span class="identifier-syntax">FALSE:TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">quoted</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">'I'</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) == </span><span class="character-syntax">'"'</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP5_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">This looks like an I-literal</span></span><span class="named-paragraph-number">5.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5_1" class="paragraph-anchor"></a><b>&#167;5.1. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">This looks like an I-literal</span><span class="named-paragraph-number">5.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">lit</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i_was</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">ended</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">while</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">'"'</span><span class="plain-syntax">) { </span><span class="identifier-syntax">ended</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PUT_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">lit</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">++));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ended</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP5_1_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">This is definitely an I-literal</span></span><span class="named-paragraph-number">5.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">lit</span><span class="plain-syntax">)</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP5">&#167;5</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. </b>  Each I-literal results in an instance of the following being created. The
I-literal <code>I&quot;quartz&quot;</code> would have content <code>quartz</code> and identifier something
like <code>TL_IS_123</code>.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="type-syntax">text_literal</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tl_identifier</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tl_content</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="type-syntax">text_literal</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure text_literal is private to this section.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP5_1_1" class="paragraph-anchor"></a><b>&#167;5.1.1. </b>  So suppose we've got a line of web such as</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">T</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="string-syntax">"quartz"</span><span class="plain-syntax">;</span>
</pre>
<div class="lsmarkdown">
<p>We create the necessary I-literal, and splice the line so that it now reads
<code>text_stream *T = TL_IS_123;</code>. (That's why we don't call any of this on a
weave run; we're actually amending the code of the web.)</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">This is definitely an I-literal</span><span class="named-paragraph-number">5.1.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">text_literal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="type-syntax">text_literal</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_identifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_identifier</span><span class="plain-syntax">, </span><span class="string-syntax">"TL_IS_%d"</span><span class="plain-syntax">, </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_content</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">lit</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">before</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">after</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">before</span><span class="plain-syntax">, </span><span class="identifier-syntax">line</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::truncate</span><span class="plain-syntax">(</span><span class="identifier-syntax">before</span><span class="plain-syntax">, </span><span class="identifier-syntax">i_was</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::copy_tail</span><span class="plain-syntax">(</span><span class="identifier-syntax">after</span><span class="plain-syntax">, </span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="string-syntax">"%S%S"</span><span class="plain-syntax">, </span><span class="identifier-syntax">before</span><span class="plain-syntax">, </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">line</span><span class="plain-syntax">, </span><span class="string-syntax">"%S"</span><span class="plain-syntax">, </span><span class="identifier-syntax">after</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">before</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">after</span><span class="plain-syntax">)</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP5_1">&#167;5.1</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. </b>  Time to predeclare things. InC is going to create a special function, right
at the end of the code, which &quot;registers&quot; the nonterminals, creating their
run-time data structures; we must predeclare this function. It will set values
for the pointers <code>action_clause_NTM</code>, and so on; these are global variables,
which we initially declare as <code>NULL</code>.</p>
<p>We also declare the nonterminal variables like <code>kind_ref_NTMV</code>, initialising
all integers to zero and all pointers to <code>NULL</code>.</p>
<p>We do something similar, but simpler, to declare text stream constants.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::additional_predeclarations</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">InCSupport::additional_predeclarations</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="type-syntax">tangle_docket</span><span class="plain-syntax"> *</span><span class="identifier-syntax">docket</span><span class="plain-syntax">, </span><span class="type-syntax">ls_web</span><span class="plain-syntax"> *</span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_chapter</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_WITHIN_CODE</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><a href="4-tt.html#SP3" class="function-link"><span class="function-syntax">TangleTargets::primary_target</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *</span><span class="identifier-syntax">L</span><span class="plain-syntax"> = (</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><a href="3-lm.html#SP13" class="function-link"><span class="function-syntax">LanguageMethods::insert_line_marker</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><a href="1-ws.html#SP15" class="function-link"><span class="function-syntax">WebStructure::web_language</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">), </span><span class="identifier-syntax">lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"nonterminal *%S = NULL;\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">, </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%S %S = %s;\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_type</span><span class="plain-syntax">, </span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_identifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_type</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"int"</span><span class="plain-syntax">))?</span><span class="string-syntax">"0"</span><span class="plain-syntax">:</span><span class="string-syntax">"NULL"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"void Inweb_InC_register_nonterminals(void);\n"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="type-syntax">text_literal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tl</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">tl</span><span class="plain-syntax">, </span><span class="type-syntax">text_literal</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"text_stream *%S = NULL;\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_identifier</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"void Inweb_InC_register_I_literals(void);\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. </b>  And here are the promised routines, which appear at the very end of the code.
They make use of macros and data structures defined in the Inform 7 web.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::gnabehs</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">InCSupport::gnabehs</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="type-syntax">ls_web</span><span class="plain-syntax"> *</span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"void Inweb_InC_register_nonterminals(void) {\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_chapter</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_WITHIN_CODE</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><a href="4-tt.html#SP3" class="function-link"><span class="function-syntax">TangleTargets::primary_target</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *</span><span class="identifier-syntax">L</span><span class="plain-syntax"> = (</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><a href="3-lm.html#SP13" class="function-link"><span class="function-syntax">LanguageMethods::insert_line_marker</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><a href="1-ws.html#SP15" class="function-link"><span class="function-syntax">WebStructure::web_language</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">), </span><span class="identifier-syntax">lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_function</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\tINTERNAL_NONTERMINAL(U\"%S\", %S, %d, %d);\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">min_word_count</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">max_word_count</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\t%S-&gt;voracious = %d;\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">voracious</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\tREGISTER_NONTERMINAL(U\"%S\", %S);\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"}\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"void Inweb_InC_register_I_literals(void) {\n"</span><span class="plain-syntax">); </span><span class="identifier-syntax">INDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">text_literal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tl</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">tl</span><span class="plain-syntax">, </span><span class="type-syntax">text_literal</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%S = Str::literal(U\"%S\");\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_identifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">tl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">tl_content</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">OUTDENT</span><span class="plain-syntax">; </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"}\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. </b>  That's it for big structural additions to the tangled C code. Now we turn
to how to tangle the lines we've given special categories to.</p>
<p>We need to tangle Preform lines (those holding nonterminal declarations)
in a special way. As can be seen, each nonterminal turns into a C function.
In the case of an internal definition, like</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">&lt;k-kind-for-template&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal</span><span class="plain-syntax"> {</span>
</pre>
<div class="lsmarkdown">
<p>we tangle this opening line to</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">k_kind_for_template_NTM</span><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="type-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">X</span><span class="plain-syntax">, </span><span class="type-syntax">void</span><span class="plain-syntax"> **</span><span class="identifier-syntax">XP</span><span class="plain-syntax">) {</span>
</pre>
<div class="lsmarkdown">
<p>that is, to a function which returns <code>TRUE</code> if it makes a match on the text
excerpt in Inform's source text, <code>FALSE</code> otherwise; if it matches and produces
an integer and/or pointer result, these are copied into <code>*X</code> and <code>*XP</code>. The
remaining lines of the function are tangled unaltered, i.e., following the
same rules as for the body of any other C function.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::insert_in_tangle</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">InCSupport::insert_in_tangle</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">did_insert</span><span class="plain-syntax">, </span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lst</span><span class="plain-syntax">, </span><span class="type-syntax">tangle_docket</span><span class="plain-syntax"> *</span><span class="identifier-syntax">docket</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *</span><span class="identifier-syntax">L</span><span class="plain-syntax"> = (</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_function</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"int %SR(wording W, int *X, void **XP) {\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"int %SC(int *X, void **XP, int *R, void **RP, wording *FW, wording W) {\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP9_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Compile the body of the compositor function</span></span><span class="named-paragraph-number">9.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"}\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">did_insert</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9_1" class="paragraph-anchor"></a><b>&#167;9.1. </b>  On the other hand, a grammar nonterminal tangles to a &quot;compositor function&quot;.
Thus the opening line</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">&lt;action-clause&gt;</span><span class="plain-syntax"> ::=</span>
</pre>
<div class="lsmarkdown">
<p>tangles to a function header:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">action_clause_NTMC</span><span class="plain-syntax">(</span><span class="type-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">X</span><span class="plain-syntax">, </span><span class="type-syntax">void</span><span class="plain-syntax"> **</span><span class="identifier-syntax">XP</span><span class="plain-syntax">, </span><span class="type-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax">, </span><span class="type-syntax">void</span><span class="plain-syntax"> **</span><span class="identifier-syntax">RP</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> *</span><span class="identifier-syntax">FW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
</pre>
<div class="lsmarkdown">
<p>Composition is what happens after a successful match of the text in the
word range <code>W</code>. The idea is that, especially if the pattern was
complicated, we will need to &quot;compose&quot; the results of parsing individual
pieces of it into a result for the whole. These partial results can be found
in the arrays <code>R[n]</code> and <code>RP[n]</code> passed as parameters; recall that every
nonterminal has in principle both an integer and a pointer result, though
often one or both is undefined.</p>
<p>A simple example would be</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">&lt;cardinal-number&gt;</span><span class="plain-syntax"> + </span><span class="function-syntax">&lt;cardinal-number&gt;</span><span class="plain-syntax"> ==&gt; </span><span class="identifier-syntax">R</span><span class="plain-syntax">[1] + </span><span class="identifier-syntax">R</span><span class="plain-syntax">[2]</span>
</pre>
<div class="lsmarkdown">
<p>where the composition function would be called on a match of, say, &quot;\INWEBMATH(5 + 7\INWEBMATH)&quot;,
and would find the values 5 and 7 in <code>R[1]</code> and <code>R[2]</code> respectively. It would
then add these together, store 12 in <code>*X</code>, and return <code>TRUE</code> to show that all
was well.</p>
<p>A more typical example, drawn from the actual Inform 7 web, is:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">&lt;k-kind-of-kind&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;k-formal-variable&gt;</span><span class="plain-syntax"> ==&gt; { </span><span class="constant-syntax">-</span><span class="plain-syntax"> , </span><span class="identifier-syntax">Kinds::var_construction</span><span class="plain-syntax">(</span><span class="identifier-syntax">R</span><span class="plain-syntax">[2], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]) }</span>
</pre>
<div class="lsmarkdown">
<p>which says that the composite result -- the right-hand formula -- is formed by
calling a particular routine on the integer result of subexpression 2
(<code>&lt;k-formal-variable&gt;</code>) and the pointer result of subexpression 1
(<code>&lt;k-kind-of-kind&gt;</code>). The answer, the composite result, that is, must be
placed in <code>*X</code> and <code>*XP</code>. (Composition functions are also allowed to
invalidate the result, by returning <code>FALSE</code>, and have other tricks up their
sleeves, but none of that is handled by us here: see the Inform 7 web for more
on this.)</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile the body of the compositor function</span><span class="named-paragraph-number">9.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">needs_collation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">) &amp;&amp; (((</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">preform_grammar</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand2</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">needs_collation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">needs_collation</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP9_1_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">At least one of the grammar lines provided an arrow and formula</span></span><span class="named-paragraph-number">9.1.2</span></a></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP9_1_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">None of the grammar lines provided an arrow and formula</span></span><span class="named-paragraph-number">9.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\treturn TRUE;\n"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP9">&#167;9</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9_1_1" class="paragraph-anchor"></a><b>&#167;9.1.1. </b>  In the absence of any <code>==&gt;</code> formulae, we simply set <code>*X</code> to the default
result supplied; this is the production number within the grammar (0 for the
first line, 1 for the second, and so on) by default, with an undefined pointer.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">None of the grammar lines provided an arrow and formula</span><span class="named-paragraph-number">9.1.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\t*X = R[0];\n"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP9_1">&#167;9.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_1_2" class="paragraph-anchor"></a><b>&#167;9.1.2. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">At least one of the grammar lines provided an arrow and formula</span><span class="named-paragraph-number">9.1.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\tswitch(R[0]) {\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">) &amp;&amp; (((</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">preform_grammar</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">, </span><span class="identifier-syntax">c</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">formula</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="3-lm.html#SP13" class="function-link"><span class="function-syntax">LanguageMethods::insert_line_marker</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><a href="1-ws.html#SP15" class="function-link"><span class="function-syntax">WebStructure::section_language</span></a><span class="plain-syntax">(</span><a href="2-ls.html#SP19" class="function-link"><span class="function-syntax">LiterateSource::section_of_line</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">)), </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\t\tcase %d: "</span><span class="plain-syntax">, </span><span class="identifier-syntax">c</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP9_1_2_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Tangle the formula on the right-hand side of the arrow</span></span><span class="named-paragraph-number">9.1.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">";\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"#pragma clang diagnostic push\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"#pragma clang diagnostic ignored \"-Wunreachable-code\"\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"break;\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"#pragma clang diagnostic pop\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\t\tdefault: *X = R[0]; break;\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\t}\n"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP9_1">&#167;9.1</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9_1_2_1" class="paragraph-anchor"></a><b>&#167;9.1.2.1. </b>  We assume that the RHS of the arrow is an expression to be evaluated,
and that it produces an integer or a pointer according to what the
non-terminal expects as its main result. But we make one exception: if
the formula begins with a paragraph macro, then it can't be an expression,
and instead we read it as code in a void context. (This code will, we
assume, set <code>*X</code> and/or <code>*XP</code> in some ingenious way of its own.)</p>
<p>Within the body of the formula, we allow a pseudo-macro to work: <code>WR[n]</code>
expands to word range <code>n</code> in the match which we're compositing. This actually
expands like so:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">action_clause_NTM</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">range_result</span><span class="plain-syntax">[</span><span class="identifier-syntax">n</span><span class="plain-syntax">]</span>
</pre>
<div class="lsmarkdown">
<p>which saves a good deal of typing. (A regular C preprocessor macro couldn't
easily do this, because it needs to include the identifier name of the
nonterminal being parsed.)</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Tangle the formula on the right-hand side of the arrow</span><span class="named-paragraph-number">9.1.2.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"{ *(%c*?) *} *(%c*)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">rewritten</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">rewritten</span><span class="plain-syntax">, </span><span class="string-syntax">"=="</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">rewritten</span><span class="plain-syntax">, </span><span class="string-syntax">"&gt; { %S }"</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><a href="3-is.html#SP11" class="function-link"><span class="function-syntax">InCSupport::tangle_line_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">rewritten</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="3-is.html#SP10" class="function-link"><span class="function-syntax">InCSupport::expand_formula</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">docket</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">rewritten</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"@&lt;%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">takes_pointer_result</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"*XP = "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"*X = "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><a href="3-is.html#SP10" class="function-link"><span class="function-syntax">InCSupport::expand_formula</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">docket</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP9_1_2">&#167;9.1.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. </b> </p>

<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::expand_formula</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">InCSupport::expand_formula</span></span>:<br/><a href="3-is.html#SP9_1_2_1">&#167;9.1.2.1</a>, <a href="3-is.html#SP11_2_3">&#167;11.2.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="type-syntax">tangle_docket</span><span class="plain-syntax"> *</span><span class="identifier-syntax">docket</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">expanded</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">'W'</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) == </span><span class="character-syntax">'R'</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+2) == </span><span class="character-syntax">'['</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Characters::isdigit</span><span class="plain-syntax">(</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+3))) &amp;&amp; (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+4) == </span><span class="character-syntax">']'</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><a href="2-we.html#SP2" class="function-link"><span class="function-syntax">WebErrors::issue_at</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"'WR[...]' notation unavailable"</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDERR</span><span class="plain-syntax">, </span><span class="string-syntax">"%S\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">formula</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">expanded</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                        </span><span class="string-syntax">"%S-&gt;range_result[%c]"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+3));</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="constant-syntax">4</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">PUT_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">expanded</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">formula</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">docket</span><span class="plain-syntax">) </span><a href="4-tt2.html#SP15" class="function-link"><span class="function-syntax">Tangler::tangle_literate_code_fragment</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">expanded</span><span class="plain-syntax">, </span><span class="identifier-syntax">docket</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><a href="3-is.html#SP11" class="function-link"><span class="function-syntax">InCSupport::tangle_line_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">expanded</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">expanded</span><span class="plain-syntax">)</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. </b>  Going down from line level to the tangling of little excerpts of C code,
we also provide for some other special extensions to C.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::tangle_line</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">InCSupport::tangle_line</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">original</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="3-is.html#SP11" class="function-link"><span class="function-syntax">InCSupport::tangle_line_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">original</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::tangle_line_inner</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">InCSupport::tangle_line_inner</span></span>:<br/><a href="3-is.html#SP9_1_2_1">&#167;9.1.2.1</a>, <a href="3-is.html#SP10">&#167;10</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">original</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">fcall_pos</span><span class="plain-syntax"> = </span><span class="constant-syntax">-1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Double-colons are namespace dividers in function names</span></span><span class="named-paragraph-number">11.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Long arrow and braces assigns Preform results</span></span><span class="named-paragraph-number">11.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">'&lt;'</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) == </span><span class="character-syntax">'&lt;'</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_3" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Double-angles sometimes delimit Preform variable names</span></span><span class="named-paragraph-number">11.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_4" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Single-angles sometimes delimit Preform nonterminal names</span></span><span class="named-paragraph-number">11.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> == </span><span class="identifier-syntax">fcall_pos</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">fcall_pos</span><span class="plain-syntax"> = </span><span class="constant-syntax">-1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">", NULL, NULL"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PUT</span><span class="plain-syntax">(</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_1" class="paragraph-anchor"></a><b>&#167;11.1. </b>  For example, a function name like <code>Text::Parsing::get_next</code> must be rewritten
as <code>Text__Parsing__get_next</code> since colons aren't valid in C identifiers. The
following is prone to all kinds of misreadings, of course; it picks up any use
of <code>::</code> between an alphanumberic character and a letter. In particular, code
like</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">printf</span><span class="plain-syntax">(</span><span class="string-syntax">"Trying Text::Parsing::get_next now.\n"</span><span class="plain-syntax">);</span>
</pre>
<div class="lsmarkdown">
<p>will be rewritten as</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">printf</span><span class="plain-syntax">(</span><span class="string-syntax">"Trying Text__Parsing__get_next now.\n"</span><span class="plain-syntax">);</span>
</pre>
<div class="lsmarkdown">
<p>This is probably unwanted, but it doesn't matter, because these Inform-only
extension features aren't intended for general use: only for Inform, where
no misreadings occur.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Double-colons are namespace dividers in function names</span><span class="named-paragraph-number">11.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">i</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">':'</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) == </span><span class="character-syntax">':'</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Characters::isalpha</span><span class="plain-syntax">(</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+2))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Characters::isalnum</span><span class="plain-syntax">(</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">-1)))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"__"</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11">&#167;11</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_2" class="paragraph-anchor"></a><b>&#167;11.2. </b>  For example, <code>==&gt; { A, B }</code> assigns the expressions A and B as the results
of parsing a Preform nonterminal.</p>
</div>
<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">MAX_PREFORM_RESULT_CLAUSES</span> <span class="constant-syntax">10</span>
</pre>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Long arrow and braces assigns Preform results</span><span class="named-paragraph-number">11.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">) == </span><span class="character-syntax">'='</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) == </span><span class="character-syntax">'='</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+2) == </span><span class="character-syntax">'&gt;'</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+3) == </span><span class="character-syntax">' '</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+4) == </span><span class="character-syntax">'{'</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">clauses</span><span class="plain-syntax">, </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_PREFORM_RESULT_CLAUSES</span><span class="plain-syntax">];</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_2_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Find the clauses</span></span><span class="named-paragraph-number">11.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_2_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Recognise one-clause specials</span></span><span class="named-paragraph-number">11.2.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">2</span><span class="plain-syntax">) </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">err</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP11_2_3" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Write the assignments</span></span><span class="named-paragraph-number">11.2.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">err</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="2-we.html#SP2" class="function-link"><span class="function-syntax">WebErrors::issue_at</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"malformed '{ , }' formula"</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDERR</span><span class="plain-syntax">, </span><span class="string-syntax">"%S\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">original</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11">&#167;11</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_2_1" class="paragraph-anchor"></a><b>&#167;11.2.1. </b>  The clauses are a comma-separated list inside the braces, except that the
commas need to be outside of any parentheses.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Find the clauses</span><span class="named-paragraph-number">11.2.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">bl</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax">+5; </span><span class="identifier-syntax">j</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">); </span><span class="identifier-syntax">j</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">inchar32_t</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">c</span><span class="plain-syntax"> == </span><span class="character-syntax">','</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">MAX_PREFORM_RESULT_CLAUSES</span><span class="plain-syntax">) </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> { </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">clauses</span><span class="plain-syntax">] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax">++; }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">c</span><span class="plain-syntax"> == </span><span class="character-syntax">'}'</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="identifier-syntax">j</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="character-syntax">'('</span><span class="plain-syntax">: </span><span class="identifier-syntax">bl</span><span class="plain-syntax">++; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="character-syntax">')'</span><span class="plain-syntax">: </span><span class="identifier-syntax">bl</span><span class="plain-syntax">--; </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PUT_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">clauses</span><span class="plain-syntax">-1], </span><span class="identifier-syntax">c</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> != </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">c</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">clauses</span><span class="plain-syntax">; </span><span class="identifier-syntax">c</span><span class="plain-syntax">++) </span><span class="identifier-syntax">Str::trim_white_space</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">c</span><span class="plain-syntax">]);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11_2">&#167;11.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_2_2" class="paragraph-anchor"></a><b>&#167;11.2.2. </b>  There are a number of special syntaxes with just one clause, and these
are implemented by rewriting them in two clauses, and sometimes adding some
extra code to execute after the assignments.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Recognise one-clause specials</span><span class="named-paragraph-number">11.2.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">I</span><span class="string-syntax">"fail"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="string-syntax">"return FAIL_NONTERMINAL;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="string-syntax">"-"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1], </span><span class="string-syntax">"-"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">I</span><span class="string-syntax">"fail production"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="string-syntax">"return FALSE;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="string-syntax">"-"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1], </span><span class="string-syntax">"-"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">I</span><span class="string-syntax">"fail nonterminal"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="string-syntax">"return FALSE;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="string-syntax">"-"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1], </span><span class="string-syntax">"-"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::prefix_eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">I</span><span class="string-syntax">"advance "</span><span class="plain-syntax">, </span><span class="constant-syntax">8</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="string-syntax">"return FAIL_NONTERMINAL + "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::substr</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="constant-syntax">8</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="string-syntax">";"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="string-syntax">"0"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1], </span><span class="string-syntax">"NULL"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::prefix_eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">I</span><span class="string-syntax">"pass "</span><span class="plain-syntax">, </span><span class="constant-syntax">5</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::substr</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="constant-syntax">5</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="string-syntax">"R[%S]"</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1], </span><span class="string-syntax">"RP[%S]"</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">I</span><span class="string-syntax">"lookahead"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">Str::new</span><span class="plain-syntax">(); </span><span class="identifier-syntax">clauses</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[0], </span><span class="string-syntax">"0"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[1], </span><span class="string-syntax">"NULL"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="string-syntax">"return preform_lookahead_mode;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11_2">&#167;11.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_2_3" class="paragraph-anchor"></a><b>&#167;11.2.3. </b>  Each clause leads to an assignment. Clauses 0 and 1 set the result values
for the current nonterminal; any subsequent clauses must specify which
variable is to be set. A dash means make no assignment.</p>
<p>For example, <code>{ R[1], - , &lt;&lt;to&gt;&gt; = R[2] }</code> sets <code>*X</code> to <code>R[1]</code>, does not
alter <code>*XP</code>, and sets <code>&lt;&lt;to&gt;&gt;</code> to <code>R[2]</code>.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Write the assignments</span><span class="named-paragraph-number">11.2.3</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">c</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">clauses</span><span class="plain-syntax">; </span><span class="identifier-syntax">c</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::ne</span><span class="plain-syntax">(</span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">c</span><span class="plain-syntax">], </span><span class="identifier-syntax">I</span><span class="string-syntax">"-"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">: </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"*X = "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><a href="3-is.html#SP10" class="function-link"><span class="function-syntax">InCSupport::expand_formula</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">c</span><span class="plain-syntax">], </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">";"</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">: </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"*XP = "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><a href="3-is.html#SP10" class="function-link"><span class="function-syntax">InCSupport::expand_formula</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">c</span><span class="plain-syntax">], </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">";"</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">default:</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">clause</span><span class="plain-syntax">[</span><span class="identifier-syntax">c</span><span class="plain-syntax">], </span><span class="identifier-syntax">U</span><span class="string-syntax">"&lt;&lt;(%P+)&gt;&gt; = *(%c*)"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">putative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0];</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pv_identifier</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">                            </span><a href="3-is.html#SP13" class="function-link"><span class="function-syntax">InCSupport::nonterminal_variable_identifier</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">putative</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pv_identifier</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%S = "</span><span class="plain-syntax">, </span><span class="identifier-syntax">pv_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                            </span><a href="3-is.html#SP10" class="function-link"><span class="function-syntax">InCSupport::expand_formula</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">";"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">err</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::ne</span><span class="plain-syntax">(</span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"-"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><a href="3-is.html#SP10" class="function-link"><span class="function-syntax">InCSupport::expand_formula</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="identifier-syntax">extra</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11_2">&#167;11.2</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_3" class="paragraph-anchor"></a><b>&#167;11.3. </b>  Angle brackets around a valid Preform variable name expand into its
C identifier; for example, <code>&lt;&lt;R&gt;&gt;</code> becomes <code>most_recent_result</code>.
We take no action if it's not a valid name, so <code>&lt;&lt;fish&gt;&gt;</code> becomes
just <code>&lt;&lt;fish&gt;&gt;</code>.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Double-angles sometimes delimit Preform variable names</span><span class="named-paragraph-number">11.3</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::substr</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">check_this</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"&lt;&lt;(%P+)&gt;&gt;%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">putative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0];</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pv_identifier</span><span class="plain-syntax"> = </span><a href="3-is.html#SP13" class="function-link"><span class="function-syntax">InCSupport::nonterminal_variable_identifier</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">putative</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pv_identifier</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%S"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pv_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">putative</span><span class="plain-syntax">) + </span><span class="constant-syntax">3</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11">&#167;11</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11_4" class="paragraph-anchor"></a><b>&#167;11.4. </b>  Similarly for nonterminals; <code>&lt;k-kind&gt;</code> might become <code>k_kind_NTM</code>.
Here, though, there's a complication:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;k-kind&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) { ...</span>
</pre>
<div class="lsmarkdown">
<p>must expand to:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Text__Languages__parse_nt_against_word_range</span><span class="plain-syntax">(</span><span class="identifier-syntax">k_kind_NTM</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) { ...</span>
</pre>
<div class="lsmarkdown">
<p>This is all syntactic sugar to make it easier to see parsing in action.
Anyway, it means we have to set <code>fcall_pos</code> to remember to add in the
two <code>NULL</code> arguments when we hit the <code>)</code> a little later. We're doing all
of this fairly laxly, but as before: it only needs to work for Inform,
and Inform doesn't cause any trouble.</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Single-angles sometimes delimit Preform nonterminal names</span><span class="named-paragraph-number">11.4</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::substr</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">, </span><span class="identifier-syntax">Str::at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">), </span><span class="identifier-syntax">Str::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">check_this</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"(&lt;%p+&gt;)%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">putative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0];</span>
<span class="plain-syntax">        </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><a href="3-is.html#SP12" class="function-link"><span class="function-syntax">InCSupport::nonterminal_by_name</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">putative</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax"> += </span><span class="identifier-syntax">Str::len</span><span class="plain-syntax">(</span><span class="identifier-syntax">putative</span><span class="plain-syntax">) </span><span class="constant-syntax">-</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">+1) == </span><span class="character-syntax">'('</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">arity</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax">+2, </span><span class="identifier-syntax">bl</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">; ((</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)); </span><span class="identifier-syntax">j</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">) == </span><span class="character-syntax">'('</span><span class="plain-syntax">) </span><span class="identifier-syntax">bl</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">) == </span><span class="character-syntax">')'</span><span class="plain-syntax">) { </span><span class="identifier-syntax">bl</span><span class="plain-syntax">--; </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">fcall_pos</span><span class="plain-syntax"> = </span><span class="identifier-syntax">j</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Str::get_at</span><span class="plain-syntax">(</span><span class="identifier-syntax">original</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">) == </span><span class="character-syntax">','</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">bl</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">)) </span><span class="identifier-syntax">arity</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"Preform__parse_nt_against_word_range("</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%S"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_C_identifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">fcall_pos</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">", "</span><span class="plain-syntax">); </span><span class="identifier-syntax">i</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">check_this</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP11">&#167;11</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. </b>  We needed two little routines to find nonterminals and their variables by
name. They're not very efficient, but experience shows that even on a web
the size of Inform 7, there's no significant gain from speeding them up
(with, say, a hash table).</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="function-syntax">InCSupport::nonterminal_by_name</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">InCSupport::nonterminal_by_name</span></span>:<br/><a href="3-is.html#SP11_4">&#167;11.4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">name</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">name</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. </b>  The special variables <code>&lt;&lt;R&gt;&gt;</code> and <code>&lt;&lt;RP&gt;&gt;</code> hold the results,
integer and pointer, for the most recent successful match. They're defined
in the Inform 7 web (see the code for parsing text against Preform grammars),
not here.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="function-syntax">InCSupport::nonterminal_variable_identifier</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">InCSupport::nonterminal_variable_identifier</span></span>:<br/><a href="3-is.html#SP11_2_3">&#167;11.2.3</a>, <a href="3-is.html#SP11_3">&#167;11.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">name</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">name</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"r"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">I</span><span class="string-syntax">"most_recent_result"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">name</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"rp"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">I</span><span class="string-syntax">"most_recent_result_p"</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">, </span><span class="type-syntax">nonterminal_variable</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">name</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">ntv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ntv_identifier</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. </b>  We saw above that the grammar lines following a non-internal declaration
were divided into actual grammar, then an arrow, then a formula. The formulae
were tangled into &quot;composition functions&quot;, but the grammar itself was
simply thrown away. It doesn't appear anywhere in the C code tangled.</p>
<p>So what does happen to it? The answer is that it's transcribed into an
auxiliary file called <code>Syntax.preform</code>, which Inform, once it is compiled,
will read in at run-time. This is how that happens:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::additional_tangling</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">InCSupport::additional_tangling</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="type-syntax">ls_web</span><span class="plain-syntax"> *</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="type-syntax">tangle_target</span><span class="plain-syntax"> *</span><span class="identifier-syntax">target</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">NUMBER_CREATED</span><span class="plain-syntax">(</span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pathname</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P</span><span class="plain-syntax"> = </span><a href="1-ws.html#SP9" class="function-link"><span class="function-syntax">WebStructure::tangled_folder</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">filename</span><span class="plain-syntax"> *</span><span class="identifier-syntax">Syntax</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Filenames::in</span><span class="plain-syntax">(</span><span class="identifier-syntax">P</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Syntax.preform"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> </span><span class="identifier-syntax">TO_struct</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax"> = &amp;</span><span class="identifier-syntax">TO_struct</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">STREAM_OPEN_TO_FILE</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Syntax</span><span class="plain-syntax">, </span><span class="identifier-syntax">ISO_ENC</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Errors::fatal_with_file</span><span class="plain-syntax">(</span><span class="string-syntax">"unable to write Preform file"</span><span class="plain-syntax">, </span><span class="identifier-syntax">Syntax</span><span class="plain-syntax">);</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">STDOUT</span><span class="plain-syntax">, </span><span class="string-syntax">"Writing Preform syntax to: %/f\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">Syntax</span><span class="plain-syntax">);</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"[Preform syntax generated by inweb: do not edit.]\n\n"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="1-bdfw.html#SP6" class="function-link"><span class="function-syntax">Bibliographic::data_exists</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Preform Language"</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"language %S\n"</span><span class="plain-syntax">, </span><a href="1-bdfw.html#SP6" class="function-link"><span class="function-syntax">Bibliographic::get_datum</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Preform Language"</span><span class="plain-syntax">));</span>

<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP14_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">Actually write out the Preform syntax</span></span><span class="named-paragraph-number">14.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">STREAM_CLOSE</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP14_1" class="paragraph-anchor"></a><b>&#167;14.1. </b>  See the &quot;English Syntax of Inform&quot; document for a heavily annotated
form of the result of the following. Note a useful convention: if the
right-hand side of the arrow in a grammar line uses a paragraph macro which
mentions a problem message, then we transcribe a Preform comment to that
effect. (This really is a comment: Inform ignores it, but it makes the
file more comprehensible to human eyes.) For example,</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">&lt;article&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> ==&gt; @&lt;</span><span class="identifier-syntax">Issue</span><span class="plain-syntax"> </span><span class="identifier-syntax">C8PropertyOfKind</span><span class="plain-syntax"> </span><span class="identifier-syntax">problem</span><span class="plain-syntax">@&gt;</span>
</pre>
<div class="lsmarkdown">
<p>(The code in this paragraph macro will indeed issue this problem message, we
assume.)</p>
</div>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Actually write out the Preform syntax</span><span class="named-paragraph-number">14.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">ls_chapter</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_WITHIN_CODE</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><a href="4-tt.html#SP3" class="function-link"><span class="function-syntax">TangleTargets::primary_target</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *</span><span class="identifier-syntax">L</span><span class="plain-syntax"> = (</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">L</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">preform_nonterminal_defined</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_function</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\n%S internal\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">nt_name</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\n%S ::=\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                ((</span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">) &amp;&amp; (((</span><span class="type-syntax">ls_line_analysis</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">analysis_ref</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">preform_grammar</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_line</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%S"</span><span class="plain-syntax">, </span><span class="identifier-syntax">A_lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">classification</span><span class="plain-syntax">.</span><span class="element-syntax">operand2</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"%c+Issue (%c+) problem%c+"</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"[issues %S]"</span><span class="plain-syntax">, </span><span class="identifier-syntax">mr</span><span class="plain-syntax">.</span><span class="identifier-syntax">exp</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP14">&#167;14</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. Weaving.</b>  The following isn't a method, but is called by the weaver directly. It adds
additional endnotes to the woven form of a paragraph which includes Preform
nonterminal definitions; it is meaningful only in the TeX format, and should
probably be dropped.</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::weave_grammar_index</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">InCSupport::weave_grammar_index</span></span>:<br/>TeX Format - <a href="5-tf.html#SP4_34">&#167;4.34</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\raggedright\\tolerance=10000"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">alphabetical_list_of_nonterminals</span><span class="plain-syntax">; </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pnt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_pnt_alphabetically</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\line{\\nonterminal{%S}%s"</span>
<span class="plain-syntax">            </span><span class="string-syntax">"\\leaders\\hbox to 1em{\\hss.\\hss}\\hfill {\\xreffont %S}}\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">unangled_name</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_function</span><span class="plain-syntax">)?</span><span class="string-syntax">" (internal)"</span><span class="plain-syntax">:</span><span class="string-syntax">""</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><a href="1-wr.html#SP1" class="function-link"><span class="function-syntax">WebRanges::of</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_defined</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">said_something</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP15_2" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">List where the nonterminal appears in other Preform declarations</span></span><span class="named-paragraph-number">15.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-is.html#SP15_1" class="named-paragraph-link"><span class="named-paragraph"><span class="mathjax_process">List where the nonterminal is called from Inform code</span></span><span class="named-paragraph-number">15.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">said_something</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\par\\hangindent=3em{\\it unused}\n\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\penalty-1000\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\smallbreak\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\hrule\\smallbreak\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15_1" class="paragraph-anchor"></a><b>&#167;15.1. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">List where the nonterminal is called from Inform code</span><span class="named-paragraph-number">15.1</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax">) </span><span class="identifier-syntax">S</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">hash_table_entry</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hte</span><span class="plain-syntax"> = </span><a href="3-ca.html#SP8" class="function-link"><span class="function-syntax">CodeAnalysis::find_hash_entry_for_section</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_defined</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">unangled_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">hash_table_entry_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">, </span><span class="type-syntax">hash_table_entry_usage</span><span class="plain-syntax">, </span><span class="identifier-syntax">hte</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">usages</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">form_of_usage</span><span class="plain-syntax"> &amp; </span><span class="constant-syntax">PREFORM_IN_CODE_USAGE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><a href="2-ls.html#SP19" class="function-link"><span class="function-syntax">LiterateSource::section_of_par</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">usage_recorded_at</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">use_count</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">S</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">use_count</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">use_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">said_something</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\par\\hangindent=3em{\\it called from} "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">S</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">", "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"{\\xreffont %S}"</span><span class="plain-syntax">, </span><a href="1-wr.html#SP1" class="function-link"><span class="function-syntax">WebRanges::of</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\n\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP15">&#167;15</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP15_2" class="paragraph-anchor"></a><b>&#167;15.2. </b> <span class="named-paragraph-container code-font"><span class="named-paragraph-defn">List where the nonterminal appears in other Preform declarations</span><span class="named-paragraph-number">15.2</span></span> =</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax">) </span><span class="identifier-syntax">S</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">hash_table_entry</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hte</span><span class="plain-syntax"> = </span><a href="3-ca.html#SP8" class="function-link"><span class="function-syntax">CodeAnalysis::find_hash_entry_for_section</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_defined</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">unangled_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="type-syntax">hash_table_entry_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">, </span><span class="type-syntax">hash_table_entry_usage</span><span class="plain-syntax">, </span><span class="identifier-syntax">hte</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">usages</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">form_of_usage</span><span class="plain-syntax"> &amp; </span><span class="constant-syntax">PREFORM_IN_GRAMMAR_USAGE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><a href="2-ls.html#SP19" class="function-link"><span class="function-syntax">LiterateSource::section_of_par</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">hteu</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">usage_recorded_at</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">use_count</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">S</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">use_count</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">use_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">said_something</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\\par\\hangindent=3em{\\it used by other nonterminals in} "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">S</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">scratch_flag</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">", "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"{\\xreffont %S}"</span><span class="plain-syntax">, </span><a href="1-wr.html#SP1" class="function-link"><span class="function-syntax">WebRanges::of</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"\n\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-is.html#SP15">&#167;15</a>.</li></ul>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. Weaving methods.</b>  If we're weaving just a document of Preform grammar, then we skip any lines
of C code which appear in <code>internal</code> nonterminal definitions:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">skipping_internal</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">preform_production_count</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>

<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::skip_in_weaving</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">InCSupport::skip_in_weaving</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="type-syntax">weave_order</span><span class="plain-syntax"> *</span><span class="identifier-syntax">wv</span><span class="plain-syntax">, </span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lst</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">wv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">theme_match</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Preform"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">match_results</span><span class="plain-syntax"> </span><span class="identifier-syntax">mr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Regexp::create_mr</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"}%c*"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">skipping_internal</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">skipping_internal</span><span class="plain-syntax">) { </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Regexp::match</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">, </span><span class="identifier-syntax">lst</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"&lt;%c*?&gt; internal%c*"</span><span class="plain-syntax">)) </span><span class="identifier-syntax">skipping_internal</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Regexp::dispose_of</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">mr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. </b>  And here is the TeX code for displaying Preform grammar:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::weave_code_line</span><button class="popup" onclick="togglePopup('usagePopup15')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup15">Usage of <span class="code-font"><span class="function-syntax">InCSupport::weave_code_line</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="type-syntax">weave_order</span><span class="plain-syntax"> *</span><span class="identifier-syntax">wv</span><span class="plain-syntax">, </span><span class="type-syntax">ls_web</span><span class="plain-syntax"> *</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="type-syntax">ls_chapter</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="type-syntax">ls_section</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="type-syntax">ls_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lst</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">matter</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">concluding_comment</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">wv</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">theme_match</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"Preform"</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="5-fm.html#SP7" class="function-link"><span class="function-syntax">WeavingFormats::preform_document</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">wv</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="identifier-syntax">lst</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">matter</span><span class="plain-syntax">, </span><span class="identifier-syntax">concluding_comment</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. Analysis methods.</b> </p>

<pre class="displayed-code all-displayed-code code-font">
<span class="type-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::analyse_code</span><button class="popup" onclick="togglePopup('usagePopup16')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup16">Usage of <span class="code-font"><span class="function-syntax">InCSupport::analyse_code</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="type-syntax">ls_web</span><span class="plain-syntax"> *</span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">, </span><span class="type-syntax">preform_nonterminal</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="3-ca.html#SP8" class="function-link"><span class="function-syntax">CodeAnalysis::find_hash_entry_for_section</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_defined</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pnt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">unangled_name</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="type-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">InCSupport::share_element</span><button class="popup" onclick="togglePopup('usagePopup17')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup17">Usage of <span class="code-font"><span class="function-syntax">InCSupport::share_element</span></span>:<br/><a href="3-is.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="type-syntax">programming_language</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">elname</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">elname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"word_ref1"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">elname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"word_ref2"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">elname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"next"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">elname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"down"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">elname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"allocation_id"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">elname</span><span class="plain-syntax">, </span><span class="identifier-syntax">U</span><span class="string-syntax">"method_set"</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-cl.html">&#10094;</a></li><li class="progresschapter"><a href="P-abgtl.html">P</a></li><li class="progresschapter"><a href="1-lm.html">1</a></li><li class="progresschapter"><a href="2-ls.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresssection"><a href="3-pl.html">pl</a></li><li class="progresssection"><a href="3-ca.html">ca</a></li><li class="progresssection"><a href="3-cc.html">cc</a></li><li class="progresssection"><a href="3-ec.html">ec</a></li><li class="progresssection"><a href="3-taf.html">taf</a></li><li class="progresssection"><a href="3-rw.html">rw</a></li><li class="progresssection"><a href="3-tp.html">tp</a></li><li class="progresssection"><a href="3-lm.html">lm</a></li><li class="progresssection"><a href="3-as.html">as</a></li><li class="progresssection"><a href="3-cl.html">cl</a></li><li class="progresscurrent">is</li><li class="progresschapter"><a href="4-tt.html">4</a></li><li class="progresschapter"><a href="5-wd.html">5</a></li><li class="progresschapter"><a href="6-mkf.html">6</a></li><li class="progressnext"><a href="4-tt.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

