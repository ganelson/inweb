[Collater::] The Collater.

To collate material generated by the weaver into finished, fully-woven files.

@h Collation.
This is the process of reading a template file, substituting material into
placeholders in it, and writing the result.

The collater needs to operate as a little processor interpreting a
meta-language all of its very own, with a stack for holding nested repeat
loops, and a program counter and -- well, and nothing else to speak of, in
fact, except for the slightly unusual way that loop variables provide context
by changing the subject of what is discussed rather than by being accessed
directly.

For convenience, we provide three ways to call:

=
void Collater::for_web_and_pattern(text_stream *OUT, ls_web *W,
	ls_pattern *pattern, filename *F, filename *into, ls_colony *context,
	weave_reporting *R) {
	Collater::collate(OUT, W, I"", F, NULL, pattern, NULL, NULL, NULL, into, context, R);
}

void Collater::for_order(text_stream *OUT, weave_order *wv,
	filename *F, filename *into, ls_colony *context, weave_reporting *R) {
	Collater::collate(OUT, wv->weave_web, wv->weave_range, F, NULL, wv->pattern,
		wv->navigation, wv->breadcrumbs, wv, into, context, R);
}

void Collater::collate(text_stream *OUT, ls_web *W, text_stream *range,
	filename *template_filename, wcl_declaration *template_wcl,
	ls_pattern *pattern, wcl_declaration *nav_file,
	linked_list *crumbs, weave_order *wv, filename *into, ls_colony *context,
	weave_reporting *R) {
	collater_state actual_ies =
		Collater::initial_state(W, range, template_filename, template_wcl, pattern, 
			nav_file, crumbs, wv, into, context, R);
	collater_state *ies = &actual_ies;
	Collater::process(OUT, ies);
}

@ The current state of the processor is recorded in the following.

@d TRACE_COLLATER_EXECUTION FALSE /* set true for debugging */

@d MAX_TEMPLATE_LINES 8192 /* maximum number of lines in template */
@d CI_STACK_CAPACITY 8 /* maximum recursion of chapter/section iteration */

=
typedef struct collater_state {
	struct ls_colony *context;
	struct ls_web *for_web;
	struct text_stream *tlines[MAX_TEMPLATE_LINES];
	int no_tlines;
	int repeat_stack_level[CI_STACK_CAPACITY];
	struct linked_list_item *repeat_stack_variable[CI_STACK_CAPACITY];
	struct linked_list_item *repeat_stack_threshold[CI_STACK_CAPACITY];
	int repeat_stack_startpos[CI_STACK_CAPACITY];
	int sp; /* And this is our stack pointer for tracking of loops */
	struct text_stream *restrict_to_range;
	struct ls_pattern *nav_pattern;
	struct wcl_declaration *nav_file;
	struct linked_list *crumbs;
	int inside_navigation_submenu;
	struct filename *errors_at;
	struct weave_order *wv;
	struct filename *into_file;
	struct linked_list *modules; /* of |ls_module| */
	struct weave_reporting *reportage;
} collater_state;

@ Note the unfortunate maximum size limit on the template file. It means
that really humungous Javascript files in plugins might have trouble, though
if so, they can always be subdivided.

=
collater_state Collater::initial_state(ls_web *W, text_stream *range,
	filename *template_filename, wcl_declaration *template_wcl,
	ls_pattern *pattern, wcl_declaration *nav_file,
	linked_list *crumbs, weave_order *wv, filename *into, ls_colony *context,
	weave_reporting *R) {
	collater_state cls;
	cls.no_tlines = 0;
	cls.restrict_to_range = Str::duplicate(range);
	cls.sp = 0;
	cls.inside_navigation_submenu = FALSE;
	cls.for_web = W;
	cls.nav_pattern = pattern;
	cls.nav_file = nav_file;
	cls.crumbs = crumbs;
	cls.errors_at = template_filename;
	cls.wv = wv;
	cls.into_file = into;
	cls.modules = NEW_LINKED_LIST(ls_module);
	cls.context = context;
	cls.reportage = R;
	if ((context == NULL) && (wv)) cls.context = wv->weave_colony;
	if (W) {
		int c = LinkedLists::len(W->main_module->dependencies);
		if (c > 0) @<Form the list of imported modules@>;
	}
	if (template_wcl) @<Read in the WCL declaration as lines@>
	else @<Read in the source file containing the contents page template@>;
	return cls;
}

@<Form the list of imported modules@> =
	ls_module **module_array = 
		Memory::calloc(c, sizeof(ls_module *), ARRAY_SORTING_MREASON);
	ls_module *M; int d=0;
	LOOP_OVER_LINKED_LIST(M, ls_module, W->main_module->dependencies)
		module_array[d++] = M;
	Collater::sort_web(W);
	qsort(module_array, (size_t) c, sizeof(ls_module *), Collater::sort_comparison);
	for (int d=0; d<c; d++) ADD_TO_LINKED_LIST(module_array[d], ls_module, cls.modules);
	Memory::I7_free(module_array, ARRAY_SORTING_MREASON, c*((int) sizeof(ls_module *)));

@<Read in the WCL declaration as lines@> =
	text_stream *line;
	LOOP_OVER_LINKED_LIST(line, text_stream, template_wcl->declaration_lines)
		if (cls.no_tlines < MAX_TEMPLATE_LINES)
			cls.tlines[cls.no_tlines++] = Str::duplicate(line);
	if (cls.no_tlines >= MAX_TEMPLATE_LINES)
		PRINT("Warning: template in declaration truncated after %d line(s)\n",
			cls.no_tlines);

@<Read in the source file containing the contents page template@> =
	TextFiles::read(template_filename, FALSE,
		"can't find contents template", TRUE, Collater::temp_line, NULL, &cls);
	if (TRACE_COLLATER_EXECUTION)
		PRINT("Read template <%f>: %d line(s)\n", template_filename, cls.no_tlines);
	if (cls.no_tlines >= MAX_TEMPLATE_LINES)
		PRINT("Warning: template <%f> truncated after %d line(s)\n",
			template_filename, cls.no_tlines);

@ =
void Collater::temp_line(text_stream *line, text_file_position *tfp, void *v_ies) {
	collater_state *cls = (collater_state *) v_ies;
	if (cls->no_tlines < MAX_TEMPLATE_LINES)
		cls->tlines[cls->no_tlines++] = Str::duplicate(line);
}

@ Running the engine...

=
void Collater::process(text_stream *OUT, collater_state *cls) {
	int lpos = 0; /* This is our program counter: a line number in the template */
	while (lpos < cls->no_tlines) {
		match_results mr = Regexp::create_mr();
		TEMPORARY_TEXT(tl)
		Str::copy(tl, cls->tlines[lpos++]); /* Fetch the line at the program counter and advance */
		@<Make any necessary substitutions to turn tl into final output@>;
		WRITE("%S\n", tl); /* Copy the now finished line to the output */
		DISCARD_TEXT(tl)
		CYCLE: ;
		Regexp::dispose_of(&mr);
	}
	if (cls->inside_navigation_submenu) WRITE("</ul>");
	cls->inside_navigation_submenu = FALSE;
}

@<Make any necessary substitutions to turn tl into final output@> =
	if (Regexp::match(&mr, tl, U"(%c*?) ")) Str::copy(tl, mr.exp[0]); /* Strip trailing spaces */
	if (TRACE_COLLATER_EXECUTION)
		@<Print line and contents of repeat stack@>;
	if ((Regexp::match(&mr, tl, U"%[%[(%c+)%]%]")) ||
		(Regexp::match(&mr, tl, U" %[%[(%c+)%]%]"))) {
		TEMPORARY_TEXT(command)
		Str::copy(command, mr.exp[0]);
		@<Deal with a Select command@>;
		@<Deal with an If command@>;
		@<Deal with an Else command@>;
		@<Deal with a Repeat command@>;
		@<Deal with a Repeat End command@>;
		DISCARD_TEXT(command)
	}
	@<Skip line if inside a failed conditional@>;
	@<Skip line if inside an empty loop@>;
	@<Make substitutions of square-bracketed variables in line@>;

@h The repeat stack and loops.
This is used only for debugging:

@<Print line and contents of repeat stack@> =
	PRINT("%04d: %S\nStack:", lpos-1, tl);
	for (int j=0; j<cls->sp; j++) {
		if (cls->repeat_stack_level[j] == CHAPTER_LEVEL)
			PRINT(" %d: %S/%S",
				j, ((ls_chapter *)
					CONTENT_IN_ITEM(cls->repeat_stack_variable[j], ls_chapter))->ch_range,
				((ls_chapter *)
					CONTENT_IN_ITEM(cls->repeat_stack_threshold[j], ls_chapter))->ch_range);
		else if (cls->repeat_stack_level[j] == SECTION_LEVEL)
			PRINT(" %d: %S/%S",
				j, WebRanges::of(((ls_section *)
					CONTENT_IN_ITEM(cls->repeat_stack_variable[j], ls_section))),
				WebRanges::of(((ls_section *)
					CONTENT_IN_ITEM(cls->repeat_stack_threshold[j], ls_section))));
	}
	PRINT("\n");

@ We start the direct commands with Select, which is implemented as a
one-iteration loop in which the loop variable has the given section or
chapter as its value during the sole iteration.

@<Deal with a Select command@> =
	match_results mr = Regexp::create_mr();
	if (Regexp::match(&mr, command, U"Select (%c*)")) {
		ls_chapter *C;
		ls_section *S;
		LOOP_OVER_LINKED_LIST(C, ls_chapter, cls->for_web->chapters)
			LOOP_OVER_LINKED_LIST(S, ls_section, C->sections)
				if (Str::eq(WebRanges::of(S), mr.exp[0])) {
					Collater::start_CI_loop(cls, SECTION_LEVEL, S_item, S_item, lpos);
					Regexp::dispose_of(&mr);
					goto CYCLE;
				}
		LOOP_OVER_LINKED_LIST(C, ls_chapter, cls->for_web->chapters)
			if (Str::eq(C->ch_range, mr.exp[0])) {
				Collater::start_CI_loop(cls, CHAPTER_LEVEL, C_item, C_item, lpos);
				Regexp::dispose_of(&mr);
				goto CYCLE;
			}
		Errors::at_position("don't recognise the chapter or section abbreviation range",
			cls->errors_at, lpos);
		Regexp::dispose_of(&mr);
		goto CYCLE;
	}

@ Conditionals:

@<Deal with an If command@> =
	if (Regexp::match(&mr, command, U"If (%c*)")) {
		text_stream *condition = mr.exp[0];
		int level = IF_FALSE_LEVEL;
		if (Str::eq(condition, I"Chapters")) {
			if (cls->for_web->chaptered) level = IF_TRUE_LEVEL;
		} else if (Str::eq(condition, I"Modules")) {
			if (LinkedLists::len(cls->modules) > 0)
				level = IF_TRUE_LEVEL;
		} else if (Str::eq(condition, I"Module Page")) {
			ls_module *M = CONTENT_IN_ITEM(
				Collater::heading_topmost_on_stack(cls, MODULE_LEVEL), ls_module);
			if ((M) && (Colonies::find(cls->context, M->module_name)))
				level = IF_TRUE_LEVEL;
		} else if (Str::eq(condition, I"Module Purpose")) {
			ls_module *M = CONTENT_IN_ITEM(
				Collater::heading_topmost_on_stack(cls, MODULE_LEVEL), ls_module);
			if (M) {
				TEMPORARY_TEXT(url)
				TEMPORARY_TEXT(purpose)
				WRITE_TO(url, "%p", M->module_location);
				Readme::write_var(purpose, url, I"Purpose");
				if (Str::len(purpose) > 0) level = IF_TRUE_LEVEL;
				DISCARD_TEXT(url)		
				DISCARD_TEXT(purpose)		
			}
		} else if (Str::eq(condition, I"Chapter Purpose")) {
			ls_chapter *C = CONTENT_IN_ITEM(
				Collater::heading_topmost_on_stack(cls, CHAPTER_LEVEL), ls_chapter);
			if ((C) && (Str::len(C->rubric) > 0)) level = IF_TRUE_LEVEL;
		} else if (Str::eq(condition, I"Section Purpose")) {
			ls_section *S = CONTENT_IN_ITEM(
				Collater::heading_topmost_on_stack(cls, SECTION_LEVEL), ls_section);
			if (Str::len(LiterateSource::unit_purpose(S->literate_source)) > 0) level = IF_TRUE_LEVEL;
		} else if (Str::eq(condition, I"Navigation")) {
			if (cls->nav_file) level = IF_TRUE_LEVEL;
		} else {
			Errors::at_position("don't recognise the condition",
				cls->errors_at, lpos);
		}
		Collater::start_CI_loop(cls, level, NULL, NULL, lpos);
		Regexp::dispose_of(&mr);
		goto CYCLE;
	}

@<Deal with an Else command@> =
	if (Regexp::match(&mr, command, U"Else")) {
		if (cls->sp <= 0) {
			Errors::at_position("Else without If",
				cls->errors_at, lpos);
			goto CYCLE;
		}
		switch (cls->repeat_stack_level[cls->sp-1]) {
			case SECTION_LEVEL:
			case CHAPTER_LEVEL:
				Errors::at_position("Else not matched with If",
					cls->errors_at, lpos);
				break;
			case IF_TRUE_LEVEL: cls->repeat_stack_level[cls->sp-1] = IF_FALSE_LEVEL; break;
			case IF_FALSE_LEVEL: cls->repeat_stack_level[cls->sp-1] = IF_TRUE_LEVEL; break;
		}
		Regexp::dispose_of(&mr);
		goto CYCLE;
	}

@ Next, a genuine loop beginning:

@<Deal with a Repeat command@> =
	int loop_level = 0;
	if (Regexp::match(&mr, command, U"Repeat Module")) loop_level = MODULE_LEVEL;
	if (Regexp::match(&mr, command, U"Repeat Chapter")) loop_level = CHAPTER_LEVEL;
	if (Regexp::match(&mr, command, U"Repeat Section")) loop_level = SECTION_LEVEL;
	if (loop_level != 0) {
		linked_list_item *from = NULL, *to = NULL;
		linked_list_item *CI = FIRST_ITEM_IN_LINKED_LIST(chapter, cls->for_web->chapters);
		while ((CI) && (CONTENT_IN_ITEM(CI, ls_chapter)->imported))
			CI = NEXT_ITEM_IN_LINKED_LIST(CI, ls_chapter);
		if (loop_level == MODULE_LEVEL) @<Begin a module repeat@>;
		if (loop_level == CHAPTER_LEVEL) @<Begin a chapter repeat@>;
		if (loop_level == SECTION_LEVEL) @<Begin a section repeat@>;
		Collater::start_CI_loop(cls, loop_level, from, to, lpos);
		goto CYCLE;
	}

@<Begin a module repeat@> =
	from = FIRST_ITEM_IN_LINKED_LIST(ls_module, cls->modules);
	to = LAST_ITEM_IN_LINKED_LIST(ls_module, cls->modules);

@<Begin a chapter repeat@> =
	from = CI;
	to = LAST_ITEM_IN_LINKED_LIST(chapter, cls->for_web->chapters);
	if (Str::eq_wide_string(cls->restrict_to_range, U"0") == FALSE) {
		ls_chapter *C;
		LOOP_OVER_LINKED_LIST(C, ls_chapter, cls->for_web->chapters)
			if (Str::eq(C->ch_range, cls->restrict_to_range)) {
				from = C_item; to = from;
				break;
			}
	}

@<Begin a section repeat@> =
	ls_chapter *within_chapter =
		CONTENT_IN_ITEM(Collater::heading_topmost_on_stack(cls, CHAPTER_LEVEL),
			ls_chapter);
	if (within_chapter == NULL) {
		if (CI) {
			ls_chapter *C = CONTENT_IN_ITEM(CI, ls_chapter);
			from = FIRST_ITEM_IN_LINKED_LIST(ls_section, C->sections);
		}
		ls_chapter *LC = LAST_IN_LINKED_LIST(ls_chapter, cls->for_web->chapters);
		if (LC) to = LAST_ITEM_IN_LINKED_LIST(ls_section, LC->sections);
	} else {
		from = FIRST_ITEM_IN_LINKED_LIST(ls_section, within_chapter->sections);
		to = LAST_ITEM_IN_LINKED_LIST(ls_section, within_chapter->sections);
	}

@ And at the other bookend:

@<Deal with a Repeat End command@> =
	int end_form = -1;
	if (Regexp::match(&mr, command, U"End Repeat")) end_form = 1;
	if (Regexp::match(&mr, command, U"End Select")) end_form = 2;
	if (Regexp::match(&mr, command, U"End If")) end_form = 3;
	if (end_form > 0) {
		if (cls->sp <= 0) {
			Errors::at_position("stack underflow on contents template",
				cls->errors_at, lpos);
			goto CYCLE;
		}
		switch (cls->repeat_stack_level[cls->sp-1]) {
			case MODULE_LEVEL:
			case CHAPTER_LEVEL:
			case SECTION_LEVEL:
				if (end_form == 3) {
					Errors::at_position("End If not matched with If",
						cls->errors_at, lpos);
					goto CYCLE;
				}
				break;
			case IF_TRUE_LEVEL:
			case IF_FALSE_LEVEL:
				if (end_form != 3) {
					Errors::at_position("If not matched with End If",
						cls->errors_at, lpos);
					goto CYCLE;
				}
				break;
		}
		switch (cls->repeat_stack_level[cls->sp-1]) {
			case MODULE_LEVEL: @<End a module repeat@>; break;
			case CHAPTER_LEVEL: @<End a chapter repeat@>; break;
			case SECTION_LEVEL: @<End a section repeat@>; break;
			case IF_TRUE_LEVEL: @<End an If@>; break;
			case IF_FALSE_LEVEL: @<End an If@>; break;
		}
		goto CYCLE;
	}

@<End a module repeat@> =
	linked_list_item *CI = cls->repeat_stack_variable[cls->sp-1];
	if (CI == cls->repeat_stack_threshold[cls->sp-1])
		Collater::end_CI_loop(cls);
	else {
		cls->repeat_stack_variable[cls->sp-1] =
			NEXT_ITEM_IN_LINKED_LIST(CI, chapter);
		lpos = cls->repeat_stack_startpos[cls->sp-1]; /* Back round loop */
	}

@<End a chapter repeat@> =
	linked_list_item *CI = cls->repeat_stack_variable[cls->sp-1];
	if (CI == cls->repeat_stack_threshold[cls->sp-1])
		Collater::end_CI_loop(cls);
	else {
		cls->repeat_stack_variable[cls->sp-1] =
			NEXT_ITEM_IN_LINKED_LIST(CI, chapter);
		lpos = cls->repeat_stack_startpos[cls->sp-1]; /* Back round loop */
	}

@<End a section repeat@> =
	linked_list_item *SI = cls->repeat_stack_variable[cls->sp-1];
	if ((SI == cls->repeat_stack_threshold[cls->sp-1]) ||
		(NEXT_ITEM_IN_LINKED_LIST(SI, ls_section) == NULL))
		Collater::end_CI_loop(cls);
	else {
		cls->repeat_stack_variable[cls->sp-1] =
			NEXT_ITEM_IN_LINKED_LIST(SI, ls_section);
		lpos = cls->repeat_stack_startpos[cls->sp-1]; /* Back round loop */
	}

@<End an If@> =
	Collater::end_CI_loop(cls);

@ It can happen that a section loop, at least, is empty:

@<Skip line if inside an empty loop@> =
	for (int rstl = cls->sp-1; rstl >= 0; rstl--)
		if (cls->repeat_stack_level[cls->sp-1] == SECTION_LEVEL) {
			linked_list_item *SI = cls->repeat_stack_threshold[cls->sp-1];
			if (NEXT_ITEM_IN_LINKED_LIST(SI, ls_section) ==
				cls->repeat_stack_variable[cls->sp-1])
				goto CYCLE;
		}

@<Skip line if inside a failed conditional@> =
	for (int j=cls->sp-1; j>=0; j--)
		if (cls->repeat_stack_level[j] == IF_FALSE_LEVEL)
			goto CYCLE;

@ If called with the non-conditional levels, the following function returns
the topmost item. It's never called for |IF_TRUE_LEVEL| or |IF_FALSE_LEVEL|.

=
linked_list_item *Collater::heading_topmost_on_stack(collater_state *cls, int level) {
	for (int rstl = cls->sp-1; rstl >= 0; rstl--)
		if (cls->repeat_stack_level[rstl] == level)
			return cls->repeat_stack_variable[rstl];
	return NULL;
}

@ This is the function for starting a loop or code block, which stacks up the
details, and similarly for ending it by popping them again:

@d MODULE_LEVEL 1
@d CHAPTER_LEVEL 2
@d SECTION_LEVEL 3
@d IF_TRUE_LEVEL 4
@d IF_FALSE_LEVEL 5

=
void Collater::start_CI_loop(collater_state *cls, int level,
	linked_list_item *from, linked_list_item *to, int pos) {
	if (cls->sp < CI_STACK_CAPACITY) {
		cls->repeat_stack_level[cls->sp] = level;
		cls->repeat_stack_variable[cls->sp] = from;
		cls->repeat_stack_threshold[cls->sp] = to;
		cls->repeat_stack_startpos[cls->sp++] = pos;
	}
}

void Collater::end_CI_loop(collater_state *cls) {
	cls->sp--;
}

@h Variable substitutions.
We can now forget about this tiny stack machine: the one task left is to
take a line from the template, and make substitutions of variables into
its square-bracketed parts.

Note that we do not allow this to recurse, i.e., if |[[X]]| substitutes into
text which itself contains a |[[...]]| notation, then we do not expand that
inner one. If we did, then the value of the bibliographic variable |[[Code]]|,
used by the HTML renderer, would cause a modest-sized explosion on some pages.

@<Make substitutions of square-bracketed variables in line@> =
	TEMPORARY_TEXT(rewritten)
	int slen, spos;
	while ((spos = Regexp::find_expansion(tl, '[', '[', ']', ']', &slen)) >= 0) {
		TEMPORARY_TEXT(varname)
		TEMPORARY_TEXT(substituted)
		TEMPORARY_TEXT(tail)
		Str::substr(rewritten, Str::start(tl), Str::at(tl, spos));
		Str::substr(varname, Str::at(tl, spos+2), Str::at(tl, spos+slen-2));
		Str::substr(tail, Str::at(tl, spos+slen), Str::end(tl));

		match_results mr = Regexp::create_mr();
		if (Bibliographic::data_exists(cls->for_web, varname)) {
			WRITE_TO(substituted, "%S", Bibliographic::get_datum(cls->for_web, varname));
		} else if (Regexp::match(&mr, varname, U"Navigation")) {
			@<Substitute Navigation@>;
		} else if (Regexp::match(&mr, varname, U"Breadcrumbs")) {
			@<Substitute Breadcrumbs@>;
		} else if (Str::eq_wide_string(varname, U"Plugins")) {
			@<Substitute Plugins@>;
		} else if (Regexp::match(&mr, varname, U"Complete (%c+)")) {
			text_stream *detail = mr.exp[0];
			@<Substitute a detail about the complete PDF@>;
		} else if (Regexp::match(&mr, varname, U"Module (%c+)")) {
			text_stream *detail = mr.exp[0];
			@<Substitute a Module@>;
		} else if (Regexp::match(&mr, varname, U"Chapter (%c+)")) {
			text_stream *detail = mr.exp[0];
			@<Substitute a Chapter@>;
		} else if (Regexp::match(&mr, varname, U"Section (%c+)")) {
			text_stream *detail = mr.exp[0];
			@<Substitute a Section@>;
		} else if (Regexp::match(&mr, varname, U"Docs")) {
			@<Substitute a Docs@>;
		} else if (Regexp::match(&mr, varname, U"Assets")) {
			@<Substitute an Assets@>;
		} else if (Regexp::match(&mr, varname, U"URL \"(%c+)\"")) {
			text_stream *link_text = mr.exp[0];
			@<Substitute a URL@>;
		} else if (Regexp::match(&mr, varname, U"Link \"(%c+)\"")) {
			text_stream *link_text = mr.exp[0];
			@<Substitute a Link@>;
		} else if (Regexp::match(&mr, varname, U"Menu \"(%c+)\"")) {
			text_stream *menu_name = mr.exp[0];
			@<Substitute a Menu@>;
		} else if (Regexp::match(&mr, varname, U"Item \"(%c+)\"")) {
			text_stream *item_name = mr.exp[0];
			int icon_size = 18;
			text_stream *icon_text = NULL;
			@<Look for icon text@>;
			text_stream *link_text = item_name;
			@<Substitute a member Item@>;
		} else if (Regexp::match(&mr, varname, U"Item \"(%c+)\" -> (%c+)")) {
			text_stream *item_name = mr.exp[0];
			text_stream *link_text = mr.exp[1];
			int icon_size = 18;
			text_stream *icon_text = NULL;
			@<Look for icon text@>;
			@<Substitute a general Item@>;
		} else if (Regexp::match(&mr, varname, U"Home \"(%c+)\" -> (%c+)")) {
			text_stream *item_name = mr.exp[0];
			text_stream *link_text = mr.exp[1];
			int icon_size = 18;
			text_stream *icon_text = NULL;
			@<Look for icon text@>;
			@<Substitute a home Item@>;
		} else if (Regexp::match(&mr, varname, U"Optional (%c+)")) {
			if (Bibliographic::data_exists(cls->for_web, mr.exp[0])) {
				WRITE_TO(substituted, "%S", Bibliographic::get_datum(cls->for_web, mr.exp[0]));
			}
		} else {
			WRITE_TO(substituted, "%S", varname);
			if (Regexp::match(&mr, varname, U"%i+%c*"))
				PRINT("Warning: unable to resolve command '%S'\n", varname);
		}
		Regexp::dispose_of(&mr);
		Str::clear(tl);
		WRITE_TO(rewritten, "%S", substituted);
		WRITE_TO(tl, "%S", tail);
		DISCARD_TEXT(tail)
		DISCARD_TEXT(varname)
		DISCARD_TEXT(substituted)
	}
	WRITE_TO(rewritten, "%S", tl);
	Str::clear(tl); Str::copy(tl, rewritten);
	DISCARD_TEXT(rewritten)

@ |[[Navigation]]| substitutes to the content of the sidebar navigation file;
this will recursively call The Collater, in fact.

@<Substitute Navigation@> =
	if (cls->nav_file) {
		Collater::collate(substituted, cls->for_web, cls->restrict_to_range,
			NULL, cls->nav_file, cls->nav_pattern, NULL, NULL, cls->wv, cls->into_file,
			cls->context, cls->reportage);
	} else {
		PRINT("Warning: no sidebar links will be generated, as -navigation is unset");
	}

@ A trail of breadcrumbs, used for overhead navigation in web pages.

@<Substitute Breadcrumbs@> =
	Colonies::drop_initial_breadcrumbs(substituted, cls->context, cls->into_file,
		cls->crumbs);

@<Substitute Plugins@> =
	Assets::include_relevant_plugins(OUT, cls->nav_pattern, cls->for_web,
		cls->wv, cls->into_file, cls->context, cls->reportage);

@ We store little about the complete-web-in-one-file PDF:

@<Substitute a detail about the complete PDF@> =
	if (swarm_leader)
		if (WeavingFormats::substitute_post_processing_data(substituted,
			swarm_leader, detail, cls->nav_pattern) == FALSE)
			WRITE_TO(substituted, "%S for complete web", detail);

@ And here for Modules:

@<Substitute a Module@> =
	ls_module *M = CONTENT_IN_ITEM(
		Collater::heading_topmost_on_stack(cls, MODULE_LEVEL), ls_module);
	if (M == NULL)
		Errors::at_position("no module is currently selected",
			cls->errors_at, lpos);
	else @<Substitute a detail about the currently selected Module@>;

@<Substitute a detail about the currently selected Module@> =
	if (Str::eq_wide_string(detail, U"Title")) {
		text_stream *owner = Collater::module_owner(M, cls->for_web);
		if (Str::len(owner) > 0) WRITE_TO(substituted, "%S/", owner);
		WRITE_TO(substituted, "%S", M->module_name);
	} else if (Str::eq_wide_string(detail, U"Page")) {
		if (Colonies::find(cls->context, M->module_name))
			Colonies::reference_URL(substituted, cls->context, M->module_name, cls->into_file);
	} else if (Str::eq_wide_string(detail, U"Purpose")) {
		TEMPORARY_TEXT(url)
		WRITE_TO(url, "%p", M->module_location);
		Readme::write_var(substituted, url, I"Purpose");
		DISCARD_TEXT(url)		
	} else {
		WRITE_TO(substituted, "%S for %S", varname, M->module_name);
	}

@ And here for Chapters:

@<Substitute a Chapter@> =
	ls_chapter *C = CONTENT_IN_ITEM(
		Collater::heading_topmost_on_stack(cls, CHAPTER_LEVEL), ls_chapter);
	if (C == NULL)
		Errors::at_position("no chapter is currently selected",
			cls->errors_at, lpos);
	else @<Substitute a detail about the currently selected Chapter@>;

@<Substitute a detail about the currently selected Chapter@> =
	if (Str::eq_wide_string(detail, U"Title")) {
		Str::copy(substituted, C->ch_title);
	} else if (Str::eq_wide_string(detail, U"Code")) {
		Str::copy(substituted, C->ch_range);
	} else if (Str::eq_wide_string(detail, U"Purpose")) {
		Str::copy(substituted, C->rubric);
	} else if (WeavingFormats::substitute_post_processing_data(substituted,
		WeavingDetails::get_ch_weave(C), detail, cls->nav_pattern)) {
		;
	} else {
		WRITE_TO(substituted, "%S for %S", varname, C->ch_title);
	}

@ And this is a very similar construction for Sections.

@<Substitute a Section@> =
	ls_section *S = CONTENT_IN_ITEM(
		Collater::heading_topmost_on_stack(cls, SECTION_LEVEL), ls_section);
	if (S == NULL)
		Errors::at_position("no section is currently selected",
			cls->errors_at, lpos);
	else @<Substitute a detail about the currently selected Section@>;

@<Substitute a detail about the currently selected Section@> =
	if (Str::eq_wide_string(detail, U"Title")) {
		Str::copy(substituted, S->sect_title);
	} else if (Str::eq_wide_string(detail, U"Purpose")) {
		WRITE_TO(substituted, "%S", LiterateSource::unit_purpose(S->literate_source));
	} else if (Str::eq_wide_string(detail, U"Code")) {
		Str::copy(substituted, WebRanges::of(S));
	} else if (Str::eq_wide_string(detail, U"Lines")) {
		WRITE_TO(substituted, "%d", S->sect_extent);
	} else if (Str::eq_wide_string(detail, U"Source")) {
		WRITE_TO(substituted, "%f", S->source_file_for_section);
	} else if (Str::eq_wide_string(detail, U"Page")) {
		Colonies::section_URL(substituted, S);
	} else if (Str::eq_wide_string(detail, U"Paragraphs")) {
		WRITE_TO(substituted, "%d", WebStructure::paragraph_count_within_section(S));
	} else if (Str::eq_wide_string(detail, U"Mean")) {
		int denom = WebStructure::paragraph_count_within_section(S);
		if (denom == 0) denom = 1;
		WRITE_TO(substituted, "%d", S->sect_extent/denom);
	} else if (WeavingFormats::substitute_post_processing_data(substituted,
		WeavingDetails::get_sect_weave(S), detail, cls->nav_pattern)) {
		;
	} else {
		WRITE_TO(substituted, "%S for %S", varname, S->sect_title);
	}

@ These commands are all used in constructing relative URLs, especially for
navigation purposes.

@<Substitute a Docs@> =
	Pathnames::relative_URL(substituted,
		Filenames::up(cls->into_file), Colonies::home(cls->context));

@<Substitute an Assets@> =
	pathname *P = Colonies::assets_path(cls->context, cls->for_web);
	if (P == NULL) P = Filenames::up(cls->into_file);
	Pathnames::relative_URL(substituted,
		Filenames::up(cls->into_file), P);

@<Substitute a URL@> =
	Pathnames::relative_URL(substituted,
		Filenames::up(cls->into_file),
		Pathnames::from_text(link_text));

@<Substitute a Link@> =
	WRITE_TO(substituted, "<a href=\"");
	Colonies::reference_URL(substituted, cls->context, link_text, cls->into_file);
	WRITE_TO(substituted, "\">");

@<Substitute a Menu@> =
	if (cls->inside_navigation_submenu) WRITE_TO(substituted, "</ul>");
	WRITE_TO(substituted, "<h2>%S</h2><ul>", menu_name);
	cls->inside_navigation_submenu = TRUE;

@<Look for icon text@> =
	match_results mr = Regexp::create_mr();
	if (Regexp::match(&mr, item_name, U"<(%i+.%i+)@*(%d*)> *(%c*)")) {
		icon_text = Str::duplicate(mr.exp[0]);
		icon_size = Str::atoi(mr.exp[1], 0);
		item_name = Str::duplicate(mr.exp[2]);
	} else if (Regexp::match(&mr, item_name, U"(%c*?) *<(%i+.%i+)@*(%d*)>")) {
		icon_text = Str::duplicate(mr.exp[1]);
		icon_size = Str::atoi(mr.exp[2], 0);
		item_name = Str::duplicate(mr.exp[0]);
	}
	Regexp::dispose_of(&mr);

@<Substitute a member Item@> =
	TEMPORARY_TEXT(url)
	Colonies::reference_URL(url, cls->context, link_text, cls->into_file);
	@<Substitute an item at this URL@>;
	DISCARD_TEXT(url)

@<Substitute a general Item@> =
	TEMPORARY_TEXT(url)
	@<Vet the link text@>;
	Colonies::link_URL(url, cls->context, link_text, cls->into_file);
	@<Substitute an item at this URL@>;
	DISCARD_TEXT(url)

@<Substitute a home Item@> =
	WRITE_TO(substituted, "<h1>");
	WRITE_TO(substituted, "<a href=\"");
	@<Vet the link text@>;
	Colonies::link_URL(substituted, cls->context, link_text, cls->into_file);
	WRITE_TO(substituted, "\">");
	@<Substitute icon and name@>;
	WRITE_TO(substituted, "</a>");
	WRITE_TO(substituted, "</h1>");

@<Vet the link text@> =
	int vaguely_URL_like = FALSE, slashed = FALSE;
	for (int i=0; i<Str::len(link_text); i++) {
		inchar32_t c = Str::get_at(link_text, i);
		if ((c == '.') || (c == '/')) vaguely_URL_like = TRUE;
	}
	match_results mr = Regexp::create_mr();
	if (Regexp::match(&mr, link_text, U" *//%c+// *")) slashed = TRUE;
	Regexp::dispose_of(&mr);
	if ((slashed == FALSE) && (vaguely_URL_like == FALSE)) {
		TEMPORARY_TEXT(err)
		WRITE_TO(err, "the link '%S' is not in '//...//' slashes, and does not look like a URL",
			link_text);
		Errors::at_position_S(err, cls->errors_at, lpos);
	}

@<Substitute an item at this URL@> =
	if (cls->inside_navigation_submenu == FALSE) WRITE_TO(substituted, "<ul>");
	cls->inside_navigation_submenu = TRUE;
	WRITE_TO(substituted, "<li>");
	if (Str::eq(url, Filenames::get_leafname(cls->into_file))) {
		WRITE_TO(substituted, "<span class=\"unlink\">");
		@<Substitute icon and name@>;
		WRITE_TO(substituted, "</span>");
	} else if (Str::eq(url, I"index.html")) {
		WRITE_TO(substituted, "<a href=\"%S\">", url);
		WRITE_TO(substituted, "<span class=\"selectedlink\">");
		@<Substitute icon and name@>;
		WRITE_TO(substituted, "</span>");
		WRITE_TO(substituted, "</a>");
	} else {
		WRITE_TO(substituted, "<a href=\"%S\">", url);
		@<Substitute icon and name@>;
		WRITE_TO(substituted, "</a>");
	}
	WRITE_TO(substituted, "</li>");

@<Substitute icon and name@> =
	if (Str::len(icon_text) > 0) {
		WRITE_TO(substituted, "<img src=\"");
		pathname *I = Colonies::assets_path(cls->context, cls->for_web);
		Pathnames::relative_URL(substituted, Filenames::up(cls->into_file), I);
		WRITE_TO(substituted, "%S\" height=%d> ", icon_text, icon_size);
	}
	WRITE_TO(substituted, "%S", item_name);

@ This is a utility for finding the owner of a module, returning |NULL| (the
empty text) if it appears to belong to the current web |W|.

=
text_stream *Collater::module_owner(const ls_module *M, ls_web *W) {
	text_stream *owner =
		Pathnames::directory_name(Pathnames::up(M->module_location));
	text_stream *me = NULL;
	if ((W) && (W->path_to_web))
		me = Pathnames::directory_name(W->path_to_web);
	if (Str::ne_insensitive(me, owner)) return owner;
	return NULL;
}

@ This enables us to sort them. The empty owner (i.e., the current web) comes
top, then all other owners, in alphabetical order, and then last of all Inweb,
so that //foundation// will always be at the bottom.

=
ls_web *sorting_web = NULL;
void Collater::sort_web(ls_web *W) {
	sorting_web = W;
}
int Collater::sort_comparison(const void *ent1, const void *ent2) {
	const ls_module *M1 = *((const ls_module **) ent1);
	const ls_module *M2 = *((const ls_module **) ent2);
	text_stream *O1 = Collater::module_owner(M1, sorting_web);
	text_stream *O2 = Collater::module_owner(M2, sorting_web);
	int r = Collater::cmp_owners(O1, O2);
	if (r != 0) return r;
	return Str::cmp_insensitive(M1->module_name, M2->module_name);
}

int Collater::cmp_owners(text_stream *O1, text_stream *O2) {
	if (Str::len(O1) == 0) {
		if (Str::len(O2) > 0) return -1;
		return 0;
	}
	if (Str::len(O2) == 0) return 1;
	if (Str::eq_insensitive(O1, I"inweb")) {
		if (Str::eq_insensitive(O2, I"inweb") == FALSE) return 1;
		return 0;
	}
	if (Str::eq_insensitive(O2, I"inweb")) return -1;
	return Str::cmp_insensitive(O1, O2);
}
